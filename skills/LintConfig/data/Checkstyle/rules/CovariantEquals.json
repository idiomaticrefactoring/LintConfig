{"CovariantEquals": {"description": "Description\n\nChecks that classes and records which define a covariant equals() method\nalso override method equals(Object).\n\n\nCovariant equals() - method that is similar to equals(Object),\nbut with a covariant parameter type (any subtype of Object).\n\n\nNotice: the enums are also checked, even\nthough they cannot override equals(Object). The reason is\nto point out that implementing equals() in enums is considered an\nawful practice: it may cause having two different enum values that are equal using\ncovariant enum method, and not equal when compared normally.\n\n\nInspired by\nFinding Bugs is Easy, chapter '4.5 Bad Covariant Definition of Equals (Eq)':\n\n\nJava classes and records may override the equals(Object) method to define\na predicate for object equality. This method is used by many of the Java runtime\nlibrary classes; for example, to implement generic containers.\n\n\nProgrammers sometimes mistakenly use the type of their class Foo\nas the type of the parameter to equals():\n\n\n\npublic boolean equals(Foo obj) {...}\n\n\nThis covariant version of equals() does not override the version in the\nObject class, and it may lead to unexpected behavior at runtime,\nespecially if the class is used with one of the standard collection classes\nwhich expect that the standard equals(Object) method is overridden.\n\n\nThis kind of bug is not obvious because it looks correct, and in circumstances where\nthe class is accessed through the references of the class type (rather than a supertype),\nit will work correctly. However, the first time it is used in a container,\nthe behavior might be mysterious. For these reasons, this type of bug can elude\ntesting and code inspections.", "option": ""}}