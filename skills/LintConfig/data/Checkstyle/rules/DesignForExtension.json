{"DesignForExtension": {"description": "Description\n\nChecks that classes are designed for extension (subclass creation).\n\n\nNothing wrong could be with founded classes.\nThis check makes sense only for library projects (not application projects)\nwhich care of ideal OOP-design to make sure that class works in all cases even misusage.\nEven in library projects this check most likely will find classes that are designed\nfor extension by somebody. User needs to use suppressions extensively to got a benefit\nfrom this check, and keep in suppressions all confirmed/known classes that are deigned\nfor inheritance intentionally to let the check catch only new classes, and bring this to\nteam/user attention.\n\n\nATTENTION: Only user can decide whether a class is designed for extension or not.\nThe check just shows all classes which are possibly designed for extension.\nIf smth inappropriate is found please use suppression.\n\n\nATTENTION: If the method which can be overridden in a subclass has a javadoc comment\n(a good practice is to explain its self-use of overridable methods) the check will not\nrise a violation. The violation can also be skipped if the method which can be overridden\nin a subclass has one or more annotations that are specified in ignoredAnnotations\noption. Note, that by default @Override annotation is not included in the\nignoredAnnotations set as in a subclass the method which has the annotation can also be\noverridden in its subclass.\n\n\nProblem is described at \"Effective Java, 2nd Edition by Joshua Bloch\" book, chapter\n\"Item 17: Design and document for inheritance or else prohibit it\".\n\n\nSome quotes from book:\n\nThe class must document its self-use of overridable methods.\nBy convention, a method that invokes overridable methods contains a description\nof these invocations at the end of its documentation comment. The description\nbegins with the phrase \u201cThis implementation.\u201d\n\nThe best solution to this problem is to prohibit subclassing in classes that\nare not designed and documented to be safely subclassed.\n\nIf a concrete class does not implement a standard interface, then you may\ninconvenience some programmers by prohibiting inheritance. If you feel that you\nmust allow inheritance from such a class, one reasonable approach is to ensure\nthat the class never invokes any of its overridable methods and to document this\nfact. In other words, eliminate the class\u2019s self-use of overridable methods entirely.\nIn doing so, you\u2019ll create a class that is reasonably safe to subclass. Overriding a\nmethod will never affect the behavior of any other method.\n\n\nThe check finds classes that have overridable methods (public or protected methods\nthat are non-static, not-final, non-abstract) and have non-empty implementation.\n\n\nRationale: This library design style protects superclasses against\nbeing broken by subclasses. The downside is that subclasses are\nlimited in their flexibility, in particular they cannot prevent\nexecution of code in the superclass, but that also means that\nsubclasses cannot corrupt the state of the superclass by forgetting\nto call the superclass's method.\n\n\nMore specifically,\nit enforces a programming style where superclasses provide empty\n\"hooks\" that can be implemented by subclasses.\n\n\nExample of code that cause violation as it is designed for extension:\n\n\n\npublic abstract class Plant {\nprivate String roots;\nprivate String trunk;\n\nprotected void validate() {\nif (roots == null) throw new IllegalArgumentException(\"No roots!\");\nif (trunk == null) throw new IllegalArgumentException(\"No trunk!\");\n}\n\npublic abstract void grow();\n}\n\npublic class Tree extends Plant {\nprivate List leaves;\n\n@Overrides\nprotected void validate() {\nsuper.validate();\nif (leaves == null) throw new IllegalArgumentException(\"No leaves!\");\n}\n\npublic void grow() {\nvalidate();\n}\n}\n\n\nExample of code without violation:\n\n\n\npublic abstract class Plant {\nprivate String roots;\nprivate String trunk;\n\nprivate void validate() {\nif (roots == null) throw new IllegalArgumentException(\"No roots!\");\nif (trunk == null) throw new IllegalArgumentException(\"No trunk!\");\nvalidateEx();\n}\n\nprotected void validateEx() { }\n\npublic abstract void grow();\n}", "option": "\nignoredAnnotations, Specify annotations which allow the check to skip the method from validation., String[], After, AfterClass, Before, BeforeClass, Test\nrequiredJavadocPhrase, Specify the comment text pattern which qualifies a method as designed for extension. Supports multi-line regex., Pattern, \".*\""}}