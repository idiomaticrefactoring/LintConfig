{"RedundantModifier": {"description": "Description\n\nChecks for redundant modifiers.\n\n\nRationale: The Java Language Specification strongly\ndiscourages the usage of public and abstract for method\ndeclarations in interface definitions as a matter of style.\n\nThe check validates:\n\nInterface and annotation definitions.\nFinal modifier on methods of final and anonymous classes.\n\nType declarations nested under interfaces that are declared as public\nor static.\n\nClass constructors.\n\nNested enum definitions that are declared\nas static.\n\n\nrecord definitions that are declared as final and nested\nrecord definitions that are declared as static.\n\n\n\ninterfaces by definition are abstract so the abstract modifier is\nredundant on them.\n\n\nType declarations nested under interfaces by definition are public and static,\nso the public and static modifiers on nested type\ndeclarations are redundant. On the other hand, classes inside of interfaces can\nbe abstract or non abstract. So, abstract modifier is allowed.\n\n\nFields in interfaces and annotations are automatically\npublic, static and final, so these modifiers are redundant as\nwell.\n\n\nAs annotations are a form of interface, their fields are also\nautomatically public, static and final just as their\nannotation fields are automatically public and abstract.\n\n\nA record class is implicitly final and cannot be abstract, these restrictions emphasize\nthat the API of a record class is defined solely by its state description, and cannot be\nenhanced later by another class. Nested records are implicitly static. This avoids an\nimmediately enclosing instance which would silently add state to the record class.\nSee JEP 395 for more info.\n\n\nEnums by definition are static implicit subclasses of java.lang.Enum<E>.\nSo, the static modifier on the enums is redundant. In addition,\nif enum is inside of interface, public modifier is also redundant.\n\n\nEnums can also contain abstract methods and methods which can be overridden by the\ndeclared enumeration fields.\nSee the following example:\n\n\n\npublic enum EnumClass {\nFIELD_1,\nFIELD_2 {\n@Override\npublic final void method1() {} // violation expected\n};\n\npublic void method1() {}\npublic final void method2() {} // no violation expected\n}\n\n\nSince these methods can be overridden in these situations, the final methods are not\nmarked as redundant even though they can't be extended by other classes/enums.\n\n\nNested enum types are always static by default.\n\n\nFinal classes by definition cannot be extended so the final\nmodifier on the method of a final class is redundant.\n\n\nPublic modifier for constructors in non-public non-protected classes\nis always obsolete:\n\n\n\npublic class PublicClass {\npublic PublicClass() {} // OK\n}\n\nclass PackagePrivateClass {\npublic PackagePrivateClass() {} // violation expected\n}\n\nThere is no violation in the following example,\nbecause removing public modifier from ProtectedInnerClass\nconstructor will make this code not compiling:\n\n\n\npackage a;\npublic class ClassExample {\nprotected class ProtectedInnerClass {\npublic ProtectedInnerClass () {}\n}\n}\n\npackage b;\nimport a.ClassExample;\npublic class ClassExtending extends ClassExample {\nProtectedInnerClass pc = new ProtectedInnerClass();\n}", "option": "\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_FIELD_DEF\n,\nINTERFACE_DEF\n,\nCTOR_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nRESOURCE\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nMETHOD_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_FIELD_DEF\n,\nINTERFACE_DEF\n,\nCTOR_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nRESOURCE\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}}