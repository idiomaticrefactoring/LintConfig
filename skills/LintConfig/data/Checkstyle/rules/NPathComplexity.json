{"NPathComplexity": {"description": "Description\n\nChecks the NPATH complexity against a specified limit.\n\n\nThe NPATH metric computes the number of possible execution\npaths through a function(method). It takes into account the nesting of\nconditional statements and multipart boolean expressions\n(A && B, C || D, E ? F :G and their combinations).\n\n\nThe NPATH metric was designed base on Cyclomatic complexity to\navoid problem of Cyclomatic complexity metric like nesting level within a\nfunction(method).\n\n\nMetric was described at\n\"NPATH: a measure of execution pathcomplexity and its applications\".\nIf you need detailed description of algorithm, please read that article,\nit is well written and have number of examples and details.\n\nHere is some quotes:\nAn NPATH threshold value of 200 has been established\nfor a function. The value 200 is based on studies done\nat AT&T Bell Laboratories [1988 year].\n\n\nSome of the most effective methods of reducing the NPATH value include:\n\n\ndistributing functionality;\nimplementing multiple if statements as a switch statement;\n\ncreating a separate function for logical expressions with a high\ncount of variables and (&&) and or (||) operators.\n\n\n\n\nAlthough strategies to reduce the NPATH complexity\nof functions are important, care must be taken not to\ndistort the logical clarity of the software by applying a\nstrategy to reduce the complexity of functions. That is,\nthere is a point of diminishing return beyond which a\nfurther attempt at reduction of complexity distorts the\nlogical clarity of the system structure.\n\n\nExamples\n\n\nStructure\nComplexity expression\n\nif ([expr]) { [if-range] }\nNP(if-range) + 1 + NP(expr)\n\nif ([expr]) { [if-range] } else { [else-range] }\nNP(if-range)\n+ NP(else-range) + NP(expr)\n\nwhile ([expr]) { [while-range] }\nNP(while-range) + NP(expr) + 1\n\n\ndo { [do-range] } while ([expr])\nNP(do-range) + NP(expr) + 1\n\nfor([expr1]; [expr2]; [expr3]) { [for-range] }\nNP(for-range) + NP(expr1)\n+ NP(expr2) + NP(expr3) + 1\n\nswitch ([expr]) { case : [case-range] default: [default-range] }\nS(i=1:i=n)NP(case-range[i]) + NP(default-range) + NP(expr)\n\n\n[expr1] ? [expr2] : [expr3]\nNP(expr1) + NP(expr2) + NP(expr3) + 2\n\n\ngoto label\n1\n\nbreak\n1\n\nExpressions\nNumber of && and || operators in expression. No\noperators - 0\n\ncontinue\n1\n\nreturn\n1\n\nStatement (even sequential statements)\n1\n\nEmpty block {}\n1\n\nFunction call\n1\n\nFunction(Method) declaration or Block\nP(i=1:i=N)NP(Statement[i])\n\n\n\n\nRationale: Nejmeh says that his group had an informal NPATH\nlimit of 200 on individual routines; functions(methods) that exceeded\nthis value were candidates for further decomposition - or at\nleast a closer look.\nPlease do not be fanatic with limit 200\n- choose number that suites your project style. Limit 200 is\nempirical number base on some sources of at AT&T Bell Laboratories\nof 1988 year.", "option": "\nmax, Specify the maximum threshold allowed., int, 200"}}