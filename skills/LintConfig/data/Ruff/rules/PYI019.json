{
  "description": "[Status: stable] [Name: custom-type-var-for-self] [Message: Use <code>Self</code> instead of custom TypeVar <code>{}</code>] What it does Checks for methods that use custom TypeVars in their annotations when they could use Self instead. Why is this bad? While the semantics are often identical, using Self is more intuitive and succinct (per PEP 673) than a custom TypeVar. For example, the use of Self will typically allow for the omission of type parameters on the self and cls arguments. This check currently applies to instance methods that return self, class methods that return an instance of cls, class methods that return cls, and __new__ methods. Example from typing import TypeVar _S = TypeVar(\"_S\", bound=\"Foo\") class Foo: def __new__(cls: type[_S], *args: str, **kwargs: int) -> _S: ... def foo(self: _S, arg: bytes) -> _S: ... @classmethod def bar(cls: type[_S], arg: int) -> _S: ... Use instead: from typing import Self class Foo: def __new__(cls, *args: str, **kwargs: int) -> Self: ... def foo(self, arg: bytes) -> Self: ... @classmethod def bar(cls, arg: int) -> Self: ... Fix behaviour The fix replaces all references to the custom type variable in the method's header and body with references to Self. The fix also adds an import of Self if neither Self nor typing is already imported in the module. If your target-version setting is set to Python 3.11 or newer, the fix imports Self from the standard-library typing module; otherwise, the fix imports Self from the third-party typing_extensions backport package. If the custom type variable is a PEP-695-style TypeVar, the fix also removes the TypeVar declaration from the method's type parameter list. However, if the type variable is an old-style TypeVar, the declaration of the type variable will not be removed by this rule's fix, as the type variable could still be used by other functions, methods or classes. See unused-private-type-var for a rule that will clean up unused private type variables. Fix safety The fix is only marked as unsafe if there is the possibility that it might delete a comment from your code. Availability Because this rule relies on the third-party typing_extensions module for Python versions before 3.11, its diagnostic will not be emitted, and no fix will be offered, if typing_extensions imports have been disabled by the lint.typing-extensions linter option.",
  "option": {
    "lint.typing-extensions": {
      "option_description": "Whether to allow imports from the third-party typing_extensions module for Python versions\nbefore a symbol was added to the first-party typing module.\n\nMany rules try to import symbols from the typing module but fall back to\ntyping_extensions for earlier versions of Python. This option can be used to disable this\nfallback behavior in cases where typing_extensions is not installed.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\n# Disable `typing_extensions` imports\ntyping-extensions = false\n\n\n\n[lint]\n# Disable `typing_extensions` imports\ntyping-extensions = false",
      "option_data_type": "bool",
      "default_value": "true",
      "option_values": {
        "valuelist": []
      }
    }
  }
}