{
  "description": "[Status: stable] [Name: error-instead-of-exception] [Message: Use <code>logging.exception</code> instead of <code>logging.error</code>] What it does Checks for uses of logging.error instead of logging.exception when logging an exception. Why is this bad? logging.exception logs the exception and the traceback, while logging.error only logs the exception. The former is more appropriate when logging an exception, as the traceback is often useful for debugging. Example import logging def func(): try: raise NotImplementedError except NotImplementedError: logging.error(\"Exception occurred\") Use instead: import logging def func(): try: raise NotImplementedError except NotImplementedError: logging.exception(\"Exception occurred\") Fix safety This rule's fix is marked as safe when run against logging.error calls, but unsafe when marked against other logger-like calls (e.g., logger.error), since the rule is prone to false positives when detecting logger-like calls outside of the logging module.",
  "option": {
    "lint.logger-objects": {
      "option_description": "A list of objects that should be treated equivalently to a\nlogging.Logger object.\n\nThis is useful for ensuring proper diagnostics (e.g., to identify\nlogging deprecations and other best-practices) for projects that\nre-export a logging.Logger object from a common module.\n\nFor example, if you have a module logging_setup.py with the following\ncontents:\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nAdding \"logging_setup.logger\" to logger-objects will ensure that\nlogging_setup.logger is treated as a logging.Logger object when\nimported from other modules (e.g., from logging_setup import logger).\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\nlogger-objects = [\"logging_setup.logger\"]\n\n\n\n[lint]\nlogger-objects = [\"logging_setup.logger\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}