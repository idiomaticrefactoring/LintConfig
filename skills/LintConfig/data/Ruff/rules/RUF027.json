{
  "description": "[Status: preview] [Name: missing-f-string-syntax] [Message: Possible f-string without an <code>f</code> prefix] What it does Searches for strings that look like they were meant to be f-strings, but are missing an f prefix. Why is this bad? Expressions inside curly braces are only evaluated if the string has an f prefix. Details There are many possible string literals which are not meant to be f-strings despite containing f-string-like syntax. As such, this lint ignores all strings where one of the following conditions applies: The string is a standalone expression. For example, the rule ignores all docstrings. The string is part of a function call with argument names that match at least one variable (for example: format(\"Message: {value}\", value=\"Hello World\")) The string (or a parent expression of the string) has a direct method call on it (for example: \"{value}\".format(...)) The string has no {...} expression sections, or uses invalid f-string syntax. The string references variables that are not in scope, or it doesn't capture variables at all. Any format specifiers in the potential f-string are invalid. The string is part of a function call that is known to expect a template string rather than an evaluated f-string: for example, a logging call, a gettext call, or a FastAPI path. Example name = \"Sarah\" day_of_week = \"Tuesday\" print(\"Hello {name}! It is {day_of_week} today!\") Use instead: name = \"Sarah\" day_of_week = \"Tuesday\" print(f\"Hello {name}! It is {day_of_week} today!\") Fix safety This fix will always change the behavior of the program and, despite the precautions detailed above, this may be undesired. As such the fix is always marked as unsafe.",
  "option": {
    "lint.logger-objects": {
      "option_description": "A list of objects that should be treated equivalently to a\nlogging.Logger object.\n\nThis is useful for ensuring proper diagnostics (e.g., to identify\nlogging deprecations and other best-practices) for projects that\nre-export a logging.Logger object from a common module.\n\nFor example, if you have a module logging_setup.py with the following\ncontents:\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nAdding \"logging_setup.logger\" to logger-objects will ensure that\nlogging_setup.logger is treated as a logging.Logger object when\nimported from other modules (e.g., from logging_setup import logger).\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\nlogger-objects = [\"logging_setup.logger\"]\n\n\n\n[lint]\nlogger-objects = [\"logging_setup.logger\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}