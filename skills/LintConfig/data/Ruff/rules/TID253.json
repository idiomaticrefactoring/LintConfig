{
  "description": "[Status: stable] [Name: banned-module-level-imports] [Message: <code>{name}</code> is banned at the module level] What it does Checks for module-level imports that should instead be imported lazily (e.g., within a function definition, or an if TYPE_CHECKING: block, or some other nested context). Why is this bad? Some modules are expensive to import. For example, importing torch or tensorflow can introduce a noticeable delay in the startup time of a Python program. In such cases, you may want to enforce that the module is imported lazily as needed, rather than at the top of the file. This could involve inlining the import into the function that uses it, rather than importing it unconditionally, to ensure that the module is only imported when necessary. Example import tensorflow as tf def show_version(): print(tf.__version__) Use instead: def show_version(): import tensorflow as tf print(tf.__version__)",
  "option": {
    "lint.flake8-tidy-imports.banned-module-level-imports": {
      "option_description": "List of specific modules that may not be imported at module level, and should instead be\nimported lazily (e.g., within a function definition, or an if TYPE_CHECKING:\nblock, or some other nested context). This also affects the rule import-outside-top-level\nif banned-module-level-imports is enabled.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.flake8-tidy-imports]\n# Ban certain modules from being imported at module level, instead requiring\n# that they're imported lazily (e.g., within a function definition).\nbanned-module-level-imports = [\"torch\", \"tensorflow\"]\n\n\n\n[lint.flake8-tidy-imports]\n# Ban certain modules from being imported at module level, instead requiring\n# that they're imported lazily (e.g., within a function definition).\nbanned-module-level-imports = [\"torch\", \"tensorflow\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}