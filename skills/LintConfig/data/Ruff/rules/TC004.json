{
  "description": "[Status: stable] [Name: runtime-import-in-type-checking-block] [Message: Move import <code>{qualified_name}</code> out of type-checking block. Import is used for more than type hinting.] What it does Checks for imports that are required at runtime but are only defined in type-checking blocks. Why is this bad? The type-checking block is not executed at runtime, so if the only definition of a symbol is in a type-checking block, it will not be available at runtime. If lint.flake8-type-checking.quote-annotations is set to true, annotations will be wrapped in quotes if doing so would enable the corresponding import to remain in the type-checking block. Example from typing import TYPE_CHECKING if TYPE_CHECKING: import foo def bar() -> None: foo.bar() # raises NameError: name 'foo' is not defined Use instead: import foo def bar() -> None: foo.bar()",
  "option": {
    "lint.flake8-type-checking.quote-annotations": {
      "option_description": "Whether to add quotes around type annotations, if doing so would allow\nthe corresponding import to be moved into a type-checking block.\n\nFor example, in the following, Python requires that Sequence be\navailable at runtime, despite the fact that it's only used in a type\nannotation:\n\nfrom collections.abc import Sequence\n\n\ndef func(value: Sequence[int]) -> None:\n    ...\n\nIn other words, moving from collections.abc import Sequence into an\nif TYPE_CHECKING: block above would cause a runtime error, as the\ntype would no longer be available at runtime.\n\nBy default, Ruff will respect such runtime semantics and avoid moving\nthe import to prevent such runtime errors.\n\nSetting quote-annotations to true will instruct Ruff to add quotes\naround the annotation (e.g., \"Sequence[int]\"), which in turn enables\nRuff to move the import into an if TYPE_CHECKING: block, like so:\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n\n\ndef func(value: \"Sequence[int]\") -> None:\n    ...\n\nNote that this setting has no effect when from __future__ import annotations\nis present, as __future__ annotations are always treated equivalently\nto quoted annotations. Similarly, this setting has no effect on Python\nversions after 3.14 because these annotations are also deferred.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.flake8-type-checking]\n# Add quotes around type annotations, if doing so would allow\n# an import to be moved into a type-checking block.\nquote-annotations = true\n\n\n\n[lint.flake8-type-checking]\n# Add quotes around type annotations, if doing so would allow\n# an import to be moved into a type-checking block.\nquote-annotations = true",
      "option_data_type": "bool",
      "default_value": "false",
      "option_values": {
        "valuelist": []
      }
    }
  }
}