{
  "description": "[Status: stable] [Name: non-pep695-type-alias] [Message: Type alias <code>{name}</code> uses {type_alias_method} instead of the <code>type</code> keyword] What it does Checks for use of TypeAlias annotations and TypeAliasType assignments for declaring type aliases. Why is this bad? The type keyword was introduced in Python 3.12 by PEP 695 for defining type aliases. The type keyword is easier to read and provides cleaner support for generics. Known problems PEP 695 uses inferred variance for type parameters, instead of the covariant and contravariant keywords used by TypeVar variables. As such, rewriting a type alias using a PEP-695 type statement may change the variance of the alias's type parameters. Unlike type aliases that use simple assignments, definitions created using PEP 695 type statements cannot be used as drop-in replacements at runtime for the value on the right-hand side of the statement. This means that while for some simple old-style type aliases you can use them as the second argument to an isinstance() call (for example), doing the same with a PEP 695 type statement will always raise TypeError at runtime. Example from typing import Annotated, TypeAlias, TypeAliasType from annotated_types import Gt ListOfInt: TypeAlias = list[int] PositiveInt = TypeAliasType(\"PositiveInt\", Annotated[int, Gt(0)]) Use instead: from typing import Annotated from annotated_types import Gt type ListOfInt = list[int] type PositiveInt = Annotated[int, Gt(0)] Fix safety This fix is marked unsafe for TypeAlias assignments outside of stub files because of the runtime behavior around isinstance() calls noted above. The fix is also unsafe for TypeAliasType assignments if there are any comments in the replacement range that would be deleted. See also This rule only applies to TypeAliases and TypeAliasTypes. See non-pep695-generic-class and non-pep695-generic-function for similar transformations for generic classes and functions. This rule replaces standalone type variables in aliases but doesn't remove the corresponding type variables even if they are unused after the fix. See unused-private-type-var for a rule to clean up unused private type variables. This rule will not rename private type variables to remove leading underscores, even though the new type parameters are restricted in scope to their associated aliases. See private-type-parameter for a rule to update these names.",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    }
  }
}