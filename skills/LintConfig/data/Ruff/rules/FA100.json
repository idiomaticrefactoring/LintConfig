{
  "description": "[Status: stable] [Name: future-rewritable-type-annotation] [Message: Add <code>from __future__ import annotations</code> to simplify <code>{name}</code>] What it does Checks for missing from __future__ import annotations imports upon detecting type annotations that can be written more succinctly under PEP 563. Why is this bad? PEP 585 enabled the use of a number of convenient type annotations, such as list[str] instead of List[str]. However, these annotations are only available on Python 3.9 and higher, unless the from __future__ import annotations import is present. Similarly, PEP 604 enabled the use of the | operator for unions, such as str | None instead of Optional[str]. However, these annotations are only available on Python 3.10 and higher, unless the from __future__ import annotations import is present. By adding the __future__ import, the pyupgrade rules can automatically migrate existing code to use the new syntax, even for older Python versions. This rule thus pairs well with pyupgrade and with Ruff's pyupgrade rules. This rule respects the target-version setting. For example, if your project targets Python 3.10 and above, adding from __future__ import annotations does not impact your ability to leverage PEP 604-style unions (e.g., to convert Optional[str] to str | None). As such, this rule will only flag such usages if your project targets Python 3.9 or below. Example from typing import List, Dict, Optional def func(obj: Dict[str, Optional[int]]) -> None: ... Use instead: from __future__ import annotations from typing import List, Dict, Optional def func(obj: Dict[str, Optional[int]]) -> None: ... After running the additional pyupgrade rules: from __future__ import annotations def func(obj: dict[str, int | None]) -> None: ... Fix safety This rule's fix is marked as unsafe, as adding from __future__ import annotations may change the semantics of the program.",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    }
  }
}