{
  "description": "[Status: stable] [Name: try-except-in-loop] [Message: <code>try</code>-<code>except</code> within a loop incurs performance overhead] What it does Checks for uses of except handling via try-except within for and while loops. Why is this bad? Exception handling via try-except blocks incurs some performance overhead, regardless of whether an exception is raised. To optimize your code, two techniques are possible: Refactor your code to put the entire loop into the try-except block, rather than wrapping each iteration in a separate try-except block. Use \"Look Before You Leap\" idioms that attempt to avoid exceptions being raised in the first place, avoiding the need to use try-except blocks in the first place. This rule is only enforced for Python versions prior to 3.11, which introduced \"zero-cost\" exception handling. However, note that even on Python 3.11 and newer, refactoring your code to avoid exception handling in tight loops can provide a significant speedup in some cases, as zero-cost exception handling is only zero-cost in the \"happy path\" where no exception is raised in the try-except block. As with all perflint rules, this is only intended as a micro-optimization. In many cases, it will have a negligible impact on performance. Example string_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"] # `try`/`except` that could be moved out of the loop: int_numbers: list[int] = [] for num in string_numbers: try: int_numbers.append(int(num)) except ValueError as e: print(f\"Couldn't convert to integer: {e}\") break # `try`/`except` used when \"look before you leap\" idioms could be used: number_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"} for number in range(5): try: name = number_names[number] except KeyError: continue else: print(f\"The name of {number} is {name}\") Use instead: string_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"] int_numbers: list[int] = [] try: for num in string_numbers: int_numbers.append(int(num)) except ValueError as e: print(f\"Couldn't convert to integer: {e}\") number_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"} for number in range(5): name = number_names.get(number) if name is not None: print(f\"The name of {number} is {name}\")",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    }
  }
}