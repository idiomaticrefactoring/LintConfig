{
  "description": "[Status: stable] [Name: non-pep695-generic-class] [Message: Generic class <code>{name}</code> uses <code>Generic</code> subclass instead of type parameters] What it does Checks for use of standalone type variables and parameter specifications in generic classes. Why is this bad? Special type parameter syntax was introduced in Python 3.12 by PEP 695 for defining generic classes. This syntax is easier to read and provides cleaner support for generics. Known problems The rule currently skips generic classes nested inside of other functions or classes. It also skips type parameters with the default argument introduced in PEP 696 and implemented in Python 3.13. This rule can only offer a fix if all of the generic types in the class definition are defined in the current module. For external type parameters, a diagnostic is emitted without a suggested fix. Not all type checkers fully support PEP 695 yet, so even valid fixes suggested by this rule may cause type checking to fail. Fix safety This fix is marked as unsafe, as PEP 695 uses inferred variance for type parameters, instead of the covariant and contravariant keywords used by TypeVar variables. As such, replacing a TypeVar variable with an inline type parameter may change its variance. Example from typing import Generic, TypeVar T = TypeVar(\"T\") class GenericClass(Generic[T]): var: T Use instead: class GenericClass[T]: var: T See also This rule replaces standalone type variables in classes but doesn't remove the corresponding type variables even if they are unused after the fix. See unused-private-type-var for a rule to clean up unused private type variables. This rule will not rename private type variables to remove leading underscores, even though the new type parameters are restricted in scope to their associated class. See private-type-parameter for a rule to update these names. This rule will correctly handle classes with multiple base classes, as long as the single Generic base class is at the end of the argument list, as checked by generic-not-last-base-class. If a Generic base class is found outside of the last position, a diagnostic is emitted without a suggested fix. This rule only applies to generic classes and does not include generic functions. See non-pep695-generic-function for the function version.",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    }
  }
}