{
  "description": "[Status: stable] [Name: super-without-brackets] [Message: <code>super</code> call is missing parentheses] What it does Detects attempts to use super without parentheses. Why is this bad? The super() callable can be used inside method definitions to create a proxy object that delegates attribute access to a superclass of the current class. Attempting to access attributes on super itself, however, instead of the object returned by a call to super(), will raise AttributeError. Example class Animal: @staticmethod def speak(): return \"This animal says something.\" class Dog(Animal): @staticmethod def speak(): original_speak = super.speak() # ERROR: `super.speak()` return f\"{original_speak} But as a dog, it barks!\" Use instead: class Animal: @staticmethod def speak(): return \"This animal says something.\" class Dog(Animal): @staticmethod def speak(): original_speak = super().speak() # Correct: `super().speak()` return f\"{original_speak} But as a dog, it barks!\"",
  "option": {
    "lint.pep8-naming.classmethod-decorators": {
      "option_description": "A list of decorators that, when applied to a method, indicate that the\nmethod should be treated as a class method (in addition to the builtin\n@classmethod).\n\nFor example, Ruff will expect that any method decorated by a decorator\nin this list takes a cls argument as its first argument.\n\nExpects to receive a list of fully-qualified names (e.g., pydantic.validator,\nrather than validator) or alternatively a plain name which is then matched against\nthe last segment in case the decorator itself consists of a dotted name.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.pep8-naming]\nclassmethod-decorators = [\n    # Allow Pydantic's `@validator` decorator to trigger class method treatment.\n    \"pydantic.validator\",\n    # Allow SQLAlchemy's dynamic decorators, like `@field.expression`, to trigger class method treatment.\n    \"declared_attr\",\n    \"expression\",\n    \"comparator\",\n]\n\n\n\n[lint.pep8-naming]\nclassmethod-decorators = [\n    # Allow Pydantic's `@validator` decorator to trigger class method treatment.\n    \"pydantic.validator\",\n    # Allow SQLAlchemy's dynamic decorators, like `@field.expression`, to trigger class method treatment.\n    \"declared_attr\",\n    \"expression\",\n    \"comparator\",\n]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    },
    "lint.pep8-naming.staticmethod-decorators": {
      "option_description": "A list of decorators that, when applied to a method, indicate that the\nmethod should be treated as a static method (in addition to the builtin\n@staticmethod).\n\nFor example, Ruff will expect that any method decorated by a decorator\nin this list has no self or cls argument.\n\nExpects to receive a list of fully-qualified names (e.g., belay.Device.teardown,\nrather than teardown) or alternatively a plain name which is then matched against\nthe last segment in case the decorator itself consists of a dotted name.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.pep8-naming]\n# Allow Belay's `@Device.teardown` decorator to trigger static method treatment.\nstaticmethod-decorators = [\"belay.Device.teardown\"]\n\n\n\n[lint.pep8-naming]\n# Allow Belay's `@Device.teardown` decorator to trigger static method treatment.\nstaticmethod-decorators = [\"belay.Device.teardown\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}