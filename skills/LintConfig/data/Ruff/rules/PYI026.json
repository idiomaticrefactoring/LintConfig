{
  "description": "[Status: stable] [Name: type-alias-without-annotation] [Message: Use <code>{module}.TypeAlias</code> for type alias, e.g., <code>{name}: TypeAlias = {value}</code>] What it does Checks for type alias definitions that are not annotated with typing.TypeAlias. Why is this bad? In Python, a type alias is defined by assigning a type to a variable (e.g., Vector = list[float]). It's best to annotate type aliases with the typing.TypeAlias type to make it clear that the statement is a type alias declaration, as opposed to a normal variable assignment. Example Vector = list[float] Use instead: from typing import TypeAlias Vector: TypeAlias = list[float] Availability Because this rule relies on the third-party typing_extensions module for Python versions before 3.10, its diagnostic will not be emitted, and no fix will be offered, if typing_extensions imports have been disabled by the lint.typing-extensions linter option.",
  "option": {
    "lint.typing-extensions": {
      "option_description": "Whether to allow imports from the third-party typing_extensions module for Python versions\nbefore a symbol was added to the first-party typing module.\n\nMany rules try to import symbols from the typing module but fall back to\ntyping_extensions for earlier versions of Python. This option can be used to disable this\nfallback behavior in cases where typing_extensions is not installed.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\n# Disable `typing_extensions` imports\ntyping-extensions = false\n\n\n\n[lint]\n# Disable `typing_extensions` imports\ntyping-extensions = false",
      "option_data_type": "bool",
      "default_value": "true",
      "option_values": {
        "valuelist": []
      }
    }
  }
}