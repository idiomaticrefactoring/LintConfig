{
  "description": "[Status: stable] [Name: non-pep604-annotation-union] [Message: Use <code>X | Y</code> for type annotations] What it does Check for type annotations that can be rewritten based on PEP 604 syntax. Why is this bad? PEP 604 introduced a new syntax for union type annotations based on the | operator. This syntax is more concise and readable than the previous typing.Union and typing.Optional syntaxes. This rule is enabled when targeting Python 3.10 or later (see: target-version). By default, it's also enabled for earlier Python versions if from __future__ import annotations is present, as __future__ annotations are not evaluated at runtime. If your code relies on runtime type annotations (either directly or via a library like Pydantic), you can disable this behavior for Python versions prior to 3.10 by setting lint.pyupgrade.keep-runtime-typing to true. Example from typing import Union foo: Union[int, str] = 1 Use instead: foo: int | str = 1 Note that this rule only checks for usages of typing.Union, while UP045 checks for typing.Optional. Fix safety This rule's fix is marked as unsafe, as it may lead to runtime errors when alongside libraries that rely on runtime type annotations, like Pydantic, on Python versions prior to Python 3.10, or as it may remove comments if they are present within the type annotation being rewritten. It may also lead to runtime errors in unusual and likely incorrect type annotations where the type does not support the | operator.",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    },
    "lint.pyupgrade.keep-runtime-typing": {
      "option_description": "Whether to avoid PEP 585 (List[int] -> list[int]) and PEP 604\n(Union[str, int] -> str | int) rewrites even if a file imports\nfrom __future__ import annotations.\n\nThis setting is only applicable when the target Python version is below\n3.9 and 3.10 respectively, and is most commonly used when working with\nlibraries like Pydantic and FastAPI, which rely on the ability to parse\ntype annotations at runtime. The use of from __future__ import annotations\ncauses Python to treat the type annotations as strings, which typically\nallows for the use of language features that appear in later Python\nversions but are not yet supported by the current version (e.g., str |\nint). However, libraries that rely on runtime type annotations will\nbreak if the annotations are incompatible with the current Python\nversion.\n\nFor example, while the following is valid Python 3.8 code due to the\npresence of from __future__ import annotations, the use of str | int\nprior to Python 3.10 will cause Pydantic to raise a TypeError at\nruntime:\n\nfrom __future__ import annotations\n\nimport pydantic\n\nclass Foo(pydantic.BaseModel):\n    bar: str | int\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.pyupgrade]\n# Preserve types, even if a file imports `from __future__ import annotations`.\nkeep-runtime-typing = true\n\n\n\n[lint.pyupgrade]\n# Preserve types, even if a file imports `from __future__ import annotations`.\nkeep-runtime-typing = true",
      "option_data_type": "bool",
      "default_value": "false",
      "option_values": {
        "valuelist": []
      }
    }
  }
}