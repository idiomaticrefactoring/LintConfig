{
  "description": "[Status: stable] [Name: unsafe-markup-use] [Message: Unsafe use of <code>{name}</code> detected] What it does Checks for non-literal strings being passed to markupsafe.Markup. Why is this bad? markupsafe.Markup does not perform any escaping, so passing dynamic content, like f-strings, variables or interpolated strings will potentially lead to XSS vulnerabilities. Instead you should interpolate the Markup object. Using lint.flake8-bandit.extend-markup-names additional objects can be treated like Markup. This rule was originally inspired by flake8-markupsafe but doesn't carve out any exceptions for i18n related calls by default. You can use lint.flake8-bandit.allowed-markup-calls to specify exceptions. Example Given: from markupsafe import Markup content = \"<script>alert('Hello, world!')</script>\" html = Markup(f\"<b>{content}</b>\") # XSS Use instead: from markupsafe import Markup content = \"<script>alert('Hello, world!')</script>\" html = Markup(\"<b>{}</b>\").format(content) # Safe Given: from markupsafe import Markup lines = [ Markup(\"<b>heading</b>\"), \"<script>alert('XSS attempt')</script>\", ] html = Markup(\"<br>\".join(lines)) # XSS Use instead: from markupsafe import Markup lines = [ Markup(\"<b>heading</b>\"), \"<script>alert('XSS attempt')</script>\", ] html = Markup(\"<br>\").join(lines) # Safe",
  "option": {
    "lint.flake8-bandit.extend-markup-names": {
      "option_description": "A list of additional callable names that behave like\nmarkupsafe.Markup.\n\nExpects to receive a list of fully-qualified names (e.g., webhelpers.html.literal, rather than\nliteral).\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.flake8-bandit]\nextend-markup-names = [\"webhelpers.html.literal\", \"my_package.Markup\"]\n\n\n\n[lint.flake8-bandit]\nextend-markup-names = [\"webhelpers.html.literal\", \"my_package.Markup\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    },
    "lint.flake8-bandit.allowed-markup-calls": {
      "option_description": "A list of callable names, whose result may be safely passed into\nmarkupsafe.Markup.\n\nExpects to receive a list of fully-qualified names (e.g., bleach.clean, rather than clean).\n\nThis setting helps you avoid false positives in code like:\n\nfrom bleach import clean\nfrom markupsafe import Markup\n\ncleaned_markup = Markup(clean(some_user_input))\n\nWhere the use of bleach.clean\nusually ensures that there's no XSS vulnerability.\n\nAlthough it is not recommended, you may also use this setting to whitelist other\nkinds of calls, e.g. calls to i18n translation functions, where how safe that is\nwill depend on the implementation and how well the translations are audited.\n\nAnother common use-case is to wrap the output of functions that generate markup\nlike xml.etree.ElementTree.tostring\nor template rendering engines where sanitization of potential user input is either\nalready baked in or has to happen before rendering.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.flake8-bandit]\nallowed-markup-calls = [\"bleach.clean\", \"my_package.sanitize\"]\n\n\n\n[lint.flake8-bandit]\nallowed-markup-calls = [\"bleach.clean\", \"my_package.sanitize\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}