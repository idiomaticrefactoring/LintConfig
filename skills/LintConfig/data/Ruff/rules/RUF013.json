{
  "description": "[Status: stable] [Name: implicit-optional] [Message: PEP 484 prohibits implicit <code>Optional</code>] What it does Checks for the use of implicit Optional in type annotations when the default parameter value is None. If lint.future-annotations is set to true, from __future__ import annotations will be added if doing so would allow using the | operator on a Python version before 3.10. Why is this bad? Implicit Optional is prohibited by PEP 484. It is confusing and inconsistent with the rest of the type system. It's recommended to use Optional[T] instead. For Python 3.10 and later, you can also use T | None. Example def foo(arg: int = None): pass Use instead: from typing import Optional def foo(arg: Optional[int] = None): pass Or, for Python 3.10 and later: def foo(arg: int | None = None): pass If you want to use the | operator in Python 3.9 and earlier, you can use future imports: from __future__ import annotations def foo(arg: int | None = None): pass Limitations Type aliases are not supported and could result in false negatives. For example, the following code will not be flagged: Text = str | bytes def foo(arg: Text = None): pass Fix safety This fix is always marked as unsafe because it can change the behavior of code that relies on type hints, and it assumes the default value is always appropriateâ€”which might not be the case.",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    },
    "lint.future-annotations": {
      "option_description": "Whether to allow rules to add from __future__ import annotations in cases where this would\nsimplify a fix or enable a new diagnostic.\n\nFor example, TC001, TC002, and TC003 can move more imports into TYPE_CHECKING blocks\nif __future__ annotations are enabled.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\n# Enable `from __future__ import annotations` imports\nfuture-annotations = true\n\n\n\n[lint]\n# Enable `from __future__ import annotations` imports\nfuture-annotations = true",
      "option_data_type": "bool",
      "default_value": "false",
      "option_values": {
        "valuelist": []
      }
    }
  }
}