{
  "description": "[Status: stable] [Name: logging-extra-attr-clash] [Message: Logging statement uses an <code>extra</code> field that clashes with a <code>LogRecord</code> field: <code>{key}</code>] What it does Checks for extra keywords in logging statements that clash with LogRecord attributes. Why is this bad? The logging module provides a mechanism for passing additional values to be logged using the extra keyword argument. These values are then passed to the LogRecord constructor. Providing a value via extra that clashes with one of the attributes of the LogRecord constructor will raise a KeyError when the LogRecord is constructed. Known problems This rule detects uses of the logging module via a heuristic. Specifically, it matches against: Uses of the logging module itself (e.g., import logging; logging.info(...)). Uses of flask.current_app.logger (e.g., from flask import current_app; current_app.logger.info(...)). Objects whose name starts with log or ends with logger or logging, when used in the same file in which they are defined (e.g., logger = logging.getLogger(); logger.info(...)). Imported objects marked as loggers via the lint.logger-objects setting, which can be used to enforce these rules against shared logger objects (e.g., from module import logger; logger.info(...), when lint.logger-objects is set to [\"module.logger\"]). Example import logging logging.basicConfig(format=\"%(name) - %(message)s\", level=logging.INFO) username = \"Maria\" logging.info(\"Something happened\", extra=dict(name=username)) Use instead: import logging logging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO) username = \"Maria\" logging.info(\"Something happened\", extra=dict(user_id=username))",
  "option": {
    "lint.logger-objects": {
      "option_description": "A list of objects that should be treated equivalently to a\nlogging.Logger object.\n\nThis is useful for ensuring proper diagnostics (e.g., to identify\nlogging deprecations and other best-practices) for projects that\nre-export a logging.Logger object from a common module.\n\nFor example, if you have a module logging_setup.py with the following\ncontents:\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nAdding \"logging_setup.logger\" to logger-objects will ensure that\nlogging_setup.logger is treated as a logging.Logger object when\nimported from other modules (e.g., from logging_setup import logger).\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\nlogger-objects = [\"logging_setup.logger\"]\n\n\n\n[lint]\nlogger-objects = [\"logging_setup.logger\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}