{
  "description": "[Status: stable] [Name: get-attr-with-constant] [Message: Do not call <code>getattr</code> with a constant attribute value. It is not any safer than normal property access.] What it does Checks for uses of getattr that take a constant attribute value as an argument (e.g., getattr(obj, \"foo\")). Why is this bad? getattr is used to access attributes dynamically. If the attribute is defined as a constant, it is no safer than a typical property access. When possible, prefer property access over getattr calls, as the former is more concise and idiomatic. Example getattr(obj, \"foo\") Use instead: obj.foo Fix safety The fix is marked as unsafe for attribute names that are not in NFKC (Normalization Form KC) normalization. Python normalizes identifiers using NFKC when using attribute access syntax (e.g., obj.attr), but does not normalize string arguments passed to getattr. Rewriting getattr(obj, \"ſ\") to obj.ſ would be interpreted as obj.s at runtime, changing behavior. Additionally, the fix is marked as unsafe if the expression contains comments, as the replacement may remove comments attached to the original getattr call. For example, the long s character \"ſ\" normalizes to \"s\" under NFKC, so: # This accesses an attribute with the exact name \"ſ\" (if it exists) value = getattr(obj, \"ſ\") # But this would normalize to \"s\" and access a different attribute obj.ſ # This is interpreted as obj.s, not obj.ſ",
  "option": {}
}