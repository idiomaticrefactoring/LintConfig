{
  "description": "[Status: stable] [Name: pytest-parametrize-names-wrong-type] [Message: Wrong type passed to first argument of <code>pytest.mark.parametrize</code>; expected {expected_string}] What it does Checks for the type of parameter names passed to pytest.mark.parametrize. Why is this bad? The argnames argument of pytest.mark.parametrize takes a string or a sequence of strings. For a single parameter, it's preferable to use a string. For multiple parameters, it's preferable to use the style configured via the lint.flake8-pytest-style.parametrize-names-type setting. Example import pytest # single parameter, always expecting string @pytest.mark.parametrize((\"param\",), [1, 2, 3]) def test_foo(param): ... # multiple parameters, expecting tuple @pytest.mark.parametrize([\"param1\", \"param2\"], [(1, 2), (3, 4)]) def test_bar(param1, param2): ... # multiple parameters, expecting tuple @pytest.mark.parametrize(\"param1,param2\", [(1, 2), (3, 4)]) def test_baz(param1, param2): ... Use instead: import pytest @pytest.mark.parametrize(\"param\", [1, 2, 3]) def test_foo(param): ... @pytest.mark.parametrize((\"param1\", \"param2\"), [(1, 2), (3, 4)]) def test_bar(param1, param2): ...",
  "option": {
    "lint.flake8-pytest-style.parametrize-names-type": {
      "option_description": "Expected type for multiple argument names in @pytest.mark.parametrize.\nThe following values are supported:\n\ncsv — a comma-separated list, e.g.\n  @pytest.mark.parametrize(\"name1,name2\", ...)\ntuple (default) — e.g.\n  @pytest.mark.parametrize((\"name1\", \"name2\"), ...)\nlist — e.g. @pytest.mark.parametrize([\"name1\", \"name2\"], ...)\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint.flake8-pytest-style]\nparametrize-names-type = \"list\"\n\n\n\n[lint.flake8-pytest-style]\nparametrize-names-type = \"list\"",
      "option_data_type": "\"csv\" | \"tuple\" | \"list\"",
      "default_value": "tuple",
      "option_values": {
        "valuelist": []
      }
    }
  }
}