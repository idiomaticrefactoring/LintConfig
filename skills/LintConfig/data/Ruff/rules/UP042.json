{
  "description": "[Status: preview] [Name: replace-str-enum] [Message: Class {name} inherits from both <code>str</code> and <code>enum.Enum</code>] What it does Checks for classes that inherit from both str and enum.Enum. Why is this bad? Python 3.11 introduced enum.StrEnum, which is preferred over inheriting from both str and enum.Enum. Example import enum class Foo(str, enum.Enum): ... Use instead: import enum class Foo(enum.StrEnum): ... Fix safety Python 3.11 introduced a breaking change for enums that inherit from both str and enum.Enum. Consider the following enum: from enum import Enum class Foo(str, Enum): BAR = \"bar\" In Python 3.11, the formatted representation of Foo.BAR changed as follows: # Python 3.10 f\"{Foo.BAR}\" # > bar # Python 3.11 f\"{Foo.BAR}\" # > Foo.BAR Migrating from str and enum.Enum to enum.StrEnum will restore the previous behavior, such that: from enum import StrEnum class Foo(StrEnum): BAR = \"bar\" f\"{Foo.BAR}\" # > bar As such, migrating to enum.StrEnum will introduce a behavior change for code that relies on the Python 3.11 behavior.",
  "option": {
    "target-version": {
      "option_description": "The minimum Python version to target, e.g., when considering automatic\ncode upgrades, like rewriting type annotations. Ruff will not propose\nchanges using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.11 or ==3.11\nspecify target-version = \"py311\".\n\nIf you're already using a pyproject.toml file, we recommend\nproject.requires-python instead, as it's based on Python packaging\nstandards, and will be respected by other tools. For example, Ruff\ntreats the following as identical to target-version = \"py38\":\n\n[project]\nrequires-python = \">=3.8\"\n\nIf both are specified, target-version takes precedence over\nrequires-python. See Inferring the Python version\nfor a complete description of how the target-version is determined\nwhen left unspecified.\n\nNote that a stub file can sometimes make use of a typing feature\nbefore it is available at runtime, as long as the stub does not make\nuse of new syntax. For example, a type checker will understand\nint | str in a stub as being a Union type annotation, even if the\ntype checker is run using Python 3.9, despite the fact that the |\noperator can only be used to create union types at runtime on Python\n3.10+. As such, Ruff will often recommend newer features in a stub\nfile than it would for an equivalent runtime file with the same target\nversion.\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff]\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"\n\n\n\n# Always generate Python 3.7-compatible code.\ntarget-version = \"py37\"",
      "option_data_type": "\"py37\" | \"py38\" | \"py39\" | \"py310\" | \"py311\" | \"py312\" | \"py313\" | \"py314\"",
      "default_value": "\"py310\"",
      "option_values": {
        "valuelist": []
      }
    }
  }
}