{
  "description": "[Status: preview] [Name: log-exception-outside-except-handler] [Message: <code>.exception()</code> call outside exception handlers] What it does Checks for .exception() logging calls outside of exception handlers. Why is this bad? The documentation states: This function should only be called from an exception handler. Calling .exception() outside of an exception handler attaches None as exception information, leading to confusing messages: >>> logging.exception(\"example\") ERROR:root:example NoneType: None Example import logging logging.exception(\"Foobar\") Use instead: import logging logging.error(\"Foobar\") Fix safety The fix, if available, will always be marked as unsafe, as it changes runtime behavior.",
  "option": {
    "lint.logger-objects": {
      "option_description": "A list of objects that should be treated equivalently to a\nlogging.Logger object.\n\nThis is useful for ensuring proper diagnostics (e.g., to identify\nlogging deprecations and other best-practices) for projects that\nre-export a logging.Logger object from a common module.\n\nFor example, if you have a module logging_setup.py with the following\ncontents:\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nAdding \"logging_setup.logger\" to logger-objects will ensure that\nlogging_setup.logger is treated as a logging.Logger object when\nimported from other modules (e.g., from logging_setup import logger).\n\n\n\nExample usage:\n\npyproject.tomlruff.toml\n\n\n[tool.ruff.lint]\nlogger-objects = [\"logging_setup.logger\"]\n\n\n\n[lint]\nlogger-objects = [\"logging_setup.logger\"]",
      "option_data_type": "list[str]",
      "default_value": "[]",
      "option_values": {
        "valuelist": []
      }
    }
  }
}