{
    "name": "GuardLogStatement",
    "category": "bestpractices",
    "summary": "Whenever using a log level, one should check if it is actually enabled, or\notherwise skip the associate String creation and manipulation, as well as any method calls.\n\nAn alternative to checking the log level are substituting parameters, formatters or lazy logging\nwith lambdas. The available alternatives depend on the actual logging framework.",
    "message": "Logger calls should be surrounded by log level guards.",
    "url": "${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#guardlogstatement",
    "since": "5.1.0",
    "priority": "2",
    "is_deprecated": false,
    "configuration": [],
    "examples": "// Add this for performance - avoid manipulating strings if the logger may drop it\nif (log.isDebugEnabled()) {\nlog.debug(\"log something\" + param1 + \" and \" + param2 + \"concat strings\");\n}\n\n// Avoid the guarding if statement with substituting parameters\nlog.debug(\"log something {} and {}\", param1, param2);\n\n// Avoid the guarding if statement with formatters\nlog.debug(\"log something %s and %s\", param1, param2);\n\n// This is still an issue, method invocations may be expensive / have side-effects\nlog.debug(\"log something expensive: {}\", calculateExpensiveLoggingText());\n\n// Avoid the guarding if statement with lazy logging and lambdas\nlog.debug(\"log something expensive: {}\", () -> calculateExpensiveLoggingText());\n\n// â€¦ alternatively use method references\nlog.debug(\"log something expensive: {}\", this::calculateExpensiveLoggingText);"
}