{
    "name": "AvoidSynchronizedAtMethodLevel",
    "category": "multithreading",
    "summary": "Method-level synchronization will pin virtual threads and can cause performance problems. Additionally, it can cause\nproblems when new code is added to the method.  Block-level ReentrantLock helps to ensure that only the code that\nneeds mutual exclusion will be locked.",
    "message": "Use block level locking rather than method level synchronization",
    "url": "${pmd.website.baseurl}/pmd_rules_java_multithreading.html#avoidsynchronizedatmethodlevel",
    "since": "3.0",
    "priority": "3",
    "is_deprecated": false,
    "configuration": [],
    "examples": "public class Foo {\n// Try to avoid this:\nsynchronized void foo() {\n// code, that doesn't need synchronization\n// ...\n// code, that requires synchronization\nif (!sharedData.has(\"bar\")) {\nsharedData.add(\"bar\");\n}\n// more code, that doesn't need synchronization\n// ...\n}\n// Prefer this:\nLock instanceLock = new ReentrantLock();\n\nvoid bar() {\n// code, that doesn't need synchronization\n// ...\ntry {\ninstanceLock.lock();  // or instanceLock.tryLock(long time, TimeUnit unit)\nif (!sharedData.has(\"bar\")) {\nsharedData.add(\"bar\");\n}\n} finally {\ninstanceLock.unlock();\n}\n// more code, that doesn't need synchronization\n// ...\n}\n\n// Try to avoid this for static methods:\nstatic synchronized void fooStatic() {\n}\n\n// Prefer this:\nprivate static Lock CLASS_LOCK = new ReentrantLock();\n\nstatic void barStatic() {\n// code, that doesn't need synchronization\n// ...\ntry {\nCLASS_LOCK.lock();\n// code, that requires synchronization\n} finally {\nCLASS_LOCK.unlock();\n}\n// more code, that doesn't need synchronization\n// ...\n}\n}"
}