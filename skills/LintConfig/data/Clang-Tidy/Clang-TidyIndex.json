[
  {
    "name": "abseil-cleanup-ctad",
    "description": "Suggests switching the initialization pattern of \nabsl::Cleanup\n\ninstances from the factory function to class template argument\ndeduction (CTAD), in C++17 and higher.\n\nauto\n \nc1\n \n=\n \nabsl\n::\nMakeCleanup\n([]\n \n{});\n\n\n\nconst\n \nauto\n \nc2\n \n=\n \nabsl\n::\nMakeCleanup\n(\nstd\n::\nfunction\n<\nvoid\n()\n>\n([]\n \n{}));\n\nbecomes\n\nabsl\n::\nCleanup\n \nc1\n \n=\n \n[]\n \n{};\n\n\n\nconst\n \nabsl\n::\nCleanup\n \nc2\n \n=\n \nstd\n::\nfunction\n<\nvoid\n()\n>\n([]\n \n{});",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/cleanup-ctad.html"
  },
  {
    "name": "abseil-duration-addition",
    "description": "Checks for cases where addition should be performed in the \nabsl::Time\n\ndomain. When adding two values, and one is known to be an \nabsl::Time\n,\nwe can infer that the other should be interpreted as an \nabsl::Duration\n\nof a similar scale, and make that inference explicit.\n\nExamples:\n\n// Original - Addition in the integer domain\n\n\nint\n \nx\n;\n\n\nabsl\n::\nTime\n \nt\n;\n\n\nint\n \nresult\n \n=\n \nabsl\n::\nToUnixSeconds\n(\nt\n)\n \n+\n \nx\n;\n\n\n\n// Suggestion - Addition in the absl::Time domain\n\n\nint\n \nresult\n \n=\n \nabsl\n::\nToUnixSeconds\n(\nt\n \n+\n \nabsl\n::\nSeconds\n(\nx\n));",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-addition.html"
  },
  {
    "name": "abseil-duration-comparison",
    "description": "Checks for comparisons which should be in the \nabsl::Duration\n domain instead\nof the floating point or integer domains.\n\nN.B.: In cases where a \nDuration\n was being converted to an integer and then\ncompared against a floating-point value, truncation during the \nDuration\n\nconversion might yield a different result. In practice this is very rare, and\nstill indicates a bug which should be fixed.\n\nExamples:\n\n// Original - Comparison in the floating point domain\n\n\ndouble\n \nx\n;\n\n\nabsl\n::\nDuration\n \nd\n;\n\n\nif\n \n(\nx\n \n<\n \nabsl\n::\nToDoubleSeconds\n(\nd\n))\n \n...\n\n\n\n// Suggested - Compare in the absl::Duration domain instead\n\n\nif\n \n(\nabsl\n::\nSeconds\n(\nx\n)\n \n<\n \nd\n)\n \n...\n\n\n\n\n// Original - Comparison in the integer domain\n\n\nint\n \nx\n;\n\n\nabsl\n::\nDuration\n \nd\n;\n\n\nif\n \n(\nx\n \n<\n \nabsl\n::\nToInt64Microseconds\n(\nd\n))\n \n...\n\n\n\n// Suggested - Compare in the absl::Duration domain instead\n\n\nif\n \n(\nabsl\n::\nMicroseconds\n(\nx\n)\n \n<\n \nd\n)\n \n...",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-comparison.html"
  },
  {
    "name": "abseil-duration-conversion-cast",
    "description": "Checks for casts of \nabsl::Duration\n conversion functions, and recommends\nthe right conversion function instead.\n\nExamples:\n\n// Original - Cast from a double to an integer\n\n\nabsl\n::\nDuration\n \nd\n;\n\n\nint\n \ni\n \n=\n \nstatic_cast\n<\nint\n>\n(\nabsl\n::\nToDoubleSeconds\n(\nd\n));\n\n\n\n// Suggested - Use the integer conversion function directly.\n\n\nint\n \ni\n \n=\n \nabsl\n::\nToInt64Seconds\n(\nd\n);\n\n\n\n\n// Original - Cast from a double to an integer\n\n\nabsl\n::\nDuration\n \nd\n;\n\n\ndouble\n \nx\n \n=\n \nstatic_cast\n<\ndouble\n>\n(\nabsl\n::\nToInt64Seconds\n(\nd\n));\n\n\n\n// Suggested - Use the integer conversion function directly.\n\n\ndouble\n \nx\n \n=\n \nabsl\n::\nToDoubleSeconds\n(\nd\n);\n\nNote: In the second example, the suggested fix could yield a different result,\nas the conversion to integer could truncate. In practice, this is very rare,\nand you should use \nabsl::Trunc\n to perform this operation explicitly instead.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-conversion-cast.html"
  },
  {
    "name": "abseil-duration-division",
    "description": "absl::Duration\n arithmetic works like it does with integers. That means that\ndivision of two \nabsl::Duration\n objects returns an \nint64\n with any\nfractional component truncated toward 0.\nSee \nthis link\n\nfor more information on arithmetic with \nabsl::Duration\n.\n\nFor example:\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\n3.5\n);\n\n\nint64\n \nsec1\n \n=\n \nd\n \n/\n \nabsl\n::\nSeconds\n(\n1\n);\n     \n// Truncates toward 0.\n\n\nint64\n \nsec2\n \n=\n \nabsl\n::\nToInt64Seconds\n(\nd\n);\n  \n// Equivalent to division.\n\n\nassert\n(\nsec1\n \n==\n \n3\n \n&&\n \nsec2\n \n==\n \n3\n);\n\n\n\ndouble\n \ndsec\n \n=\n \nd\n \n/\n \nabsl\n::\nSeconds\n(\n1\n);\n  \n// WRONG: Still truncates toward 0.\n\n\nassert\n(\ndsec\n \n==\n \n3.0\n);\n\nIf you want floating-point division, you should use either the\n\nabsl::FDivDuration()\n function, or one of the unit conversion functions such\nas \nabsl::ToDoubleSeconds()\n. For example:\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\n3.5\n);\n\n\ndouble\n \ndsec1\n \n=\n \nabsl\n::\nFDivDuration\n(\nd\n,\n \nabsl\n::\nSeconds\n(\n1\n));\n  \n// GOOD: No truncation.\n\n\ndouble\n \ndsec2\n \n=\n \nabsl\n::\nToDoubleSeconds\n(\nd\n);\n                 \n// GOOD: No truncation.\n\n\nassert\n(\ndsec1\n \n==\n \n3.5\n \n&&\n \ndsec2\n \n==\n \n3.5\n);\n\nThis check looks for uses of \nabsl::Duration\n division that is done in a\nfloating-point context, and recommends the use of a function that returns a\nfloating-point value.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-division.html"
  },
  {
    "name": "abseil-duration-factory-float",
    "description": "Checks for cases where the floating-point overloads of various\n\nabsl::Duration\n factory functions are called when the more-efficient\ninteger versions could be used instead.\n\nThis check will not suggest fixes for literals which contain fractional\nfloating point values or non-literals. It will suggest removing\nsuperfluous casts.\n\nExamples:\n\n// Original - Providing a floating-point literal.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\n10.0\n);\n\n\n\n// Suggested - Use an integer instead.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\n10\n);\n\n\n\n\n// Original - Explicitly casting to a floating-point type.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\nstatic_cast\n<\ndouble\n>\n(\n10\n));\n\n\n\n// Suggested - Remove the explicit cast\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\n10\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-factory-float.html"
  },
  {
    "name": "abseil-duration-factory-scale",
    "description": "Checks for cases where arguments to \nabsl::Duration\n factory functions are\nscaled internally and could be changed to a different factory function. This\ncheck also looks for arguments with a zero value and suggests using\n\nabsl::ZeroDuration()\n instead.\n\nExamples:\n\n// Original - Internal multiplication.\n\n\nint\n \nx\n;\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\n60\n \n*\n \nx\n);\n\n\n\n// Suggested - Use absl::Minutes instead.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nMinutes\n(\nx\n);\n\n\n\n\n// Original - Internal division.\n\n\nint\n \ny\n;\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nMilliseconds\n(\ny\n \n/\n \n1000.\n);\n\n\n\n// Suggested - Use absl:::Seconds instead.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\ny\n);\n\n\n\n\n// Original - Zero-value argument.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nHours\n(\n0\n);\n\n\n\n// Suggested = Use absl::ZeroDuration instead\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nZeroDuration\n();",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-factory-scale.html"
  },
  {
    "name": "abseil-duration-subtraction",
    "description": "Checks for cases where subtraction should be performed in the\n\nabsl::Duration\n domain. When subtracting two values, and the first one is\nknown to be a conversion from \nabsl::Duration\n, we can infer that the second\nshould also be interpreted as an \nabsl::Duration\n, and make that inference\nexplicit.\n\nExamples:\n\n// Original - Subtraction in the double domain\n\n\ndouble\n \nx\n;\n\n\nabsl\n::\nDuration\n \nd\n;\n\n\ndouble\n \nresult\n \n=\n \nabsl\n::\nToDoubleSeconds\n(\nd\n)\n \n-\n \nx\n;\n\n\n\n// Suggestion - Subtraction in the absl::Duration domain instead\n\n\ndouble\n \nresult\n \n=\n \nabsl\n::\nToDoubleSeconds\n(\nd\n \n-\n \nabsl\n::\nSeconds\n(\nx\n));\n\n\n\n// Original - Subtraction of two Durations in the double domain\n\n\nabsl\n::\nDuration\n \nd1\n,\n \nd2\n;\n\n\ndouble\n \nresult\n \n=\n \nabsl\n::\nToDoubleSeconds\n(\nd1\n)\n \n-\n \nabsl\n::\nToDoubleSeconds\n(\nd2\n);\n\n\n\n// Suggestion - Subtraction in the absl::Duration domain instead\n\n\ndouble\n \nresult\n \n=\n \nabsl\n::\nToDoubleSeconds\n(\nd1\n \n-\n \nd2\n);\n\nNote: As with other \nclang-tidy\n checks, it is possible that multiple fixes\nmay overlap (as in the case of nested expressions), so not all occurrences can\nbe transformed in one run. In particular, this may occur for nested subtraction\nexpressions. Running \nclang-tidy\n multiple times will find and fix these\noverlaps.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-subtraction.html"
  },
  {
    "name": "abseil-duration-unnecessary-conversion",
    "description": "Finds and fixes cases where \nabsl::Duration\n values are being converted to\nnumeric types and back again.\n\nFloating-point examples:\n\n// Original - Conversion to double and back again\n\n\nabsl\n::\nDuration\n \nd1\n;\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nabsl\n::\nSeconds\n(\nabsl\n::\nToDoubleSeconds\n(\nd1\n));\n\n\n\n// Suggestion - Remove unnecessary conversions\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nd1\n;\n\n\n\n// Original - Division to convert to double and back again\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nabsl\n::\nSeconds\n(\nabsl\n::\nFDivDuration\n(\nd1\n,\n \nabsl\n::\nSeconds\n(\n1\n)));\n\n\n\n// Suggestion - Remove division and conversion\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nd1\n;\n\nInteger examples:\n\n// Original - Conversion to integer and back again\n\n\nabsl\n::\nDuration\n \nd1\n;\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nabsl\n::\nHours\n(\nabsl\n::\nToInt64Hours\n(\nd1\n));\n\n\n\n// Suggestion - Remove unnecessary conversions\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nd1\n;\n\n\n\n// Original - Integer division followed by conversion\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nabsl\n::\nSeconds\n(\nd1\n \n/\n \nabsl\n::\nSeconds\n(\n1\n));\n\n\n\n// Suggestion - Remove division and conversion\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nd1\n;\n\nUnwrapping scalar operations:\n\n// Original - Multiplication by a scalar\n\n\nabsl\n::\nDuration\n \nd1\n;\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nabsl\n::\nSeconds\n(\nabsl\n::\nToInt64Seconds\n(\nd1\n)\n \n*\n \n2\n);\n\n\n\n// Suggestion - Remove unnecessary conversion\n\n\nabsl\n::\nDuration\n \nd2\n \n=\n \nd1\n \n*\n \n2\n;\n\nNote: Converting to an integer and back to an \nabsl::Duration\n might be a\ntruncating operation if the value is not aligned to the scale of conversion.\nIn the rare case where this is the intended result, callers should use\n\nabsl::Trunc\n to truncate explicitly.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/duration-unnecessary-conversion.html"
  },
  {
    "name": "abseil-faster-strsplit-delimiter",
    "description": "Finds instances of \nabsl::StrSplit()\n or \nabsl::MaxSplits()\n where the\ndelimiter is a single character string literal and replaces with a character.\nThe check will offer a suggestion to change the string literal into a\ncharacter. It will also catch code using \nabsl::ByAnyChar()\n for just a\nsingle character and will transform that into a single character as well.\n\nThese changes will give the same result, but using characters rather than\nsingle character string literals is more efficient and readable.\n\nExamples:\n\n// Original - the argument is a string literal.\n\n\nfor\n \n(\nauto\n \npiece\n \n:\n \nabsl\n::\nStrSplit\n(\nstr\n,\n \n\"B\"\n))\n \n{\n\n\n\n// Suggested - the argument is a character, which causes the more efficient\n\n\n// overload of absl::StrSplit() to be used.\n\n\nfor\n \n(\nauto\n \npiece\n \n:\n \nabsl\n::\nStrSplit\n(\nstr\n,\n \n'B'\n))\n \n{\n\n\n\n\n// Original - the argument is a string literal inside absl::ByAnyChar call.\n\n\nfor\n \n(\nauto\n \npiece\n \n:\n \nabsl\n::\nStrSplit\n(\nstr\n,\n \nabsl\n::\nByAnyChar\n(\n\"B\"\n)))\n \n{\n\n\n\n// Suggested - the argument is a character, which causes the more efficient\n\n\n// overload of absl::StrSplit() to be used and we do not need absl::ByAnyChar\n\n\n// anymore.\n\n\nfor\n \n(\nauto\n \npiece\n \n:\n \nabsl\n::\nStrSplit\n(\nstr\n,\n \n'B'\n))\n \n{\n\n\n\n\n// Original - the argument is a string literal inside absl::MaxSplits call.\n\n\nfor\n \n(\nauto\n \npiece\n \n:\n \nabsl\n::\nStrSplit\n(\nstr\n,\n \nabsl\n::\nMaxSplits\n(\n\"B\"\n,\n \n1\n)))\n \n{\n\n\n\n// Suggested - the argument is a character, which causes the more efficient\n\n\n// overload of absl::StrSplit() to be used.\n\n\nfor\n \n(\nauto\n \npiece\n \n:\n \nabsl\n::\nStrSplit\n(\nstr\n,\n \nabsl\n::\nMaxSplits\n(\n'B'\n,\n \n1\n)))\n \n{",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/faster-strsplit-delimiter.html"
  },
  {
    "name": "abseil-no-internal-dependencies",
    "description": "Warns if code using Abseil depends on internal details. If something is in a\nnamespace that includes the word âinternalâ, code is not allowed to depend upon\nit because itâs an implementation detail. They cannot friend it, include it,\nyou mention it or refer to it in any way. Doing so violates Abseilâs\ncompatibility guidelines and may result in breakage. See\n\nhttps://abseil.io/about/compatibility\n for more information.\n\nThe following cases will result in warnings:\n\nabsl\n::\nstrings_internal\n::\nfoo\n();\n\n\n// warning triggered on this line\n\n\nclass\n \nfoo\n \n{\n\n\n  \nfriend\n \nstruct\n \nabsl\n::\ncontainer_internal\n::\nfaa\n;\n\n\n  \n// warning triggered on this line\n\n\n};\n\n\nabsl\n::\nmemory_internal\n::\nMakeUniqueResult\n();\n\n\n// warning triggered on this line",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/no-internal-dependencies.html"
  },
  {
    "name": "abseil-no-namespace",
    "description": "Ensures code does not open \nnamespace\n \nabsl\n as that violates Abseilâs\ncompatibility guidelines. Code should not open \nnamespace\n \nabsl\n as that\nconflicts with Abseilâs compatibility guidelines and may result in breakage.\n\nAny code that uses:\n\nnamespace\n \nabsl\n \n{\n\n\n \n...\n\n\n}\n\nwill be prompted with a warning.\n\nSee \nthe full Abseil compatibility guidelines\n for more information.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/no-namespace.html"
  },
  {
    "name": "abseil-redundant-strcat-calls",
    "description": "Suggests removal of unnecessary calls to \nabsl::StrCat\n when the result is\nbeing passed to another call to \nabsl::StrCat\n or \nabsl::StrAppend\n.\n\nThe extra calls cause unnecessary temporary strings to be constructed. Removing\nthem makes the code smaller and faster.\n\nExamples:\n\nstd\n::\nstring\n \ns\n \n=\n \nabsl\n::\nStrCat\n(\n\"A\"\n,\n \nabsl\n::\nStrCat\n(\n\"B\"\n,\n \nabsl\n::\nStrCat\n(\n\"C\"\n,\n \n\"D\"\n)));\n\n\n//before\n\n\n\nstd\n::\nstring\n \ns\n \n=\n \nabsl\n::\nStrCat\n(\n\"A\"\n,\n \n\"B\"\n,\n \n\"C\"\n,\n \n\"D\"\n);\n\n\n//after\n\n\n\nabsl\n::\nStrAppend\n(\n&\ns\n,\n \nabsl\n::\nStrCat\n(\n\"E\"\n,\n \n\"F\"\n,\n \n\"G\"\n));\n\n\n//before\n\n\n\nabsl\n::\nStrAppend\n(\n&\ns\n,\n \n\"E\"\n,\n \n\"F\"\n,\n \n\"G\"\n);\n\n\n//after",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/redundant-strcat-calls.html"
  },
  {
    "name": "abseil-str-cat-append",
    "description": "Flags uses of \nabsl::StrCat()\n to append to a \nstd::string\n. Suggests\n\nabsl::StrAppend()\n should be used instead.\n\nThe extra calls cause unnecessary temporary strings to be constructed. Removing\nthem makes the code smaller and faster.\n\na\n \n=\n \nabsl\n::\nStrCat\n(\na\n,\n \nb\n);\n \n// Use absl::StrAppend(&a, b) instead.\n\nDoes not diagnose cases where \nabsl::StrCat()\n is used as a template\nargument for a functor.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/str-cat-append.html"
  },
  {
    "name": "abseil-string-find-startswith",
    "description": "Checks whether a \nstd::string::find()\n or \nstd::string::rfind()\n (and\ncorresponding \nstd::string_view\n methods) result is compared with 0, and\nsuggests replacing with \nabsl::StartsWith()\n. This is both a readability and\nperformance issue.\n\nstarts_with\n was added as a built-in function on those types in C++20. If\navailable, prefer enabling \nmodernize-use-starts-ends-with\n instead of this check.\n\nstring\n \ns\n \n=\n \n\"...\"\n;\n\n\nif\n \n(\ns\n.\nfind\n(\n\"Hello World\"\n)\n \n==\n \n0\n)\n \n{\n \n/* do something */\n \n}\n\n\nif\n \n(\ns\n.\nrfind\n(\n\"Hello World\"\n,\n \n0\n)\n \n==\n \n0\n)\n \n{\n \n/* do something */\n \n}\n\nbecomes\n\nstring\n \ns\n \n=\n \n\"...\"\n;\n\n\nif\n \n(\nabsl\n::\nStartsWith\n(\ns\n,\n \n\"Hello World\"\n))\n \n{\n \n/* do something */\n \n}\n\n\nif\n \n(\nabsl\n::\nStartsWith\n(\ns\n,\n \n\"Hello World\"\n))\n \n{\n \n/* do something */\n \n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringLikeClasses\nÂ¶\n\n\nSemicolon-separated list of names of string-like classes. By default both\n\nstd::basic_string\n and \nstd::basic_string_view\n are considered. The list\nof methods to be considered is fixed.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nAbseilStringsMatchHeader\nÂ¶\n\n\nThe location of Abseilâs \nstrings/match.h\n. Defaults to\n\nabsl/strings/match.h\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/string-find-startswith.html"
  },
  {
    "name": "abseil-string-find-str-contains",
    "description": "Finds \ns.find(...)\n \n==\n \nstring::npos\n comparisons (for various string-like\ntypes) and suggests replacing with \nabsl::StrContains()\n.\n\nThis improves readability and reduces the likelihood of accidentally mixing\n\nfind()\n and \nnpos\n from different string-like types.\n\nBy default, âstring-like typesâ includes \n::std::basic_string\n,\n\n::std::basic_string_view\n, and \n::absl::string_view\n. See the\nStringLikeClasses option to change this.\n\nstd\n::\nstring\n \ns\n \n=\n \n\"...\"\n;\n\n\nif\n \n(\ns\n.\nfind\n(\n\"Hello World\"\n)\n \n==\n \nstd\n::\nstring\n::\nnpos\n)\n \n{\n \n/* do something */\n \n}\n\n\n\nabsl\n::\nstring_view\n \na\n \n=\n \n\"...\"\n;\n\n\nif\n \n(\nabsl\n::\nstring_view\n::\nnpos\n \n!=\n \na\n.\nfind\n(\n\"Hello World\"\n))\n \n{\n \n/* do something */\n \n}\n\nbecomes\n\nstd\n::\nstring\n \ns\n \n=\n \n\"...\"\n;\n\n\nif\n \n(\n!\nabsl\n::\nStrContains\n(\ns\n,\n \n\"Hello World\"\n))\n \n{\n \n/* do something */\n \n}\n\n\n\nabsl\n::\nstring_view\n \na\n \n=\n \n\"...\"\n;\n\n\nif\n \n(\nabsl\n::\nStrContains\n(\na\n,\n \n\"Hello World\"\n))\n \n{\n \n/* do something */\n \n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringLikeClasses\nÂ¶\n\n\nSemicolon-separated list of names of string-like classes. By default includes\n\n::std::basic_string\n, \n::std::basic_string_view\n, and\n\n::absl::string_view\n.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nAbseilStringsMatchHeader\nÂ¶\n\n\nThe location of Abseilâs \nstrings/match.h\n. Defaults to\n\nabsl/strings/match.h\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/string-find-str-contains.html"
  },
  {
    "name": "abseil-time-comparison",
    "description": "Prefer comparisons in the \nabsl::Time\n domain instead of the integer domain.\n\nN.B.: In cases where an \nabsl::Time\n is being converted to an integer,\nalignment may occur. If the comparison depends on this alignment, doing the\ncomparison in the \nabsl::Time\n domain may yield a different result. In\npractice this is very rare, and still indicates a bug which should be fixed.\n\nExamples:\n\n// Original - Comparison in the integer domain\n\n\nint\n \nx\n;\n\n\nabsl\n::\nTime\n \nt\n;\n\n\nif\n \n(\nx\n \n<\n \nabsl\n::\nToUnixSeconds\n(\nt\n))\n \n...\n\n\n\n// Suggested - Compare in the absl::Time domain instead\n\n\nif\n \n(\nabsl\n::\nFromUnixSeconds\n(\nx\n)\n \n<\n \nt\n)\n \n...",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/time-comparison.html"
  },
  {
    "name": "abseil-time-subtraction",
    "description": "Finds and fixes \nabsl::Time\n subtraction expressions to do subtraction\nin the Time domain instead of the numeric domain.\n\nThere are two cases of Time subtraction in which deduce additional type\ninformation:\n\nWhen the result is an \nabsl::Duration\n and the first argument is an\n\nabsl::Time\n.\n\n\nWhen the second argument is a \nabsl::Time\n.\n\nIn the first case, we must know the result of the operation, since without that\nthe second operand could be either an \nabsl::Time\n or an \nabsl::Duration\n.\nIn the second case, the first operand \nmust\n be an \nabsl::Time\n, because\nsubtracting an \nabsl::Time\n from an \nabsl::Duration\n is not defined.\n\nExamples:\n\nint\n \nx\n;\n\n\nabsl\n::\nTime\n \nt\n;\n\n\n\n// Original - absl::Duration result and first operand is an absl::Time.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nSeconds\n(\nabsl\n::\nToUnixSeconds\n(\nt\n)\n \n-\n \nx\n);\n\n\n\n// Suggestion - Perform subtraction in the Time domain instead.\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nt\n \n-\n \nabsl\n::\nFromUnixSeconds\n(\nx\n);\n\n\n\n\n// Original - Second operand is an absl::Time.\n\n\nint\n \ni\n \n=\n \nx\n \n-\n \nabsl\n::\nToUnixSeconds\n(\nt\n);\n\n\n\n// Suggestion - Perform subtraction in the Time domain instead.\n\n\nint\n \ni\n \n=\n \nabsl\n::\nToInt64Seconds\n(\nabsl\n::\nFromUnixSeconds\n(\nx\n)\n \n-\n \nt\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/time-subtraction.html"
  },
  {
    "name": "abseil-unchecked-statusor-access",
    "description": "This check identifies unsafe accesses to values contained in\n\nabsl::StatusOr<T>\n objects. Below we will refer to this type as\n\nStatusOr<T>\n.\n\nAn access to the value of an \nStatusOr<T>\n occurs when one of its\n\nvalue\n, \noperator*\n, or \noperator->\n member functions is invoked.\nTo align with common misconceptions, the check considers these member\nfunctions as equivalent, even though there are subtle differences\nrelated to exceptions vs.Â undefined behavior.\n\nAn access to the value of a \nStatusOr<T>\n is considered safe if and\nonly if code in the local scope (e.g.Â function body) ensures that the\nstatus of the \nStatusOr<T>\n is ok in all possible execution paths that\ncan reach the access. That should happen either through an explicit\ncheck, using the \nStatusOr<T>::ok\n member function, or by constructing\nthe \nStatusOr<T>\n in a way that shows that its status is unambiguously\nok (e.g.Â by passing a value to its constructor).\n\nBelow we list some examples of safe and unsafe \nStatusOr<T>\n access\npatterns.\n\nNote: If the check isnât behaving as you would have expected on a code\nsnippet, please \nreport it\n.\n\nFalse negatives\nÂ¶\n\n\nThis check generally does \nnot\n generate false negatives. That means that if\nan access is not marked as unsafe, it is provably safe. If it cannot prove an\naccess safe, it is assumed to be unsafe. In some cases, the static analysis\ncannot prove an access safe even though it is, for a variety of reasons (e.g.\nunmodelled invariants of functions called). In these cases, the analysis does\nproduce false positive reports.\n\n\nThat being said, there are some heuristics used that in very rare cases might\nbe incorrect:\n\n\n\n\na const method accessor (without arguments) that returns different\nvalues when called multiple times\n.\n\n\n\n\nIf you think the check generated a false negative, please \nreport\nit\n.\n\nKnown limitations\nÂ¶\n\n\nThis is a non-exhaustive list of constructs that are currently not\nmodelled in the check and will lead to false positives:\n\n\n\n\nChecking a StatusOr and then capturing it in a lambda\n\n\nIndexing into a container with the same index\n\n\nProject specific helper-functions\n,\n\n\nFunctions with a stable return value\n\n\nAny\n \ncross-function reasoning\n. This is by\ndesign and will not change in the future.\n\nChecking if the status is ok, then accessing the value\nÂ¶\n\n\nThe check recognizes all straightforward ways for checking the status\nand accessing the value contained in a \nStatusOr<T>\n object. For\nexample:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nx\n);\n\n\n  \n}\n\n\n}\n\nChecking if the status is ok, then accessing the value from a copy\nÂ¶\n\n\nThe criteria that the check uses is semantic, not syntactic. It\nrecognizes when a copy of the \nStatusOr<T>\n object being accessed is\nknown to have ok status. For example:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx1\n)\n \n{\n\n\n  \nif\n \n(\nx1\n.\nok\n())\n \n{\n\n\n    \nabsl\n::\noptional\n<\nint\n>\n \nx2\n \n=\n \nx1\n;\n\n\n    \nuse\n(\n*\nx2\n);\n\n\n  \n}\n\n\n}\n\nEnsuring that the status is ok using common macros\nÂ¶\n\n\nThe check is aware of common macros like \nABSL_CHECK\n and \nASSERT_THAT\n.\nThose can be used to ensure that the status of a \nStatusOr<T>\n object\nis ok. For example:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nABSL_CHECK_OK\n(\nx\n);\n\n\n  \nuse\n(\n*\nx\n);\n\n\n}\n\nEnsuring that the status is ok, then accessing the value in a correlated branch\nÂ¶\n\n\nThe check is aware of correlated branches in the code and can figure out\nwhen a \nStatusOr<T>\n object is ensured to have ok status on all\nexecution paths that lead to an access. For example:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nbool\n \nsafe\n \n=\n \nfalse\n;\n\n\n  \nif\n \n(\nx\n.\nok\n()\n \n&&\n \nSomeOtherCondition\n())\n \n{\n\n\n    \nsafe\n \n=\n \ntrue\n;\n\n\n  \n}\n\n\n  \n// ... more code...\n\n\n  \nif\n \n(\nsafe\n)\n \n{\n\n\n    \nuse\n(\n*\nx\n);\n\n\n  \n}\n\n\n}\n\nAccessing the value without checking the status\nÂ¶\n\n\nThe check flags accesses to the value that are not locally guarded by a\nstatus check:\n\n\nvoid\n \nf1\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nuse\n(\n*\nx\n);\n \n// unsafe: it is unclear whether the status of `x` is ok.\n\n\n}\n\n\n\nvoid\n \nf2\n(\nabsl\n::\nStatusOr\n<\nMyStruct\n>\n \nx\n)\n \n{\n\n\n  \nuse\n(\nx\n->\nmember\n);\n \n// unsafe: it is unclear whether the status of `x` is ok.\n\n\n}\n\n\n\nvoid\n \nf3\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nuse\n(\nx\n.\nvalue\n());\n \n// unsafe: it is unclear whether the status of `x` is ok.\n\n\n}\n\n\n\n\n\n\nUse \nABSL_CHECK_OK\n to signal that you knowingly want to crash on\nnon-OK values.\n\n\nNOTE: Even though using \n.value()\n  on a non-\nok()\n \nStatusOr\n is defined\nto crash, it is often unintentional. That is why our checker flags those as\nwell.\n\nAccessing the value in the wrong branch\nÂ¶\n\n\nThe check is aware of the state of a \nStatusOr<T>\n object in different\nbranches of the code. For example:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n  \n}\n \nelse\n \n{\n\n\n    \nuse\n(\n*\nx\n);\n \n// unsafe: it is clear that the status of `x` is *not* ok.\n\n\n  \n}\n\n\n}\n\nAssuming a function result to be stable\nÂ¶\n\n\nThe check is aware that function results might not be stable. That is,\nconsecutive calls to the same function might return different values.\nFor example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nfoo\n.\nx\n().\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nfoo\n.\nx\n());\n \n// unsafe: it is unclear whether the status of `foo.x()` is ok.\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIn such cases it is best to store the result of the function call in a\nlocal variable and use it to access the value. For example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nconst\n \nauto\n&\n \nx\n \n=\n \nfoo\n.\nx\n();\n \nx\n.\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nx\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe check \ndoes\n assume that \nconst\n-qualified accessor functions\nreturn a stable value if no non-const function was called between the\ntwo calls:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nconst\n \nabsl\n::\nStatusOr\n<\nint\n>&\n \nget\n()\n \nconst\n \n{\n\n\n    \n[...];\n\n\n  \n}\n\n\n}\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nfoo\n.\nget\n().\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nfoo\n.\nget\n());\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIf there is a call to a non-\nconst\n-qualified function, the check\nassumes the return value of the accessor was mutated.\n\n\nclass\n \nFoo\n \n{\n\n\n  \nconst\n \nabsl\n::\nStatusOr\n<\nint\n>&\n \nget\n()\n \nconst\n \n{\n\n\n    \n[...];\n\n\n  \n}\n\n\n  \nvoid\n \nmutate\n();\n\n\n}\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nfoo\n.\nget\n().\nok\n())\n \n{\n\n\n    \nfoo\n.\nmutate\n();\n\n\n    \nuse\n(\n*\nfoo\n.\nget\n());\n \n// unsafe: `mutate()` might have changed the state of the object\n\n\n  \n}\n\n\n}\n\nRelying on invariants of uncommon APIs\nÂ¶\n\n\nThe check is unaware of invariants of uncommon APIs. For example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nfoo\n.\nHasProperty\n(\n\"bar\"\n))\n \n{\n\n\n    \nuse\n(\n*\nfoo\n.\nGetProperty\n(\n\"bar\"\n));\n \n// unsafe: it is unclear whether the status of `foo.GetProperty(\"bar\")` is ok.\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIn such cases it is best to check explicitly that the status of the\n\nStatusOr<T>\n object is ok. For example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nconst\n \nauto\n&\n \nproperty\n \n=\n \nfoo\n.\nGetProperty\n(\n\"bar\"\n);\n \nproperty\n.\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nproperty\n);\n\n\n  \n}\n\n\n}\n\nChecking if the \nStatusOr<T>\n is ok, then passing it to another function\nÂ¶\n\n\nThe check relies on local reasoning. The check and value access must\nboth happen in the same function. An access is considered unsafe even if\nthe caller of the function performing the access ensures that the status\nof the \nStatusOr<T>\n is ok. For example:\n\n\nvoid\n \ng\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nuse\n(\n*\nx\n);\n \n// unsafe: it is unclear whether the status of `x` is ok.\n\n\n}\n\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n    \ng\n(\nx\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nIn such cases it is best to either pass the value directly when calling\na function or check that the status of the \nStatusOr<T>\n is ok in the\nlocal scope of the callee. For example:\n\n\nvoid\n \ng\n(\nint\n \nval\n)\n \n{\n\n\n  \nuse\n(\nval\n);\n\n\n}\n\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n    \ng\n(\n*\nx\n);\n\n\n  \n}\n\n\n}\n\nAliases created via \nusing\n declarations\nÂ¶\n\n\nThe check is aware of aliases of \nStatusOr<T>\n types that are created\nvia \nusing\n declarations. For example:\n\n\nusing\n \nStatusOrInt\n \n=\n \nabsl\n::\nStatusOr\n<\nint\n>\n;\n\n\n\nvoid\n \nf\n(\nStatusOrInt\n \nx\n)\n \n{\n\n\n  \nuse\n(\n*\nx\n);\n \n// unsafe: it is unclear whether the status of `x` is ok.\n\n\n}\n\nContainers\nÂ¶\n\n\nThe check is more strict than necessary when it comes to containers of\n\nStatusOr<T>\n values. Simply checking that the status of an element of\na container is ok is not sufficient to deem accessing it safe. For\nexample:\n\n\nvoid\n \nf\n(\nstd\n::\nvector\n<\nabsl\n::\nStatusOr\n<\nint\n>>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n[\n0\n].\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nx\n[\n0\n]);\n \n// unsafe: it is unclear whether the status of `x[0]` is ok.\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nOne needs to grab a reference to a particular object and use that\ninstead:\n\n\nvoid\n \nf\n(\nstd\n::\nvector\n<\nabsl\n::\nStatusOr\n<\nint\n>>\n \nx\n)\n \n{\n\n\n  \nabsl\n::\nStatusOr\n<\nint\n>&\n \nx0\n \n=\n \nx\n[\n0\n];\n\n\n  \nif\n \n(\nx0\n.\nok\n())\n \n{\n\n\n    \nuse\n(\n*\nx0\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nA future version could improve the understanding of more safe usage\npatterns that involve containers.\n\nLambdas\nÂ¶\n\n\nThe check is capable of reporting unsafe \nStatusOr<T>\n accesses in\nlambdas, but isnât smart enough to propagate information from the\nsurrounding context through the lambda. This means that the following\npattern will be reported as an unsafe access:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n    \n[\n&\nx\n]()\n \n{\n\n\n      \nuse\n(\n*\nx\n);\n \n// unsafe: it is unclear whether the status of `x` is ok.\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nTo avoid the issue, you should instead capture the contained object,\neither by value or by reference. An init-capture is useful for this,\nhere capturing by reference:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n    \n[\n&\nx\n \n=\n \n*\nx\n]()\n \n{\n\n\n      \nuse\n(\nx\n);\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAlternatively you could add a check inside the lambda where the value is\naccessed:\n\n\nvoid\n \nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\n \nx\n)\n \n{\n\n\n  \n[\n&\nx\n]()\n \n{\n\n\n    \nif\n \n(\nx\n.\nok\n())\n \n{\n\n\n      \nuse\n(\n*\nx\n);\n\n\n    \n}\n\n\n  \n}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/unchecked-statusor-access.html"
  },
  {
    "name": "abseil-upgrade-duration-conversions",
    "description": "Finds calls to \nabsl::Duration\n arithmetic operators and factories whose\nargument needs an explicit cast to continue compiling after upcoming API\nchanges.\n\nThe operators \n*=\n, \n/=\n, \n*\n, and \n/\n for \nabsl::Duration\n currently\naccept an argument of class type that is convertible to an arithmetic type.\nSuch a call currently converts the value to an \nint64_t\n, even in a case such\nas \nstd::atomic<float>\n that would result in lossy conversion.\n\nAdditionally, the \nabsl::Duration\n factory functions (\nabsl::Hours\n,\n\nabsl::Minutes\n, etc) currently accept an \nint64_t\n or a floating-point\ntype. Similar to the arithmetic operators, calls with an argument of class type\nthat is convertible to an arithmetic type go through the \nint64_t\n path.\n\nThese operators and factories will be changed to only accept arithmetic types\nto prevent unintended behavior. After these changes are released, passing an\nargument of class type will no longer compile, even if the type is implicitly\nconvertible to an arithmetic type.\n\nHere are example fixes created by this check:\n\nstd\n::\natomic\n<\nint\n>\n \na\n;\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nMilliseconds\n(\na\n);\n\n\nd\n \n*=\n \na\n;\n\nbecomes\n\nstd\n::\natomic\n<\nint\n>\n \na\n;\n\n\nabsl\n::\nDuration\n \nd\n \n=\n \nabsl\n::\nMilliseconds\n(\nstatic_cast\n<\nint64_t\n>\n(\na\n));\n\n\nd\n \n*=\n \nstatic_cast\n<\nint64_t\n>\n(\na\n);\n\nNote that this check always adds a cast to \nint64_t\n in order to preserve the\ncurrent behavior of user code. It is possible that this uncovers unintended\nbehavior due to types implicitly convertible to a floating-point type.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/abseil/upgrade-duration-conversions.html"
  },
  {
    "name": "altera-id-dependent-backward-branch",
    "description": "Finds ID-dependent variables and fields that are used within loops. This causes\nbranches to occur inside the loops, and thus leads to performance degradation.\n\n// The following code will produce a warning because this ID-dependent\n\n\n// variable is used in a loop condition statement.\n\n\nint\n \nThreadID\n \n=\n \nget_local_id\n(\n0\n);\n\n\n\n// The following loop will produce a warning because the loop condition\n\n\n// statement depends on an ID-dependent variable.\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nThreadID\n;\n \n++\ni\n)\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \ni\n \n<<\n \nstd\n::\nendl\n;\n\n\n}\n\n\n\n// The following loop will not produce a warning, because the ID-dependent\n\n\n// variable is not used in the loop condition statement.\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \n++\ni\n)\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \nThreadID\n \n<<\n \nstd\n::\nendl\n;\n\n\n}\n\nBased on the \nAltera SDK for OpenCL: Best Practices Guide\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/altera/id-dependent-backward-branch.html"
  },
  {
    "name": "altera-kernel-name-restriction",
    "description": "Finds kernel files and include directives whose filename is \nkernel.cl\n,\n\nVerilog.cl\n, or \nVHDL.cl\n. The check is case insensitive.\n\nSuch kernel file names cause the offline compiler to generate intermediate\ndesign files that have the same names as certain internal files, which\nleads to a compilation error.\n\nBased on the \nGuidelines for Naming the Kernel\n section in the\n\nIntel FPGA SDK for OpenCL Pro Edition: Programming Guide\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/altera/kernel-name-restriction.html"
  },
  {
    "name": "altera-single-work-item-barrier",
    "description": "Finds OpenCL kernel functions that call a barrier function but do not call\nan ID function (\nget_local_id\n, \nget_local_id\n, \nget_group_id\n, or\n\nget_local_linear_id\n).\n\nThese kernels may be viable single work-item kernels, but will be forced to\nexecute as NDRange kernels if using a newer version of the Altera Offline\nCompiler (>= v17.01).\n\nIf using an older version of the Altera Offline Compiler, these kernel\nfunctions will be treated as single work-item kernels, which could be\ninefficient or lead to errors if NDRange semantics were intended.\n\nBased on the \nAltera SDK for OpenCL: Best Practices Guide\n.\n\nExamples:\n\n// error: function calls barrier but does not call an ID function.\n\n\nvoid\n \n__kernel\n \nbarrier_no_id\n(\n__global\n \nint\n \n*\n \nfoo\n,\n \nint\n \nsize\n)\n \n{\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n++\n)\n \n{\n\n\n    \nfoo\n[\ni\n]\n \n+=\n \n5\n;\n\n\n  \n}\n\n\n  \nbarrier\n(\nCLK_GLOBAL_MEM_FENCE\n);\n\n\n}\n\n\n\n// ok: function calls barrier and an ID function.\n\n\nvoid\n \n__kernel\n \nbarrier_with_id\n(\n__global\n \nint\n \n*\n \nfoo\n,\n \nint\n \nsize\n)\n \n{\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n++\n)\n \n{\n\n\n    \nint\n \ntid\n \n=\n \nget_global_id\n(\n0\n);\n\n\n    \nfoo\n[\ntid\n]\n \n+=\n \n5\n;\n\n\n  \n}\n\n\n  \nbarrier\n(\nCLK_GLOBAL_MEM_FENCE\n);\n\n\n}\n\n\n\n// ok with AOC Version 17.01: the reqd_work_group_size turns this into\n\n\n// an NDRange.\n\n\n__attribute__\n((\nreqd_work_group_size\n(\n2\n,\n2\n,\n2\n)))\n\n\nvoid\n \n__kernel\n \nbarrier_with_id\n(\n__global\n \nint\n \n*\n \nfoo\n,\n \nint\n \nsize\n)\n \n{\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \ni\n++\n)\n \n{\n\n\n    \nfoo\n[\ntid\n]\n \n+=\n \n5\n;\n\n\n  \n}\n\n\n  \nbarrier\n(\nCLK_GLOBAL_MEM_FENCE\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nAOCVersion\nÂ¶\n\n\nDefines the version of the Altera Offline Compiler. Defaults to \n1600\n\n(corresponding to version 16.00).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/altera/single-work-item-barrier.html"
  },
  {
    "name": "altera-struct-pack-align",
    "description": "Finds structs that are inefficiently packed or aligned, and recommends\npacking and/or aligning of said structs as needed.\n\nStructs that are not packed take up more space than they should, and accessing\nstructs that are not well aligned is inefficient.\n\nFix-its are provided to fix both of these issues by inserting and/or amending\nrelevant struct attributes.\n\nBased on the \nAltera SDK for OpenCL: Best Practices Guide\n.\n\n// The following struct is originally aligned to 4 bytes, and thus takes up\n\n\n// 12 bytes of memory instead of 10. Packing the struct will make it use\n\n\n// only 10 bytes of memory, and aligning it to 16 bytes will make it\n\n\n// efficient to access.\n\n\nstruct\n \nexample\n \n{\n\n\n  \nchar\n \na\n;\n    \n// 1 byte\n\n\n  \ndouble\n \nb\n;\n  \n// 8 bytes\n\n\n  \nchar\n \nc\n;\n    \n// 1 byte\n\n\n};\n\n\n\n// The following struct is arranged in such a way that packing is not needed.\n\n\n// However, it is aligned to 4 bytes instead of 8, and thus needs to be\n\n\n// explicitly aligned.\n\n\nstruct\n \nimplicitly_packed_example\n \n{\n\n\n  \nchar\n \na\n;\n  \n// 1 byte\n\n\n  \nchar\n \nb\n;\n  \n// 1 byte\n\n\n  \nchar\n \nc\n;\n  \n// 1 byte\n\n\n  \nchar\n \nd\n;\n  \n// 1 byte\n\n\n  \nint\n \ne\n;\n   \n// 4 bytes\n\n\n};\n\n\n\n// The following struct is explicitly aligned and packed.\n\n\nstruct\n \ngood_example\n \n{\n\n\n  \nchar\n \na\n;\n    \n// 1 byte\n\n\n  \ndouble\n \nb\n;\n  \n// 8 bytes\n\n\n  \nchar\n \nc\n;\n    \n// 1 byte\n\n\n}\n \n__attribute__\n((\npacked\n))\n \n__attribute__\n((\naligned\n(\n16\n));\n\n\n\n// Explicitly aligning a struct to the wrong value will result in a warning.\n\n\n// The following example should be aligned to 16 bytes, not 32.\n\n\nstruct\n \nbadly_aligned_example\n \n{\n\n\n  \nchar\n \na\n;\n    \n// 1 byte\n\n\n  \ndouble\n \nb\n;\n  \n// 8 bytes\n\n\n  \nchar\n \nc\n;\n    \n// 1 byte\n\n\n}\n \n__attribute__\n((\npacked\n))\n \n__attribute__\n((\naligned\n(\n32\n)));",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/altera/struct-pack-align.html"
  },
  {
    "name": "altera-unroll-loops",
    "description": "Finds inner loops that have not been unrolled, as well as fully unrolled loops\nwith unknown loop bounds or a large number of iterations.\n\nUnrolling inner loops could improve the performance of OpenCL kernels. However,\nif they have unknown loop bounds or a large number of iterations, they cannot\nbe fully unrolled, and should be partially unrolled.\n\nNotes:\n\nThis check is unable to determine the number of iterations in a \nwhile\n or\n\ndo..while\n loop; hence if such a loop is fully unrolled, a note is emitted\nadvising the user to partially unroll instead.\n\n\nIn \nfor\n loops, our check only works with simple arithmetic increments (\n\n+\n, \n-\n, \n*\n, \n/\n). For all other increments, partial unrolling is\nadvised.\n\n\nDepending on the exit condition, the calculations for determining if the\nnumber of iterations is large may be off by 1. This should not be an issue\nsince the cut-off is generally arbitrary.\n\nBased on the \nAltera SDK for OpenCL: Best Practices Guide\n.\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n++\n)\n \n{\n  \n// ok: outer loops should not be unrolled\n\n\n   \nint\n \nj\n \n=\n \n0\n;\n\n\n   \ndo\n \n{\n  \n// warning: this inner do..while loop should be unrolled\n\n\n      \nj\n++\n;\n\n\n   \n}\n \nwhile\n \n(\nj\n \n<\n \n15\n);\n\n\n\n   \nint\n \nk\n \n=\n \n0\n;\n\n\n   \n#pragma unroll\n\n\n   \nwhile\n \n(\nk\n \n<\n \n20\n)\n \n{\n  \n// ok: this inner loop is already unrolled\n\n\n      \nk\n++\n;\n\n\n   \n}\n\n\n}\n\n\n\nint\n \nA\n[\n1000\n];\n\n\n#pragma unroll\n\n\n// warning: this loop is large and should be partially unrolled\n\n\nfor\n \n(\nint\n \na\n \n:\n \nA\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \na\n);\n\n\n}\n\n\n\n#pragma unroll 5\n\n\n// ok: this loop is large, but is partially unrolled\n\n\nfor\n \n(\nint\n \na\n \n:\n \nA\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \na\n);\n\n\n}\n\n\n\n#pragma unroll\n\n\n// warning: this loop is large and should be partially unrolled\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n1000\n;\n \n++\ni\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \ni\n);\n\n\n}\n\n\n\n#pragma unroll 5\n\n\n// ok: this loop is large, but is partially unrolled\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n1000\n;\n \n++\ni\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \ni\n);\n\n\n}\n\n\n\n#pragma unroll\n\n\n// warning: << operator not supported, recommend partial unrolling\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n1000\n;\n \ni\n<<\n1\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \ni\n);\n\n\n}\n\n\n\nstd\n::\nvector\n<\nint\n>\n \nsomeVector\n \n(\n100\n,\n \n0\n);\n\n\nint\n \ni\n \n=\n \n0\n;\n\n\n#pragma unroll\n\n\n// note: loop may be large, recommend partial unrolling\n\n\nwhile\n \n(\ni\n \n<\n \nsomeVector\n.\nsize\n())\n \n{\n\n\n   \nsomeVector\n[\ni\n]\n++\n;\n\n\n}\n\n\n\n#pragma unroll\n\n\n// note: loop may be large, recommend partial unrolling\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n\n   \nprintf\n(\n\"In loop\"\n);\n\n\n}\n\n\n\n#pragma unroll 5\n\n\n// ok: loop may be large, but is partially unrolled\n\n\nwhile\n \n(\ni\n \n<\n \nsomeVector\n.\nsize\n())\n \n{\n\n\n   \nsomeVector\n[\ni\n]\n++\n;\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nMaxLoopIterations\nÂ¶\n\n\nDefines the maximum number of loop iterations that a fully unrolled loop\ncan have. By default, it is set to \n100\n.\n\n\nIn practice, this refers to the integer value of the upper bound\nwithin the loop statementâs condition expression.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/altera/unroll-loops.html"
  },
  {
    "name": "android-cloexec-accept",
    "description": "The usage of \naccept()\n is not recommended, itâs better to use \naccept4()\n.\nWithout this flag, an opened sensitive file descriptor would remain open across\na fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\naccept\n(\nsockfd\n,\n \naddr\n,\n \naddrlen\n);\n\n\n\n// becomes\n\n\n\naccept4\n(\nsockfd\n,\n \naddr\n,\n \naddrlen\n,\n \nSOCK_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-accept.html"
  },
  {
    "name": "android-cloexec-accept4",
    "description": "accept4()\n should include \nSOCK_CLOEXEC\n in its type argument to avoid the\nfile descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\naccept4\n(\nsockfd\n,\n \naddr\n,\n \naddrlen\n,\n \nSOCK_NONBLOCK\n);\n\n\n\n// becomes\n\n\n\naccept4\n(\nsockfd\n,\n \naddr\n,\n \naddrlen\n,\n \nSOCK_NONBLOCK\n \n|\n \nSOCK_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-accept4.html"
  },
  {
    "name": "android-cloexec-creat",
    "description": "The usage of \ncreat()\n is not recommended, itâs better to use \nopen()\n.\n\nExamples:\n\nint\n \nfd\n \n=\n \ncreat\n(\npath\n,\n \nmode\n);\n\n\n\n// becomes\n\n\n\nint\n \nfd\n \n=\n \nopen\n(\npath\n,\n \nO_WRONLY\n \n|\n \nO_CREAT\n \n|\n \nO_TRUNC\n \n|\n \nO_CLOEXEC\n,\n \nmode\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-creat.html"
  },
  {
    "name": "android-cloexec-dup",
    "description": "The usage of \ndup()\n is not recommended, itâs better to use \nfcntl()\n,\nwhich can set the close-on-exec flag. Otherwise, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\nint\n \nfd\n \n=\n \ndup\n(\noldfd\n);\n\n\n\n// becomes\n\n\n\nint\n \nfd\n \n=\n \nfcntl\n(\noldfd\n,\n \nF_DUPFD_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-dup.html"
  },
  {
    "name": "android-cloexec-epoll-create",
    "description": "The usage of \nepoll_create()\n is not recommended, itâs better to use\n\nepoll_create1()\n, which allows close-on-exec.\n\nExamples:\n\nepoll_create\n(\nsize\n);\n\n\n\n// becomes\n\n\n\nepoll_create1\n(\nEPOLL_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-epoll-create.html"
  },
  {
    "name": "android-cloexec-epoll-create1",
    "description": "epoll_create1()\n should include \nEPOLL_CLOEXEC\n in its type argument to\navoid the file descriptor leakage. Without this flag, an opened sensitive file\nwould remain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\nepoll_create1\n(\n0\n);\n\n\n\n// becomes\n\n\n\nepoll_create1\n(\nEPOLL_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-epoll-create1.html"
  },
  {
    "name": "android-cloexec-fopen",
    "description": "fopen()\n should include \ne\n in their mode string; so \nre\n would be\nvalid. This is equivalent to having set \nFD_CLOEXEC\n \non\n that descriptor.\n\nExamples:\n\nfopen\n(\n\"fn\"\n,\n \n\"r\"\n);\n\n\n\n// becomes\n\n\n\nfopen\n(\n\"fn\"\n,\n \n\"re\"\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-fopen.html"
  },
  {
    "name": "android-cloexec-inotify-init",
    "description": "The usage of \ninotify_init()\n is not recommended, itâs better to use\n\ninotify_init1()\n.\n\nExamples:\n\ninotify_init\n();\n\n\n\n// becomes\n\n\n\ninotify_init1\n(\nIN_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-inotify-init.html"
  },
  {
    "name": "android-cloexec-inotify-init1",
    "description": "inotify_init1()\n should include \nIN_CLOEXEC\n in its type argument\nto avoid the file descriptor leakage. Without this flag, an opened\nsensitive file would remain open across a fork+exec to a\nlower-privileged SELinux domain.\n\nExamples:\n\ninotify_init1\n(\nIN_NONBLOCK\n);\n\n\n\n// becomes\n\n\n\ninotify_init1\n(\nIN_NONBLOCK\n \n|\n \nIN_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-inotify-init1.html"
  },
  {
    "name": "android-cloexec-memfd-create",
    "description": "memfd_create()\n should include \nMFD_CLOEXEC\n in its type argument to avoid\nthe file descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\nmemfd_create\n(\nname\n,\n \nMFD_ALLOW_SEALING\n);\n\n\n\n// becomes\n\n\n\nmemfd_create\n(\nname\n,\n \nMFD_ALLOW_SEALING\n \n|\n \nMFD_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-memfd-create.html"
  },
  {
    "name": "android-cloexec-open",
    "description": "A common source of security bugs is code that opens a file without using the\n\nO_CLOEXEC\n flag. Without that flag, an opened sensitive file would remain\nopen across a fork+exec to a lower-privileged SELinux domain, leaking that\nsensitive data. Open-like functions including \nopen()\n, \nopenat()\n, and\n\nopen64()\n should include \nO_CLOEXEC\n in their flags argument.\n\nExamples:\n\nopen\n(\n\"filename\"\n,\n \nO_RDWR\n);\n\n\nopen64\n(\n\"filename\"\n,\n \nO_RDWR\n);\n\n\nopenat\n(\n0\n,\n \n\"filename\"\n,\n \nO_RDWR\n);\n\n\n\n// becomes\n\n\n\nopen\n(\n\"filename\"\n,\n \nO_RDWR\n \n|\n \nO_CLOEXEC\n);\n\n\nopen64\n(\n\"filename\"\n,\n \nO_RDWR\n \n|\n \nO_CLOEXEC\n);\n\n\nopenat\n(\n0\n,\n \n\"filename\"\n,\n \nO_RDWR\n \n|\n \nO_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-open.html"
  },
  {
    "name": "android-cloexec-pipe",
    "description": "This check detects usage of \npipe()\n. Using \npipe()\n is not recommended,\n\npipe2()\n is the suggested replacement. The check also adds the \nO_CLOEXEC\n\nflag that marks the file descriptor to be closed in child processes.\nWithout this flag a sensitive file descriptor can be leaked to a\nchild process, potentially into a lower-privileged SELinux domain.\n\nExamples:\n\npipe\n(\npipefd\n);\n\nSuggested replacement:\n\npipe2\n(\npipefd\n,\n \nO_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-pipe.html"
  },
  {
    "name": "android-cloexec-pipe2",
    "description": "This check ensures that \npipe2()\n is called with the \nO_CLOEXEC\n flag.\nThe check also adds the \nO_CLOEXEC\n flag that marks the file descriptor\nto be closed in child processes.\nWithout this flag a sensitive file descriptor can be leaked to a child process,\npotentially into a lower-privileged SELinux domain.\n\nExamples:\n\npipe2\n(\npipefd\n,\n \nO_NONBLOCK\n);\n\nSuggested replacement:\n\npipe2\n(\npipefd\n,\n \nO_NONBLOCK\n \n|\n \nO_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-pipe2.html"
  },
  {
    "name": "android-cloexec-socket",
    "description": "socket()\n should include \nSOCK_CLOEXEC\n in its type argument to avoid the\nfile descriptor leakage. Without this flag, an opened sensitive file would\nremain open across a fork+exec to a lower-privileged SELinux domain.\n\nExamples:\n\nsocket\n(\ndomain\n,\n \ntype\n,\n \nSOCK_STREAM\n);\n\n\n\n// becomes\n\n\n\nsocket\n(\ndomain\n,\n \ntype\n,\n \nSOCK_STREAM\n \n|\n \nSOCK_CLOEXEC\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/cloexec-socket.html"
  },
  {
    "name": "android-comparison-in-temp-failure-retry",
    "description": "Diagnoses comparisons that appear to be incorrectly placed in the argument to\nthe \nTEMP_FAILURE_RETRY\n macro. Having such a use is incorrect in the vast\nmajority of cases, and will often silently defeat the purpose of the\n\nTEMP_FAILURE_RETRY\n macro.\n\nFor context, \nTEMP_FAILURE_RETRY\n is \na convenience macro\n\nprovided by both glibc and Bionic. Its purpose is to repeatedly run a syscall\nuntil it either succeeds, or fails for reasons other than being interrupted.\n\nExample buggy usage looks like:\n\nchar\n \ncs\n[\n1\n];\n\n\nwhile\n \n(\nTEMP_FAILURE_RETRY\n(\nread\n(\nSTDIN_FILENO\n,\n \ncs\n,\n \nsizeof\n(\ncs\n))\n \n!=\n \n0\n))\n \n{\n\n\n  \n// Do something with cs.\n\n\n}\n\nBecause \nTEMP_FAILURE_RETRY\n will check for whether the result\n\nof the comparison\n is \n-1\n, and retry if so.\n\nIf you encounter this, the fix is simple: lift the comparison out of the\n\nTEMP_FAILURE_RETRY\n argument, like so:\n\nchar\n \ncs\n[\n1\n];\n\n\nwhile\n \n(\nTEMP_FAILURE_RETRY\n(\nread\n(\nSTDIN_FILENO\n,\n \ncs\n,\n \nsizeof\n(\ncs\n)))\n \n!=\n \n0\n)\n \n{\n\n\n  \n// Do something with cs.\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nRetryMacros\nÂ¶\n\n\nA comma-separated list of the names of retry macros to be checked.\nDefault is \nTEMP_FAILURE_RETRY\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/android/comparison-in-temp-failure-retry.html"
  },
  {
    "name": "boost-use-ranges",
    "description": "Detects calls to standard library iterator algorithms that could be replaced\nwith a Boost ranges version instead.\n\nExample\nÂ¶\n\n\nauto\n \nIter1\n \n=\n \nstd\n::\nfind\n(\nItems\n.\nbegin\n(),\n \nItems\n.\nend\n(),\n \n0\n);\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nequal\n(\nItems1\n.\ncbegin\n(),\n \nItems1\n.\ncend\n(),\n \nstd\n::\nbegin\n(\nItems2\n),\n\n\n                          \nstd\n::\nend\n(\nItems2\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nIter1\n \n=\n \nboost\n::\nrange\n::\nfind\n(\nItems\n,\n \n0\n);\n\n\nauto\n \nAreSame\n \n=\n \nboost\n::\nrange\n::\nequal\n(\nItems1\n,\n \nItems2\n);\n\nSupported algorithms\nÂ¶\n\n\nCalls to the following std library algorithms are checked:\n\n\nstd::accumulate\n,\n\nstd::adjacent_difference\n,\n\nstd::adjacent_find\n,\n\nstd::all_of\n,\n\nstd::any_of\n,\n\nstd::binary_search\n,\n\nstd::copy_backward\n,\n\nstd::copy_if\n,\n\nstd::copy\n,\n\nstd::count_if\n,\n\nstd::count\n,\n\nstd::equal_range\n,\n\nstd::equal\n,\n\nstd::fill\n,\n\nstd::find_end\n,\n\nstd::find_first_of\n,\n\nstd::find_if_not\n,\n\nstd::find_if\n,\n\nstd::find\n,\n\nstd::for_each\n,\n\nstd::generate\n,\n\nstd::includes\n,\n\nstd::iota\n,\n\nstd::is_partitioned\n,\n\nstd::is_permutation\n,\n\nstd::is_sorted_until\n,\n\nstd::is_sorted\n,\n\nstd::lexicographical_compare\n,\n\nstd::lower_bound\n,\n\nstd::make_heap\n,\n\nstd::max_element\n,\n\nstd::merge\n,\n\nstd::min_element\n,\n\nstd::mismatch\n,\n\nstd::next_permutation\n,\n\nstd::none_of\n,\n\nstd::partial_sum\n,\n\nstd::partial_sort_copy\n,\n\nstd::partition_copy\n,\n\nstd::partition_point\n,\n\nstd::partition\n,\n\nstd::pop_heap\n,\n\nstd::prev_permutation\n,\n\nstd::push_heap\n,\n\nstd::random_shuffle\n,\n\nstd::reduce\n,\n\nstd::remove_copy_if\n,\n\nstd::remove_copy\n,\n\nstd::remove_if\n,\n\nstd::remove\n,\n\nstd::replace_copy_if\n,\n\nstd::replace_copy\n,\n\nstd::replace_if\n,\n\nstd::replace\n,\n\nstd::reverse_copy\n,\n\nstd::reverse\n,\n\nstd::search\n,\n\nstd::set_difference\n,\n\nstd::set_intersection\n,\n\nstd::set_symmetric_difference\n,\n\nstd::set_union\n,\n\nstd::sort_heap\n,\n\nstd::sort\n,\n\nstd::stable_partition\n,\n\nstd::stable_sort\n,\n\nstd::transform\n,\n\nstd::unique_copy\n,\n\nstd::unique\n,\n\nstd::upper_bound\n.\n\n\nThe check will also look for the following functions from the\n\nboost::algorithm\n namespace:\n\n\nall_of_equal\n,\n\nany_of_equal\n,\n\nany_of\n,\n\napply_permutation\n,\n\napply_reverse_permutation\n,\n\nclamp_range\n,\n\ncopy_if_until\n,\n\ncopy_if_while\n,\n\ncopy_if\n,\n\ncopy_until\n,\n\ncopy_while\n,\n\nfind_backward\n,\n\nfind_if_backward\n,\n\nfind_if_not_backward\n,\n\nfind_if_not\n,\n\nfind_not_backward\n,\n\nhex_lower\n,\n\nhex\n,\n\niota\n, \nall_of\n,\n\nis_decreasing\n,\n\nis_increasing\n,\n\nis_palindrome\n,\n\nis_partitioned_until\n,\n\nis_partitioned\n,\n\nis_permutation\n,\n\nis_sorted_until\n,\n\nis_sorted\n,\n\nis_strictly_decreasing\n,\n\nis_strictly_increasing\n,\n\nnone_of_equal\n,\n\nnone_of\n,\n\none_of_equal\n,\n\none_of\n,\n\npartition_copy\n,\n\npartition_point\n,\n\nreduce\n,\n\nunhex\n.\n\nReverse Iteration\nÂ¶\n\n\nIf calls are made using reverse iterators on containers, The code will be\nfixed using the \nboost::adaptors::reverse\n adaptor.\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nequal\n(\nItems1\n.\nrbegin\n(),\n \nItems1\n.\nrend\n(),\n\n\n                          \nstd\n::\ncrbegin\n(\nItems2\n),\n \nstd\n::\ncrend\n(\nItems2\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nAreSame\n \n=\n \nboost\n::\nrange\n::\nequal\n(\nboost\n::\nadaptors\n::\nreverse\n(\nItems1\n),\n\n\n                                   \nboost\n::\nadaptors\n::\nreverse\n(\nItems2\n));\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nIncludeBoostSystem\nÂ¶\n\n\nIf \ntrue\n (default value) the boost headers are included as system headers\nwith angle brackets (\n#include <boost.hpp>\n), otherwise quotes are used\n(\n#include âboost.hppâ\n).\n\n\n\n\n\n\n\n\nUseReversePipe\nÂ¶\n\n\nWhen \ntrue\n (default \nfalse\n), fixes which involve reverse ranges will use the\npipe adaptor syntax instead of the function syntax.\n\n\nstd\n::\nfind\n(\nItems\n.\nrbegin\n(),\n \nItems\n.\nrend\n(),\n \n0\n);\n\n\n\n\n\n\nTransforms to:\n\n\nboost\n::\nrange\n::\nfind\n(\nItems\n \n|\n \nboost\n::\nadaptors\n::\nreversed\n,\n \n0\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/boost/use-ranges.html"
  },
  {
    "name": "boost-use-to-string",
    "description": "This check finds conversion from integer type like \nint\n to\n\nstd::string\n or \nstd::wstring\n using \nboost::lexical_cast\n,\nand replace it with calls to \nstd::to_string\n and \nstd::to_wstring\n.\n\nIt doesnât replace conversion from floating points despite the \nto_string\n\noverloads, because it would change the behavior.\n\nauto\n \nstr\n \n=\n \nboost\n::\nlexical_cast\n<\nstd\n::\nstring\n>\n(\n42\n);\n\n\nauto\n \nwstr\n \n=\n \nboost\n::\nlexical_cast\n<\nstd\n::\nwstring\n>\n(\n2137L\nL\n);\n\n\n\n// Will be changed to\n\n\nauto\n \nstr\n \n=\n \nstd\n::\nto_string\n(\n42\n);\n\n\nauto\n \nwstr\n \n=\n \nstd\n::\nto_wstring\n(\n2137L\nL\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/boost/use-to-string.html"
  },
  {
    "name": "bugprone-argument-comment",
    "description": "Checks that argument comments match parameter names.\n\nThe check understands argument comments in the form \n/*parameter_name=*/\n\nthat are placed right before the argument.\n\nvoid\n \nf\n(\nbool\n \nfoo\n);\n\n\n\n...\n\n\n\nf\n(\n/*bar=*/\ntrue\n);\n\n\n// warning: argument name 'bar' in comment does not match parameter name 'foo'\n\nThe check tries to detect typos and suggest automated fixes for them.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen \nfalse\n, the check will ignore leading and trailing\nunderscores and case when comparing names â otherwise they are taken into\naccount. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreSingleArgument\nÂ¶\n\n\nWhen \ntrue\n, the check will ignore the single argument. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nCommentBoolLiterals\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the boolean literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\nbool\n \nTurnKey\n,\n \nbool\n \nPressButton\n);\n\n\n\nfoo\n(\ntrue\n,\n \nfalse\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\nbool\n \nTurnKey\n,\n \nbool\n \nPressButton\n);\n\n\n\nfoo\n(\n/*TurnKey=*/\ntrue\n,\n \n/*PressButton=*/\nfalse\n);\n\n\n\n\n\n\n\n\n\n\nCommentIntegerLiterals\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the integer literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\nint\n \nMeaningOfLife\n);\n\n\n\nfoo\n(\n42\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\nint\n \nMeaningOfLife\n);\n\n\n\nfoo\n(\n/*MeaningOfLife=*/\n42\n);\n\n\n\n\n\n\n\n\n\n\nCommentFloatLiterals\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the float/double literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\nfloat\n \nPi\n);\n\n\n\nfoo\n(\n3.14159\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\nfloat\n \nPi\n);\n\n\n\nfoo\n(\n/*Pi=*/\n3.14159\n);\n\n\n\n\n\n\n\n\n\n\nCommentStringLiterals\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the string literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\nconst\n \nchar\n \n*\nString\n);\n\n\nvoid\n \nfoo\n(\nconst\n \nwchar_t\n \n*\nWideString\n);\n\n\n\nfoo\n(\n\"Hello World\"\n);\n\n\nfoo\n(\nL\n\"Hello World\"\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\nconst\n \nchar\n \n*\nString\n);\n\n\nvoid\n \nfoo\n(\nconst\n \nwchar_t\n \n*\nWideString\n);\n\n\n\nfoo\n(\n/*String=*/\n\"Hello World\"\n);\n\n\nfoo\n(\n/*WideString=*/\nL\n\"Hello World\"\n);\n\n\n\n\n\n\n\n\n\n\nCommentCharacterLiterals\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the character literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\nchar\n \n*\nCharacter\n);\n\n\n\nfoo\n(\n'A'\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\nchar\n \n*\nCharacter\n);\n\n\n\nfoo\n(\n/*Character=*/\n'A'\n);\n\n\n\n\n\n\n\n\n\n\nCommentUserDefinedLiterals\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the user defined literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\ndouble\n \nDistance\n);\n\n\n\ndouble\n \noperator\n\"\"\n \n_km\n(\nlong\n \ndouble\n);\n\n\n\nfoo\n(\n402.0\n_km\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\ndouble\n \nDistance\n);\n\n\n\ndouble\n \noperator\n\"\"\n \n_km\n(\nlong\n \ndouble\n);\n\n\n\nfoo\n(\n/*Distance=*/\n402.0\n_km\n);\n\n\n\n\n\n\n\n\n\n\nCommentNullPtrs\nÂ¶\n\n\nWhen \ntrue\n, the check will add argument comments in the format\n\n/*ParameterName=*/\n right before the nullptr literal argument.\nDefault is \nfalse\n.\n\n\n\n\nBefore:\n\n\nvoid\n \nfoo\n(\nA\n*\n \nValue\n);\n\n\n\nfoo\n(\nnullptr\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n(\nA\n*\n \nValue\n);\n\n\n\nfoo\n(\n/*Value=*/\nnullptr\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/argument-comment.html"
  },
  {
    "name": "bugprone-assert-side-effect",
    "description": "Finds \nassert()\n with side effect.\n\nThe condition of \nassert()\n is evaluated only in debug builds so a\ncondition with side effect can cause different behavior in debug / release\nbuilds.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAssertMacros\nÂ¶\n\n\nA comma-separated list of the names of assert macros to be checked.\nDefault is \nassert,NSAssert,NSCAssert\n.\n\n\n\n\n\n\n\n\nCheckFunctionCalls\nÂ¶\n\n\nWhether to treat non-const member and non-member functions as they produce\nside effects. Disabled by default because it can increase the number of false\npositive warnings.\n\n\n\n\n\n\n\n\nIgnoredFunctions\nÂ¶\n\n\nA semicolon-separated list of the names of functions or methods to be\nconsidered as not having side-effects. Regular expressions are accepted,\ne.g. \n[Rr]ef(erence)?$\n matches every type with suffix \nRef\n, \nref\n,\n\nReference\n and \nreference\n. The default is empty. If a name in the list\ncontains the sequence \n::\n it is matched against the qualified type name\n(i.e. \nnamespace::Type\n), otherwise it is matched against only\nthe type name (i.e. \nType\n).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/assert-side-effect.html"
  },
  {
    "name": "bugprone-assignment-in-if-condition",
    "description": "Finds assignments within conditions of \nif\n statements.\nSuch assignments are bug-prone because they may have been intended as\nequality tests.\n\nThis check finds all assignments within \nif\n conditions, including ones that\nare not flagged by \n-Wparentheses\n due to an extra set of parentheses, and\nincluding assignments that call an overloaded \noperator=()\n. The identified\nassignments violate\n\nBARR group âRule 8.2.câ\n.\n\nint\n \nf\n \n=\n \n3\n;\n\n\nif\n(\nf\n \n=\n \n4\n)\n \n{\n \n// This is identified by both `Wparentheses` and this check - should it have been: `if (f == 4)` ?\n\n\n  \nf\n \n=\n \nf\n \n+\n \n1\n;\n\n\n}\n\n\n\nif\n((\nf\n \n==\n \n5\n)\n \n||\n \n(\nf\n \n=\n \n6\n))\n \n{\n \n// the assignment here `(f = 6)` is identified by this check, but not by `-Wparentheses`. Should it have been `(f == 6)` ?\n\n\n  \nf\n \n=\n \nf\n \n+\n \n2\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/assignment-in-if-condition.html"
  },
  {
    "name": "bugprone-bad-signal-to-kill-thread",
    "description": "Finds \npthread_kill\n function calls when a thread is terminated by\nraising \nSIGTERM\n signal and the signal kills the entire process, not\njust the individual thread. Use any signal except \nSIGTERM\n.\n\npthread_kill\n(\nthread\n,\n \nSIGTERM\n);\n\nThis check corresponds to the CERT C Coding Standard rule\n\nPOS44-C. Do not use signals to terminate threads\n.\n\ncert-pos44-c\n redirects here as an alias of this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/bad-signal-to-kill-thread.html"
  },
  {
    "name": "bugprone-bitwise-pointer-cast",
    "description": "Warns about code that tries to cast between pointers by means of\n\nstd::bit_cast\n or \nmemcpy\n.\n\nThe motivation is that \nstd::bit_cast\n is advertised as the safe alternative\nto type punning via \nreinterpret_cast\n in modern C++. However, one should not\nblindly replace \nreinterpret_cast\n with \nstd::bit_cast\n, as follows:\n\nint\n \nx\n{};\n\n\n-\nfloat\n \ny\n \n=\n \n*\nreinterpret_cast\n<\nfloat\n*>\n(\n&\nx\n);\n\n\n+\nfloat\n \ny\n \n=\n \n*\nstd\n::\nbit_cast\n<\nfloat\n*>\n(\n&\nx\n);\n\nThe drop-in replacement behaves exactly the same as \nreinterpret_cast\n, and\nUndefined Behavior is still invoked. \nstd::bit_cast\n is copying the bytes of\nthe input pointer, not the pointee, into an output pointer of a different type,\nwhich may violate the strict aliasing rules. However, simply looking at the\ncode, it looks âsafeâ, because it uses \nstd::bit_cast\n which is advertised as\nsafe.\n\nThe solution to safe type punning is to apply \nstd::bit_cast\n on value types,\nnot on pointer types:\n\nint\n \nx\n{};\n\n\nfloat\n \ny\n \n=\n \nstd\n::\nbit_cast\n<\nfloat\n>\n(\nx\n);\n\nThis way, the bytes of the input object are copied into the output object,\nwhich is much safer. Do note that Undefined Behavior can still occur, if there\nis no value of type \nTo\n corresponding to the value representation produced.\nCompilers may be able to optimize this copy and generate identical assembly to\nthe original \nreinterpret_cast\n version.\n\nCode before C++20 may backport \nstd::bit_cast\n by means of \nmemcpy\n, or\nsimply call \nmemcpy\n directly, which is equally problematic. This is also\ndetected by this check:\n\nint\n*\n \nx\n{};\n\n\nfloat\n*\n \ny\n{};\n\n\nstd\n::\nmemcpy\n(\n&\ny\n,\n \n&\nx\n,\n \nsizeof\n(\nx\n));\n\nAlternatively, if a cast between pointers is truly wanted, \nreinterpret_cast\n\nshould be used, to clearly convey the intent and enable warnings from compilers\nand linters, which should be addressed accordingly.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/bitwise-pointer-cast.html"
  },
  {
    "name": "bugprone-bool-pointer-implicit-conversion",
    "description": "Checks for conditions based on implicit conversion from a \nbool\n pointer to\n\nbool\n.\n\nExample:\n\nbool\n \n*\np\n;\n\n\nif\n \n(\np\n)\n \n{\n\n\n  \n// Never used in a pointer-specific way.\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/bool-pointer-implicit-conversion.html"
  },
  {
    "name": "bugprone-branch-clone",
    "description": "Checks for repeated branches in \nif/else\n \nif/else\n chains, consecutive\nrepeated branches in \nswitch\n statements and identical true and false\nbranches in conditional operators.\n\nif\n \n(\ntest_value\n(\nx\n))\n \n{\n\n\n  \ny\n++\n;\n\n\n  \ndo_something\n(\nx\n,\n \ny\n);\n\n\n}\n \nelse\n \n{\n\n\n  \ny\n++\n;\n\n\n  \ndo_something\n(\nx\n,\n \ny\n);\n\n\n}\n\nIn this simple example (which could arise e.g. as a copy-paste error) the\n\nthen\n and \nelse\n branches are identical and the code is equivalent the\nfollowing shorter and cleaner code:\n\ntest_value\n(\nx\n);\n \n// can be omitted unless it has side effects\n\n\ny\n++\n;\n\n\ndo_something\n(\nx\n,\n \ny\n);\n\nIf this is the intended behavior, then there is no reason to use a conditional\nstatement; otherwise the issue can be solved by fixing the branch that is\nhandled incorrectly.\n\nThe check detects repeated branches in longer \nif/else\n \nif/else\n chains\nwhere it would be even harder to notice the problem.\n\nThe check also detects repeated inner and outer \nif\n statements that may\nbe a result of a copy-paste error. This check cannot currently detect\nidentical inner and outer \nif\n statements if code is between the \nif\n\nconditions. An example is as follows.\n\nvoid\n \ntest_warn_inner_if_1\n(\nint\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n \n==\n \n1\n)\n \n{\n    \n// warns, if with identical inner if\n\n\n    \nif\n \n(\nx\n \n==\n \n1\n)\n    \n// inner if is here\n\n\n      \n;\n\n\n  \nif\n \n(\nx\n \n==\n \n1\n)\n \n{\n    \n// does not warn, cannot detect\n\n\n    \nint\n \ny\n \n=\n \nx\n;\n\n\n    \nif\n \n(\nx\n \n==\n \n1\n)\n\n\n      \n;\n\n\n  \n}\n\n\n}\n\nIn \nswitch\n statements the check only reports repeated branches when they are\nconsecutive, because it is relatively common that the \ncase:\n labels have\nsome natural ordering and rearranging them would decrease the readability of\nthe code. For example:\n\nswitch\n \n(\nch\n)\n \n{\n\n\ncase\n \n'a'\n:\n\n\n  \nreturn\n \n10\n;\n\n\ncase\n \n'A'\n:\n\n\n  \nreturn\n \n10\n;\n\n\ncase\n \n'b'\n:\n\n\n  \nreturn\n \n11\n;\n\n\ncase\n \n'B'\n:\n\n\n  \nreturn\n \n11\n;\n\n\ndefault\n:\n\n\n  \nreturn\n \n10\n;\n\n\n}\n\nHere the check reports that the \n'a'\n and \n'A'\n branches are identical\n(and that the \n'b'\n and \n'B'\n branches are also identical), but does not\nreport that the \ndefault:\n branch is also identical to the first two branches.\nIf this is indeed the correct behavior, then it could be implemented as:\n\nswitch\n \n(\nch\n)\n \n{\n\n\ncase\n \n'a'\n:\n\n\ncase\n \n'A'\n:\n\n\n  \nreturn\n \n10\n;\n\n\ncase\n \n'b'\n:\n\n\ncase\n \n'B'\n:\n\n\n  \nreturn\n \n11\n;\n\n\ndefault\n:\n\n\n  \nreturn\n \n10\n;\n\n\n}\n\nHere the check does not warn for the repeated \nreturn\n \n10;\n, which is good if\nwe want to preserve that \n'a'\n is before \n'b'\n and \ndefault:\n is the last\nbranch.\n\nSwitch cases marked with the \n[[fallthrough]]\n attribute are ignored.\n\nFinally, the check also examines conditional operators and reports code like:\n\nreturn\n \ntest_value\n(\nx\n)\n \n?\n \nx\n \n:\n \nx\n;\n\nUnlike if statements, the check does not detect chains of conditional\noperators.\n\nNote: This check also reports situations where branches become identical only\nafter preprocessing.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/branch-clone.html"
  },
  {
    "name": "bugprone-capturing-this-in-member-variable",
    "description": "Finds lambda captures that capture the \nthis\n pointer and store it as class\nmembers without handle the copy and move constructors and the assignments.\n\nCapture this in a lambda and store it as a class member is dangerous because\nthe lambda can outlive the object it captures. Especially when the object is\ncopied or moved, the captured \nthis\n pointer will be implicitly propagated\nto the new object. Most of the time, people will believe that the captured\n\nthis\n pointer points to the new object, which will lead to bugs.\n\nstruct\n \nC\n \n{\n\n\n  \nC\n()\n \n:\n \nCaptured\n([\nthis\n]()\n \n->\n \nC\n \nconst\n \n*\n \n{\n \nreturn\n \nthis\n;\n \n})\n \n{}\n\n\n  \nstd\n::\nfunction\n<\nC\n \nconst\n \n*\n()\n>\n \nCaptured\n;\n\n\n};\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nC\n \nv1\n{};\n\n\n  \nC\n \nv2\n \n=\n \nv1\n;\n \n// v2.Captured capture v1's 'this' pointer\n\n\n  \nassert\n(\nv2\n.\nCaptured\n()\n \n==\n \nv1\n.\nCaptured\n());\n \n// v2.Captured capture v1's 'this' pointer\n\n\n  \nassert\n(\nv2\n.\nCaptured\n()\n \n==\n \n&\nv2\n);\n \n// assertion failed.\n\n\n}\n\nPossible fixes:\n\n\nmarking copy and move constructors and assignment operators deleted.\n\n\nusing class member method instead of class member variable with function\nobject types.\n\n\npassing \nthis\n pointer as parameter.\n\nOptions\nÂ¶\n\n\n\n\n\n\nFunctionWrapperTypes\nÂ¶\n\n\nA semicolon-separated list of names of types. Used to specify function\nwrapper that can hold lambda expressions.\nDefault is \n::std::function;::std::move_only_function;::boost::function\n.\n\n\n\n\n\n\n\n\nBindFunctions\nÂ¶\n\n\nA semicolon-separated list of fully qualified names of functions that can\ncapture \nthis\n pointer.\nDefault is \n::std::bind;::boost::bind;::std::bind_front;::std::bind_back;\n::boost::compat::bind_front;::boost::compat::bind_back\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/capturing-this-in-member-variable.html"
  },
  {
    "name": "bugprone-casting-through-void",
    "description": "Detects unsafe or redundant two-step casting operations involving \nvoid*\n,\nwhich is equivalent to \nreinterpret_cast\n as per the\n\nC++ Standard\n.\n\nTwo-step type conversions via \nvoid*\n are discouraged for several reasons.\n\nThey obscure code and impede its understandability, complicating maintenance.\n\n\nThese conversions bypass valuable compiler support, erasing warnings related\nto pointer alignment. It may violate strict aliasing rule and leading to\nundefined behavior.\n\n\nIn scenarios involving multiple inheritance, ambiguity and unexpected\noutcomes can arise due to the loss of type information, posing runtime\nissues.\n\nIn summary, avoiding two-step type conversions through \nvoid*\n ensures\nclearer code, maintains essential compiler warnings, and prevents ambiguity\nand potential runtime errors, particularly in complex inheritance scenarios.\nIf such a cast is wanted, it shall be done via \nreinterpret_cast\n,\nto express the intent more clearly.\n\nNote: it is expected that, after applying the suggested fix and using\n\nreinterpret_cast\n, the check\n\ncppcoreguidelines-pro-type-reinterpret-cast\n will emit a warning.\nThis is intentional: \nreinterpret_cast\n is a dangerous operation that can\neasily break the strict aliasing rules when dereferencing the casted pointer,\ninvoking Undefined Behavior. The warning is there to prompt users to carefully\nanalyze whether the usage of \nreinterpret_cast\n is safe, in which case the\nwarning may be suppressed.\n\nExamples:\n\nusing\n \nIntegerPointer\n \n=\n \nint\n \n*\n;\n\n\ndouble\n \n*\nptr\n;\n\n\n\nstatic_cast\n<\nIntegerPointer\n>\n(\nstatic_cast\n<\nvoid\n \n*>\n(\nptr\n));\n \n// WRONG\n\n\nreinterpret_cast\n<\nIntegerPointer\n>\n(\nreinterpret_cast\n<\nvoid\n \n*>\n(\nptr\n));\n \n// WRONG\n\n\n(\nIntegerPointer\n)(\nvoid\n \n*\n)\nptr\n;\n \n// WRONG\n\n\nIntegerPointer\n(\nstatic_cast\n<\nvoid\n \n*>\n(\nptr\n));\n \n// WRONG\n\n\n\nreinterpret_cast\n<\nIntegerPointer\n>\n(\nptr\n);\n \n// OK, clearly expresses intent.\n\n\n                                       \n// NOTE: dereferencing this pointer violates\n\n\n                                       \n// the strict aliasing rules, invoking\n\n\n                                       \n// Undefined Behavior.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/casting-through-void.html"
  },
  {
    "name": "bugprone-chained-comparison",
    "description": "Check detects chained comparison operators that can lead to unintended\nbehavior or logical errors.\n\nChained comparisons are expressions that use multiple comparison operators\nto compare three or more values. For example, the expression \na\n \n<\n \nb\n \n<\n \nc\n\ncompares the values of \na\n, \nb\n, and \nc\n. However, this expression does\nnot evaluate as \n(a\n \n<\n \nb)\n \n&&\n \n(b\n \n<\n \nc)\n, which is probably what the developer\nintended. Instead, it evaluates as \n(a\n \n<\n \nb)\n \n<\n \nc\n, which may produce\nunintended results, especially when the types of \na\n, \nb\n, and \nc\n are\ndifferent.\n\nTo avoid such errors, the check will issue a warning when a chained\ncomparison operator is detected, suggesting to use parentheses to specify\nthe order of evaluation or to use a logical operator to separate comparison\nexpressions.\n\nConsider the following examples:\n\nint\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n6\n,\n \nc\n \n=\n \n4\n;\n\n\nif\n \n(\na\n \n<\n \nb\n \n<\n \nc\n)\n \n{\n\n\n    \n// This block will be executed\n\n\n}\n\nIn this example, the developer intended to check if \na\n is less than \nb\n\nand \nb\n is less than \nc\n. However, the expression \na\n \n<\n \nb\n \n<\n \nc\n is\nequivalent to \n(a\n \n<\n \nb)\n \n<\n \nc\n. Since \na\n \n<\n \nb\n is \ntrue\n, the expression\n\n(a\n \n<\n \nb)\n \n<\n \nc\n is evaluated as \n1\n \n<\n \nc\n, which is equivalent to \ntrue\n \n<\n \nc\n\nand is invalid in this case as \nb\n \n<\n \nc\n is \nfalse\n.\n\nEven that above issue could be detected as comparison of \nint\n to \nbool\n,\nthere is more dangerous example:\n\nbool\n \na\n \n=\n \nfalse\n,\n \nb\n \n=\n \nfalse\n,\n \nc\n \n=\n \ntrue\n;\n\n\nif\n \n(\na\n \n==\n \nb\n \n==\n \nc\n)\n \n{\n\n\n    \n// This block will be executed\n\n\n}\n\nIn this example, the developer intended to check if \na\n, \nb\n, and \nc\n are\nall equal. However, the expression \na\n \n==\n \nb\n \n==\n \nc\n is evaluated as\n\n(a\n \n==\n \nb)\n \n==\n \nc\n. Since \na\n \n==\n \nb\n is true, the expression \n(a\n \n==\n \nb)\n \n==\n \nc\n\nis evaluated as \ntrue\n \n==\n \nc\n, which is equivalent to \ntrue\n \n==\n \ntrue\n.\nThis comparison yields \ntrue\n, even though \na\n and \nb\n are \nfalse\n, and\nare not equal to \nc\n.\n\nTo avoid this issue, the developer can use a logical operator to separate the\ncomparison expressions, like this:\n\nif\n \n(\na\n \n==\n \nb\n \n&&\n \nb\n \n==\n \nc\n)\n \n{\n\n\n    \n// This block will not be executed\n\n\n}\n\nAlternatively, use of parentheses in the comparison expressions can make the\ndeveloperâs intention more explicit and help avoid misunderstanding.\n\nif\n \n((\na\n \n==\n \nb\n)\n \n==\n \nc\n)\n \n{\n\n\n    \n// This block will be executed\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf \ntrue\n, the check will not warn on chained comparisons inside macros.\nDefault is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/chained-comparison.html"
  },
  {
    "name": "bugprone-command-processor",
    "description": "Flags calls to \nsystem()\n, \npopen()\n, and \n_popen()\n, which\nexecute a command processor. It does not flag calls to \nsystem()\n with a null\npointer argument, as such a call checks for the presence of a command processor\nbut does not actually attempt to execute a command.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C Coding Standard rule\n\nENV33-C. Do not call system()\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/command-processor.html"
  },
  {
    "name": "bugprone-compare-pointer-to-member-virtual-function",
    "description": "Detects unspecified behavior about equality comparison between pointer to\nmember virtual function and anything other than null-pointer-constant.\n\nstruct\n \nA\n \n{\n\n\n  \nvoid\n \nf1\n();\n\n\n  \nvoid\n \nf2\n();\n\n\n  \nvirtual\n \nvoid\n \nf3\n();\n\n\n  \nvirtual\n \nvoid\n \nf4\n();\n\n\n\n  \nvoid\n \ng1\n(\nint\n);\n\n\n};\n\n\n\nvoid\n \nfn\n()\n \n{\n\n\n  \nbool\n \nr1\n \n=\n \n(\n&\nA\n::\nf1\n \n==\n \n&\nA\n::\nf2\n);\n  \n// ok\n\n\n  \nbool\n \nr2\n \n=\n \n(\n&\nA\n::\nf1\n \n==\n \n&\nA\n::\nf3\n);\n  \n// bugprone\n\n\n  \nbool\n \nr3\n \n=\n \n(\n&\nA\n::\nf1\n \n!=\n \n&\nA\n::\nf3\n);\n  \n// bugprone\n\n\n  \nbool\n \nr4\n \n=\n \n(\n&\nA\n::\nf3\n \n==\n \nnullptr\n);\n \n// ok\n\n\n  \nbool\n \nr5\n \n=\n \n(\n&\nA\n::\nf3\n \n==\n \n&\nA\n::\nf4\n);\n  \n// bugprone\n\n\n\n  \nvoid\n \n(\nA\n::*\nv1\n)()\n \n=\n \n&\nA\n::\nf3\n;\n\n\n  \nbool\n \nr6\n \n=\n \n(\nv1\n \n==\n \n&\nA\n::\nf1\n);\n \n// bugprone\n\n\n  \nbool\n \nr6\n \n=\n \n(\nv1\n \n==\n \nnullptr\n);\n \n// ok\n\n\n\n  \nvoid\n \n(\nA\n::*\nv2\n)()\n \n=\n \n&\nA\n::\nf2\n;\n\n\n  \nbool\n \nr7\n \n=\n \n(\nv2\n \n==\n \n&\nA\n::\nf1\n);\n \n// false positive, but potential risk if assigning other value to v2.\n\n\n\n  \nvoid\n \n(\nA\n::*\nv3\n)(\nint\n)\n \n=\n \n&\nA\n::\ng1\n;\n\n\n  \nbool\n \nr8\n \n=\n \n(\nv3\n \n==\n \n&\nA\n::\ng1\n);\n \n// ok, no virtual function match void(A::*)(int) signature.\n\n\n}\n\nProvide warnings on equality comparisons involve pointers to member virtual\nfunction or variables which is potential pointer to member virtual function and\nany entity other than a null-pointer constant.\n\nIn certain compilers, virtual function addresses are not conventional pointers\nbut instead consist of offsets and indexes within a virtual function table\n(vtable). Consequently, these pointers may vary between base and derived\nclasses, leading to unpredictable behavior when compared directly. This issue\nbecomes particularly challenging when dealing with pointers to pure virtual\nfunctions, as they may not even have a valid address, further complicating\ncomparisons.\n\nInstead, it is recommended to utilize the \ntypeid\n operator or other\nappropriate mechanisms for comparing objects to ensure robust and predictable\nbehavior in your codebase. By heeding this detection and adopting a more reliable\ncomparison method, you can mitigate potential issues related to unspecified\nbehavior, especially when dealing with pointers to member virtual functions or pure\nvirtual functions, thereby improving the overall stability and maintainability\nof your code. In scenarios involving pointers to member virtual functions, itâs\nonly advisable to employ \nnullptr\n for comparisons.\n\nLimitations\nÂ¶\n\n\nDoes not analyze values stored in a variable. For variable, only analyze all\nvirtual methods in the same \nclass\n or \nstruct\n and diagnose when assigning\na pointer to member virtual function to this variable is possible.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/compare-pointer-to-member-virtual-function.html"
  },
  {
    "name": "bugprone-copy-constructor-init",
    "description": "Finds copy constructors where the constructor doesnât call the copy constructor\nof the base class.\n\nclass\n \nCopyable\n \n{\n\n\npublic\n:\n\n\n  \nCopyable\n()\n \n=\n \ndefault\n;\n\n\n  \nCopyable\n(\nconst\n \nCopyable\n \n&\n)\n \n=\n \ndefault\n;\n\n\n\n  \nint\n \nmemberToBeCopied\n \n=\n \n0\n;\n\n\n};\n\n\n\nclass\n \nX2\n \n:\n \npublic\n \nCopyable\n \n{\n\n\n  \nX2\n(\nconst\n \nX2\n \n&\nother\n)\n \n{}\n \n// Copyable(other) is missing\n\n\n};\n\nAlso finds copy constructors where the constructor of\nthe base class donât have parameter.\n\nclass\n \nX3\n \n:\n \npublic\n \nCopyable\n \n{\n\n\n  \nX3\n(\nconst\n \nX3\n \n&\nother\n)\n \n:\n \nCopyable\n()\n \n{}\n \n// other is missing\n\n\n};\n\nFailure to properly initialize base class sub-objects during copy construction\ncan result in undefined behavior, crashes, data corruption, or other unexpected\noutcomes. The check ensures that the copy constructor of a derived class\nproperly calls the copy constructor of the base class, helping to prevent bugs\nand improve code quality.\n\nLimitations\nÂ¶\n\n\n\n\nIt wonât generate warnings for empty classes, as there are no class members\n(including base class sub-objects) to worry about.\n\n\nIt wonât generate warnings for base classes that have copy constructor\nprivate or deleted.\n\n\nIt wonât generate warnings for base classes that are initialized using other\nnon-default constructor, as this could be intentional.\n\n\n\n\nThe check also suggests a fix-its in some cases.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/copy-constructor-init.html"
  },
  {
    "name": "bugprone-copy-constructor-mutates-argument",
    "description": "Finds assignments to the copied object and its direct or indirect members\nin copy constructors and copy assignment operators.\n\nThis check corresponds to the CERT C Coding Standard rule\n\nOOP58-CPP. Copy operations must not mutate the source object\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/copy-constructor-mutates-argument.html"
  },
  {
    "name": "bugprone-crtp-constructor-accessibility",
    "description": "Detects error-prone Curiously Recurring Template Pattern usage, when the CRTP\ncan be constructed outside itself and the derived class.\n\nThe CRTP is an idiom, in which a class derives from a template class, where\nitself is the template argument. It should be ensured that if a class is\nintended to be a base class in this idiom, it can only be instantiated if\nthe derived class is its template argument.\n\nExample:\n\ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nCRTP\n \n{\n\n\nprivate\n:\n\n\n  \nCRTP\n()\n \n=\n \ndefault\n;\n\n\n  \nfriend\n \nT\n;\n\n\n};\n\n\n\nclass\n \nDerived\n \n:\n \nCRTP\n<\nDerived\n>\n \n{};\n\nBelow can be seen some common mistakes that will allow the breaking of the\nidiom.\n\nIf the constructor of a class intended to be used in a CRTP is public, then\nit allows users to construct that class on its own.\n\nExample:\n\ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nCRTP\n \n{\n\n\npublic\n:\n\n\n  \nCRTP\n()\n \n=\n \ndefault\n;\n\n\n};\n\n\n\nclass\n \nGood\n \n:\n \nCRTP\n<\nGood\n>\n \n{};\n\n\nGood\n \nGoodInstance\n;\n\n\n\nCRTP\n<\nint\n>\n \nBadInstance\n;\n\nIf the constructor is protected, the possibility of an accidental instantiation\nis prevented, however it can fade an error, when a different class is used as\nthe template parameter instead of the derived one.\n\nExample:\n\ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nCRTP\n \n{\n\n\nprotected\n:\n\n\n  \nCRTP\n()\n \n=\n \ndefault\n;\n\n\n};\n\n\n\nclass\n \nGood\n \n:\n \nCRTP\n<\nGood\n>\n \n{};\n\n\nGood\n \nGoodInstance\n;\n\n\n\nclass\n \nBad\n \n:\n \nCRTP\n<\nGood\n>\n \n{};\n\n\nBad\n \nBadInstance\n;\n\nTo ensure that no accidental instantiation happens, the best practice is to\nmake the constructor private and declare the derived class as friend. Note\nthat as a tradeoff, this also gives the derived class access to every other\nprivate members of the CRTP. However, constructors can still be public or\nprotected if they are deleted.\n\nExample:\n\ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nCRTP\n \n{\n\n\n  \nCRTP\n()\n \n=\n \ndefault\n;\n\n\n  \nfriend\n \nT\n;\n\n\n};\n\n\n\nclass\n \nGood\n \n:\n \nCRTP\n<\nGood\n>\n \n{};\n\n\nGood\n \nGoodInstance\n;\n\n\n\nclass\n \nBad\n \n:\n \nCRTP\n<\nGood\n>\n \n{};\n\n\nBad\n \nCompileTimeError\n;\n\n\n\nCRTP\n<\nint\n>\n \nAlsoCompileTimeError\n;\n\nLimitations\nÂ¶\n\n\n\n\nThe check is not supported below C++11\n\n\nThe check does not handle when the derived class is passed as a variadic\ntemplate argument\n\n\nAccessible functions that can construct the CRTP, like factory functions\nare not checked\n\n\n\n\nThe check also suggests a fix-its in some cases.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/crtp-constructor-accessibility.html"
  },
  {
    "name": "bugprone-dangling-handle",
    "description": "Detect dangling references in value handles like \nstd::string_view\n.\nThese dangling references can be a result of constructing handles from\ntemporary values, where the temporary is destroyed soon after the handle\nis created.\n\nExamples:\n\nstring_view\n \nView\n \n=\n \nstring\n();\n  \n// View will dangle.\n\n\nstring\n \nA\n;\n\n\nView\n \n=\n \nA\n \n+\n \n\"A\"\n;\n  \n// still dangle.\n\n\n\nvector\n<\nstring_view\n>\n \nV\n;\n\n\nV\n.\npush_back\n(\nstring\n());\n  \n// V[0] is dangling.\n\n\nV\n.\nresize\n(\n3\n,\n \nstring\n());\n  \n// V[1] and V[2] will also dangle.\n\n\n\nstring_view\n \nf\n()\n \n{\n\n\n  \n// All these return values will dangle.\n\n\n  \nreturn\n \nstring\n();\n\n\n  \nstring\n \nS\n;\n\n\n  \nreturn\n \nS\n;\n\n\n  \nchar\n \nArray\n[\n10\n]{};\n\n\n  \nreturn\n \nArray\n;\n\n\n}\n\n\n\nspan\n<\nint\n>\n \ng\n()\n \n{\n\n\n  \narray\n<\nint\n,\n \n1\n>\n \nV\n;\n\n\n  \nreturn\n \n{\nV\n};\n\n\n  \nint\n \nArray\n[\n10\n]{};\n\n\n  \nreturn\n \n{\nArray\n};\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nHandleClasses\nÂ¶\n\n\nA semicolon-separated list of class names that should be treated as handles.\nBy default only \nstd::basic_string_view\n,\n\nstd::experimental::basic_string_view\n and \nstd::span\n are considered.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/dangling-handle.html"
  },
  {
    "name": "bugprone-default-operator-new-on-overaligned-type",
    "description": "Flags uses of default \noperator\n \nnew\n where the type has extended\nalignment (an alignment greater than the fundamental alignment).\n\nThe default \noperator\n \nnew\n is guaranteed to provide the correct alignment\nif the requested alignment is less or equal to the fundamental alignment.\nOnly cases are detected (by design) where the \noperator\n \nnew\n is not\nuser-defined and is not a placement new (the reason is that in these cases we\nassume that the user provided the correct memory allocation).\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nMEM57-CPP. Avoid using default operator new for over-aligned types\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/default-operator-new-on-overaligned-type.html"
  },
  {
    "name": "bugprone-derived-method-shadowing-base-method",
    "description": "Finds derived class methods that shadow a (non-virtual) base class method.\n\nIn order to be considered âshadowingâ, methods must have the same signature\n(i.e. the same name, same number of parameters, same parameter types, etc).\nOnly checks public, non-templated methods.\n\nThe below example is bugprone because consumers of the \nDerived\n class will\nexpect the \nreset\n method to do the work of \nBase::reset()\n in addition to\nextra work required to reset the \nDerived\n class.  Common fixes include:\n\nMaking the \nreset\n method polymorphic\n\n\nRe-naming \nDerived::reset\n if itâs not meant to intersect with\n\nBase::reset\n\n\nUsing \nusing\n \nBase::reset\n to change the access specifier\n\nThis is also a violation of the Liskov Substitution Principle.\n\nstruct\n \nBase\n \n{\n\n\n  \nvoid\n \nreset\n()\n \n{\n/* reset the base class */\n};\n\n\n};\n\n\n\nstruct\n \nDerived\n \n:\n \npublic\n \nBase\n \n{\n\n\n  \nvoid\n \nreset\n()\n \n{\n/* reset the derived class, but not the base class */\n};\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/derived-method-shadowing-base-method.html"
  },
  {
    "name": "bugprone-dynamic-static-initializers",
    "description": "Finds instances of static variables that are dynamically initialized\nin header files.\n\nThis can pose problems in certain multithreaded contexts. For example,\nwhen disabling compiler generated synchronization instructions for\nstatic variables initialized at runtime (e.g. by \n-fno-threadsafe-statics\n),\neven if a particular project takes the necessary precautions to prevent race\nconditions during initialization by providing their own synchronization, header\nfiles included from other projects may not. Therefore, such a check is helpful\nfor ensuring that disabling compiler generated synchronization for static\nvariable initialization will not cause problems.\n\nConsider the following code:\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstatic\n \nint\n \nk\n \n=\n \nbar\n();\n\n\n  \nreturn\n \nk\n;\n\n\n}\n\nWhen synchronization of static initialization is disabled, if two threads both\ncall \nfoo\n for the first time, there is the possibility that \nk\n will be double\ninitialized, creating a race condition.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/dynamic-static-initializers.html"
  },
  {
    "name": "bugprone-easily-swappable-parameters",
    "description": "Finds function definitions where parameters of convertible types follow each\nother directly, making call sites prone to calling the function with\nswapped (or badly ordered) arguments.\n\nvoid\n \ndrawPoint\n(\nint\n \nX\n,\n \nint\n \nY\n)\n \n{\n \n/* ... */\n \n}\n\n\nFILE\n \n*\nopen\n(\nconst\n \nchar\n \n*\nDir\n,\n \nconst\n \nchar\n \n*\nName\n,\n \nFlags\n \nMode\n)\n \n{\n \n/* ... */\n \n}\n\nA potential call like \ndrawPoint(-2,\n \n5)\n or\n\nopenPath(\"a.txt\",\n \n\"tmp\",\n \nRead)\n is perfectly legal from the languageâs\nperspective, but might not be what the developer of the function intended.\n\nMore elaborate and type-safe constructs, such as opaque typedefs or strong\ntypes should be used instead, to prevent a mistaken order of arguments.\n\nstruct\n \nCoord2D\n \n{\n \nint\n \nX\n;\n \nint\n \nY\n;\n \n};\n\n\nvoid\n \ndrawPoint\n(\nconst\n \nCoord2D\n \nPos\n)\n \n{\n \n/* ... */\n \n}\n\n\n\nFILE\n \n*\nopen\n(\nconst\n \nPath\n \n&\nDir\n,\n \nconst\n \nFilename\n \n&\nName\n,\n \nFlags\n \nMode\n)\n \n{\n \n/* ... */\n \n}\n\nDue to the potentially elaborate refactoring and API-breaking that is necessary\nto strengthen the type safety of a project, no automatic fix-its are offered.\n\nOptions\nÂ¶\n\n\n\n\nExtension/relaxation options\nÂ¶\n\n\nRelaxation (or extension) options can be used to broaden the scope of the\nanalysis and fine-tune the enabling of more mixes between types.\nSome mixes may depend on coding style or preference specific to a project,\nhowever, it should be noted that enabling \nall\n of these relaxations model the\nway of mixing at call sites the most.\nThese options are expected to make the check report for more functions, and\nreport longer mixable ranges.\n\n\n\n\n\n\nQualifiersMix\nÂ¶\n\n\nWhether to consider parameters of some \ncvr-qualified\n \nT\n and a\ndifferently \ncvr-qualified\n \nT\n (i.e. \nT\n and \nconst\n \nT\n, \nconst\n \nT\n\nand \nvolatile\n \nT\n, etc.) mixable between one another.\nIf \nfalse\n, the check will consider differently qualified types unmixable.\n\nTrue\n turns the warnings on.\nDefaults to \nfalse\n.\n\n\nThe following example produces a diagnostic only if \nQualifiersMix\n is\nenabled:\n\n\nvoid\n \n*\nmemcpy\n(\nconst\n \nvoid\n \n*\nDestination\n,\n \nvoid\n \n*\nSource\n,\n \nstd\n::\nsize_t\n \nN\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\n\n\n\n\n\n\nModelImplicitConversions\nÂ¶\n\n\nWhether to consider parameters of type \nT\n and \nU\n mixable if there\nexists an implicit conversion from \nT\n to \nU\n and \nU\n to \nT\n.\nIf \nfalse\n, the check will not consider implicitly convertible types for\nmixability.\n\nTrue\n turns warnings for implicit conversions on.\nDefaults to \ntrue\n.\n\n\nThe following examples produce a diagnostic only if\n\nModelImplicitConversions\n is enabled:\n\n\nvoid\n \nfun\n(\nint\n \nInt\n,\n \ndouble\n \nDouble\n)\n \n{\n \n/* ... */\n \n}\n\n\nvoid\n \ncompare\n(\nconst\n \nchar\n \n*\nCharBuf\n,\n \nstd\n::\nstring\n \nString\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\n\n\nNote\n\n\nChanging the qualifiers of an expressionâs type (e.g. from \nint\n to\n\nconst\n \nint\n) is defined as an \nimplicit conversion\n in the C++\nStandard.\nHowever, the check separates this decision-making on the mixability of\ndifferently qualified types based on whether \nQualifiersMix\n was\nenabled.\n\n\nFor example, the following code snippet will only produce a diagnostic\nif \nboth\n \nQualifiersMix\n and \nModelImplicitConversions\n are enabled:\n\n\nvoid\n \nfun2\n(\nint\n \nInt\n,\n \nconst\n \ndouble\n \nDouble\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering options\nÂ¶\n\n\nFiltering options can be used to lessen the size of the diagnostics emitted by\nthe checker, whether the aim is to ignore certain constructs or dampen the\nnoisiness.\n\n\n\n\n\n\nMinimumLength\nÂ¶\n\n\nThe minimum length required from an adjacent parameter sequence to be\ndiagnosed.\nDefaults to \n2\n.\nMight be any positive integer greater or equal to \n2\n.\nIf \n0\n or \n1\n is given, the default value \n2\n will be used instead.\n\n\nFor example, if \n3\n is specified, the examples above will not be matched.\n\n\n\n\n\n\n\n\nIgnoredParameterNames\nÂ¶\n\n\nThe list of parameter \nnames\n that should never be considered part of a\nswappable adjacent parameter sequence.\nThe value is a \n;\n-separated list of names.\nTo ignore unnamed parameters, add \nââ\n to the list verbatim (not the\nempty string, but the two quotes, potentially escaped!).\n\nThis option is case-sensitive!\n\n\nBy default, the following parameter names, and their Uppercase-initial\nvariants are ignored:\n\nââ\n (unnamed parameters), \niterator\n, \nbegin\n, \nend\n, \nfirst\n, \nlast\n,\n\nlhs\n, \nrhs\n.\n\n\n\n\n\n\n\n\nIgnoredParameterTypeSuffixes\nÂ¶\n\n\nThe list of parameter \ntype name suffixes\n that should never be\nconsidered part of a swappable adjacent parameter sequence.\nParameters which type, as written in the source code, end with an element\nof this option will be ignored.\nThe value is a \n;\n-separated list of names.\n\nThis option is case-sensitive!\n\n\nBy default, the following, and their lowercase-initial variants are ignored:\n\nbool\n, \nIt\n, \nIterator\n, \nInputIt\n, \nForwardIt\n, \nBidirIt\n, \nRandomIt\n,\n\nrandom_iterator\n, \nReverseIt\n, \nreverse_iterator\n,\n\nreverse_const_iterator\n, \nRandomIt\n, \nrandom_iterator\n, \nReverseIt\n,\n\nreverse_iterator\n, \nreverse_const_iterator\n, \nConst_Iterator\n,\n\nConstIterator\n, \nconst_reverse_iterator\n, \nConstReverseIterator\n.\nIn addition, \n_Bool\n (but not \n_bool\n) is also part of the default value.\n\n\n\n\n\n\n\n\nSuppressParametersUsedTogether\nÂ¶\n\n\nSuppresses diagnostics about parameters that are used together or in a\nsimilar fashion inside the functionâs body.\nDefaults to \ntrue\n.\nSpecifying \nfalse\n will turn off the heuristics.\n\n\nCurrently, the following heuristics are implemented which will suppress the\nwarning about the parameter pair involved:\n\n\n\n\nThe parameters are used in the same expression, e.g. \nf(a,\n \nb)\n or\n\na\n \n<\n \nb\n.\n\n\nThe parameters are further passed to the same function to the same\nparameter of that function, of the same overload.\nE.g. \nf(a,\n \n1)\n and \nf(b,\n \n2)\n to some \nf(T,\n \nint)\n.\n\n\n\n\nNote\n\n\nThe check does not perform path-sensitive analysis, and as such,\nâsame functionâ in this context means the same function declaration.\nIf the same member function of a type on two distinct instances are\ncalled with the parameters, it will still be regarded as\nâsame functionâ.\n\n\n\n\n\n\nThe same member field is accessed, or member method is called of the\ntwo parameters, e.g. \na.foo()\n and \nb.foo()\n.\n\n\nSeparate \nreturn\n statements return either of the parameters on\ndifferent code paths.\n\n\n\n\n\n\n\n\n\n\nNamePrefixSuffixSilenceDissimilarityThreshold\nÂ¶\n\n\nThe number of characters two parameter names might be different on \neither\n\nthe head or the tail end with the rest of the name the same so that the\nwarning about the two parameters are silenced.\nDefaults to \n1\n.\nMight be any positive integer.\nIf \n0\n, the filtering heuristic based on the parametersâ names is turned\noff.\n\n\nThis option can be used to silence warnings about parameters where the\nnaming scheme indicates that the order of those parameters do not matter.\n\n\nFor example, the parameters \nLHS\n and \nRHS\n are 1-dissimilar suffixes\nof each other: \nL\n and \nR\n is the different character, while \nHS\n\nis the common suffix.\nSimilarly, parameters \ntext1,\n \ntext2,\n \ntext3\n are 1-dissimilar prefixes\nof each other, with the numbers at the end being the dissimilar part.\nIf the value is at least \n1\n, such cases will not be reported.\n\nLimitations\nÂ¶\n\n\nThis check is designed to check function signatures!\n\n\nThe check does not investigate functions that are generated by the compiler\nin a context that is only determined from a call site.\nThese cases include variadic functions, functions in C code that do not have\nan argument list, and C++ template instantiations.\nMost of these cases, which are otherwise swappable from a callerâs standpoint,\nhave no way of getting âfixedâ at the definition point.\nIn the case of C++ templates, only primary template definitions and explicit\nspecializations are matched and analyzed.\n\n\nNone of the following cases produce a diagnostic:\n\n\nint\n \nprintf\n(\nconst\n \nchar\n \n*\nFormat\n,\n \n...)\n \n{\n \n/* ... */\n \n}\n\n\nint\n \nsomeOldCFunction\n()\n \n{\n \n/* ... */\n \n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \nU\n>\n\n\nint\n \nadd\n(\nT\n \nX\n,\n \nU\n \nY\n)\n \n{\n \nreturn\n \nX\n \n+\n \nY\n \n};\n\n\n\nvoid\n \ntheseAreNotWarnedAbout\n()\n \n{\n\n\n    \nprintf\n(\n\"%d %d\n\\n\n\"\n,\n \n1\n,\n \n2\n);\n   \n// Two ints passed, they could be swapped.\n\n\n    \nsomeOldCFunction\n(\n1\n,\n \n2\n,\n \n3\n);\n \n// Similarly, multiple ints passed.\n\n\n\n    \nadd\n(\n1\n,\n \n2\n);\n \n// Instantiates 'add<int, int>', but that's not a user-defined function.\n\n\n}\n\n\n\n\n\n\nDue to the limitation above, parameters which type are further dependent upon\ntemplate instantiations to \nprove\n that they mix with another parameterâs is\nnot diagnosed.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nVector\n \n{\n\n\n  \ntypedef\n \nT\n \nelement_type\n;\n\n\n};\n\n\n\n// Diagnosed: Explicit instantiation was done by the user, we can prove it\n\n\n// is the same type.\n\n\nvoid\n \ninstantiated\n(\nint\n \nA\n,\n \nVector\n<\nint\n>::\nelement_type\n \nB\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n// Diagnosed: The two parameter types are exactly the same.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nexact\n(\ntypename\n \nVector\n<\nT\n>::\nelement_type\n \nA\n,\n\n\n           \ntypename\n \nVector\n<\nT\n>::\nelement_type\n \nB\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n// Skipped: The two parameters are both 'T' but we cannot prove this\n\n\n// without actually instantiating.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nfalseNegative\n(\nT\n \nA\n,\n \ntypename\n \nVector\n<\nT\n>::\nelement_type\n \nB\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\nIn the context of \nimplicit conversions\n (when \nModelImplicitConversions\n is\nenabled), the modelling performed by the check\nwarns if the parameters are swappable and the swapped order matches implicit\nconversions.\nIt does not model whether there exists an unrelated third type from which\n\nboth\n parameters can be given in a function call.\nThis means that in the following example, even while \nstrs()\n clearly carries\nthe possibility to be called with swapped arguments (as long as the arguments\nare string literals), will not be warned about.\n\n\nstruct\n \nString\n \n{\n\n\n    \nString\n(\nconst\n \nchar\n \n*\nBuf\n);\n\n\n};\n\n\n\nstruct\n \nStringView\n \n{\n\n\n    \nStringView\n(\nconst\n \nchar\n \n*\nBuf\n);\n\n\n    \noperator\n \nconst\n \nchar\n \n*\n()\n \nconst\n;\n\n\n};\n\n\n\n// Skipped: Directly swapping expressions of the two type cannot mix.\n\n\n// (Note: StringView -> const char * -> String would be **two**\n\n\n// user-defined conversions, which is disallowed by the language.)\n\n\nvoid\n \nstrs\n(\nString\n \nStr\n,\n \nStringView\n \nSV\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n// Diagnosed: StringView implicitly converts to and from a buffer.\n\n\nvoid\n \ncStr\n(\nStringView\n \nSV\n,\n \nconst\n \nchar\n \n*\nBuf\n()\n \n{\n \n/* ... */\n \n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/easily-swappable-parameters.html"
  },
  {
    "name": "bugprone-empty-catch",
    "description": "Detects and suggests addressing issues with empty catch statements.\n\ntry\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n \ncatch\n(\nconst\n \nstd\n::\nexception\n&\n)\n \n{\n\n\n}\n\nHaving empty catch statements in a codebase can be a serious problem that\ndevelopers should be aware of. Catch statements are used to handle exceptions\nthat are thrown during program execution. When an exception is thrown, the\nprogram jumps to the nearest catch statement that matches the type of the\nexception.\n\nEmpty catch statements, also known as âswallowingâ exceptions, catch the\nexception but do nothing with it. This means that the exception is not handled\nproperly, and the program continues to run as if nothing happened. This can\nlead to several issues, such as:\n\nHidden Bugs\n: If an exception is caught and ignored, it can lead to hidden\nbugs that are difficult to diagnose and fix. The root cause of the problem\nmay not be apparent, and the program may continue to behave in unexpected\nways.\n\n\nSecurity Issues\n: Ignoring exceptions can lead to security issues, such as\nbuffer overflows or null pointer dereferences. Hackers can exploit these\nvulnerabilities to gain access to sensitive data or execute malicious code.\n\n\nPoor Code Quality\n: Empty catch statements can indicate poor code quality\nand a lack of attention to detail. This can make the codebase difficult to\nmaintain and update, leading to longer development cycles and increased\ncosts.\n\n\nUnreliable Code\n: Code that ignores exceptions is often unreliable and can\nlead to unpredictable behavior. This can cause frustration for users and\nerode trust in the software.\n\nTo avoid these issues, developers should always handle exceptions properly.\nThis means either fixing the underlying issue that caused the exception or\npropagating the exception up the call stack to a higher-level handler.\nIf an exception is not important, it should still be logged or reported in\nsome way so that it can be tracked and addressed later.\n\nIf the exception is something that can be handled locally, then it should be\nhandled within the catch block. This could involve logging the exception or\ntaking other appropriate action to ensure that the exception is not ignored.\n\nHere is an example:\n\ntry\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n \ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nex\n)\n \n{\n\n\n  \n// Properly handle the exception, e.g.:\n\n\n  \nstd\n::\ncerr\n \n<<\n \n\"Exception caught: \"\n \n<<\n \nex\n.\nwhat\n()\n \n<<\n \nstd\n::\nendl\n;\n\n\n}\n\nIf the exception cannot be handled locally and needs to be propagated up the\ncall stack, it should be re-thrown or new exception should be thrown.\n\nHere is an example:\n\ntry\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n \ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nex\n)\n \n{\n\n\n  \n// Re-throw the exception\n\n\n  \nthrow\n;\n\n\n}\n\nIn some cases, catching the exception at this level may not be necessary, and\nit may be appropriate to let the exception propagate up the call stack.\nThis can be done simply by not using \ntry/catch\n block.\n\nHere is an example:\n\nvoid\n \nfunction\n()\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n\n\n\nvoid\n \ncallerFunction\n()\n \n{\n\n\n  \ntry\n \n{\n\n\n    \nfunction\n();\n\n\n  \n}\n \ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nex\n)\n \n{\n\n\n    \n// Handling exception on higher level\n\n\n    \nstd\n::\ncerr\n \n<<\n \n\"Exception caught: \"\n \n<<\n \nex\n.\nwhat\n()\n \n<<\n \nstd\n::\nendl\n;\n\n\n  \n}\n\n\n}\n\nOther potential solution to avoid empty catch statements is to modify the code\nto avoid throwing the exception in the first place. This can be achieved by\nusing a different API, checking for error conditions beforehand, or handling\nerrors in a different way that does not involve exceptions. By eliminating the\nneed for try-catch blocks, the code becomes simpler and less error-prone.\n\nHere is an example:\n\n// Old code:\n\n\ntry\n \n{\n\n\n  \nmapContainer\n[\n\"Key\"\n].\ncallFunction\n();\n\n\n}\n \ncatch\n(\nconst\n \nstd\n::\nout_of_range\n&\n)\n \n{\n\n\n}\n\n\n\n// New code\n\n\nif\n \n(\nauto\n \nit\n \n=\n \nmapContainer\n.\nfind\n(\n\"Key\"\n);\n \nit\n \n!=\n \nmapContainer\n.\nend\n())\n \n{\n\n\n  \nit\n->\nsecond\n.\ncallFunction\n();\n\n\n}\n\nIn conclusion, empty catch statements are a bad practice that can lead to\nhidden bugs, security issues, poor code quality, and unreliable code. By\nhandling exceptions properly, developers can ensure that their code is\nrobust, secure, and maintainable.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreCatchWithKeywords\nÂ¶\n\n\nThis option can be used to ignore specific catch statements containing\ncertain keywords. If a \ncatch\n statement body contains (case-insensitive)\nany of the keywords listed in this semicolon-separated option, then the\ncatch will be ignored, and no warning will be raised.\nDefault value: \n@TODO;@FIXME\n.\n\n\n\n\n\n\n\n\nAllowEmptyCatchForExceptions\nÂ¶\n\n\nThis option can be used to ignore empty catch statements for specific\nexception types. By default, the check will raise a warning if an empty\ncatch statement is detected, regardless of the type of exception being\ncaught. However, in certain situations, such as when a developer wants to\nintentionally ignore certain exceptions or handle them in a different way,\nit may be desirable to allow empty catch statements for specific exception\ntypes.\nTo configure this option, a semicolon-separated list of exception type names\nshould be provided. If an exception type name in the list is caught in an\nempty catch statement, no warning will be raised.\nDefault value: empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/empty-catch.html"
  },
  {
    "name": "bugprone-exception-copy-constructor-throws",
    "description": "Checks whether a thrown objectâs copy constructor can throw.\n\nException objects are required to be copy constructible in C++. However, an\nexceptionâs copy constructor should not throw to avoid potential issues when\nunwinding the stack. If an exception is thrown during stack unwinding (such\nas from a copy constructor of an exception object), the program will\nterminate via \nstd::terminate\n.\n\nclass\n \nSomeException\n \n{\n\n\npublic\n:\n\n\n  \nSomeException\n()\n \n=\n \ndefault\n;\n\n\n  \nSomeException\n(\nconst\n \nSomeException\n&\n)\n \n{\n \n/* may throw */\n \n}\n\n\n};\n\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \nthrow\n \nSomeException\n();\n  \n// warning: thrown exception type's copy constructor can throw\n\n\n}\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nERR60-CPP. Exception objects must be nothrow copy constructible\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/exception-copy-constructor-throws.html"
  },
  {
    "name": "bugprone-exception-escape",
    "description": "Finds functions which may throw an exception directly or indirectly, but they\nshould not. The functions which should not throw exceptions are the following:\n\nDestructors\n\n\nMove constructors\n\n\nMove assignment operators\n\n\nThe \nmain()\n functions\n\n\nswap()\n functions\n\n\niter_swap()\n functions\n\n\niter_move()\n functions\n\n\nFunctions marked with \nthrow()\n or \nnoexcept\n\n\nOther functions given as option\n\nA destructor throwing an exception may result in undefined behavior, resource\nleaks or unexpected termination of the program. Throwing move constructor or\nmove assignment also may result in undefined behavior or resource leak. The\n\nswap()\n operations expected to be non throwing most of the cases and they\nare always possible to implement in a non throwing way. Non throwing \nswap()\n\noperations are also used to create move operations. A throwing \nmain()\n\nfunction also results in unexpected termination.\n\nFunctions declared explicitly with \nnoexcept(false)\n or \nthrow(exception)\n\nwill be excluded from the analysis, as even though it is not recommended for\nfunctions like \nswap()\n, \nmain()\n, move constructors, move assignment\noperators and destructors, it is a clear indication of the developerâs\nintention and should be respected.\n\nWARNING! This check may be expensive on large source files.\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckDestructors\nÂ¶\n\n\nWhen \ntrue\n, destructors are analyzed to not throw exceptions.\nDefault value is \ntrue\n.\n\n\n\n\n\n\n\n\nCheckMoveMemberFunctions\nÂ¶\n\n\nWhen \ntrue\n, move constructors and move assignment operators are analyzed\nto not throw exceptions. Default value is \ntrue\n.\n\n\n\n\n\n\n\n\nCheckMain\nÂ¶\n\n\nWhen \ntrue\n, the \nmain()\n function is analyzed to not throw exceptions.\nDefault value is \ntrue\n.\n\n\n\n\n\n\n\n\nCheckNothrowFunctions\nÂ¶\n\n\nWhen \ntrue\n, functions marked with \nnoexcept\n or \nthrow()\n exception\nspecifications are analyzed to not throw exceptions. Default value is \ntrue\n.\n\n\n\n\n\n\n\n\nCheckedSwapFunctions\nÂ¶\n\n\nComma-separated list of swap function names which should not throw exceptions.\nDefault value is \nswap,iter_swap,iter_move\n.\n\n\n\n\n\n\n\n\nFunctionsThatShouldNotThrow\nÂ¶\n\n\nComma separated list containing function names which should not throw. An\nexample value for this parameter can be \nWinMain\n which adds function\n\nWinMain()\n in the Windows API to the list of the functions which should\nnot throw. Default value is an empty string.\n\n\n\n\n\n\n\n\nIgnoredExceptions\nÂ¶\n\n\nComma separated list containing type names which are not counted as thrown\nexceptions in the check. Default value is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/exception-escape.html"
  },
  {
    "name": "bugprone-float-loop-counter",
    "description": "Flags \nfor\n loops where the induction expression has a floating-point type.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C Coding Standard rule\n\nFLP30-C. Do not use floating-point variables as loop counters\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/float-loop-counter.html"
  },
  {
    "name": "bugprone-fold-init-type",
    "description": "The check flags type mismatches in\n\nfolds\n\nlike \nstd::accumulate\n that might result in loss of precision.\n\nstd::accumulate\n folds an input range into an initial value using\nthe type of the latter, with \noperator+\n by default. This can cause\nloss of precision through:\n\nTruncation: The following code uses a floating point range and an int\ninitial value, so truncation will happen at every application of\n\noperator+\n  and the result will be \n0\n, which might not be what the\nuser expected.\n\nauto\n \na\n \n=\n \n{\n0.5f\n,\n \n0.5f\n,\n \n0.5f\n,\n \n0.5f\n};\n\n\nreturn\n \nstd\n::\naccumulate\n(\nstd\n::\nbegin\n(\na\n),\n \nstd\n::\nend\n(\na\n),\n \n0\n);\n\nOverflow: The following code also returns \n0\n.\n\nauto\n \na\n \n=\n \n{\n65536L\nL\n \n*\n \n65536\n \n*\n \n65536\n};\n\n\nreturn\n \nstd\n::\naccumulate\n(\nstd\n::\nbegin\n(\na\n),\n \nstd\n::\nend\n(\na\n),\n \n0\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/fold-init-type.html"
  },
  {
    "name": "bugprone-forward-declaration-namespace",
    "description": "Checks if an unused forward declaration is in a wrong namespace.\n\nThe check inspects all unused forward declarations and checks if there is any\ndeclaration/definition with the same name existing, which could indicate that\nthe forward declaration is in a potentially wrong namespace.\n\nnamespace\n \nna\n \n{\n \nstruct\n \nA\n;\n \n}\n\n\nnamespace\n \nnb\n \n{\n \nstruct\n \nA\n \n{};\n \n}\n\n\nnb\n::\nA\n \na\n;\n\n\n// warning : no definition found for 'A', but a definition with the same name\n\n\n// 'A' found in another namespace 'nb::'\n\nThis check can only generate warnings, but it canât suggest a fix at this\npoint.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forward-declaration-namespace.html"
  },
  {
    "name": "bugprone-forwarding-reference-overload",
    "description": "The check looks for perfect forwarding constructors that can hide copy or move\nconstructors. If a non const lvalue reference is passed to the constructor, the\nforwarding reference parameter will be a better match than the const reference\nparameter of the copy constructor, so the perfect forwarding constructor will\nbe called, which can be confusing.\nFor detailed description of this issue see: Scott Meyers, Effective Modern C++,\nItem 26.\n\nConsider the following example:\n\nclass\n \nPerson\n \n{\n\n\npublic\n:\n\n\n  \n// C1: perfect forwarding ctor\n\n\n  \ntemplate\n<\ntypename\n \nT\n>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// C2: perfect forwarding ctor with parameter default value\n\n\n  \ntemplate\n<\ntypename\n \nT\n>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n,\n \nint\n \nx\n \n=\n \n1\n)\n \n{}\n\n\n\n  \n// C3: perfect forwarding ctor guarded with enable_if\n\n\n  \ntemplate\n<\ntypename\n \nT\n,\n \ntypename\n \nX\n \n=\n \nenable_if_t\n<\nis_special\n<\nT\n>\n,\n \nvoid\n>>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// C4: variadic perfect forwarding ctor guarded with enable_if\n\n\n  \ntemplate\n<\ntypename\n...\n \nA\n,\n\n\n    \nenable_if_t\n<\nis_constructible_v\n<\ntuple\n<\nstring\n,\n \nint\n>\n,\n \nA\n&&\n...\n>\n,\n \nint\n>\n \n=\n \n0\n>\n\n\n  \nexplicit\n \nPerson\n(\nA\n&&\n...\n \na\n)\n \n{}\n\n\n\n  \n// C5: perfect forwarding ctor guarded with requires expression\n\n\n  \ntemplate\n<\ntypename\n \nT\n>\n\n\n  \nrequires\n \nrequires\n \n{\n \nis_special\n<\nT\n>\n;\n \n}\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// C6: perfect forwarding ctor guarded with concept requirement\n\n\n  \ntemplate\n<\nSpecial\n \nT\n>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// (possibly compiler generated) copy ctor\n\n\n  \nPerson\n(\nconst\n \nPerson\n&\n \nrhs\n);\n\n\n};\n\nThe check warns for constructors C1 and C2, because those can hide copy and\nmove constructors. We suppress warnings if the copy and the move constructors\nare both disabled (deleted or private), because there is nothing the perfect\nforwarding constructor could hide in this case. We also suppress warnings for\nconstructors like C3-C6 that are guarded with an \nenable_if\n or a concept,\nassuming the programmer was aware of the possible hiding.\n\nBackground\nÂ¶\n\n\nFor deciding whether a constructor is guarded with enable_if, we consider the\ntypes of the constructor parameters, the default values of template type parameters\nand the types of non-type template parameters with a default literal value. If any\npart of these types is \nstd::enable_if\n or \nstd::enable_if_t\n, we assume the\nconstructor is guarded.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"
  },
  {
    "name": "bugprone-implicit-widening-of-multiplication-result",
    "description": "The check diagnoses instances where a result of a multiplication is implicitly\nwidened, and suggests (with fix-it) to either silence the code by making\nwidening explicit, or to perform the multiplication in a wider type,\nto avoid the widening afterwards.\n\nThis is mainly useful when operating on very large buffers.\nFor example, consider:\n\nvoid\n \nzeroinit\n(\nchar\n*\n \nbase\n,\n \nunsigned\n \nwidth\n,\n \nunsigned\n \nheight\n)\n \n{\n\n\n  \nfor\n(\nunsigned\n \nrow\n \n=\n \n0\n;\n \nrow\n \n!=\n \nheight\n;\n \n++\nrow\n)\n \n{\n\n\n    \nfor\n(\nunsigned\n \ncol\n \n=\n \n0\n;\n \ncol\n \n!=\n \nwidth\n;\n \n++\ncol\n)\n \n{\n\n\n      \nchar\n*\n \nptr\n \n=\n \nbase\n \n+\n \nrow\n \n*\n \nwidth\n \n+\n \ncol\n;\n\n\n      \n*\nptr\n \n=\n \n0\n;\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\nThis is fine in general, but if \nwidth\n \n*\n \nheight\n overflows,\nyou end up wrapping back to the beginning of \nbase\n\ninstead of processing the entire requested buffer.\n\nIndeed, this only matters for pretty large buffers (4GB+),\nbut that can happen very easily for example in image processing,\nwhere for that to happen you âonlyâ need a ~269MPix image.\n\nOptions\nÂ¶\n\n\n\n\n\n\nUseCXXStaticCastsInCppSources\nÂ¶\n\n\nWhen suggesting fix-its for C++ code, should C++-style \nstatic_cast<>()\nâs\nbe suggested, or C-style casts. Defaults to \ntrue\n.\n\n\n\n\n\n\n\n\nUseCXXHeadersInCppSources\nÂ¶\n\n\nWhen suggesting to include the appropriate header in C++ code,\nshould \n<cstddef>\n header be suggested, or \n<stddef.h>\n.\nDefaults to \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreConstantIntExpr\nÂ¶\n\n\nIf the multiplication operands are compile-time constants (like literals or\nare \nconstexpr\n) and fit within the source expression type, do not emit a\ndiagnostic or suggested fix.  Only considers expressions where the source\nexpression is a signed integer type.  Defaults to \nfalse\n.\n\n\n\n\nExamples:\n\n\nlong\n \nmul\n(\nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \na\n \n*\n \nb\n;\n \n// warning: performing an implicit widening conversion to type 'long' of a multiplication performed in type 'int'\n\n\n}\n\n\n\nchar\n*\n \nptr_add\n(\nchar\n \n*\nbase\n,\n \nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \nbase\n \n+\n \na\n \n*\n \nb\n;\n \n// warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n\n\n}\n\n\n\nchar\n \nptr_subscript\n(\nchar\n \n*\nbase\n,\n \nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \nbase\n[\na\n \n*\n \nb\n];\n \n// warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/implicit-widening-of-multiplication-result.html"
  },
  {
    "name": "bugprone-inaccurate-erase",
    "description": "Checks for inaccurate use of the \nerase()\n method.\n\nAlgorithms like \nremove()\n do not actually remove any element from the\ncontainer but return an iterator to the first redundant element at the end\nof the container. These redundant elements must be removed using the\n\nerase()\n method. This check warns when not all of the elements will be\nremoved due to using an inappropriate overload.\n\nFor example, the following code erases only one element:\n\nstd\n::\nvector\n<\nint\n>\n \nxs\n;\n\n\n...\n\n\nxs\n.\nerase\n(\nstd\n::\nremove\n(\nxs\n.\nbegin\n(),\n \nxs\n.\nend\n(),\n \n10\n));\n\nCall the two-argument overload of \nerase()\n to remove the subrange:\n\nstd\n::\nvector\n<\nint\n>\n \nxs\n;\n\n\n...\n\n\nxs\n.\nerase\n(\nstd\n::\nremove\n(\nxs\n.\nbegin\n(),\n \nxs\n.\nend\n(),\n \n10\n),\n \nxs\n.\nend\n());",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/inaccurate-erase.html"
  },
  {
    "name": "bugprone-inc-dec-in-conditions",
    "description": "Detects when a variable is both incremented/decremented and referenced inside a\ncomplex condition and suggests moving them outside to avoid ambiguity in the\nvariableâs value.\n\nWhen a variable is modified and also used in a complex condition, it can lead\nto unexpected behavior. The side-effect of changing the variableâs value within\nthe condition can make the code difficult to reason about. Additionally, the\ndeveloperâs intended timing for the modification of the variable may not be\nclear, leading to misunderstandings and errors. This can be particularly\nproblematic when the condition involves logical operators like \n&&\n and\n\n||\n, where the order of evaluation can further complicate the situation.\n\nConsider the following example:\n\nint\n \ni\n \n=\n \n0\n;\n\n\n// ...\n\n\nif\n \n(\ni\n++\n \n<\n \n5\n \n&&\n \ni\n \n>\n \n0\n)\n \n{\n\n\n  \n// do something\n\n\n}\n\nIn this example, the result of the expression may not be what the developer\nintended. The original intention of the developer could be to increment \ni\n\nafter the entire condition is evaluated, but in reality, i will be incremented\nbefore \ni\n \n>\n \n0\n is executed. This can lead to unexpected behavior and bugs in\nthe code. To fix this issue, the developer should separate the increment\noperation from the condition and perform it separately. For example, they can\nincrement \ni\n in a separate statement before or after the condition is\nevaluated. This ensures that the value of \ni\n is predictable and consistent\nthroughout the code.\n\nint\n \ni\n \n=\n \n0\n;\n\n\n// ...\n\n\ni\n++\n;\n\n\nif\n \n(\ni\n \n<=\n \n5\n \n&&\n \ni\n \n>\n \n0\n)\n \n{\n\n\n  \n// do something\n\n\n}\n\nAnother common issue occurs when multiple increments or decrements are\nperformed on the same variable inside a complex condition. For example:\n\nint\n \ni\n \n=\n \n4\n;\n\n\n// ...\n\n\nif\n \n(\ni\n++\n \n<\n \n5\n \n||\n \n--\ni\n \n>\n \n2\n)\n \n{\n\n\n  \n// do something\n\n\n}\n\nThere is a potential issue with this code due to the order of evaluation in\nC++. The \n||\n operator used in the condition statement guarantees that if\nthe first operand evaluates to \ntrue\n, the second operand will not be\nevaluated. This means that if \ni\n were initially \n4\n, the first operand\n\ni\n \n<\n \n5\n would evaluate to \ntrue\n and the second operand \ni\n \n>\n \n2\n would\nnot be evaluated. As a result, the decrement operation \n--i\n would not be\nexecuted and \ni\n would hold value \n5\n, which may not be the intended\nbehavior for the developer.\n\nTo avoid this potential issue, the both increment and decrement operation on\n\ni\n should be moved outside the condition statement.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/inc-dec-in-conditions.html"
  },
  {
    "name": "bugprone-incorrect-enable-if",
    "description": "Detects incorrect usages of \nstd::enable_if\n that donât name the nested\n\ntype\n type.\n\nIn C++11 introduced \nstd::enable_if\n as a convenient way to leverage SFINAE.\nOne form of using \nstd::enable_if\n is to declare an unnamed template type\nparameter with a default type equal to\n\ntypename\n \nstd::enable_if<condition>::type\n. If the author forgets to name\nthe nested type \ntype\n, then the code will always consider the candidate\ntemplate even if the condition is not met.\n\nBelow are some examples of code using \nstd::enable_if\n correctly and\nincorrect examples that this check flags.\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \ntypename\n \nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>::\ntype\n>\n\n\nvoid\n \nvalid_usage\n()\n \n{\n \n...\n \n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n>>\n\n\nvoid\n \nvalid_usage_with_trait_helpers\n()\n \n{\n \n...\n \n}\n\n\n\n// The below code is not a correct application of SFINAE. Even if\n\n\n// T::some_trait is not true, the function will still be considered in the\n\n\n// set of function candidates. It can either incorrectly select the function\n\n\n// when it should not be a candidates, and/or lead to hard compile errors\n\n\n// if the body of the template does not compile if the condition is not\n\n\n// satisfied.\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>>\n\n\nvoid\n \ninvalid_usage\n()\n \n{\n \n...\n \n}\n\n\n\n// The tool suggests the following replacement for 'invalid_usage':\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \ntypename\n \nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>::\ntype\n>\n\n\nvoid\n \nfixed_invalid_usage\n()\n \n{\n \n...\n \n}\n\nC++14 introduced the trait helper \nstd::enable_if_t\n which reduces the\nlikelihood of this error. C++20 introduces constraints, which generally\nsupersede the use of \nstd::enable_if\n. See\n\nmodernize-type-traits\n for another tool\nthat will replace \nstd::enable_if\n with\n\nstd::enable_if_t\n, and see\n\nmodernize-use-constraints\n for another\ntool that replaces \nstd::enable_if\n with C++20 constraints. Consider these\nnewer mechanisms where possible.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/incorrect-enable-if.html"
  },
  {
    "name": "bugprone-incorrect-enable-shared-from-this",
    "description": "Detect classes or structs that do not publicly inherit from\n\nstd::enable_shared_from_this\n, because unintended behavior will\notherwise occur when calling \nshared_from_this\n.\n\nConsider the following code:\n\n#include\n \n<memory>\n\n\n\n// private inheritance\n\n\nclass\n \nBadExample\n \n:\n \nstd\n::\nenable_shared_from_this\n<\nBadExample\n>\n \n{\n\n\n\n// ``shared_from_this``` unintended behaviour\n\n\n// `libstdc++` implementation returns uninitialized ``weak_ptr``\n\n\n    \npublic\n:\n\n\n    \nBadExample\n*\n \nfoo\n()\n \n{\n \nreturn\n \nshared_from_this\n().\nget\n();\n \n}\n\n\n    \nvoid\n \nbar\n()\n \n{\n \nreturn\n;\n \n}\n\n\n};\n\n\n\nvoid\n \nusing_not_public\n()\n \n{\n\n\n    \nauto\n \nbad_example\n \n=\n \nstd\n::\nmake_shared\n<\nBadExample\n>\n();\n\n\n    \nauto\n*\n \nb_ex\n \n=\n \nbad_example\n->\nfoo\n();\n\n\n    \nb_ex\n->\nbar\n();\n\n\n}\n\nUsing \nlibstdc++\n implementation, \nshared_from_this\n will throw\n\nstd::bad_weak_ptr\n. When \nusing_not_public()\n is called, this code will\ncrash without exception handling.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/incorrect-enable-shared-from-this.html"
  },
  {
    "name": "bugprone-incorrect-roundings",
    "description": "Checks the usage of patterns known to produce incorrect rounding.\nProgrammers often use:\n\n(\nint\n)(\ndouble_expression\n \n+\n \n0.5\n)\n\nto round the double expression to an integer. The problem with this:\n\nIt is unnecessarily slow.\n\n\nIt is incorrect. The number 0.499999975 (smallest representable float\nnumber below 0.5) rounds to 1.0. Even worse behavior for negative\nnumbers where both -0.5f and -1.4f both round to 0.0.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/incorrect-roundings.html"
  },
  {
    "name": "bugprone-infinite-loop",
    "description": "Finds obvious infinite loops (loops where the condition variable is not changed\nat all).\n\nFinding infinite loops is well-known to be impossible (halting problem).\nHowever, it is possible to detect some obvious infinite loops, for example, if\nthe loop condition is not changed. This check detects such loops. A loop is\nconsidered infinite if it does not have any loop exit statement (\nbreak\n,\n\ncontinue\n, \ngoto\n, \nreturn\n, \nthrow\n or a call to a function called as\n\n[[noreturn]]\n) and all of the following conditions hold for every variable\nin the condition:\n\nIt is a local variable.\n\n\nIt has no reference or pointer aliases.\n\n\nIt is not a structure or class member.\n\nFurthermore, the condition must not contain a function call to consider the\nloop infinite since functions may return different values for different calls.\n\nFor example, the following loop is considered infinite \ni\n is not changed in\nthe body:\n\nint\n \ni\n \n=\n \n0\n,\n \nj\n \n=\n \n0\n;\n\n\nwhile\n \n(\ni\n \n<\n \n10\n)\n \n{\n\n\n  \n++\nj\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/infinite-loop.html"
  },
  {
    "name": "bugprone-integer-division",
    "description": "Finds cases where integer division in a floating point context is likely to\ncause unintended loss of precision.\n\nNo reports are made if divisions are part of the following expressions:\n\noperands of operators expecting integral or bool types,\n\n\ncall expressions of integral or bool types, and\n\n\nexplicit cast expressions to integral or bool types,\n\nas these are interpreted as signs of deliberateness from the programmer.\n\nExamples:\n\nfloat\n \nfloatFunc\n(\nfloat\n);\n\n\nint\n \nintFunc\n(\nint\n);\n\n\ndouble\n \nd\n;\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n\n// Warn, floating-point values expected.\n\n\nd\n \n=\n \n32\n \n*\n \n8\n \n/\n \n(\n2\n \n+\n \ni\n);\n\n\nd\n \n=\n \n8\n \n*\n \nfloatFunc\n(\n1\n \n+\n \n7\n \n/\n \n2\n);\n\n\nd\n \n=\n \ni\n \n/\n \n(\n1\n \n<<\n \n4\n);\n\n\n\n// OK, no integer division.\n\n\nd\n \n=\n \n32\n \n*\n \n8.0\n \n/\n \n(\n2\n \n+\n \ni\n);\n\n\nd\n \n=\n \n8\n \n*\n \nfloatFunc\n(\n1\n \n+\n \n7.0\n \n/\n \n2\n);\n\n\nd\n \n=\n \n(\ndouble\n)\ni\n \n/\n \n(\n1\n \n<<\n \n4\n);\n\n\n\n// OK, there are signs of deliberateness.\n\n\nd\n \n=\n \n1\n \n<<\n \n(\ni\n \n/\n \n2\n);\n\n\nd\n \n=\n \n9\n \n+\n \nintFunc\n(\n6\n \n*\n \ni\n \n/\n \n32\n);\n\n\nd\n \n=\n \n(\nint\n)(\ni\n \n/\n \n32\n)\n \n-\n \n8\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/integer-division.html"
  },
  {
    "name": "bugprone-invalid-enum-default-initialization",
    "description": "Detects default initialization (to 0) of variables with \nenum\n type where\nthe enum has no enumerator with value of 0.\n\nIn C++ a default initialization is performed if a variable is initialized with\ninitializer list or in other implicit ways, and no value is specified at the\ninitialization. In such cases the value 0 is used for the initialization.\nThis also applies to enumerations even if it does not have an enumerator with\nvalue 0. In this way a variable with the \nenum\n type may contain initially an\ninvalid value (if the program expects that it contains only the listed\nenumerator values).\n\nThe check emits a warning only if an \nenum\n variable is default-initialized\n(contrary to not initialized) and the \nenum\n does not have an enumerator with\nvalue of 0. The type can be a scoped or non-scoped \nenum\n. Unions are not\nhandled by the check (if it contains a member of enumeration type).\n\nNote that the \nenum\n \nstd::errc\n is always ignored because it is expected\nto be default initialized, despite not defining an enumerator with the value 0.\n\nenum\n \nclass\n \nEnum1\n:\n \nint\n \n{\n\n\n  \nA\n \n=\n \n1\n,\n\n\n  \nB\n\n\n};\n\n\n\nenum\n \nclass\n \nEnum0\n:\n \nint\n \n{\n\n\n  \nA\n \n=\n \n0\n,\n\n\n  \nB\n\n\n};\n\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \nEnum1\n \nX1\n{};\n \n// warn: 'X1' is initialized to 0\n\n\n  \nEnum1\n \nX2\n \n=\n \nEnum1\n();\n \n// warn: 'X2' is initialized to 0\n\n\n  \nEnum1\n \nX3\n;\n \n// no warning: 'X3' is not initialized\n\n\n  \nEnum0\n \nX4\n{};\n \n// no warning: type has an enumerator with value of 0\n\n\n}\n\n\n\nstruct\n \nS1\n \n{\n\n\n  \nEnum1\n \nA\n;\n\n\n  \nS\n()\n:\n \nA\n()\n \n{}\n \n// warn: 'A' is initialized to 0\n\n\n};\n\n\n\nstruct\n \nS2\n \n{\n\n\n  \nint\n \nA\n;\n\n\n  \nEnum1\n \nB\n;\n\n\n};\n\n\n\nS2\n \nVarS2\n{};\n \n// warn: member 'B' is initialized to 0\n\nThe check applies to initialization of arrays or structures with initialization\nlists in C code too. In these cases elements not specified in the list (and have\nenum type) are set to 0.\n\nenum\n \nEnum1\n \n{\n\n\n  \nEnum1_A\n \n=\n \n1\n,\n\n\n  \nEnum1_B\n\n\n};\n\n\nstruct\n \nStruct1\n \n{\n\n\n  \nint\n \na\n;\n\n\n  \nenum\n \nEnum1\n \nb\n;\n\n\n};\n\n\n\nenum\n \nEnum1\n \nArray1\n[\n2\n]\n \n=\n \n{\nEnum1_A\n};\n \n// warn: omitted elements are initialized to 0\n\n\nenum\n \nEnum1\n \nArray2\n[\n2\n][\n2\n]\n \n=\n \n{{\nEnum1_A\n},\n \n{\nEnum1_A\n}};\n \n// warn: last element of both nested arrays is initialized to 0\n\n\nenum\n \nEnum1\n \nArray3\n[\n2\n][\n2\n]\n \n=\n \n{{\nEnum1_A\n,\n \nEnum1_A\n}};\n \n// warn: elements of second array are initialized to 0\n\n\n\nstruct\n \nStruct1\n \nS1\n \n=\n \n{\n1\n};\n \n// warn: element 'b' is initialized to 0\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredEnums\nÂ¶\n\n\nSemicolon-separated list of regexes specifying enums for which this check wonât be\nenforced. Default is \n::std::errc\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/invalid-enum-default-initialization.html"
  },
  {
    "name": "bugprone-lambda-function-name",
    "description": "Checks for attempts to get the name of a function from within a lambda\nexpression. The name of a lambda is always something like \noperator()\n, which\nis almost never what was intended.\n\nExample:\n\nvoid\n \nFancyFunction\n()\n \n{\n\n\n  \n[]\n \n{\n \nprintf\n(\n\"Called from %s\n\\n\n\"\n,\n \n__func__\n);\n \n}();\n\n\n  \n[]\n \n{\n \nprintf\n(\n\"Now called from %s\n\\n\n\"\n,\n \n__FUNCTION__\n);\n \n}();\n\n\n}\n\nOutput:\n\nCalled\n \nfrom\n \noperator\n()\n\n\nNow\n \ncalled\n \nfrom\n \noperator\n()\n\nLikely intended output:\n\nCalled\n \nfrom\n \nFancyFunction\n\n\nNow\n \ncalled\n \nfrom\n \nFancyFunction\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nThe value \ntrue\n specifies that attempting to get the name of a function from\nwithin a macro should not be diagnosed. The default value is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/lambda-function-name.html"
  },
  {
    "name": "bugprone-macro-parentheses",
    "description": "Finds macros that can have unexpected behavior due to missing parentheses.\n\nMacros are expanded by the preprocessor as-is. As a result, there can be\nunexpected behavior; operators may be evaluated in unexpected order and\nunary operators may become binary operators, etc.\n\nWhen the replacement list has an expression, it is recommended to surround\nit with parentheses. This ensures that the macro result is evaluated\ncompletely before it is used.\n\nIt is also recommended to surround macro arguments in the replacement list\nwith parentheses. This ensures that the argument value is calculated\nproperly.\n\nThis check corresponds to the CERT C Coding Standard rule\n\nPRE02-C. Macro replacement lists should be parenthesized.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/macro-parentheses.html"
  },
  {
    "name": "bugprone-macro-repeated-side-effects",
    "description": "Checks for repeated argument with side effects in macros.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/macro-repeated-side-effects.html"
  },
  {
    "name": "bugprone-misleading-setter-of-reference",
    "description": "Finds setter-like member functions that take a pointer parameter and set a\nreference member of the same class with the pointed value.\n\nThe check detects member functions that take a single pointer parameter,\nand contain a single expression statement that dereferences the parameter and\nassigns the result to a data member with a reference type.\n\nThe fact that a setter function takes a pointer might cause the belief that an\ninternal reference (if it would be a pointer) is changed instead of the\npointed-to (or referenced) value.\n\nExample:\n\nclass\n \nMyClass\n \n{\n\n\n  \nint\n \n&\nInternalRef\n;\n  \n// non-const reference member\n\n\npublic\n:\n\n\n  \nMyClass\n(\nint\n \n&\nValue\n)\n \n:\n \nInternalRef\n(\nValue\n)\n \n{}\n\n\n\n  \n// Warning: This setter could lead to unintended behaviour.\n\n\n  \nvoid\n \nsetRef\n(\nint\n \n*\nValue\n)\n \n{\n\n\n    \nInternalRef\n \n=\n \n*\nValue\n;\n  \n// This assigns to the referenced value, not changing what InternalRef references.\n\n\n  \n}\n\n\n};\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nint\n \nValue1\n \n=\n \n42\n;\n\n\n  \nint\n \nValue2\n \n=\n \n100\n;\n\n\n  \nMyClass\n \nX\n(\nValue1\n);\n\n\n\n  \n// This might look like it changes what InternalRef references to,\n\n\n  \n// but it actually modifies Value1 to be 100.\n\n\n  \nX\n.\nsetRef\n(\n&\nValue2\n);\n\n\n}\n\nPossible fixes:\n\n\nChange the parameter type of the âsetâ function to non-pointer type (for\nexample, a const reference).\n\n\nChange the type of the member variable to a pointer and in the âsetâ\nfunction assign a value to the pointer (without dereference).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/misleading-setter-of-reference.html"
  },
  {
    "name": "bugprone-misplaced-operator-in-strlen-in-alloc",
    "description": "Finds cases where \n1\n is added to the string in the argument to \nstrlen()\n,\n\nstrnlen()\n, \nstrnlen_s()\n, \nwcslen()\n, \nwcsnlen()\n, and\n\nwcsnlen_s()\n instead of the result and the value is used as an argument to a\nmemory allocation function (\nmalloc()\n, \ncalloc()\n, \nrealloc()\n,\n\nalloca()\n) or the \nnew[]\n operator in \nC++\n. The check detects error cases\neven if one of these functions (except the \nnew[]\n operator) is called by a\nconstant function pointer. Cases where \n1\n is added both to the parameter and\nthe result of the \nstrlen()\n-like function are ignored, as are cases where\nthe whole addition is surrounded by extra parentheses.\n\nC\n example code:\n\nvoid\n \nbad_malloc\n(\nchar\n \n*\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nc\n \n=\n \n(\nchar\n*\n)\n \nmalloc\n(\nstrlen\n(\nstr\n \n+\n \n1\n));\n\n\n}\n\nThe suggested fix is to add \n1\n to the return value of \nstrlen()\n and not\nto its argument. In the example above the fix would be\n\nchar\n \n*\nc\n \n=\n \n(\nchar\n*\n)\n \nmalloc\n(\nstrlen\n(\nstr\n)\n \n+\n \n1\n);\n\nC++\n example code:\n\nvoid\n \nbad_new\n(\nchar\n \n*\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nc\n \n=\n \nnew\n \nchar\n[\nstrlen\n(\nstr\n \n+\n \n1\n)];\n\n\n}\n\nAs in the \nC\n code with the \nmalloc()\n function, the suggested fix is to\nadd \n1\n to the return value of \nstrlen()\n and not to its argument. In the\nexample above the fix would be\n\nchar\n \n*\nc\n \n=\n \nnew\n \nchar\n[\nstrlen\n(\nstr\n)\n \n+\n \n1\n];\n\nExample for silencing the diagnostic:\n\nvoid\n \nbad_malloc\n(\nchar\n \n*\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nc\n \n=\n \n(\nchar\n*\n)\n \nmalloc\n(\nstrlen\n((\nstr\n \n+\n \n1\n)));\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/misplaced-operator-in-strlen-in-alloc.html"
  },
  {
    "name": "bugprone-misplaced-pointer-arithmetic-in-alloc",
    "description": "Finds cases where an integer expression is added to or subtracted from the\nresult of a memory allocation function (\nmalloc()\n, \ncalloc()\n,\n\nrealloc()\n, \nalloca()\n) instead of its argument. The check detects error\ncases even if one of these functions is called by a constant function pointer.\n\nExample code:\n\nvoid\n \nbad_malloc\n(\nint\n \nn\n)\n \n{\n\n\n  \nchar\n \n*\np\n \n=\n \n(\nchar\n*\n)\n \nmalloc\n(\nn\n)\n \n+\n \n10\n;\n\n\n}\n\nThe suggested fix is to add the integer expression to the argument of\n\nmalloc\n and not to its result. In the example above the fix would be\n\nchar\n \n*\np\n \n=\n \n(\nchar\n*\n)\n \nmalloc\n(\nn\n \n+\n \n10\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/misplaced-pointer-arithmetic-in-alloc.html"
  },
  {
    "name": "bugprone-misplaced-widening-cast",
    "description": "This check will warn when there is a cast of a calculation result to a bigger\ntype. If the intention of the cast is to avoid loss of precision then the cast\nis misplaced, and there can be loss of precision. Otherwise the cast is\nineffective.\n\nExample code:\n\nlong\n \nf\n(\nint\n \nx\n)\n \n{\n\n\n    \nreturn\n \n(\nlong\n)(\nx\n \n*\n \n1000\n);\n\n\n}\n\nThe result \nx\n \n*\n \n1000\n is first calculated using \nint\n precision. If the\nresult exceeds \nint\n precision there is loss of precision. Then the result is\ncasted to \nlong\n.\n\nIf there is no loss of precision then the cast can be removed or you can\nexplicitly cast to \nint\n instead.\n\nIf you want to avoid loss of precision then put the cast in a proper location,\nfor instance:\n\nlong\n \nf\n(\nint\n \nx\n)\n \n{\n\n\n    \nreturn\n \n(\nlong\n)\nx\n \n*\n \n1000\n;\n\n\n}\n\nImplicit casts\nÂ¶\n\n\nForgetting to place the cast at all is at least as dangerous and at least as\ncommon as misplacing it. If \nCheckImplicitCasts\n is enabled the check\nalso detects these cases, for instance:\n\n\nlong\n \nf\n(\nint\n \nx\n)\n \n{\n\n\n    \nreturn\n \nx\n \n*\n \n1000\n;\n\n\n}\n\nFloating point\nÂ¶\n\n\nCurrently warnings are only written for integer conversion. No warning is\nwritten for this code:\n\n\ndouble\n \nf\n(\nfloat\n \nx\n)\n \n{\n\n\n    \nreturn\n \n(\ndouble\n)(\nx\n \n*\n \n10.0f\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckImplicitCasts\nÂ¶\n\n\nIf \ntrue\n, enables detection of implicit casts. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/misplaced-widening-cast.html"
  },
  {
    "name": "bugprone-move-forwarding-reference",
    "description": "Warns if \nstd::move\n is called on a forwarding reference, for example:\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nfoo\n(\nT\n&&\n \nt\n)\n \n{\n\n\n  \nbar\n(\nstd\n::\nmove\n(\nt\n));\n\n\n}\n\nForwarding references\n should\ntypically be passed to \nstd::forward\n instead of \nstd::move\n, and this is\nthe fix that will be suggested.\n\n(A forwarding reference is an rvalue reference of a type that is a deduced\nfunction template argument.)\n\nIn this example, the suggested fix would be\n\nbar\n(\nstd\n::\nforward\n<\nT\n>\n(\nt\n));\n\nBackground\nÂ¶\n\n\nCode like the example above is sometimes written with the expectation that\n\nT&&\n will always end up being an rvalue reference, no matter what type is\ndeduced for \nT\n, and that it is therefore not possible to pass an lvalue to\n\nfoo()\n. However, this is not true. Consider this example:\n\n\nstd\n::\nstring\n \ns\n \n=\n \n\"Hello, world\"\n;\n\n\nfoo\n(\ns\n);\n\n\n\n\n\n\nThis code compiles and, after the call to \nfoo()\n, \ns\n is left in an\nindeterminate state because it has been moved from. This may be surprising to\nthe caller of \nfoo()\n because no \nstd::move\n was used when calling\n\nfoo()\n.\n\n\nThe reason for this behavior lies in the special rule for template argument\ndeduction on function templates like \nfoo()\n â i.e. on function templates\nthat take an rvalue reference argument of a type that is a deduced function\ntemplate argument. (See section [temp.deduct.call]/3 in the C++11 standard.)\n\n\nIf \nfoo()\n is called on an lvalue (as in the example above), then \nT\n is\ndeduced to be an lvalue reference. In the example, \nT\n is deduced to be\n\nstd::string\n \n&\n. The type of the argument \nt\n therefore becomes\n\nstd::string&\n \n&&\n; by the reference collapsing rules, this collapses to\n\nstd::string&\n.\n\n\nThis means that the \nfoo(s)\n call passes \ns\n as an lvalue reference, and\n\nfoo()\n ends up moving \ns\n and thereby placing it into an indeterminate\nstate.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/move-forwarding-reference.html"
  },
  {
    "name": "bugprone-multi-level-implicit-pointer-conversion",
    "description": "Detects implicit conversions between pointers of different levels of\nindirection.\n\nConversions between pointer types of different levels of indirection can be\ndangerous and may lead to undefined behavior, particularly if the converted\npointer is later cast to a type with a different level of indirection.\nFor example, converting a pointer to a pointer to an \nint\n (\nint**\n) to\na \nvoid*\n can result in the loss of information about the original level of\nindirection, which can cause problems when attempting to use the converted\npointer. If the converted pointer is later cast to a type with a different\nlevel of indirection and dereferenced, it may lead to access violations,\nmemory corruption, or other undefined behavior.\n\nConsider the following example:\n\nvoid\n \nfoo\n(\nvoid\n*\n \nptr\n);\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nint\n \nx\n \n=\n \n42\n;\n\n\n  \nint\n*\n \nptr\n \n=\n \n&\nx\n;\n\n\n  \nint\n**\n \nptr_ptr\n \n=\n \n&\nptr\n;\n\n\n  \nfoo\n(\nptr_ptr\n);\n \n// warning will trigger here\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\nIn this example, \nfoo()\n is called with \nptr_ptr\n as its argument. However,\n\nptr_ptr\n is a \nint**\n pointer, while \nfoo()\n expects a \nvoid*\n pointer.\nThis results in an implicit pointer level conversion, which could cause issues\nif \nfoo()\n dereferences the pointer assuming itâs a \nint*\n pointer.\n\nUsing an explicit cast is a recommended solution to prevent issues caused by\nimplicit pointer level conversion, as it allows the developer to explicitly\nstate their intention and show their reasoning for the type conversion.\nAdditionally, it is recommended that developers thoroughly check and verify the\nsafety of the conversion before using an explicit cast. This extra level of\ncaution can help catch potential issues early on in the development process,\nimproving the overall reliability and maintainability of the code.\n\nOptions\nÂ¶\n\n\n\n\n\n\nEnableInC\nÂ¶\n\n\nIf \ntrue\n, enables the check in C code (it is always enabled in C++ code).\nDefault is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/multi-level-implicit-pointer-conversion.html"
  },
  {
    "name": "bugprone-multiple-new-in-one-expression",
    "description": "Finds multiple \nnew\n operator calls in a single expression, where the\nallocated memory by the first \nnew\n may leak if the second allocation fails\nand throws exception.\n\nC++ does often not specify the exact order of evaluation of the operands of an\noperator or arguments of a function. Therefore if a first allocation succeeds\nand a second fails, in an exception handler it is not possible to tell which\nallocation has failed and free the memory. Even if the order is fixed the\nresult of a first \nnew\n may be stored in a temporary location that is not\nreachable at the time when a second allocation fails. It is best to avoid any\nexpression that contains more than one \noperator\n \nnew\n call, if exception\nhandling is used to check for allocation errors.\n\nDifferent rules apply for are the short-circuit operators \n||\n and \n&&\n and\nthe \n,\n operator, where evaluation of one side must be completed before the\nother starts. Expressions of a list-initialization (initialization or\nconstruction using \n{\n and \n}\n characters) are evaluated in fixed order.\nSimilarly, condition of a \n?\n operator is evaluated before the branches are\nevaluated.\n\nThe check reports warning if two \nnew\n calls appear in one expression at\ndifferent sides of an operator, or if \nnew\n calls appear in different\narguments of a function call (that can be an object construction with \n()\n\nsyntax). These \nnew\n calls can be nested at any level.\nFor any warning to be emitted the \nnew\n calls should be in a code block where\nexception handling is used with catch for \nstd::bad_alloc\n or\n\nstd::exception\n. At \n||\n, \n&&\n, \n,\n, \n?\n (condition and one branch)\noperators no warning is emitted. No warning is emitted if both of the memory\nallocations are not assigned to a variable or not passed directly to a\nfunction. The reason is that in this case the memory may be intentionally not\nfreed or the allocated objects can be self-destructing objects.\n\nExamples:\n\nstruct\n \nA\n \n{\n\n\n  \nint\n \nVar\n;\n\n\n};\n\n\nstruct\n \nB\n \n{\n\n\n  \nB\n();\n\n\n  \nB\n(\nA\n \n*\n);\n\n\n  \nint\n \nVar\n;\n\n\n};\n\n\nstruct\n \nC\n \n{\n\n\n  \nint\n \n*\nX1\n;\n\n\n  \nint\n \n*\nX2\n;\n\n\n};\n\n\n\nvoid\n \nf\n(\nA\n \n*\n,\n \nB\n \n*\n);\n\n\nint\n \nf1\n(\nA\n \n*\n);\n\n\nint\n \nf1\n(\nB\n \n*\n);\n\n\nbool\n \nf2\n(\nA\n \n*\n);\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nA\n \n*\nPtrA\n;\n\n\n  \nB\n \n*\nPtrB\n;\n\n\n  \ntry\n \n{\n\n\n    \n// Allocation of 'B'/'A' may fail after memory for 'A'/'B' was allocated.\n\n\n    \nf\n(\nnew\n \nA\n,\n \nnew\n \nB\n);\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined\n\n\n\n    \n// List (aggregate) initialization is used.\n\n\n    \nC\n \nC1\n{\nnew\n \nint\n,\n \nnew\n \nint\n};\n \n// no warning\n\n\n\n    \n// Allocation of 'B'/'A' may fail after memory for 'A'/'B' was allocated but not yet passed to function 'f1'.\n\n\n    \nint\n \nX\n \n=\n \nf1\n(\nnew\n \nA\n)\n \n+\n \nf1\n(\nnew\n \nB\n);\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined\n\n\n\n    \n// Allocation of 'B' may fail after memory for 'A' was allocated.\n\n\n    \n// From C++17 on memory for 'B' is allocated first but still may leak if allocation of 'A' fails.\n\n\n    \nPtrB\n \n=\n \nnew\n \nB\n(\nnew\n \nA\n);\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception\n\n\n\n    \n// 'new A' and 'new B' may be performed in any order.\n\n\n    \n// 'new B'/'new A' may fail after memory for 'A'/'B' was allocated but not assigned to 'PtrA'/'PtrB'.\n\n\n    \n(\nPtrA\n \n=\n \nnew\n \nA\n)\n->\nVar\n \n=\n \n(\nPtrB\n \n=\n \nnew\n \nB\n)\n->\nVar\n;\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined\n\n\n\n    \n// Evaluation of 'f2(new A)' must be finished before 'f1(new B)' starts.\n\n\n    \n// If 'new B' fails the allocated memory for 'A' is supposedly handled correctly because function 'f2' could take the ownership.\n\n\n    \nbool\n \nZ\n \n=\n \nf2\n(\nnew\n \nA\n)\n \n||\n \nf1\n(\nnew\n \nB\n);\n \n// no warning\n\n\n\n    \nX\n \n=\n \n(\nf2\n(\nnew\n \nA\n)\n \n?\n \nf1\n(\nnew\n \nA\n)\n \n:\n \nf1\n(\nnew\n \nB\n));\n \n// no warning\n\n\n\n    \n// No warning if the result of both allocations is not passed to a function\n\n\n    \n// or stored in a variable.\n\n\n    \n(\nnew\n \nA\n)\n->\nVar\n \n=\n \n(\nnew\n \nB\n)\n->\nVar\n;\n \n// no warning\n\n\n\n    \n// No warning if at least one non-throwing allocation is used.\n\n\n    \nf\n(\nnew\n(\nstd\n::\nnothrow\n)\n \nA\n,\n \nnew\n \nB\n);\n \n// no warning\n\n\n  \n}\n \ncatch\n(\nstd\n::\nbad_alloc\n)\n \n{\n\n\n  \n}\n\n\n\n  \n// No warning if the allocation is outside a try block (or no catch handler exists for std::bad_alloc).\n\n\n  \n// (The fact if exceptions can escape from 'foo' is not taken into account.)\n\n\n  \nf\n(\nnew\n \nA\n,\n \nnew\n \nB\n);\n \n// no warning\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/multiple-new-in-one-expression.html"
  },
  {
    "name": "bugprone-multiple-statement-macro",
    "description": "Detect multiple statement macros that are used in unbraced conditionals. Only\nthe first statement of the macro will be inside the conditional and the other\nones will be executed unconditionally.\n\nExample:\n\n#define INCREMENT_TWO(x, y) (x)++; (y)++\n\n\nif\n \n(\ndo_increment\n)\n\n\n  \nINCREMENT_TWO\n(\na\n,\n \nb\n);\n  \n// (b)++ will be executed unconditionally.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/multiple-statement-macro.html"
  },
  {
    "name": "bugprone-narrowing-conversions",
    "description": "cppcoreguidelines-narrowing-conversions\n redirects here as an alias for\nthis check.\n\nChecks for silent narrowing conversions, e.g: \nint\n \ni\n \n=\n \n0;\n \ni\n \n+=\n \n0.1;\n. While\nthe issue is obvious in this former example, it might not be so in the\nfollowing: \nvoid\n \nMyClass::f(double\n \nd)\n \n{\n \nint_member_\n \n+=\n \nd;\n \n}\n.\n\nWe flag narrowing conversions from:\n\n\nan integer to a narrower integer (e.g. \nchar\n to \nunsigned\n \nchar\n)\nif WarnOnIntegerNarrowingConversion Option is set,\n\n\nan integer to a narrower floating-point (e.g. \nuint64_t\n to \nfloat\n)\nif WarnOnIntegerToFloatingPointNarrowingConversion Option is set,\n\n\na floating-point to an integer (e.g. \ndouble\n to \nint\n),\n\n\na floating-point to a narrower floating-point (e.g. \ndouble\n to \nfloat\n)\nif WarnOnFloatingPointNarrowingConversion Option is set.\n\n\n\n\n\n\nThis check will flag:\n\n\nAll narrowing conversions that are not marked by an explicit cast (c-style\nor \nstatic_cast\n). For example: \nint\n \ni\n \n=\n \n0;\n \ni\n \n+=\n \n0.1;\n,\n\nvoid\n \nf(int);\n \nf(0.1);\n,\n\n\nAll applications of binary operators with a narrowing conversions.\nFor example: \nint\n \ni;\n \ni+=\n \n0.1;\n.\n\nArithmetic with smaller integer types than \nint\n trigger implicit conversions,\nas explained under \nâIntegral Promotionâ on cppreference.com\n.\nThis check diagnoses more instances of narrowing than the compiler warning\n\n-Wconversion\n does. The example below demonstrates this behavior.\n\n// The following function definition demonstrates usage of arithmetic with\n\n\n// integer types smaller than `int` and how the narrowing conversion happens\n\n\n// implicitly.\n\n\nvoid\n \ncomputation\n(\nshort\n \nargument1\n,\n \nshort\n \nargument2\n)\n \n{\n\n\n  \n// Arithmetic written by humans:\n\n\n  \nshort\n \nresult\n \n=\n \nargument1\n \n+\n \nargument2\n;\n\n\n  \n// Arithmetic actually performed by C++:\n\n\n  \nshort\n \nresult\n \n=\n \nstatic_cast\n<\nshort\n>\n(\nstatic_cast\n<\nint\n>\n(\nargument1\n)\n \n+\n \nstatic_cast\n<\nint\n>\n(\nargument2\n));\n\n\n}\n\n\n\nvoid\n \nrecommended_resolution\n(\nshort\n \nargument1\n,\n \nshort\n \nargument2\n)\n \n{\n\n\n  \nshort\n \nresult\n \n=\n \nargument1\n \n+\n \nargument2\n;\n\n\n  \n//           ^ warning: narrowing conversion from 'int' to signed type 'short' is implementation-defined\n\n\n\n  \n// The cppcoreguidelines recommend to resolve this issue by using the GSL\n\n\n  \n// in one of two ways. Either by a cast that throws if a loss of precision\n\n\n  \n// would occur.\n\n\n  \nshort\n \nresult\n \n=\n \ngsl\n::\nnarrow\n<\nshort\n>\n(\nargument1\n \n+\n \nargument2\n);\n\n\n  \n// Or it can be resolved without checking the result risking invalid results.\n\n\n  \nshort\n \nresult\n \n=\n \ngsl\n::\nnarrow_cast\n<\nshort\n>\n(\nargument1\n \n+\n \nargument2\n);\n\n\n\n  \n// A classical `static_cast` will silence the warning as well if the GSL\n\n\n  \n// is not available.\n\n\n  \nshort\n \nresult\n \n=\n \nstatic_cast\n<\nshort\n>\n(\nargument1\n \n+\n \nargument2\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnIntegerNarrowingConversion\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing integer conversion\n(e.g. \nint\n to \nsize_t\n). \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnOnIntegerToFloatingPointNarrowingConversion\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing integer to floating-point\nconversion (e.g. \nsize_t\n to \ndouble\n). \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnOnFloatingPointNarrowingConversion\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing floating point conversion\n(e.g. \ndouble\n to \nfloat\n). \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnWithinTemplateInstantiation\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing conversions within template\ninstantiations. \nfalse\n by default.\n\n\n\n\n\n\n\n\nWarnOnEquivalentBitWidth\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing conversions that arise from\ncasting between types of equivalent bit width. (e.g.\n\nint n = uint(0);\n or \nlong long n = double(0);\n) \ntrue\n by default.\n\n\n\n\n\n\n\n\nIgnoreConversionFromTypes\nÂ¶\n\n\nNarrowing conversions from any type in this semicolon-separated list will be\nignored. This may be useful to weed out commonly occurring, but less commonly\nproblematic assignments such as \nint n = std::vector<char>().size();\n or\n\nint n = std::difference(it1, it2);\n. The default list is empty, but one\nsuggested list for a legacy codebase would be\n\nsize_t;ptrdiff_t;size_type;difference_type\n.\n\n\n\n\n\n\n\n\nPedanticMode\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on assigning a floating point constant\nto an integer value even if the floating point value is exactly\nrepresentable in the destination type (e.g. \nint\n \ni\n \n=\n \n1.0;\n).\n\nfalse\n by default.\n\nFAQ\nÂ¶\n\n\n\n\n\n\nWhat does ânarrowing conversion from âintâ to âfloatââ mean?\n\n\n\n\n\n\nAn IEEE754 Floating Point number can represent all integer values in the range\n[-2^PrecisionBits, 2^PrecisionBits] where PrecisionBits is the number of bits\nin the mantissa.\n\n\nFor \nfloat\n this would be [-2^23, 2^23], where \nint\n can represent values\nin the range [-2^31, 2^31-1].\n\n\n\n\n\n\nWhat does âimplementation-definedâ mean?\n\n\n\n\n\n\nYou may have encountered messages like ânarrowing conversion from âunsigned\nintâ to signed type âintâ is implementation-definedâ.\nThe C/C++ standard does not mandate twoâs complement for signed integers, and\nso the compiler is free to define what the semantics are for converting an\nunsigned integer to signed integer. Clangâs implementation uses the twoâs\ncomplement format.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"
  },
  {
    "name": "bugprone-no-escape",
    "description": "Finds pointers with the \nnoescape\n attribute that are captured by an\nasynchronously-executed block. The block arguments in \ndispatch_async()\n and\n\ndispatch_after()\n are guaranteed to escape, so it is an error if a pointer\nwith the \nnoescape\n attribute is captured by one of these blocks.\n\nThe following is an example of an invalid use of the \nnoescape\n attribute.\n\nvoid\n \nfoo\n(\n__attribute__\n((\nnoescape\n))\n \nint\n \n*\np\n)\n \n{\n\n\n  \ndispatch_async\n(\nqueue\n,\n \n^\n{\n\n\n    \n*\np\n \n=\n \n123\n;\n\n\n  \n});\n\n\n});",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/no-escape.html"
  },
  {
    "name": "bugprone-non-zero-enum-to-bool-conversion",
    "description": "Detect implicit and explicit casts of \nenum\n type into \nbool\n where\n\nenum\n type doesnât have a zero-value enumerator. If the \nenum\n is used\nonly to hold values equal to its enumerators, then conversion to \nbool\n will\nalways result in \ntrue\n value. This can lead to unnecessary code that reduces\nreadability and maintainability and can result in bugs.\n\nMay produce false positives if the \nenum\n is used to store other values\n(used as a bit-mask or zero-initialized on purpose). To deal with them,\n\n//\n \nNOLINT\n or casting first to the underlying type before casting to\n\nbool\n can be used.\n\nIt is important to note that this check will not generate warnings if the\ndefinition of the enumeration type is not available.\nAdditionally, C++11 enumeration classes are supported by this check.\n\nOverall, this check serves to improve code quality and readability by\nidentifying and flagging instances where implicit or explicit casts from\nenumeration types to boolean could cause potential issues.\n\nExample\nÂ¶\n\n\nenum\n \nEStatus\n \n{\n\n\n  \nOK\n \n=\n \n1\n,\n\n\n  \nNOT_OK\n,\n\n\n  \nUNKNOWN\n\n\n};\n\n\n\nvoid\n \nprocess\n(\nEStatus\n \nstatus\n)\n \n{\n\n\n  \nif\n \n(\n!\nstatus\n)\n \n{\n\n\n    \n// this true-branch won't be executed\n\n\n    \nreturn\n;\n\n\n  \n}\n\n\n  \n// proceed with \"valid data\"\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nEnumIgnoreList\nÂ¶\n\n\nOption is used to ignore certain enum types when checking for\nimplicit/explicit casts to bool. It accepts a semicolon-separated list of\n(fully qualified) enum type names or regular expressions that match the enum\ntype names.\nThe default value is an empty string, which means no enums will be ignored.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/non-zero-enum-to-bool-conversion.html"
  },
  {
    "name": "bugprone-nondeterministic-pointer-iteration-order",
    "description": "Finds nondeterministic usages of pointers in unordered containers.\n\nOne canonical example is iteration across a container of pointers.\n\n{\n\n\n  \nint\n \na\n \n=\n \n1\n,\n \nb\n \n=\n \n2\n;\n\n\n  \nstd\n::\nunordered_set\n<\nint\n \n*>\n \nUnorderedPtrSet\n \n=\n \n{\n&\na\n,\n \n&\nb\n};\n\n\n  \nfor\n \n(\nauto\n \ni\n \n:\n \nUnorderedPtrSet\n)\n\n\n    \nf\n(\ni\n);\n\n\n}\n\nAnother such example is sorting a container of pointers.\n\n{\n\n\n  \nint\n \na\n \n=\n \n1\n,\n \nb\n \n=\n \n2\n;\n\n\n  \nstd\n::\nvector\n<\nint\n \n*>\n \nVectorOfPtr\n \n=\n \n{\n&\na\n,\n \n&\nb\n};\n\n\n  \nstd\n::\nsort\n(\nVectorOfPtr\n.\nbegin\n(),\n \nVectorOfPtr\n.\nend\n());\n\n\n}\n\nIteration of a containers of pointers may present the order of different\npointers differently across different runs of a program. In some cases this\nmay be acceptable behavior, in others this may be unexpected behavior. This\ncheck is advisory for this reason.\n\nThis check only detects range-based for loops over unordered sets and maps. It\nalso detects calls sorting-like algorithms on containers holding pointers.\nOther similar usages will not be found and are false negatives.\n\nLimitations\nÂ¶\n\n\n\n\nThis check currently does not check if a nondeterministic iteration order is\nlikely to be a mistake, and instead marks all such iterations as bugprone.\n\n\nstd::reference_wrapper is not considered yet.\n\n\nOnly for loops are considered, other iterators can be included in\nimprovements.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/nondeterministic-pointer-iteration-order.html"
  },
  {
    "name": "bugprone-not-null-terminated-result",
    "description": "Finds function calls where it is possible to cause a not null-terminated\nresult. Usually the proper length of a string is \nstrlen(src)\n \n+\n \n1\n or equal\nlength of this expression, because the null terminator needs an extra space.\nWithout the null terminator it can result in undefined behavior when the\nstring is read.\n\nThe following and their respective \nwchar_t\n based functions are checked:\n\nmemcpy\n, \nmemcpy_s\n, \nmemchr\n, \nmemmove\n, \nmemmove_s\n,\n\nstrerror_s\n, \nstrncmp\n, \nstrxfrm\n\nThe following is a real-world example where the programmer forgot to increase\nthe passed third argument, which is \nsize_t\n \nlength\n. That is why the length\nof the allocated memory is not enough to hold the null terminator.\n\nstatic\n \nchar\n \n*\nstringCpy\n(\nconst\n \nstd\n::\nstring\n \n&\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nresult\n \n=\n \nreinterpret_cast\n<\nchar\n \n*>\n(\nmalloc\n(\nstr\n.\nsize\n()));\n\n\n  \nmemcpy\n(\nresult\n,\n \nstr\n.\ndata\n(),\n \nstr\n.\nsize\n());\n\n\n  \nreturn\n \nresult\n;\n\n\n}\n\nIn addition to issuing warnings, fix-it rewrites all the necessary code.\nIt also tries to adjust the capacity of the destination array:\n\nstatic\n \nchar\n \n*\nstringCpy\n(\nconst\n \nstd\n::\nstring\n \n&\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nresult\n \n=\n \nreinterpret_cast\n<\nchar\n \n*>\n(\nmalloc\n(\nstr\n.\nsize\n()\n \n+\n \n1\n));\n\n\n  \nstrcpy\n(\nresult\n,\n \nstr\n.\ndata\n());\n\n\n  \nreturn\n \nresult\n;\n\n\n}\n\nNote: It cannot guarantee to rewrite every of the path-sensitive memory\nallocations.\n\nTransformation rules of âmemcpy()â\nÂ¶\n\n\nIt is possible to rewrite the \nmemcpy()\n and \nmemcpy_s()\n calls as the\nfollowing four functions:  \nstrcpy()\n, \nstrncpy()\n, \nstrcpy_s()\n,\n\nstrncpy_s()\n, where the latter two are the safer versions of the former two.\nIt rewrites the \nwchar_t\n based memory handler functions respectively.\n\n\n\n\nRewrite based on the destination array\nÂ¶\n\n\n\n\nIf copy to the destination array cannot overflow [1] the new function should\nbe the older copy function (ending with \ncpy\n), because it is more\nefficient than the safe version.\n\n\nIf copy to the destination array can overflow [1] and\n\nWantToUseSafeFunctions\n is set to \ntrue\n and it is possible to\nobtain the capacity of the destination array then the new function could be\nthe safe version (ending with \ncpy_s\n).\n\n\nIf the new function is could be safe version and C++ files are analyzed and\nthe destination array is plain \nchar\n/\nwchar_t\n without \nun/signed\n\nthen the length of the destination array can be omitted.\n\n\nIf the new function is could be safe version and the destination array is\n\nun/signed\n it needs to be casted to plain \nchar\n \n*\n/\nwchar_t\n \n*\n.\n\n\n\n\n\n\n[1] It is possible to overflow:\n\n\nIf the capacity of the destination array is unknown.\n\n\nIf the given length is equal to the destination arrayâs capacity.\n\n\n\n\n\n\n\n\n\n\n\n\nRewrite based on the length of the source string\nÂ¶\n\n\n\n\nIf the given length is \nstrlen(source)\n or equal length of this expression\nthen the new function should be the older copy function (ending with\n\ncpy\n), as it is more efficient than the safe version (ending with\n\ncpy_s\n).\n\n\nOtherwise we assume that the programmer wanted to copy âNâ characters, so the\nnew function is \nncpy\n-like which copies âNâ characters.\n\nTransformations with âstrlen()â or equal length of this expression\nÂ¶\n\n\nIt transforms the \nwchar_t\n based memory and string handler functions\nrespectively (where only \nstrerror_s\n does not have \nwchar_t\n based alias).\n\n\n\n\nMemory handler functions\nÂ¶\n\n\nmemcpy\n\nPlease visit the\n\nTransformation rules of âmemcpy()â\n section.\n\n\nmemchr\n\nUsually there is a C-style cast and it is needed to be removed, because the\nnew function \nstrchr\nâs return type is correct. The given length is going\nto be removed.\n\n\nmemmove\n\nIf safe functions are available the new function is \nmemmove_s\n, which has\na new second argument which is the length of the destination array, it is\nadjusted, and the length of the source string is incremented by one.\nIf safe functions are not available the given length is incremented by one.\n\n\nmemmove_s\n\nThe given length is incremented by one.\n\n\n\n\n\n\nString handler functions\nÂ¶\n\n\nstrerror_s\n\nThe given length is incremented by one.\n\n\nstrncmp\n\nIf the third argument is the first or the second argumentâs \nlength\n \n+\n \n1\n\nit has to be truncated without the \n+\n \n1\n operation.\n\n\nstrxfrm\n\nThe given length is incremented by one.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWantToUseSafeFunctions\nÂ¶\n\n\nThe value \ntrue\n specifies that the target environment is considered to\nimplement â_sâ suffixed memory and string handler functions which are safer\nthan older versions (e.g. âmemcpy_s()â). The default value is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/not-null-terminated-result.html"
  },
  {
    "name": "bugprone-optional-value-conversion",
    "description": "Detects potentially unintentional and redundant conversions where a value is\nextracted from an optional-like type and then used to create a new instance of\nthe same optional-like type.\n\nThese conversions might be the result of developer oversight, leftovers from\ncode refactoring, or other situations that could lead to unintended exceptions\nor cases where the resulting optional is always initialized, which might be\nunexpected behavior.\n\nTo illustrate, consider the following problematic code snippet:\n\n#include\n \n<optional>\n\n\n\nvoid\n \nprint\n(\nstd\n::\noptional\n<\nint\n>\n);\n\n\n\nint\n \nmain\n()\n\n\n{\n\n\n  \nstd\n::\noptional\n<\nint\n>\n \nopt\n;\n\n\n  \n// ...\n\n\n\n  \n// Unintentional conversion from std::optional<int> to int and back to\n\n\n  \n// std::optional<int>:\n\n\n  \nprint\n(\nopt\n.\nvalue\n());\n\n\n\n  \n// ...\n\n\n}\n\nA better approach would be to directly pass \nopt\n to the \nprint\n function\nwithout extracting its value:\n\n#include\n \n<optional>\n\n\n\nvoid\n \nprint\n(\nstd\n::\noptional\n<\nint\n>\n);\n\n\n\nint\n \nmain\n()\n\n\n{\n\n\n  \nstd\n::\noptional\n<\nint\n>\n \nopt\n;\n\n\n  \n// ...\n\n\n\n  \n// Proposed code: Directly pass the std::optional<int> to the print\n\n\n  \n// function.\n\n\n  \nprint\n(\nopt\n);\n\n\n\n  \n// ...\n\n\n}\n\nBy passing \nopt\n directly to the print function, unnecessary conversions are\navoided, and potential unintended behavior or exceptions are minimized.\n\nValue extraction using \noperator\n \n*\n is matched by default.\nThe support for non-standard optional types such as \nboost::optional\n or\n\nabsl::optional\n may be limited.\n\nOptions:\nÂ¶\n\n\n\n\n\n\nOptionalTypes\nÂ¶\n\n\nSemicolon-separated list of (fully qualified) optional type names or regular\nexpressions that match the optional types.\nDefault value is \n::std::optional;::absl::optional;::boost::optional\n.\n\n\n\n\n\n\n\n\nValueMethods\nÂ¶\n\n\nSemicolon-separated list of (fully qualified) method names or regular\nexpressions that match the methods.\nDefault value is \n::value$;::get$\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/optional-value-conversion.html"
  },
  {
    "name": "bugprone-parent-virtual-call",
    "description": "Detects and fixes calls to grand-â¦parent virtual methods instead of calls\nto overridden parentâs virtual methods.\n\nstruct\n \nA\n \n{\n\n\n  \nint\n \nvirtual\n \nfoo\n()\n \n{...}\n\n\n};\n\n\n\nstruct\n \nB\n:\n \npublic\n \nA\n \n{\n\n\n  \nint\n \nfoo\n()\n \noverride\n \n{...}\n\n\n};\n\n\n\nstruct\n \nC\n:\n \npublic\n \nB\n \n{\n\n\n  \nint\n \nfoo\n()\n \noverride\n \n{\n \nA\n::\nfoo\n();\n \n}\n\n\n//                     ^^^^^^^^\n\n\n// warning: qualified name A::foo refers to a member overridden in subclass; did you mean 'B'?  [bugprone-parent-virtual-call]\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/parent-virtual-call.html"
  },
  {
    "name": "bugprone-pointer-arithmetic-on-polymorphic-object",
    "description": "Finds pointer arithmetic performed on classes that contain a virtual function.\n\nPointer arithmetic on polymorphic objects where the pointerâs static type is\ndifferent from its dynamic type is undefined behavior, as the two types could\nhave different sizes, and thus the vtable pointer could point to an\ninvalid address.\n\nFinding pointers where the static type contains a virtual member function is a\ngood heuristic, as the pointer is likely to point to a different,\nderived object.\n\nExample:\n\nstruct\n \nBase\n \n{\n\n\n  \nvirtual\n \n~\nBase\n();\n\n\n  \nint\n \ni\n;\n\n\n};\n\n\n\nstruct\n \nDerived\n \n:\n \npublic\n \nBase\n \n{};\n\n\n\nvoid\n \nfoo\n(\nBase\n*\n \nb\n)\n \n{\n\n\n  \nb\n \n+=\n \n1\n;\n\n\n  \n// warning: pointer arithmetic on class that declares a virtual function can\n\n\n  \n// result in undefined behavior if the dynamic type differs from the\n\n\n  \n// pointer type\n\n\n}\n\n\n\nint\n \nbar\n(\nconst\n \nDerived\n \nd\n[])\n \n{\n\n\n  \nreturn\n \nd\n[\n1\n].\ni\n;\n \n// warning due to pointer arithmetic on polymorphic object\n\n\n}\n\n\n\n// Making Derived final suppresses the warning\n\n\nstruct\n \nFinalDerived\n \nfinal\n \n:\n \npublic\n \nBase\n \n{};\n\n\n\nint\n \nbaz\n(\nconst\n \nFinalDerived\n \nd\n[])\n \n{\n\n\n  \nreturn\n \nd\n[\n1\n].\ni\n;\n \n// no warning as FinalDerived is final\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreInheritedVirtualFunctions\nÂ¶\n\n\nWhen \ntrue\n, objects that only inherit a virtual function are not checked.\nClasses that do not declare a new virtual function are excluded\nby default, as they make up the majority of false positives.\nDefault: \nfalse\n.\n\n\nvoid\n \nbar\n(\nBase\n \nb\n[],\n \nDerived\n \nd\n[])\n \n{\n\n\n  \nb\n \n+=\n \n1\n;\n \n// warning, as Base declares a virtual destructor\n\n\n  \nd\n \n+=\n \n1\n;\n \n// warning only if IgnoreVirtualDeclarationsOnly is set to false\n\n\n}\n\nReferences\nÂ¶\n\n\nThis check corresponds to the SEI Cert rule\n\nCTR56-CPP. Do not use pointer arithmetic on polymorphic objects\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/pointer-arithmetic-on-polymorphic-object.html"
  },
  {
    "name": "bugprone-posix-return",
    "description": "Checks if any calls to \npthread_*\n or \nposix_*\n functions\n(except \nposix_openpt\n) expect negative return values. These functions return\neither \n0\n on success or an \nerrno\n on failure, which is positive only.\n\nExample buggy usage looks like:\n\nif\n \n(\nposix_fadvise\n(...)\n \n<\n \n0\n)\n \n{\n\nThis will never happen as the return value is always non-negative.\nA simple fix could be:\n\nif\n \n(\nposix_fadvise\n(...)\n \n>\n \n0\n)\n \n{",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/posix-return.html"
  },
  {
    "name": "bugprone-random-generator-seed",
    "description": "Flags all pseudo-random number engines, engine adaptor\ninstantiations and \nsrand()\n when initialized or seeded with default\nargument, constant expression or any user-configurable type. Pseudo-random\nnumber engines seeded with a predictable value may cause vulnerabilities\ne.g. in security protocols.\n\nExamples:\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nmt19937\n \nengine1\n;\n \n// Diagnose, always generate the same sequence\n\n\n  \nstd\n::\nmt19937\n \nengine2\n(\n1\n);\n \n// Diagnose\n\n\n  \nengine1\n.\nseed\n();\n \n// Diagnose\n\n\n  \nengine2\n.\nseed\n(\n1\n);\n \n// Diagnose\n\n\n\n  \nstd\n::\ntime_t\n \nt\n;\n\n\n  \nengine1\n.\nseed\n(\nstd\n::\ntime\n(\n&\nt\n));\n \n// Diagnose, system time might be controlled by user\n\n\n\n  \nint\n \nx\n \n=\n \natoi\n(\nargv\n[\n1\n]);\n\n\n  \nstd\n::\nmt19937\n \nengine3\n(\nx\n);\n  \n// Will not warn\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nDisallowedSeedTypes\nÂ¶\n\n\nA comma-separated list of the type names which are disallowed.\nDefault value is \ntime_t,std::time_t\n.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rules\n\nMSC51-CPP. Ensure your random number generator is properly seeded\n and\n\nMSC32-C. Properly seed pseudorandom number generators\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/random-generator-seed.html"
  },
  {
    "name": "bugprone-raw-memory-call-on-non-trivial-type",
    "description": "Flags use of the C standard library functions \nmemset\n, \nmemcpy\n and\n\nmemcmp\n and similar derivatives on non-trivial types.\n\nThe check will detect the following functions: \nmemset\n, \nstd::memset\n,\n\nstd::memcpy\n, \nmemcpy\n, \nstd::memmove\n, \nmemmove\n, \nstd::strcpy\n,\n\nstrcpy\n, \nmemccpy\n, \nstpncpy\n, \nstrncpy\n, \nstd::memcmp\n, \nmemcmp\n,\n\nstd::strcmp\n, \nstrcmp\n, \nstrncmp\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nMemSetNames\nÂ¶\n\n\nSpecify extra functions to flag that act similarly to \nmemset\n. Specify\nnames in a semicolon-delimited list. Default is an empty string.\n\n\n\n\n\n\n\n\nMemCpyNames\nÂ¶\n\n\nSpecify extra functions to flag that act similarly to \nmemcpy\n. Specify\nnames in a semicolon-delimited list. Default is an empty string.\n\n\n\n\n\n\n\n\nMemCmpNames\nÂ¶\n\n\nSpecify extra functions to flag that act similarly to \nmemcmp\n. Specify\nnames in a semicolon-delimited list. Default is an empty string.\n\n\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nOOP57-CPP. Prefer special member functions and overloaded operators to C\nStandard Library functions\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/raw-memory-call-on-non-trivial-type.html"
  },
  {
    "name": "bugprone-redundant-branch-condition",
    "description": "Finds condition variables in nested \nif\n statements that were also checked in\nthe outer \nif\n statement and were not changed.\n\nSimple example:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nif\n \n(\nonFire\n)\n\n\n    \nscream\n();\n\n\n}\n\nHere \nonFire\n is checked both in the outer \nif\n and the inner \nif\n\nstatement without a possible change between the two checks. The check warns for\nthis code and suggests removal of the second checking of variable \nonFire\n.\n\nThe checker also detects redundant condition checks if the condition variable\nis an operand of a logical âandâ (\n&&\n) or a logical âorâ (\n||\n) operator:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nif\n \n(\nonFire\n \n&&\n \npeopleInTheBuilding\n \n>\n \n0\n)\n\n\n    \nscream\n();\n\n\n}\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nif\n \n(\nonFire\n \n||\n \nisCollapsing\n())\n\n\n    \nscream\n();\n\n\n}\n\nIn the first case (logical âandâ) the suggested fix is to remove the redundant\ncondition variable and keep the other side of the \n&&\n. In the second case\n(logical âorâ) the whole \nif\n is removed similarly to the simple case on the\ntop.\n\nThe condition of the outer \nif\n statement may also be a logical âandâ\n(\n&&\n) expression:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n \n&&\n \nfireFighters\n \n<\n \n10\n)\n \n{\n\n\n  \nif\n \n(\nsomeOtherCondition\n())\n \n{\n\n\n    \nif\n \n(\nonFire\n)\n\n\n      \nscream\n();\n\n\n  \n}\n\n\n}\n\nThe error is also detected if both the outer statement is a logical âandâ\n(\n&&\n) and the inner statement is a logical âandâ (\n&&\n) or âorâ (\n||\n).\nThe inner \nif\n statement does not have to be a direct descendant of the outer\none.\n\nNo error is detected if the condition variable may have been changed between\nthe two checks:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \ntryToExtinguish\n(\nonFire\n);\n\n\n  \nif\n \n(\nonFire\n \n&&\n \npeopleInTheBuilding\n \n>\n \n0\n)\n\n\n    \nscream\n();\n\n\n}\n\nEvery possible change is considered, thus if the condition variable is not\na local variable of the function, it is a volatile or it has an alias (pointer\nor reference) then no warning is issued.\n\nLimitations\nÂ¶\n\n\nThe \nelse\n branch is not checked currently for negated condition variable:\n\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nscream\n();\n\n\n}\n \nelse\n \n{\n\n\n  \nif\n \n(\n!\nonFire\n)\n \n{\n\n\n    \ncontinueWork\n();\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe checker currently only detects redundant checking of single condition\nvariables. More complex expressions are not checked:\n\n\nif\n \n(\npeopleInTheBuilding\n \n==\n \n1\n)\n \n{\n\n\n  \nif\n \n(\npeopleInTheBuilding\n \n==\n \n1\n)\n \n{\n\n\n    \ndoSomething\n();\n\n\n  \n}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/redundant-branch-condition.html"
  },
  {
    "name": "bugprone-reserved-identifier",
    "description": "cert-dcl37-c\n and \ncert-dcl51-cpp\n redirect here as an alias for this check.\n\nChecks for usages of identifiers reserved for use by the implementation.\n\nThe C and C++ standards both reserve the following names for such use:\n\nidentifiers that begin with an underscore followed by an uppercase letter;\n\n\nidentifiers in the global namespace that begin with an underscore.\n\nThe C standard additionally reserves names beginning with a double underscore,\nwhile the C++ standard strengthens this to reserve names with a double\nunderscore occurring anywhere.\n\nViolating the naming rules above results in undefined behavior.\n\nnamespace\n \nNS\n \n{\n\n\n  \nvoid\n \n__f\n();\n \n// name is not allowed in user code\n\n\n  \nusing\n \n_Int\n \n=\n \nint\n;\n \n// same with this\n\n\n  \n#define cool__macro \n// also this\n\n\n}\n\n\nint\n \n_g\n();\n \n// disallowed in global namespace only\n\nThe check can also be inverted, i.e. it can be configured to flag any\nidentifier that is \nnot\n a reserved identifier. This mode is for use by e.g.\nstandard library implementors, to ensure they donât infringe on the user\nnamespace.\n\nThis check does not (yet) check for other reserved names, e.g. macro names\nidentical to language keywords, and names specifically reserved by language\nstandards, e.g. C++ âzombie namesâ and C future library directions.\n\nThis check corresponds to CERT C Coding Standard rule \nDCL37-C. Do not declare\nor define a reserved identifier\n\nas well as its C++ counterpart, \nDCL51-CPP. Do not declare or define a reserved\nidentifier\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nInvert\nÂ¶\n\n\nIf \ntrue\n, inverts the check, i.e. flags names that are not reserved.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nAllowedIdentifiers\nÂ¶\n\n\nSemicolon-separated list of regular expressions that the check ignores. Default is an\nempty list.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/reserved-identifier.html"
  },
  {
    "name": "bugprone-return-const-ref-from-parameter",
    "description": "Detects return statements that return a constant reference parameter as\nconstant reference. This may cause use-after-free errors if the caller\nuses xvalues as arguments.\n\nIn C++, constant reference parameters can accept xvalues which will be\ndestructed after the call. When the function returns such a parameter also\nas constant reference, then the returned reference can be used after the\nobject it refers to has been destroyed.\n\nExample\nÂ¶\n\n\nstruct\n \nS\n \n{\n\n\n  \nint\n \nv\n;\n\n\n  \nS\n(\nint\n);\n\n\n  \n~\nS\n();\n\n\n};\n\n\n\nconst\n \nS\n \n&\nfn\n(\nconst\n \nS\n \n&\na\n)\n \n{\n\n\n  \nreturn\n \na\n;\n\n\n}\n\n\n\nconst\n \nS\n&\n \ns\n \n=\n \nfn\n(\nS\n{\n1\n});\n\n\ns\n.\nv\n;\n \n// use after free\n\n\n\n\n\n\nThis issue can be resolved by declaring an overload of the problematic function\nwhere the \nconst\n \n&\n parameter is instead declared as \n&&\n. The developer has\nto ensure that the implementation of that function does not produce a\nuse-after-free, the exact error that this check is warning against.\nMarking such an \n&&\n overload as \ndeleted\n, will silence the warning as\nwell. In the case of different \nconst\n \n&\n parameters being returned depending\non the control flow of the function, an overload where all problematic\n\nconst\n \n&\n parameters have been declared as \n&&\n will resolve the issue.\n\n\nThis issue can also be resolved by adding \n[[clang::lifetimebound]]\n. Clang\nenable \n-Wdangling\n warning by default which can detect mis-uses of the\nannotated function. See \nlifetimebound attribute\n\nfor details.\n\n\nconst\n \nint\n \n&\nf\n(\nconst\n \nint\n \n&\na\n \n[[\nclang\n::\nlifetimebound\n]])\n \n{\n \nreturn\n \na\n;\n \n}\n \n// no warning\n\n\nconst\n \nint\n \n&\nv\n \n=\n \nf\n(\n1\n);\n \n// warning: temporary bound to local reference 'v' will be destroyed at the end of the full-expression [-Wdangling]",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/return-const-ref-from-parameter.html"
  },
  {
    "name": "bugprone-shared-ptr-array-mismatch",
    "description": "Finds initializations of C++ shared pointers to non-array type that are\ninitialized with an array.\n\nIf a shared pointer \nstd::shared_ptr<T>\n is initialized with a new-expression\n\nnew\n \nT[]\n the memory is not deallocated correctly. The pointer uses plain\n\ndelete\n in this case to deallocate the target memory. Instead a \ndelete[]\n\ncall is needed. A \nstd::shared_ptr<T[]>\n calls the correct delete operator.\n\nThe check offers replacement of \nshared_ptr<T>\n to \nshared_ptr<T[]>\n if it\nis used at a single variable declaration (one variable in one statement).\n\nExample:\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx\n(\nnew\n \nFoo\n[\n10\n]);\n \n// -> std::shared_ptr<Foo[]> x(new Foo[10]);\n\n\n//                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx1\n(\nnew\n \nFoo\n),\n \nx2\n(\nnew\n \nFoo\n[\n10\n]);\n \n// no replacement\n\n\n//                                   ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n\n\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx3\n(\nnew\n \nFoo\n[\n10\n],\n \n[](\nconst\n \nFoo\n \n*\nptr\n)\n \n{\n \ndelete\n[]\n \nptr\n;\n \n});\n \n// no warning\n\n\n\nstruct\n \nS\n \n{\n\n\n  \nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx\n(\nnew\n \nFoo\n[\n10\n]);\n \n// no replacement in this case\n\n\n  \n//                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n\n\n};\n\nThis check partially covers the CERT C++ Coding Standard rule\n\nMEM51-CPP. Properly deallocate dynamically allocated resources\n\nHowever, only the \nstd::shared_ptr\n case is detected by this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/shared-ptr-array-mismatch.html"
  },
  {
    "name": "bugprone-signal-handler",
    "description": "Finds specific constructs in signal handler functions that can cause undefined\nbehavior. The rules for what is allowed differ between C++ language versions.\n\nChecked signal handler rules for C:\n\nCalls to non-asynchronous-safe functions are not allowed.\n\nChecked signal handler rules for up to and including C++14:\n\nCalls to non-asynchronous-safe functions are not allowed.\n\n\nC++-specific code constructs are not allowed in signal handlers.\nIn other words, only the common subset of C and C++ is allowed to be used.\n\n\nCalls to functions with non-C linkage are not allowed (including the signal\nhandler itself).\n\nThe check is disabled on C++17 and later.\n\nAsynchronous-safety is determined by comparing the functionâs name against a\nset of known functions. In addition, the function must come from a system\nheader include and in a global namespace. The (possible) arguments passed to\nthe function are not checked. Any function that cannot be determined to be\nasynchronous-safe is assumed to be non-asynchronous-safe by the check,\nincluding user functions for which only the declaration is visible.\nCalls to user-defined functions with visible definitions are checked\nrecursively.\n\nThis check implements the CERT C Coding Standard rule\n\nSIG30-C. Call only asynchronous-safe functions within signal handlers\n\nand the rule\n\nMSC54-CPP. A signal handler must be a plain old function\n.\nIt has the alias names \ncert-sig30-c\n and \ncert-msc54-cpp\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAsyncSafeFunctionSet\nÂ¶\n\n\nSelects which set of functions is considered as asynchronous-safe\n(and therefore allowed in signal handlers). It can be set to the following values:\n\n\n\n\n\n\nminimal\nSelects a minimal set that is defined in the CERT SIG30-C rule.\nand includes functions \nabort()\n, \n_Exit()\n, \nquick_exit()\n and\n\nsignal()\n.\n\n\n\n\n\n\n\n\n\n\nPOSIX\nSelects a larger set of functions that is listed in POSIX.1-2017 (see \nthis\nlink\n\nfor more information). The following functions are included:\n\n_Exit\n, \n_exit\n, \nabort\n, \naccept\n, \naccess\n, \naio_error\n,\n\naio_return\n, \naio_suspend\n, \nalarm\n, \nbind\n, \ncfgetispeed\n,\n\ncfgetospeed\n, \ncfsetispeed\n, \ncfsetospeed\n, \nchdir\n, \nchmod\n,\n\nchown\n, \nclock_gettime\n, \nclose\n, \nconnect\n, \ncreat\n, \ndup\n,\n\ndup2\n, \nexecl\n, \nexecle\n, \nexecv\n, \nexecve\n, \nfaccessat\n,\n\nfchdir\n, \nfchmod\n, \nfchmodat\n, \nfchown\n, \nfchownat\n, \nfcntl\n,\n\nfdatasync\n, \nfexecve\n, \nffs\n, \nfork\n, \nfstat\n, \nfstatat\n,\n\nfsync\n, \nftruncate\n, \nfutimens\n, \ngetegid\n, \ngeteuid\n,\n\ngetgid\n, \ngetgroups\n, \ngetpeername\n, \ngetpgrp\n, \ngetpid\n,\n\ngetppid\n, \ngetsockname\n, \ngetsockopt\n, \ngetuid\n, \nhtonl\n,\n\nhtons\n, \nkill\n, \nlink\n, \nlinkat\n, \nlisten\n, \nlongjmp\n,\n\nlseek\n, \nlstat\n, \nmemccpy\n, \nmemchr\n, \nmemcmp\n, \nmemcpy\n,\n\nmemmove\n, \nmemset\n, \nmkdir\n, \nmkdirat\n, \nmkfifo\n, \nmkfifoat\n,\n\nmknod\n, \nmknodat\n, \nntohl\n, \nntohs\n, \nopen\n, \nopenat\n,\n\npause\n, \npipe\n, \npoll\n, \nposix_trace_event\n, \npselect\n,\n\npthread_kill\n, \npthread_self\n, \npthread_sigmask\n, \nquick_exit\n,\n\nraise\n, \nread\n, \nreadlink\n, \nreadlinkat\n, \nrecv\n, \nrecvfrom\n,\n\nrecvmsg\n, \nrename\n, \nrenameat\n, \nrmdir\n, \nselect\n, \nsem_post\n,\n\nsend\n, \nsendmsg\n, \nsendto\n, \nsetgid\n, \nsetpgid\n, \nsetsid\n,\n\nsetsockopt\n, \nsetuid\n, \nshutdown\n, \nsigaction\n, \nsigaddset\n,\n\nsigdelset\n, \nsigemptyset\n, \nsigfillset\n, \nsigismember\n,\n\nsiglongjmp\n, \nsignal\n, \nsigpause\n, \nsigpending\n, \nsigprocmask\n,\n\nsigqueue\n, \nsigset\n, \nsigsuspend\n, \nsleep\n, \nsockatmark\n,\n\nsocket\n, \nsocketpair\n, \nstat\n, \nstpcpy\n, \nstpncpy\n,\n\nstrcat\n, \nstrchr\n, \nstrcmp\n, \nstrcpy\n, \nstrcspn\n, \nstrlen\n,\n\nstrncat\n, \nstrncmp\n, \nstrncpy\n, \nstrnlen\n, \nstrpbrk\n,\n\nstrrchr\n, \nstrspn\n, \nstrstr\n, \nstrtok_r\n, \nsymlink\n,\n\nsymlinkat\n, \ntcdrain\n, \ntcflow\n, \ntcflush\n, \ntcgetattr\n,\n\ntcgetpgrp\n, \ntcsendbreak\n, \ntcsetattr\n, \ntcsetpgrp\n,\n\ntime\n, \ntimer_getoverrun\n, \ntimer_gettime\n, \ntimer_settime\n,\n\ntimes\n, \numask\n, \nuname\n, \nunlink\n, \nunlinkat\n, \nutime\n,\n\nutimensat\n, \nutimes\n, \nwait\n, \nwaitpid\n, \nwcpcpy\n,\n\nwcpncpy\n, \nwcscat\n, \nwcschr\n, \nwcscmp\n, \nwcscpy\n, \nwcscspn\n,\n\nwcslen\n, \nwcsncat\n, \nwcsncmp\n, \nwcsncpy\n, \nwcsnlen\n, \nwcspbrk\n,\n\nwcsrchr\n, \nwcsspn\n, \nwcsstr\n, \nwcstok\n, \nwmemchr\n, \nwmemcmp\n,\n\nwmemcpy\n, \nwmemmove\n, \nwmemset\n, \nwrite\n\n\nThe function \nquick_exit\n is not included in the POSIX list but it\nis included here in the set of safe functions.\n\n\n\n\n\n\n\n\n\n\nThe default value is \nPOSIX\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signal-handler.html"
  },
  {
    "name": "bugprone-signed-char-misuse",
    "description": "cert-str34-c\n redirects here as an alias for this check. For the CERT alias,\nthe \nDiagnoseSignedUnsignedCharComparisons\n option is set to \nfalse\n.\n\nFinds those \nsigned\n \nchar\n -> integer conversions which might indicate a\nprogramming error. The basic problem with the \nsigned\n \nchar\n, that it might\nstore the non-ASCII characters as negative values. This behavior can cause a\nmisunderstanding of the written code both when an explicit and when an\nimplicit conversion happens.\n\nWhen the code contains an explicit \nsigned\n \nchar\n -> integer conversion, the\nhuman programmer probably expects that the converted value matches with the\ncharacter code (a value from [0..255]), however, the actual value is in\n[-128..127] interval. To avoid this kind of misinterpretation, the desired way\nof converting from a \nsigned\n \nchar\n to an integer value is converting to\n\nunsigned\n \nchar\n first, which stores all the characters in the positive\n[0..255] interval which matches the known character codes.\n\nIn case of implicit conversion, the programmer might not actually be aware\nthat a conversion happened and char value is used as an integer. There are\nsome use cases when this unawareness might lead to a functionally imperfect\ncode. For example, checking the equality of a \nsigned\n \nchar\n and an\n\nunsigned\n \nchar\n variable is something we should avoid in C++ code. During\nthis comparison, the two variables are converted to integers which have\ndifferent value ranges. For \nsigned\n \nchar\n, the non-ASCII characters are\nstored as a value in [-128..-1] interval, while the same characters are\nstored in the [128..255] interval for an \nunsigned\n \nchar\n.\n\nIt depends on the actual platform whether plain \nchar\n is handled as\n\nsigned\n \nchar\n by default and so it is caught by this check or not.\nTo change the default behavior you can use \n-funsigned-char\n and\n\n-fsigned-char\n compilation options.\n\nCurrently, this check warns in the following cases:\n\nsigned\n \nchar\n is assigned to an integer variable\n\n\nsigned\n \nchar\n and \nunsigned\n \nchar\n are compared with\nequality/inequality operator\n\n\nsigned\n \nchar\n is converted to an integer in the array subscript\n\nSee also:\n\nSTR34-C. Cast characters to unsigned char before converting to larger\ninteger sizes\n\nA good example from the CERT description when a \nchar\n variable is used to\nread from a file that might contain non-ASCII characters. The problem comes\nup when the code uses the \n-1\n integer value as EOF, while the 255 character\ncode is also stored as \n-1\n in twoâs complement form of char type.\nSee a simple example of this below. This code stops not only when it reaches\nthe end of the file, but also when it gets a character with the 255 code.\n\n#define EOF (-1)\n\n\n\nint\n \nread\n(\nvoid\n)\n \n{\n\n\n  \nchar\n \nCChar\n;\n\n\n  \nint\n \nIChar\n \n=\n \nEOF\n;\n\n\n\n  \nif\n \n(\nreadChar\n(\nCChar\n))\n \n{\n\n\n    \nIChar\n \n=\n \nCChar\n;\n\n\n  \n}\n\n\n  \nreturn\n \nIChar\n;\n\n\n}\n\nA proper way to fix the code above is converting the \nchar\n variable to\nan \nunsigned\n \nchar\n value first.\n\n#define EOF (-1)\n\n\n\nint\n \nread\n(\nvoid\n)\n \n{\n\n\n  \nchar\n \nCChar\n;\n\n\n  \nint\n \nIChar\n \n=\n \nEOF\n;\n\n\n\n  \nif\n \n(\nreadChar\n(\nCChar\n))\n \n{\n\n\n    \nIChar\n \n=\n \nstatic_cast\n<\nunsigned\n \nchar\n>\n(\nCChar\n);\n\n\n  \n}\n\n\n  \nreturn\n \nIChar\n;\n\n\n}\n\nAnother use case is checking the equality of two \nchar\n variables with\ndifferent signedness. Inside the non-ASCII value range this comparison between\na \nsigned\n \nchar\n and an \nunsigned\n \nchar\n always returns \nfalse\n.\n\nbool\n \ncompare\n(\nsigned\n \nchar\n \nSChar\n,\n \nunsigned\n \nchar\n \nUSChar\n)\n \n{\n\n\n  \nif\n \n(\nSChar\n \n==\n \nUSChar\n)\n\n\n    \nreturn\n \ntrue\n;\n\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\nThe easiest way to fix this kind of comparison is casting one of the arguments,\nso both arguments will have the same type.\n\nbool\n \ncompare\n(\nsigned\n \nchar\n \nSChar\n,\n \nunsigned\n \nchar\n \nUSChar\n)\n \n{\n\n\n  \nif\n \n(\nstatic_cast\n<\nunsigned\n \nchar\n>\n(\nSChar\n)\n \n==\n \nUSChar\n)\n\n\n    \nreturn\n \ntrue\n;\n\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nCharTypedefsToIgnore\nÂ¶\n\n\nA semicolon-separated list of typedef names. In this list, we can list\ntypedefs for \nchar\n or \nsigned\n \nchar\n, which will be ignored by the\ncheck. This is useful when a typedef introduces an integer alias like\n\nsal_Int8\n or \nint8_t\n. In this case, human misinterpretation is not\nan issue. Default is an empty string.\n\n\n\n\n\n\n\n\nDiagnoseSignedUnsignedCharComparisons\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on \nsigned\n \nchar\n/\nunsigned\n \nchar\n comparisons,\notherwise these comparisons are ignored. By default, this option is set to \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"
  },
  {
    "name": "bugprone-sizeof-container",
    "description": "The check finds usages of \nsizeof\n on expressions of STL container types.\nMost likely the user wanted to use \n.size()\n instead.\n\nAll class/struct types declared in namespace \nstd::\n having a const\n\nsize()\n method are considered containers, with the exception of\n\nstd::bitset\n and \nstd::array\n.\n\nExamples:\n\nstd\n::\nstring\n \ns\n;\n\n\nint\n \na\n \n=\n \n47\n \n+\n \nsizeof\n(\ns\n);\n \n// warning: sizeof() doesn't return the size of the container. Did you mean .size()?\n\n\n\nint\n \nb\n \n=\n \nsizeof\n(\nstd\n::\nstring\n);\n \n// no warning, probably intended.\n\n\n\nstd\n::\nstring\n \narray_of_strings\n[\n10\n];\n\n\nint\n \nc\n \n=\n \nsizeof\n(\narray_of_strings\n)\n \n/\n \nsizeof\n(\narray_of_strings\n[\n0\n]);\n \n// no warning, definitely intended.\n\n\n\nstd\n::\narray\n<\nint\n,\n \n3\n>\n \nstd_array\n;\n\n\nint\n \nd\n \n=\n \nsizeof\n(\nstd_array\n);\n \n// no warning, probably intended.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-container.html"
  },
  {
    "name": "bugprone-sizeof-expression",
    "description": "The check finds usages of \nsizeof\n expressions which are most likely errors.\n\nThe \nsizeof\n operator yields the size (in bytes) of its operand, which may be\nan expression or the parenthesized name of a type. Misuse of this operator may\nbe leading to errors and possible software vulnerabilities.\n\nSuspicious usage of âsizeof(K)â\nÂ¶\n\n\nA common mistake is to query the \nsizeof\n of an integer literal. This is\nequivalent to query the size of its type (probably \nint\n). The intent of the\nprogrammer was probably to simply get the integer and not its size.\n\n\n#define BUFLEN 42\n\n\nchar\n \nbuf\n[\nBUFLEN\n];\n\n\nmemset\n(\nbuf\n,\n \n0\n,\n \nsizeof\n(\nBUFLEN\n));\n  \n// sizeof(42) ==> sizeof(int)\n\nSuspicious usage of âsizeof(expr)â\nÂ¶\n\n\nIn cases, where there is an enum or integer to represent a type, a common\nmistake is to query the \nsizeof\n on the integer or enum that represents the\ntype that should be used by \nsizeof\n. This results in the size of the integer\nand not of the type the integer represents:\n\n\nenum\n \ndata_type\n \n{\n\n\n  \nFLOAT_TYPE\n,\n\n\n  \nDOUBLE_TYPE\n\n\n};\n\n\n\nstruct\n \ndata\n \n{\n\n\n  \ndata_type\n \ntype\n;\n\n\n  \nvoid\n*\n \nbuffer\n;\n\n\n  \ndata_type\n \nget_type\n()\n \n{\n\n\n    \nreturn\n \ntype\n;\n\n\n  \n}\n\n\n};\n\n\n\nvoid\n \nf\n(\ndata\n \nd\n,\n \nint\n \nnumElements\n)\n \n{\n\n\n  \n// should be sizeof(float) or sizeof(double), depending on d.get_type()\n\n\n  \nint\n \nnumBytes\n \n=\n \nnumElements\n \n*\n \nsizeof\n(\nd\n.\nget_type\n());\n\n\n  \n...\n\n\n}\n\nSuspicious usage of âsizeof(this)â\nÂ¶\n\n\nThe \nthis\n keyword is evaluated to a pointer to an object of a given type.\nThe expression \nsizeof(this)\n is returning the size of a pointer. The\nprogrammer most likely wanted the size of the object and not the size of the\npointer.\n\n\nclass\n \nPoint\n \n{\n\n\n  \n[...]\n\n\n  \nsize_t\n \nsize\n()\n \n{\n \nreturn\n \nsizeof\n(\nthis\n);\n \n}\n  \n// should probably be sizeof(*this)\n\n\n  \n[...]\n\n\n};\n\nSuspicious usage of âsizeof(char*)â\nÂ¶\n\n\nThere is a subtle difference between declaring a string literal with\n\nchar*\n \nA\n \n=\n \n\"\"\n and \nchar\n \nA[]\n \n=\n \n\"\"\n. The first case has the type \nchar*\n\ninstead of the aggregate type \nchar[]\n. Using \nsizeof\n on an object\ndeclared with \nchar*\n type is returning the size of a pointer instead of\nthe number of characters (bytes) in the string literal.\n\n\nconst\n \nchar\n*\n \nkMessage\n \n=\n \n\"Hello World!\"\n;\n      \n// const char kMessage[] = \"...\";\n\n\nvoid\n \ngetMessage\n(\nchar\n*\n \nbuf\n)\n \n{\n\n\n  \nmemcpy\n(\nbuf\n,\n \nkMessage\n,\n \nsizeof\n(\nkMessage\n));\n  \n// sizeof(char*)\n\n\n}\n\nSuspicious usage of âsizeof(A*)â\nÂ¶\n\n\nA common mistake is to compute the size of a pointer instead of its pointee.\nThese cases may occur because of explicit cast or implicit conversion.\n\n\nint\n \nA\n[\n10\n];\n\n\nmemset\n(\nA\n,\n \n0\n,\n \nsizeof\n(\nA\n \n+\n \n0\n));\n\n\n\nstruct\n \nPoint\n \npoint\n;\n\n\nmemset\n(\npoint\n,\n \n0\n,\n \nsizeof\n(\n&\npoint\n));\n\nSuspicious usage of âsizeof(â¦)/sizeof(â¦)â\nÂ¶\n\n\nDividing \nsizeof\n expressions is typically used to retrieve the number of\nelements of an aggregate. This check warns on incompatible or suspicious cases.\n\n\nIn the following example, the entity has 10-bytes and is incompatible with the\ntype \nint\n which has 4 bytes.\n\n\nchar\n \nbuf\n[]\n \n=\n \n{\n \n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n \n};\n  \n// sizeof(buf) => 10\n\n\nvoid\n \ngetMessage\n(\nchar\n*\n \ndst\n)\n \n{\n\n\n  \nmemcpy\n(\ndst\n,\n \nbuf\n,\n \nsizeof\n(\nbuf\n)\n \n/\n \nsizeof\n(\nint\n));\n  \n// sizeof(int) => 4  [incompatible sizes]\n\n\n}\n\n\n\n\n\n\nIn the following example, the expression \nsizeof(Values)\n is returning the\nsize of \nchar*\n. One can easily be fooled by its declaration, but in parameter\ndeclaration the size â10â is ignored and the function is receiving a \nchar*\n.\n\n\nchar\n \nOrderedValues\n[\n10\n]\n \n=\n \n{\n \n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n \n};\n\n\nreturn\n \nCompareArray\n(\nchar\n \nValues\n[\n10\n])\n \n{\n\n\n  \nreturn\n \nmemcmp\n(\nOrderedValues\n,\n \nValues\n,\n \nsizeof\n(\nValues\n))\n \n==\n \n0\n;\n  \n// sizeof(Values) ==> sizeof(char*) [implicit cast to char*]\n\n\n}\n\nSuspicious âsizeofâ by âsizeofâ expression\nÂ¶\n\n\nMultiplying \nsizeof\n expressions typically makes no sense and is probably a\nlogic error. In the following example, the programmer used \n*\n instead of\n\n/\n.\n\n\nconst\n \nchar\n \nkMessage\n[]\n \n=\n \n\"Hello World!\"\n;\n\n\nvoid\n \ngetMessage\n(\nchar\n*\n \nbuf\n)\n \n{\n\n\n  \nmemcpy\n(\nbuf\n,\n \nkMessage\n,\n \nsizeof\n(\nkMessage\n)\n \n*\n \nsizeof\n(\nchar\n));\n  \n//  sizeof(kMessage) / sizeof(char)\n\n\n}\n\n\n\n\n\n\nThis check may trigger on code using the arraysize macro. The following code is\nworking correctly but should be simplified by using only the \nsizeof\n\noperator.\n\n\nextern\n \nObject\n \nobjects\n[\n100\n];\n\n\nvoid\n \nInitializeObjects\n()\n \n{\n\n\n  \nmemset\n(\nobjects\n,\n \n0\n,\n \narraysize\n(\nobjects\n)\n \n*\n \nsizeof\n(\nObject\n));\n  \n// sizeof(objects)\n\n\n}\n\nSuspicious usage of âsizeof(sizeof(â¦))â\nÂ¶\n\n\nGetting the \nsizeof\n of a \nsizeof\n makes no sense and is typically an error\nhidden through macros.\n\n\n#define INT_SZ sizeof(int)\n\n\nint\n \nbuf\n[]\n \n=\n \n{\n \n42\n \n};\n\n\nvoid\n \ngetInt\n(\nint\n*\n \ndst\n)\n \n{\n\n\n  \nmemcpy\n(\ndst\n,\n \nbuf\n,\n \nsizeof\n(\nINT_SZ\n));\n  \n// sizeof(sizeof(int)) is suspicious.\n\n\n}\n\nSuspicious usages of âsizeof(â¦)â in pointer arithmetic\nÂ¶\n\n\nArithmetic operators on pointers automatically scale the result with the size\nof the pointed typed.\nFurther use of \nsizeof\n around pointer arithmetic will typically result in an\nunintended result.\n\n\n\n\nScaling the result of pointer difference\nÂ¶\n\n\nSubtracting two pointers results in an integer expression (of type\n\nptrdiff_t\n) which expresses the distance between the two pointed objects in\nânumber of objects betweenâ.\nA common mistake is to think that the result is ânumber of bytes betweenâ, and\nscale the difference with \nsizeof\n, such as \nP1\n \n-\n \nP2\n \n==\n \nN\n \n*\n \nsizeof(T)\n\n(instead of \nP1\n \n-\n \nP2\n \n==\n \nN\n) or \n(P1\n \n-\n \nP2)\n \n/\n \nsizeof(T)\n instead of\n\nP1\n \n-\n \nP2\n.\n\n\nvoid\n \nsplitFour\n(\nconst\n \nObj\n*\n \nObjs\n,\n \nsize_t\n \nN\n,\n \nObj\n \nDelimiter\n)\n \n{\n\n\n  \nconst\n \nObj\n \n*\nP\n \n=\n \nObjs\n;\n\n\n  \nwhile\n \n(\nP\n \n<\n \nObjs\n \n+\n \nN\n)\n \n{\n\n\n    \nif\n \n(\n*\nP\n \n==\n \nDelimiter\n)\n \n{\n\n\n      \nbreak\n;\n\n\n    \n}\n\n\n  \n}\n\n\n\n  \nif\n \n(\nP\n \n-\n \nObjs\n \n!=\n \n4\n \n*\n \nsizeof\n(\nObj\n))\n \n{\n \n// Expecting a distance multiplied by sizeof is suspicious.\n\n\n    \nerror\n();\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nvoid\n \niterateIfEvenLength\n(\nint\n \n*\nBegin\n,\n \nint\n \n*\nEnd\n)\n \n{\n\n\n  \nauto\n \nN\n \n=\n \n(\nBegin\n \n-\n \nEnd\n)\n \n/\n \nsizeof\n(\nint\n);\n \n// Dividing by sizeof() is suspicious.\n\n\n  \nif\n \n(\nN\n \n%\n \n2\n)\n\n\n    \nreturn\n;\n\n\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\n\nStepping a pointer with a scaled integer\nÂ¶\n\n\nConversely, when performing pointer arithmetics to add or subtract from a\npointer, the arithmetic operator implicitly scales the value actually added to\nthe pointer with the size of the pointee, as \nPtr\n \n+\n \nN\n expects \nN\n to be\nânumber of objects to stepâ, and not ânumber of bytes to stepâ.\n\n\nSeeing the calculation of a pointer where \nsizeof\n appears is suspicious,\nand the result is typically unintended, often out of bounds.\n\nPtr\n \n+\n \nsizeof(T)\n will offset the pointer by \nsizeof(T)\n elements,\neffectively exponentiating the scaling factor to the power of 2.\n\n\nSimilarly, multiplying or dividing a numeric value with the \nsizeof\n of an\nelement or the whole buffer is suspicious, because the dimensional connection\nbetween the numeric value and the actual \nsizeof\n result can not always be\ndeduced.\nWhile scaling an integer up (multiplying) with \nsizeof\n is likely \nalways\n\nan issue, a scaling down (division) is not always inherently dangerous, in case\nthe developer is aware that the division happens between an appropriate number\nof _bytes_ and a \nsizeof\n value.\nTurning \nWarnOnOffsetDividedBySizeOf\n off will restrict the\nwarnings to the multiplication case.\n\n\nThis case also checks suspicious \nalignof\n and \noffsetof\n usages in\npointer arithmetic, as both return the âsizeâ in bytes and not elements,\npotentially resulting in doubly-scaled offsets.\n\n\nvoid\n \nprintEveryEvenIndexElement\n(\nint\n \n*\nArray\n,\n \nsize_t\n \nN\n)\n \n{\n\n\n  \nint\n \n*\nP\n \n=\n \nArray\n;\n\n\n  \nwhile\n \n(\nP\n \n<=\n \nArray\n \n+\n \nN\n \n*\n \nsizeof\n(\nint\n))\n \n{\n \n// Suspicious pointer arithmetic using sizeof()!\n\n\n    \nprintf\n(\n\"%d \"\n,\n \n*\nP\n);\n\n\n\n    \nP\n \n+=\n \n2\n \n*\n \nsizeof\n(\nint\n);\n \n// Suspicious pointer arithmetic using sizeof()!\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nstruct\n \nMessage\n \n{\n \n/* ... */\n;\n \nchar\n \nFlags\n[\n8\n];\n \n};\n\n\nvoid\n \nclearFlags\n(\nMessage\n \n*\nArray\n,\n \nsize_t\n \nN\n)\n \n{\n\n\n  \nconst\n \nMessage\n \n*\nEnd\n \n=\n \nArray\n \n+\n \nN\n;\n\n\n  \nwhile\n \n(\nArray\n \n<\n \nEnd\n)\n \n{\n\n\n    \nmemset\n(\nArray\n \n+\n \noffsetof\n(\nMessage\n,\n \nFlags\n),\n \n// Suspicious pointer arithmetic using offsetof()!\n\n\n           \n0\n,\n \nsizeof\n(\nMessage\n::\nFlags\n));\n\n\n    \n++\nArray\n;\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nFor this checked bogus pattern, \ncert-arr39-c\n redirects here as an alias of\nthis check.\n\n\nThis check corresponds to the CERT C Coding Standard rule\n\nARR39-C. Do not add or subtract a scaled integer to a pointer\n.\n\nLimitations\nÂ¶\n\n\nCases where the pointee type has a size of \n1\n byte (such as, and most\nimportantly, \nchar\n) are excluded.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnSizeOfConstant\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like\n\nsizeof(CONSTANT)\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfIntegerExpression\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like \nsizeof(expr)\n\nwhere the expression results in an integer. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfThis\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like \nsizeof(this)\n.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfCompareToConstant\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like\n\nsizeof(expr)\n \n<=\n \nk\n for a suspicious constant \nk\n while \nk\n is \n0\n or\ngreater than \n0x8000\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfPointerToAggregate\nÂ¶\n\n\nWhen \ntrue\n, the check will warn when the argument of \nsizeof\n is either a\npointer-to-aggregate type, an expression returning a pointer-to-aggregate\nvalue or an expression that returns a pointer from an array-to-pointer\nconversion (that may be implicit or explicit, for example \narray\n \n+\n \n2\n or\n\n(int\n \n*)array\n). Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfPointer\nÂ¶\n\n\nWhen \ntrue\n, the check will report all expressions where the argument of\n\nsizeof\n is an expression that produces a pointer (except for a few\nidiomatic expressions that are probably intentional and correct).\nThis detects occurrences of CWE 467. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nWarnOnOffsetDividedBySizeOf\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on pointer arithmetic where the\nelement count is obtained from a division with \nsizeof(...)\n,\ne.g., \nPtr\n \n+\n \nBytes\n \n/\n \nsizeof(*T)\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfInLoopTermination\nÂ¶\n\n\nWhen \ntrue\n, the check will warn about incorrect use of sizeof expression\nin loop termination condition. The warning triggers if the \nsizeof\n\nexpression appears to be incorrectly used to determine the number of\narray/buffer elements.\ne.g, \nlong\n \narr[10];\n \nfor(int\n \ni\n \n=\n \n0;\n \ni\n \n<\n \nsizeof(arr);\n \ni++)\n \n{\n \n...\n \n}\n. Default\nis \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html"
  },
  {
    "name": "bugprone-spuriously-wake-up-functions",
    "description": "Finds \ncnd_wait\n, \ncnd_timedwait\n, \nwait\n, \nwait_for\n, or\n\nwait_until\n function calls when the function is not invoked from a loop\nthat checks whether a condition predicate holds or the function has a\ncondition parameter.\n\nif\n \n(\ncondition_predicate\n)\n \n{\n\n\n    \ncondition\n.\nwait\n(\nlk\n);\n\n\n}\n\nif\n \n(\ncondition_predicate\n)\n \n{\n\n\n    \nif\n \n(\nthrd_success\n \n!=\n \ncnd_wait\n(\n&\ncondition\n,\n \n&\nlock\n))\n \n{\n\n\n    \n}\n\n\n}\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nCON54-CPP. Wrap functions that can spuriously wake up in a loop\n.\nand CERT C Coding Standard rule\n\nCON36-C. Wrap functions that can spuriously wake up in a loop\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/spuriously-wake-up-functions.html"
  },
  {
    "name": "bugprone-standalone-empty",
    "description": "Warns when \nempty()\n is used on a range and the result is ignored. Suggests\n\nclear()\n if it is an existing member function.\n\nThe \nempty()\n method on several common ranges returns a Boolean indicating\nwhether or not the range is empty, but is often mistakenly interpreted as\na way to clear the contents of a range. Some ranges offer a \nclear()\n\nmethod for this purpose. This check warns when a call to empty returns a\nresult that is ignored, and suggests replacing it with a call to \nclear()\n\nif it is available as a member function of the range.\n\nFor example, the following code could be used to indicate whether a range\nis empty or not, but the result is ignored:\n\nstd\n::\nvector\n<\nint\n>\n \nv\n;\n\n\n...\n\n\nv\n.\nempty\n();\n\nA call to \nclear()\n would appropriately clear the contents of the range:\n\nstd\n::\nvector\n<\nint\n>\n \nv\n;\n\n\n...\n\n\nv\n.\nclear\n();\n\nLimitations\nÂ¶\n\n\n\n\nDoesnât warn if \nempty()\n is defined and used with the ignore result in the\nclass template definition (for example in the library implementation). These\nerror cases can be caught with \n[[nodiscard]]\n attribute.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/standalone-empty.html"
  },
  {
    "name": "bugprone-std-namespace-modification",
    "description": "Warns on modifications of the \nstd\n or \nposix\n namespaces which can\nresult in undefined behavior.\n\nThe \nstd\n (or \nposix\n) namespace is allowed to be extended with (class or\nfunction) template specializations that depend on an user-defined type (a type\nthat is not defined in the standard system headers).\n\nThe check detects the following (user provided) declarations in namespace\n\nstd\n or \nposix\n:\n\nAnything that is not a template specialization.\n\n\nExplicit specializations of any standard library function template or class\ntemplate, if it does not have any user-defined type as template argument.\n\n\nExplicit specializations of any member function of a standard library class\ntemplate.\n\n\nExplicit specializations of any member function template of a standard\nlibrary class or class template.\n\n\nExplicit or partial specialization of any member class template of a standard\nlibrary class or class template.\n\nExamples:\n\nnamespace\n \nstd\n \n{\n\n\n  \nint\n \nx\n;\n \n// warning: modification of 'std' namespace can result in undefined behavior [bugprone-dont-modify-std-namespace]\n\n\n}\n\n\n\nnamespace\n \nposix\n::\na\n \n{\n \n// warning: modification of 'posix' namespace can result in undefined behavior\n\n\n}\n\n\n\ntemplate\n \n<>\n\n\nstruct\n \n::\nstd\n::\nhash\n<\nlong\n>\n \n{\n \n// warning: modification of 'std' namespace can result in undefined behavior\n\n\n  \nunsigned\n \nlong\n \noperator\n()(\nconst\n \nlong\n \n&\nK\n)\n \nconst\n \n{\n\n\n    \nreturn\n \nK\n;\n\n\n  \n}\n\n\n};\n\n\n\nstruct\n \nMyData\n \n{\n \nlong\n \ndata\n;\n \n};\n\n\n\ntemplate\n \n<>\n\n\nstruct\n \n::\nstd\n::\nhash\n<\nMyData\n>\n \n{\n \n// no warning: specialization with user-defined type\n\n\n  \nunsigned\n \nlong\n \noperator\n()(\nconst\n \nMyData\n \n&\nK\n)\n \nconst\n \n{\n\n\n    \nreturn\n \nK\n.\ndata\n;\n\n\n  \n}\n\n\n};\n\n\n\nnamespace\n \nstd\n \n{\n\n\n  \ntemplate\n \n<>\n\n\n  \nvoid\n \nswap\n<\nbool\n>\n(\nbool\n \n&\na\n,\n \nbool\n \n&\nb\n);\n \n// warning: modification of 'std' namespace can result in undefined behavior\n\n\n\n  \ntemplate\n \n<>\n\n\n  \nbool\n \nless\n<\nvoid\n>::\noperator\n()\n<\nMyData\n \n&&\n,\n \nMyData\n \n&&>\n(\nMyData\n \n&&\n,\n \nMyData\n \n&&\n)\n \nconst\n \n{\n \n// warning: modification of 'std' namespace can result in undefined behavior\n\n\n    \nreturn\n \ntrue\n;\n\n\n  \n}\n\n\n}\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nDCL58-CPP. Do not modify the standard namespaces\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/std-namespace-modification.html"
  },
  {
    "name": "bugprone-string-constructor",
    "description": "Finds string constructors that are suspicious and probably errors.\n\nA common mistake is to swap parameters to the âfillâ string-constructor.\n\nExamples:\n\nstd\n::\nstring\n \nstr\n(\n'x'\n,\n \n50\n);\n \n// should be str(50, 'x')\n\nCalling the string-literal constructor with a length bigger than the literal is\nsuspicious and adds extra random characters to the string.\n\nExamples:\n\nstd\n::\nstring\n(\n\"test\"\n,\n \n200\n);\n   \n// Will include random characters after \"test\".\n\n\nstd\n::\nstring\n(\n\"test\"\n,\n \n2\n,\n \n5\n);\n  \n// Will include random characters after \"st\".\n\n\nstd\n::\nstring_view\n(\n\"test\"\n,\n \n200\n);\n\nCreating an empty string from constructors with parameters is considered\nsuspicious. The programmer should use the empty constructor instead.\n\nExamples:\n\nstd\n::\nstring\n(\n\"test\"\n,\n \n0\n);\n   \n// Creation of an empty string.\n\n\nstd\n::\nstring\n(\n\"test\"\n,\n \n1\n,\n \n0\n);\n\n\nstd\n::\nstring_view\n(\n\"test\"\n,\n \n0\n);\n\nPassing an invalid first character position parameter to constructor will\ncause \nstd::out_of_range\n exception at runtime.\n\nExamples:\n\nstd\n::\nstring\n(\n\"test\"\n,\n \n-1\n,\n \n10\n);\n \n// Negative first character position.\n\n\nstd\n::\nstring\n(\n\"test\"\n,\n \n10\n,\n \n10\n);\n \n// First character position is bigger than string literal character range\".\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnLargeLength\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on a string with a length greater than\n\nLargeLengthThreshold\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nLargeLengthThreshold\nÂ¶\n\n\nAn integer specifying the large length threshold. Default is \n0x800000\n.\n\n\n\n\n\n\n\n\nStringNames\nÂ¶\n\n\nDefault is \n::std::basic_string;::std::basic_string_view\n.\n\n\nSemicolon-delimited list of class names to apply this check to.\nBy default \n::std::basic_string\n applies to \nstd::string\n and\n\nstd::wstring\n. Set to e.g. \n::std::basic_string;llvm::StringRef;QString\n\nto perform this check on custom classes.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/string-constructor.html"
  },
  {
    "name": "bugprone-string-integer-assignment",
    "description": "The check finds assignments of an integer to \nstd::basic_string<CharT>\n\n(\nstd::string\n, \nstd::wstring\n, etc.). The source of the problem is the\nfollowing assignment operator of \nstd::basic_string<CharT>\n:\n\nbasic_string\n&\n \noperator\n=\n(\n \nCharT\n \nch\n \n);\n\nNumeric types can be implicitly casted to character types.\n\nstd\n::\nstring\n \ns\n;\n\n\nint\n \nx\n \n=\n \n5965\n;\n\n\ns\n \n=\n \n6\n;\n\n\ns\n \n=\n \nx\n;\n\nUse the appropriate conversion functions or character literals.\n\nstd\n::\nstring\n \ns\n;\n\n\nint\n \nx\n \n=\n \n5965\n;\n\n\ns\n \n=\n \n'6'\n;\n\n\ns\n \n=\n \nstd\n::\nto_string\n(\nx\n);\n\nIn order to suppress false positives, use an explicit cast.\n\nstd\n::\nstring\n \ns\n;\n\n\ns\n \n=\n \nstatic_cast\n<\nchar\n>\n(\n6\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/string-integer-assignment.html"
  },
  {
    "name": "bugprone-string-literal-with-embedded-nul",
    "description": "Finds occurrences of string literal with embedded NUL character and validates\ntheir usage.\n\nInvalid escaping\nÂ¶\n\n\nSpecial characters can be escaped within a string literal by using their\nhexadecimal encoding like \n\\x42\n. A common mistake is to escape them\nlike this \n\\0x42\n where the \n\\0\n stands for the NUL character.\n\n\nconst\n \nchar\n*\n \nExample\n[]\n \n=\n \n\"Invalid character: \n\\0\nx12 should be \n\\x12\n\"\n;\n\n\nconst\n \nchar\n*\n \nBytes\n[]\n \n=\n \n\"\n\\x03\\0\nx02\n\\0\nx01\n\\0\nx00\n\\0\nxFF\n\\0\nxFF\n\\0\nxFF\"\n;\n\nTruncated literal\nÂ¶\n\n\nString-like classes can manipulate strings with embedded NUL as they are\nkeeping track of the bytes and the length. This is not the case for a\n\nchar*\n (NUL-terminated) string.\n\n\nA common mistake is to pass a string-literal with embedded NUL to a string\nconstructor expecting a NUL-terminated string. The bytes after the first NUL\ncharacter are truncated.\n\n\nstd\n::\nstring\n \nstr\n(\n\"abc\n\\0\ndef\"\n);\n  \n// \"def\" is truncated\n\n\nstr\n \n+=\n \n\"\n\\0\n\"\n;\n                  \n// This statement is doing nothing\n\n\nif\n \n(\nstr\n \n==\n \n\"\n\\0\nabc\"\n)\n \nreturn\n;\n   \n// This expression is always true",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/string-literal-with-embedded-nul.html"
  },
  {
    "name": "bugprone-stringview-nullptr",
    "description": "Checks for various ways that the \nconst\n \nCharT*\n constructor of\n\nstd::basic_string_view\n can be passed a null argument and replaces them\nwith the default constructor in most cases. For the comparison operators,\nbraced initializer list does not compile so instead a call to \n.empty()\n\nor the empty string literal are used, where appropriate.\n\nThis prevents code from invoking behavior which is unconditionally undefined.\nThe single-argument \nconst\n \nCharT*\n constructor does not check for the null\ncase before dereferencing its input. The standard is slated to add an\nexplicitly-deleted overload to catch some of these cases: wg21.link/p2166\n\nTo catch the additional cases of \nNULL\n (which expands to \n__null\n) and\n\n0\n, first run the \nmodernize-use-nullptr\n check to convert the callers to\n\nnullptr\n.\n\nstd\n::\nstring_view\n \nsv\n \n=\n \nnullptr\n;\n\n\n\nsv\n \n=\n \nnullptr\n;\n\n\n\nbool\n \nis_empty\n \n=\n \nsv\n \n==\n \nnullptr\n;\n\n\nbool\n \nisnt_empty\n \n=\n \nsv\n \n!=\n \nnullptr\n;\n\n\n\naccepts_sv\n(\nnullptr\n);\n\n\n\naccepts_sv\n({{}});\n  \n// A\n\n\n\naccepts_sv\n({\nnullptr\n,\n \n0\n});\n  \n// B\n\nis translated intoâ¦\n\nstd\n::\nstring_view\n \nsv\n \n=\n \n{};\n\n\n\nsv\n \n=\n \n{};\n\n\n\nbool\n \nis_empty\n \n=\n \nsv\n.\nempty\n();\n\n\nbool\n \nisnt_empty\n \n=\n \n!\nsv\n.\nempty\n();\n\n\n\naccepts_sv\n(\n\"\"\n);\n\n\n\naccepts_sv\n(\n\"\"\n);\n  \n// A\n\n\n\naccepts_sv\n({\nnullptr\n,\n \n0\n});\n  \n// B\n\nNote\n\n\nThe source pattern with trailing comment âAâ selects the \n(const\n \nCharT*)\n\nconstructor overload and then value-initializes the pointer, causing a null\ndereference. It happens to not include the \nnullptr\n literal, but it is\nstill within the scope of this ClangTidy check.\n\nNote\n\n\nThe source pattern with trailing comment âBâ selects the\n\n(const\n \nCharT*,\n \nsize_type)\n constructor which is perfectly valid, since the\nlength argument is \n0\n. It is not changed by this ClangTidy check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/stringview-nullptr.html"
  },
  {
    "name": "bugprone-suspicious-enum-usage",
    "description": "The checker detects various cases when an enum is probably misused\n(as a bitmask).\n\nWhen âADDâ or âbitwise ORâ is used between two enum which come\nfrom different types and these types value ranges are not disjoint.\n\nThe following cases will be investigated only using \nStrictMode\n. We\nregard the enum as a (suspicious)\nbitmask if the three conditions below are true at the same time:\n\nat most half of the elements of the enum are non pow-of-2 numbers (because of\nshort enumerations)\n\n\nthere is another non pow-of-2 number than the enum constant representing all\nchoices (the result âbitwise ORâ operation of all enum elements)\n\n\nenum type variable/enumconstant is used as an argument of a \n+\n or âbitwise\nORâ operator\n\nSo whenever the non pow-of-2 element is used as a bitmask element we diagnose a\nmisuse and give a warning.\n\nInvestigating the right hand side of \n+=\n and \n|=\n operator.\n\n\nCheck only the enum value side of a \n|\n and \n+\n operator if one of\nthem is not enum val.\n\n\nCheck both side of \n|\n or \n+\n operator where the enum values are from\nthe same enum type.\n\nExamples:\n\nenum\n \n{\n \nA\n,\n \nB\n,\n \nC\n \n};\n\n\nenum\n \n{\n \nD\n,\n \nE\n,\n \nF\n \n=\n \n5\n \n};\n\n\nenum\n \n{\n \nG\n \n=\n \n10\n,\n \nH\n \n=\n \n11\n,\n \nI\n \n=\n \n12\n \n};\n\n\n\nunsigned\n \nflag\n;\n\n\nflag\n \n=\n\n\n    \nA\n \n|\n\n\n    \nH\n;\n \n// OK, disjoint value intervals in the enum types ->probably good use.\n\n\nflag\n \n=\n \nB\n \n|\n \nF\n;\n \n// Warning, have common values so they are probably misused.\n\n\n\n// Case 2:\n\n\nenum\n \nBitmask\n \n{\n\n\n  \nA\n \n=\n \n0\n,\n\n\n  \nB\n \n=\n \n1\n,\n\n\n  \nC\n \n=\n \n2\n,\n\n\n  \nD\n \n=\n \n4\n,\n\n\n  \nE\n \n=\n \n8\n,\n\n\n  \nF\n \n=\n \n16\n,\n\n\n  \nG\n \n=\n \n31\n \n// OK, real bitmask.\n\n\n};\n\n\n\nenum\n \nAlmostbitmask\n \n{\n\n\n  \nAA\n \n=\n \n0\n,\n\n\n  \nBB\n \n=\n \n1\n,\n\n\n  \nCC\n \n=\n \n2\n,\n\n\n  \nDD\n \n=\n \n4\n,\n\n\n  \nEE\n \n=\n \n8\n,\n\n\n  \nFF\n \n=\n \n16\n,\n\n\n  \nGG\n \n// Problem, forgot to initialize.\n\n\n};\n\n\n\nunsigned\n \nflag\n \n=\n \n0\n;\n\n\nflag\n \n|=\n \nE\n;\n \n// OK.\n\n\nflag\n \n|=\n\n\n    \nEE\n;\n \n// Warning at the decl, and note that it was used here as a bitmask.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nDefault value: 0.\nWhen non-null the suspicious bitmask usage will be investigated additionally\nto the different enum usage check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-enum-usage.html"
  },
  {
    "name": "bugprone-suspicious-include",
    "description": "The check detects various cases when an include refers to what appears to be an\nimplementation file, which often leads to hard-to-track-down ODR violations.\n\nExamples:\n\n#include\n \n\"Dinosaur.hpp\"\n     // OK, .hpp files tend not to have definitions.\n\n\n#include\n \n\"Pterodactyl.h\"\n    // OK, .h files tend not to have definitions.\n\n\n#include\n \n\"Velociraptor.cpp\"\n // Warning, filename is suspicious.\n\n\n#include_next <stdio.c>     \n// Warning, filename is suspicious.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredRegex\nÂ¶\n\n\nA regular expression for the file name to be ignored by the check. Default\nis empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-include.html"
  },
  {
    "name": "bugprone-suspicious-memory-comparison",
    "description": "Finds potentially incorrect calls to \nmemcmp()\n based on properties of the\narguments. The following cases are covered:\n\nCase 1: Non-standard-layout type\n\nComparing the object representations of non-standard-layout objects may not\nproperly compare the value representations.\n\nCase 2: Types with no unique object representation\n\nObjects with the same value may not have the same object representation.\nThis may be caused by padding or floating-point types.\n\nSee also:\n\nEXP42-C. Do not compare padding data\n\nand\n\nFLP37-C. Do not use object representations to compare floating-point values\n\nThis check is also related to and partially overlaps the CERT C++ Coding Standard rules\n\nOOP57-CPP. Prefer special member functions and overloaded operators to\nC Standard Library functions\n\nand\n\nEXP62-CPP. Do not access the bits of an object representation that are not\npart of the objectâs value representation\n\ncert-exp42-c\n redirects here as an alias of this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-memory-comparison.html"
  },
  {
    "name": "bugprone-suspicious-memset-usage",
    "description": "This check finds \nmemset()\n calls with potential mistakes in their arguments.\nConsidering the function as \nvoid*\n \nmemset(void*\n \ndestination,\n \nint\n \nfill_value,\n\n\nsize_t\n \nbyte_count)\n, the following cases are covered:\n\nCase 1: Fill value is a character ``â0â``\n\nFilling up a memory area with ASCII code 48 characters is not customary,\npossibly integer zeroes were intended instead.\nThe check offers a replacement of \n'0'\n with \n0\n. Memsetting character\npointers with \n'0'\n is allowed.\n\nCase 2: Fill value is truncated\n\nMemset converts \nfill_value\n to \nunsigned\n \nchar\n before using it. If\n\nfill_value\n is out of unsigned character range, it gets truncated\nand memory will not contain the desired pattern.\n\nCase 3: Byte count is zero\n\nCalling memset with a literal zero in its \nbyte_count\n argument is likely\nto be unintended and swapped with \nfill_value\n. The check offers to swap\nthese two arguments.\n\nCorresponding cpplint.py check name: \nruntime/memset\n.\n\nExamples:\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nint\n \ni\n[\n5\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n};\n\n\n  \nint\n \n*\nip\n \n=\n \ni\n;\n\n\n  \nchar\n \nc\n \n=\n \n'1'\n;\n\n\n  \nchar\n \n*\ncp\n \n=\n \n&\nc\n;\n\n\n  \nint\n \nv\n \n=\n \n0\n;\n\n\n\n  \n// Case 1\n\n\n  \nmemset\n(\nip\n,\n \n'0'\n,\n \n1\n);\n \n// suspicious\n\n\n  \nmemset\n(\ncp\n,\n \n'0'\n,\n \n1\n);\n \n// OK\n\n\n\n  \n// Case 2\n\n\n  \nmemset\n(\nip\n,\n \n0xabcd\n,\n \n1\n);\n \n// fill value gets truncated\n\n\n  \nmemset\n(\nip\n,\n \n0x00\n,\n \n1\n);\n   \n// OK\n\n\n\n  \n// Case 3\n\n\n  \nmemset\n(\nip\n,\n \nsizeof\n(\nint\n),\n \nv\n);\n \n// zero length, potentially swapped\n\n\n  \nmemset\n(\nip\n,\n \n0\n,\n \n1\n);\n           \n// OK\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-memset-usage.html"
  },
  {
    "name": "bugprone-suspicious-missing-comma",
    "description": "String literals placed side-by-side are concatenated at translation phase 6\n(after the preprocessor). This feature is used to represent long string\nliteral on multiple lines.\n\nFor instance, the following declarations are equivalent:\n\nconst\n \nchar\n*\n \nA\n[]\n \n=\n \n\"This is a test\"\n;\n\n\nconst\n \nchar\n*\n \nB\n[]\n \n=\n \n\"This\"\n \n\" is a \"\n    \n\"test\"\n;\n\nA common mistake done by programmers is to forget a comma between two string\nliterals in an array initializer list.\n\nconst\n \nchar\n*\n \nTest\n[]\n \n=\n \n{\n\n\n  \n\"line 1\"\n,\n\n\n  \n\"line 2\"\n     \n// Missing comma!\n\n\n  \n\"line 3\"\n,\n\n\n  \n\"line 4\"\n,\n\n\n  \n\"line 5\"\n\n\n};\n\nThe array contains the string âline 2line3â at offset 1 (i.e. Test[1]). Clang\nwonât generate warnings at compile time.\n\nThis check may warn incorrectly on cases like:\n\nconst\n \nchar\n*\n \nSupportedFormat\n[]\n \n=\n \n{\n\n\n  \n\"Error %s\"\n,\n\n\n  \n\"Code \"\n \nPRIu64\n,\n   \n// May warn here.\n\n\n  \n\"Warning %s\"\n,\n\n\n};\n\nOptions\nÂ¶\n\n\n\n\n\n\nSizeThreshold\nÂ¶\n\n\nAn unsigned integer specifying the minimum size of a string literal to be\nconsidered by the check. Default is \n5U\n.\n\n\n\n\n\n\n\n\nRatioThreshold\nÂ¶\n\n\nA string specifying the maximum threshold ratio [0, 1.0] of suspicious string\nliterals to be considered. Default is \n\".2\"\n.\n\n\n\n\n\n\n\n\nMaxConcatenatedTokens\nÂ¶\n\n\nAn unsigned integer specifying the maximum number of concatenated tokens.\nDefault is \n5U\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-missing-comma.html"
  },
  {
    "name": "bugprone-suspicious-realloc-usage",
    "description": "This check finds usages of \nrealloc\n where the return value is assigned to\nthe same expression as passed to the first argument:\n\np\n \n=\n \nrealloc(p,\n \nsize);\n\nThe problem with this construct is that if \nrealloc\n fails it returns a\nnull pointer but does not deallocate the original memory. If no other variable\nis pointing to it, the original memory block is not available any more for the\nprogram to use or free. In either case \np\n \n=\n \nrealloc(p,\n \nsize);\n indicates bad\ncoding style and can be replaced by \nq\n \n=\n \nrealloc(p,\n \nsize);\n.\n\nThe pointer expression (used at \nrealloc\n) can be a variable or a field\nmember of a data structure, but can not contain function calls or unresolved\ntypes.\n\nIn obvious cases when the pointer used at realloc is assigned to another\nvariable before the \nrealloc\n call, no warning is emitted. This happens only\nif a simple expression in form of \nq\n \n=\n \np\n or \nvoid\n \n*q\n \n=\n \np\n is found in the\nsame function where \np\n \n=\n \nrealloc(p,\n \n...)\n is found. The assignment has to be\nbefore the call to realloc (but otherwise at any place) in the same function.\nThis suppression works only if \np\n is a single variable.\n\nExamples:\n\nstruct\n \nA\n \n{\n\n\n  \nvoid\n \n*\np\n;\n\n\n};\n\n\n\nA\n \n&\ngetA\n();\n\n\n\nvoid\n \nfoo\n(\nvoid\n \n*\np\n,\n \nA\n \n*\na\n,\n \nint\n \nnew_size\n)\n \n{\n\n\n  \np\n \n=\n \nrealloc\n(\np\n,\n \nnew_size\n);\n \n// warning: 'p' may be set to null if 'realloc' fails, which may result in a leak of the original buffer\n\n\n  \na\n->\np\n \n=\n \nrealloc\n(\na\n->\np\n,\n \nnew_size\n);\n \n// warning: 'a->p' may be set to null if 'realloc' fails, which may result in a leak of the original buffer\n\n\n  \ngetA\n().\np\n \n=\n \nrealloc\n(\ngetA\n().\np\n,\n \nnew_size\n);\n \n// no warning\n\n\n}\n\n\n\nvoid\n \nfoo1\n(\nvoid\n \n*\np\n,\n \nint\n \nnew_size\n)\n \n{\n\n\n  \nvoid\n \n*\np1\n \n=\n \np\n;\n\n\n  \np\n \n=\n \nrealloc\n(\np\n,\n \nnew_size\n);\n \n// no warning\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-realloc-usage.html"
  },
  {
    "name": "bugprone-suspicious-semicolon",
    "description": "Finds most instances of stray semicolons that unexpectedly alter the meaning of\nthe code. More specifically, it looks for \nif\n, \nwhile\n, \nfor\n and\n\nfor-range\n statements whose body is a single semicolon, and then analyzes\nthe context of the code (e.g. indentation) in an attempt to determine whether\nthat is intentional.\n\nif\n \n(\nx\n \n<\n \ny\n);\n\n\n{\n\n\n  \nx\n++\n;\n\n\n}\n\nHere the body of the \nif\n statement consists of only the semicolon at the end\nof the first line, and \nx\n will be incremented regardless of the condition.\n\nwhile\n \n((\nline\n \n=\n \nreadLine\n(\nfile\n))\n \n!=\n \nNULL\n);\n\n\n  \nprocessLine\n(\nline\n);\n\nAs a result of this code, \nprocessLine()\n will only be called once, when the\n\nwhile\n loop with the empty body exits with \nline\n \n==\n \nNULL\n. The indentation\nof the code indicates the intention of the programmer.\n\nif\n \n(\nx\n \n>=\n \ny\n);\n\n\nx\n \n-=\n \ny\n;\n\nWhile the indentation does not imply any nesting, there is simply no valid\nreason to have an \nif\n statement with an empty body (but it can make sense for\na loop). So this check issues a warning for the code above.\n\nTo solve the issue remove the stray semicolon or in case the empty body is\nintentional, reflect this using code indentation or put the semicolon in a new\nline. For example:\n\nwhile\n \n(\nreadWhitespace\n());\n\n\n  \nToken\n \nt\n \n=\n \nreadNextToken\n();\n\nHere the second line is indented in a way that suggests that it is meant to be\nthe body of the \nwhile\n loop - whose body is in fact empty, because of the\nsemicolon at the end of the first line.\n\nEither remove the indentation from the second line:\n\nwhile\n \n(\nreadWhitespace\n());\n\n\nToken\n \nt\n \n=\n \nreadNextToken\n();\n\nâ¦ or move the semicolon from the end of the first line to a new line:\n\nwhile\n \n(\nreadWhitespace\n())\n\n\n  \n;\n\n\n\n  \nToken\n \nt\n \n=\n \nreadNextToken\n();\n\nIn this case the check will assume that you know what you are doing, and will\nnot raise a warning.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-semicolon.html"
  },
  {
    "name": "bugprone-suspicious-string-compare",
    "description": "Find suspicious usage of runtime string comparison functions.\nThis check is valid in C and C++.\n\nChecks for calls with implicit comparator and proposed to explicitly add it.\n\nif\n \n(\nstrcmp\n(...))\n       \n// Implicitly compare to zero\n\n\nif\n \n(\n!\nstrcmp\n(...))\n      \n// Won't warn\n\n\nif\n \n(\nstrcmp\n(...)\n \n!=\n \n0\n)\n  \n// Won't warn\n\nChecks that compare function results (i.e., \nstrcmp\n) are compared to valid\nconstant. The resulting value is\n\n<\n  \n0\n    \nwhen\n \nlower\n \nthan\n,\n\n\n>\n  \n0\n    \nwhen\n \ngreater\n \nthan\n,\n\n\n==\n \n0\n    \nwhen\n \nequals\n.\n\nA common mistake is to compare the result to \n1\n or \n-1\n.\n\nif\n \n(\nstrcmp\n(...)\n \n==\n \n-1\n)\n  \n// Incorrect usage of the returned value.\n\nAdditionally, the check warns if the results value is implicitly cast to a\n\nsuspicious\n non-integer type. Itâs happening when the returned value is\nused in a wrong context.\n\nif\n \n(\nstrcmp\n(...)\n \n<\n \n0.\n)\n  \n// Incorrect usage of the returned value.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnImplicitComparison\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on implicit comparison. \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnOnLogicalNotComparison\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on logical not comparison. \nfalse\n by default.\n\n\n\n\n\n\n\n\nStringCompareLikeFunctions\nÂ¶\n\n\nA string specifying the comma-separated names of the extra string comparison\nfunctions. Default is an empty string.\nThe check will detect the following string comparison functions:\n\n__builtin_memcmp\n, \n__builtin_strcasecmp\n, \n__builtin_strcmp\n,\n\n__builtin_strncasecmp\n, \n__builtin_strncmp\n, \n_mbscmp\n, \n_mbscmp_l\n,\n\n_mbsicmp\n, \n_mbsicmp_l\n, \n_mbsnbcmp\n, \n_mbsnbcmp_l\n, \n_mbsnbicmp\n,\n\n_mbsnbicmp_l\n, \n_mbsncmp\n, \n_mbsncmp_l\n, \n_mbsnicmp\n, \n_mbsnicmp_l\n,\n\n_memicmp\n, \n_memicmp_l\n, \n_stricmp\n, \n_stricmp_l\n, \n_strnicmp\n,\n\n_strnicmp_l\n, \n_wcsicmp\n, \n_wcsicmp_l\n, \n_wcsnicmp\n, \n_wcsnicmp_l\n,\n\nlstrcmp\n, \nlstrcmpi\n, \nmemcmp\n, \nmemicmp\n, \nstrcasecmp\n, \nstrcmp\n,\n\nstrcmpi\n, \nstricmp\n, \nstrncasecmp\n, \nstrncmp\n, \nstrnicmp\n, \nwcscasecmp\n,\n\nwcscmp\n, \nwcsicmp\n, \nwcsncmp\n, \nwcsnicmp\n, \nwmemcmp\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-string-compare.html"
  },
  {
    "name": "bugprone-suspicious-stringview-data-usage",
    "description": "Identifies suspicious usages of \nstd::string_view::data()\n that could lead to\nreading out-of-bounds data due to inadequate or incorrect string null\ntermination.\n\nIt warns when the result of \ndata()\n is passed to a constructor or function\nwithout also passing the corresponding result of \nsize()\n or \nlength()\n\nmember function. Such usage can lead to unintended behavior, particularly when\nassuming the data pointed to by \ndata()\n is null-terminated.\n\nThe absence of a \nc_str()\n method in \nstd::string_view\n often leads\ndevelopers to use \ndata()\n as a substitute, especially when interfacing with\nC APIs that expect null-terminated strings. However, since \ndata()\n does not\nguarantee null termination, this can result in unintended behavior if the API\nrelies on proper null termination for correct string interpretation.\n\nIn todayâs programming landscape, this scenario can occur when implicitly\nconverting an \nstd::string_view\n to an \nstd::string\n. Since the constructor\nin \nstd::string\n designed for string-view-like objects is \nexplicit\n,\nattempting to pass an \nstd::string_view\n to a function expecting an\n\nstd::string\n will result in a compilation error. As a workaround, developers\nmay be tempted to utilize the \n.data()\n method to achieve compilation,\nintroducing potential risks.\n\nFor instance:\n\nvoid\n \nprintString\n(\nconst\n \nstd\n::\nstring\n&\n \nstr\n)\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \n\"String: \"\n \n<<\n \nstr\n \n<<\n \nstd\n::\nendl\n;\n\n\n}\n\n\n\nvoid\n \nsomething\n(\nstd\n::\nstring_view\n \nsv\n)\n \n{\n\n\n  \nprintString\n(\nsv\n.\ndata\n());\n\n\n}\n\nIn this example, directly passing \nsv\n to the \nprintString\n function would\nlead to a compilation error due to the explicit nature of the \nstd::string\n\nconstructor. Consequently, developers might opt for \nsv.data()\n to resolve the\ncompilation error, albeit introducing potential hazards as discussed.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringViewTypes\nÂ¶\n\n\nOption allows users to specify custom string view-like types for analysis. It\naccepts a semicolon-separated list of type names or regular expressions\nmatching these types. Default value is:\n\n::std::basic_string_view;::llvm::StringRef\n.\n\n\n\n\n\n\n\n\nAllowedCallees\nÂ¶\n\n\nSpecifies methods, functions, or classes where the result of \n.data()\n is\npassed to. Allows to exclude such calls from the analysis. Accepts a\nsemicolon-separated list of names or regular expressions matching these\nentities. Default value is: empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-stringview-data-usage.html"
  },
  {
    "name": "bugprone-swapped-arguments",
    "description": "Finds potentially swapped arguments by examining implicit conversions.\nIt analyzes the types of the arguments being passed to a function and compares\nthem to the expected types of the corresponding parameters. If there is a\nmismatch or an implicit conversion that indicates a potential swap, a warning\nis raised.\n\nvoid\n \nprintNumbers\n(\nint\n \na\n,\n \nfloat\n \nb\n);\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \n// Swapped arguments: float passed as int, int as float)\n\n\n  \nprintNumbers\n(\n10.0f\n,\n \n5\n);\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\nCovers a wide range of implicit conversions, including:\n- User-defined conversions\n- Conversions from floating-point types to boolean or integral types\n- Conversions from integral types to boolean or floating-point types\n- Conversions from boolean to integer types or floating-point types\n- Conversions from (member) pointers to boolean\n\nIt is important to note that for most argument swaps, the types need to match\nexactly. However, there are exceptions to this rule. Specifically, when the\nswapped argument is of integral type, an exact match is not always necessary.\nImplicit casts from other integral types are also accepted. Similarly, when\ndealing with floating-point arguments, implicit casts between different\nfloating-point types are considered acceptable.\n\nTo avoid confusion, swaps where both swapped arguments are of integral types or\nboth are of floating-point types do not trigger the warning. In such cases,\nitâs assumed that the developer intentionally used different integral or\nfloating-point types and does not raise a warning. This approach prevents false\npositives and provides flexibility in handling situations where varying\nintegral or floating-point types are intentionally utilized.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/swapped-arguments.html"
  },
  {
    "name": "bugprone-switch-missing-default-case",
    "description": "Ensures that switch statements without default cases are flagged, focuses only\non covering cases with non-enums where the compiler may not issue warnings.\n\nSwitch statements without a default case can lead to unexpected\nbehavior and incomplete handling of all possible cases. When a switch statement\nlacks a default case, if a value is encountered that does not match any of the\nspecified cases, the switch statement will do nothing and the program will\ncontinue execution without handling the value.\n\nThis check helps identify switch statements that are missing a default case,\nallowing developers to ensure that all possible cases are handled properly.\nAdding a default case allows for graceful handling of unexpected or unmatched\nvalues, reducing the risk of program errors and unexpected behavior.\n\nExample:\n\n// Example 1:\n\n\n// warning: switching on non-enum value without default case may not cover all cases\n\n\nswitch\n \n(\ni\n)\n \n{\n\n\ncase\n \n0\n:\n\n\n  \nbreak\n;\n\n\n}\n\n\n\n// Example 2:\n\n\nenum\n \nE\n \n{\n \neE1\n \n};\n\n\nE\n \ne\n \n=\n \neE1\n;\n\n\nswitch\n \n(\ne\n)\n \n{\n \n// no-warning\n\n\ncase\n \neE1\n:\n\n\n  \nbreak\n;\n\n\n}\n\n\n\n// Example 3:\n\n\nint\n \ni\n \n=\n \n0\n;\n\n\nswitch\n \n(\ni\n)\n \n{\n \n// no-warning\n\n\ncase\n \n0\n:\n\n\n  \nbreak\n;\n\n\ndefault\n:\n\n\n  \nbreak\n;\n\n\n}\n\nNote\n\n\nEnum types are already covered by compiler warnings (comes under -Wswitch)\nwhen a switch statement does not handle all enum values. This check focuses\non non-enum types where the compiler warnings may not be present.\n\nSee also\n\n\nThe \nCppCoreGuideline ES.79\n\nprovide guidelines on switch statements, including the recommendation to\nalways provide a default case.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/switch-missing-default-case.html"
  },
  {
    "name": "bugprone-tagged-union-member-count",
    "description": "Gives warnings for tagged unions, where the number of tags is\ndifferent from the number of data members inside the union.\n\nA struct or a class is considered to be a tagged union if it has\nexactly one union data member and exactly one enum data member and\nany number of other data members that are neither unions or enums.\nFurthermore, the types of the union and the enum members must\nnot come from system header files nor the \nstd\n namespace.\n\nExample:\n\nenum\n \nTags\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnion\n \n{\n \n// warning: tagged union has more data members (3) than tags (2)\n\n\n  \nenum\n \nTags\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nfloat\n \nF\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\nThe following example illustrates the exception for unions and enums from\nsystem header files and the \nstd\n namespace.\n\n#include\n \n<pthread.h>\n\n\n\nstruct\n \nNotTaggedUnion\n \n{\n\n\n  \nenum\n \nMyEnum\n \n{\n \nMyEnumConstant1\n,\n \nMyEnumConstant2\n \n}\n \nEn\n;\n\n\n  \npthread_mutex_t\n \nMutex\n;\n\n\n};\n\nThe \npthread_mutex_t\n type may be defined as a union behind a \ntypedef\n,\nin which case the check could mistake this type as a user-defined tagged union.\nAfter all, it has exactly one enum data member and exactly one union data member.\nTo avoid false-positive cases originating from this, unions and enums from\nsystem headers and the \nstd\n namespace are ignored when pinpointing the\nunion part and the enum part of a potential user-defined tagged union.\n\nHow enum constants are counted\nÂ¶\n\n\nThe main complicating factor when counting the number of enum constants is that\nsome of them might be auxiliary values that purposefully donât have a\ncorresponding union data member and are used for something else. For example\nthe last enum constant sometimes explicitly âpoints toâ the last declared valid\nenum constant or tracks how many enum constants have been declared.\n\n\nFor an illustration:\n\n\nenum\n \nTagWithLast\n \n{\n\n\n  \nTag1\n \n=\n \n0\n,\n\n\n  \nTag2\n \n=\n \n1\n,\n\n\n  \nTag3\n \n=\n \n2\n,\n\n\n  \nLastTag\n \n=\n \n2\n\n\n};\n\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n \n// is 0\n\n\n  \nTag2\n,\n \n// is 1\n\n\n  \nTag3\n,\n \n// is 2\n\n\n  \nTagCount\n,\n \n// is 3\n\n\n};\n\n\n\n\n\n\nThe check counts the number of distinct values among the enum constants and not\nthe enum constants themselves. This way the enum constants that are essentially\njust aliases of other enum constants are not included in the final count.\n\n\nHandling of counting enum constants (ones like \nTagCount\n in the previous\ncode example) is done by decreasing the number of enum values by one if the name\nof the last enum constant starts with a prefix or ends with a suffix specified in\n\nCountingEnumPrefixes\n, \nCountingEnumSuffixes\n and itâs value is\none less than the total number of distinct values in the enum.\n\n\nWhen the final count is adjusted based on this heuristic then a diagnostic note\nis emitted that shows which enum constant matched the criteria.\n\n\nThe heuristic can be disabled entirely (\nEnableCountingEnumHeuristic\n)\nor configured to follow your naming convention (\nCountingEnumPrefixes\n,\n\nCountingEnumSuffixes\n).\nThe strings specified in \nCountingEnumPrefixes\n,\n\nCountingEnumSuffixes\n are matched case insensitively.\n\n\nExample counts:\n\n\n// Enum count is 3, because the value 2 is counted only once\n\n\nenum\n \nTagWithLast\n \n{\n\n\n  \nTag1\n \n=\n \n0\n,\n\n\n  \nTag2\n \n=\n \n1\n,\n\n\n  \nTag3\n \n=\n \n2\n,\n\n\n  \nLastTag\n \n=\n \n2\n\n\n};\n\n\n\n// Enum count is 3, because TagCount is heuristically excluded\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n \n// is 0\n\n\n  \nTag2\n,\n \n// is 1\n\n\n  \nTag3\n,\n \n// is 2\n\n\n  \nTagCount\n,\n \n// is 3\n\n\n};\n\nOptions\nÂ¶\n\n\n\n\n\n\nEnableCountingEnumHeuristic\nÂ¶\n\n\n\n\nThis option enables or disables the counting enum heuristic.\nIt uses the prefixes and suffixes specified in the options\n\nCountingEnumPrefixes\n, \nCountingEnumSuffixes\n to find counting enum constants by\nusing them for prefix and suffix matching.\n\n\nThis option is enabled by default.\n\n\nWhen \nEnableCountingEnumHeuristic\n is \nfalse\n:\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nTagCount\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnion\n \n{\n\n\n  \nTagWithCounter\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\nWhen \nEnableCountingEnumHeuristic\n is \ntrue\n:\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nTagCount\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnion\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounter\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nCountingEnumPrefixes\nÂ¶\n\n\n\n\nSee \nCountingEnumSuffixes\n below.\n\n\n\n\n\n\nCountingEnumSuffixes\nÂ¶\n\n\n\n\nCountingEnumPrefixes and CountingEnumSuffixes are lists of semicolon\nseparated strings that are used to search for possible counting enum constants.\nThese strings are matched case insensitively as prefixes and suffixes\nrespectively on the names of the enum constants.\nIf \nEnableCountingEnumHeuristic\n is \nfalse\n then these options do nothing.\n\n\nThe default value of \nCountingEnumSuffixes\n is \ncount\n and of\n\nCountingEnumPrefixes\n is the empty string.\n\n\nWhen \nEnableCountingEnumHeuristic\n is \ntrue\n and\n\nCountingEnumSuffixes\n is \ncount;size\n:\n\n\nenum\n \nTagWithCounterCount\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nTagCount\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionCount\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterCount\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\nenum\n \nTagWithCounterSize\n \n{\n\n\n  \nTag11\n,\n\n\n  \nTag22\n,\n\n\n  \nTag33\n,\n\n\n  \nTagSize\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionSize\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterSize\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\nWhen \nEnableCountingEnumHeuristic\n is \ntrue\n and\n\nCountingEnumPrefixes\n is \nmaxsize;last_\n\n\nenum\n \nTagWithCounterLast\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nlast_tag\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionLast\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterLast\n \ntag\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nshort\n \nS\n;\n\n\n    \nchar\n \n*\nC\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\nenum\n \nTagWithCounterMaxSize\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nMaxSizeTag\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionMaxSize\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterMaxSize\n \ntag\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nshort\n \nS\n;\n\n\n    \nchar\n \n*\nC\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\n\n\nWhen enabled, the check will also give a warning, when the number of tags\nis greater than the number of union data members.\n\n\nThis option is disabled by default.\n\n\nWhen \nStrictMode\n is \nfalse\n:\n\n\nstruct\n \nTaggedUnion\n \n{\n\n\n  \nenum\n \n{\n\n\n    \nTag1\n,\n\n\n    \nTag2\n,\n\n\n    \nTag3\n,\n\n\n  \n}\n \nTags\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\nWhen \nStrictMode\n is \ntrue\n:\n\n\nstruct\n \nTaggedUnion\n \n{\n \n// warning: tagged union has fewer data members (2) than tags (3)\n\n\n  \nenum\n \n{\n\n\n    \nTag1\n,\n\n\n    \nTag2\n,\n\n\n    \nTag3\n,\n\n\n  \n}\n \nTags\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/tagged-union-member-count.html"
  },
  {
    "name": "bugprone-terminating-continue",
    "description": "Detects \ndo\n \nwhile\n loops with a condition always evaluating to false that\nhave a \ncontinue\n statement, as this \ncontinue\n terminates the loop\neffectively.\n\nvoid\n \nf\n()\n \n{\n\n\ndo\n \n{\n\n\n  \n// some code\n\n\n  \ncontinue\n;\n \n// terminating continue\n\n\n  \n// some other code\n\n\n}\n \nwhile\n(\nfalse\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/terminating-continue.html"
  },
  {
    "name": "bugprone-throw-keyword-missing",
    "description": "Warns about a potentially missing \nthrow\n keyword. If a temporary object\nis created, but the objectâs type derives from (or is the same as) a class\nthat has âEXCEPTIONâ, âExceptionâ or âexceptionâ in its name, we can assume\nthat the programmerâs intention was to throw that object.\n\nExample:\n\nvoid\n \nf\n(\nint\n \ni\n)\n \n{\n\n\n  \nif\n \n(\ni\n \n<\n \n0\n)\n \n{\n\n\n    \n// Exception is created but is not thrown.\n\n\n    \nstd\n::\nruntime_error\n(\n\"Unexpected argument\"\n);\n\n\n  \n}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/throw-keyword-missing.html"
  },
  {
    "name": "bugprone-throwing-static-initialization",
    "description": "Finds all \nstatic\n or \nthread_local\n variable declarations where the\ninitializer for the object may throw an exception.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nERR58-CPP. Handle all exceptions thrown before main() begins executing\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/throwing-static-initialization.html"
  },
  {
    "name": "bugprone-too-small-loop-variable",
    "description": "Detects those \nfor\n loops that have a loop variable with a âtoo smallâ type\nwhich means this type canât represent all values which are part of the\niteration range.\n\nint\n \nmain\n()\n \n{\n\n\n  \nlong\n \nsize\n \n=\n \n294967296l\n;\n\n\n  \nfor\n \n(\nshort\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nsize\n;\n \n++\ni\n)\n \n{}\n\n\n}\n\nThis \nfor\n loop is an infinite loop because the \nshort\n type canât\nrepresent all values in the \n[0..size]\n interval.\n\nIn a real use case size means a containerâs size which depends on the\nuser input.\n\nint\n \ndoSomething\n(\nconst\n \nstd\n::\nvector\n&\n \nitems\n)\n \n{\n\n\n  \nfor\n \n(\nshort\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nitems\n.\nsize\n();\n \n++\ni\n)\n \n{}\n\n\n}\n\nThis algorithm works for a small amount of objects, but will lead to freeze for\na larger user input.\n\nItâs recommended to enable the compiler warning\n\n-Wtautological-constant-out-of-range-compare\n as well, since check does\nnot inspect compile-time constant loop boundaries to avoid overlaps with\nthe warning.\n\nOptions\nÂ¶\n\n\n\n\n\n\nMagnitudeBitsUpperLimit\nÂ¶\n\n\nUpper limit for the magnitude bits of the loop variable. If itâs set the check\nfilters out those catches in which the loop variableâs type has more magnitude\nbits as the specified upper limit. The default value is 16.\nFor example, if the user sets this option to 31 (bits), then a 32-bit \nunsigned\n \nint\n\nis ignored by the check, however a 32-bit \nint\n is not (A 32-bit \nsigned\n \nint\n\nhas 31 magnitude bits).\n\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nlong\n \nsize\n \n=\n \n294967296l\n;\n\n\n  \nfor\n \n(\nunsigned\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nsize\n;\n \n++\ni\n)\n \n{}\n \n// no warning with MagnitudeBitsUpperLimit = 31 on a system where unsigned is 32-bit\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nsize\n;\n \n++\ni\n)\n \n{}\n \n// warning with MagnitudeBitsUpperLimit = 31 on a system where int is 32-bit\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/too-small-loop-variable.html"
  },
  {
    "name": "bugprone-unchecked-optional-access",
    "description": "Note\n: This check uses a flow-sensitive static analysis to produce its\nresults. Therefore, it may be more resource intensive (RAM, CPU) than the\naverage clang-tidy check.\n\nThis check identifies unsafe accesses to values contained in\n\nstd::optional<T>\n, \nabsl::optional<T>\n, \nbase::Optional<T>\n,\n\nfolly::Optional<T>\n, \nbsl::optional\n, or\n\nBloombergLP::bdlb::NullableValue\n objects. Below we will refer to all these\ntypes collectively as \noptional<T>\n.\n\nAn access to the value of an \noptional<T>\n occurs when one of its \nvalue\n,\n\noperator*\n, or \noperator->\n member functions is invoked.  To align with\ncommon misconceptions, the check considers these member functions as\nequivalent, even though there are subtle differences related to exceptions\nversus undefined behavior. See \nAdditional notes\n, below, for more information\non this topic.\n\nAn access to the value of an \noptional<T>\n is considered safe if and only if\ncode in the local scope (for example, a function body) ensures that the\n\noptional<T>\n has a value in all possible execution paths that can reach the\naccess. That should happen either through an explicit check, using the\n\noptional<T>::has_value\n member function, or by constructing the\n\noptional<T>\n in a way that shows that it unambiguously holds a value (e.g\nusing \nstd::make_optional\n which always returns a populated\n\nstd::optional<T>\n).\n\nBelow we list some examples, starting with unsafe optional access patterns,\nfollowed by safe access patterns.\n\nUnsafe access patterns\nÂ¶\n\n\n\n\nAccess the value without checking if it exists\nÂ¶\n\n\nThe check flags accesses to the value that are not locally guarded by\nexistence check:\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nuse\n(\n*\nopt\n);\n \n// unsafe: it is unclear whether `opt` has a value.\n\n\n}\n\n\n\n\n\n\n\n\n\n\nAccess the value in the wrong branch\nÂ¶\n\n\nThe check is aware of the state of an optional object in different\nbranches of the code. For example:\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nif\n \n(\nopt\n.\nhas_value\n())\n \n{\n\n\n  \n}\n \nelse\n \n{\n\n\n    \nuse\n(\nopt\n.\nvalue\n());\n \n// unsafe: it is clear that `opt` does *not* have a value.\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nAssume a function result to be stable\nÂ¶\n\n\nThe check is aware that function results might not be stable. That is,\nconsecutive calls to the same function might return different values.\nFor example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nfoo\n.\ntake\n().\nhas_value\n())\n \n{\n\n\n    \nuse\n(\n*\nfoo\n.\ntake\n());\n \n// unsafe: it is unclear whether `foo.take()` has a value.\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\nException: accessor methods\nÂ¶\n\n\nThe check assumes \naccessor\n methods of a class are stable, with a heuristic to\ndetermine which methods are accessors. Specifically, parameter-free \nconst\n\nmethods and smart pointer-like APIs (non \nconst\n overloads of \n*\n when\nthere is a parallel \nconst\n overload) are treated as accessors. Note that\nthis is not guaranteed to be safe â but, it is widely used (safely) in\npractice. Calls to non \nconst\n methods are assumed to modify the state of\nthe object and affect the stability of earlier accessor calls.\n\n\n\n\n\n\n\n\nRely on invariants of uncommon APIs\nÂ¶\n\n\nThe check is unaware of invariants of uncommon APIs. For example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nfoo\n.\nHasProperty\n(\n\"bar\"\n))\n \n{\n\n\n    \nuse\n(\n*\nfoo\n.\nGetProperty\n(\n\"bar\"\n));\n \n// unsafe: it is unclear whether `foo.GetProperty(\"bar\")` has a value.\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nCheck if a value exists, then pass the optional to another function\nÂ¶\n\n\nThe check relies on local reasoning. The check and value access must\nboth happen in the same function. An access is considered unsafe even if\nthe caller of the function performing the access ensures that the\noptional has a value. For example:\n\n\nvoid\n \ng\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nuse\n(\n*\nopt\n);\n \n// unsafe: it is unclear whether `opt` has a value.\n\n\n}\n\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nif\n \n(\nopt\n.\nhas_value\n())\n \n{\n\n\n    \ng\n(\nopt\n);\n\n\n  \n}\n\n\n}\n\nSafe access patterns\nÂ¶\n\n\n\n\nCheck if a value exists, then access the value\nÂ¶\n\n\nThe check recognizes all straightforward ways for checking if a value\nexists and accessing the value contained in an optional object. For\nexample:\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nif\n \n(\nopt\n.\nhas_value\n())\n \n{\n\n\n    \nuse\n(\n*\nopt\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nCheck if a value exists, then access the value from a copy\nÂ¶\n\n\nThe criteria that the check uses is semantic, not syntactic. It\nrecognizes when a copy of the optional object being accessed is known to\nhave a value. For example:\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt1\n)\n \n{\n\n\n  \nif\n \n(\nopt1\n.\nhas_value\n())\n \n{\n\n\n    \nstd\n::\noptional\n<\nint\n>\n \nopt2\n \n=\n \nopt1\n;\n\n\n    \nuse\n(\n*\nopt2\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nEnsure that a value exists using common macros\nÂ¶\n\n\nThe check is aware of common macros like \nCHECK\n and \nDCHECK\n. Those can be\nused to ensure that an optional object has a value. For example:\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nDCHECK\n(\nopt\n.\nhas_value\n());\n\n\n  \nuse\n(\n*\nopt\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nEnsure that a value exists, then access the value in a correlated branch\nÂ¶\n\n\nThe check is aware of correlated branches in the code and can figure out\nwhen an optional object is ensured to have a value on all execution\npaths that lead to an access. For example:\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nbool\n \nsafe\n \n=\n \nfalse\n;\n\n\n  \nif\n \n(\nopt\n.\nhas_value\n()\n \n&&\n \nSomeOtherCondition\n())\n \n{\n\n\n    \nsafe\n \n=\n \ntrue\n;\n\n\n  \n}\n\n\n  \n// ... more code...\n\n\n  \nif\n \n(\nsafe\n)\n \n{\n\n\n    \nuse\n(\n*\nopt\n);\n\n\n  \n}\n\n\n}\n\nStabilize function results\nÂ¶\n\n\nFunction results are not assumed to be stable across calls, except for\nconst accessor methods. For more complex accessors (non-const, or depend on\nmultiple params) it is best to store the result of the function call in a\nlocal variable and use that variable to access the value. For example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nconst\n \nauto\n&\n \nfoo_opt\n \n=\n \nfoo\n.\ntake\n();\n \nfoo_opt\n.\nhas_value\n())\n \n{\n\n\n    \nuse\n(\n*\nfoo_opt\n);\n\n\n  \n}\n\n\n}\n\nDo not rely on uncommon-API invariants\nÂ¶\n\n\nWhen uncommon APIs guarantee that an optional has contents, do not rely on it\nâ instead, check explicitly that the optional object has a value. For example:\n\n\nvoid\n \nf\n(\nFoo\n \nfoo\n)\n \n{\n\n\n  \nif\n \n(\nconst\n \nauto\n&\n \nproperty\n \n=\n \nfoo\n.\nGetProperty\n(\n\"bar\"\n))\n \n{\n\n\n    \nuse\n(\n*\nproperty\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\ninstead of the \nHasProperty\n, \nGetProperty\n pairing we saw above.\n\nDo not rely on caller-performed checks\nÂ¶\n\n\nIf you know that all of a functionâs callers have checked that an optional\nargument has a value, either change the function to take the value directly or\ncheck the optional again in the local scope of the callee. For example:\n\n\nvoid\n \ng\n(\nint\n \nval\n)\n \n{\n\n\n  \nuse\n(\nval\n);\n\n\n}\n\n\n\nvoid\n \nf\n(\nstd\n::\noptional\n<\nint\n>\n \nopt\n)\n \n{\n\n\n  \nif\n \n(\nopt\n.\nhas_value\n())\n \n{\n\n\n    \ng\n(\n*\nopt\n);\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nand\n\n\nstruct\n \nS\n \n{\n\n\n  \nstd\n::\noptional\n<\nint\n>\n \nopt\n;\n\n\n  \nint\n \nx\n;\n\n\n};\n\n\n\nvoid\n \ng\n(\nconst\n \nS\n \n&\ns\n)\n \n{\n\n\n  \nif\n \n(\ns\n.\nopt\n.\nhas_value\n()\n \n&&\n \ns\n.\nx\n \n>\n \n10\n)\n \n{\n\n\n    \nuse\n(\n*\ns\n.\nopt\n);\n\n\n}\n\n\n\nvoid\n \nf\n(\nS\n \ns\n)\n \n{\n\n\n  \nif\n \n(\ns\n.\nopt\n.\nhas_value\n())\n \n{\n\n\n    \ng\n(\ns\n);\n\n\n  \n}\n\n\n}\n\nAdditional notes\nÂ¶\n\n\n\n\nAliases created via \nusing\n declarations\nÂ¶\n\n\nThe check is aware of aliases of optional types that are created via\n\nusing\n declarations. For example:\n\n\nusing\n \nOptionalInt\n \n=\n \nstd\n::\noptional\n<\nint\n>\n;\n\n\n\nvoid\n \nf\n(\nOptionalInt\n \nopt\n)\n \n{\n\n\n  \nuse\n(\nopt\n.\nvalue\n());\n \n// unsafe: it is unclear whether `opt` has a value.\n\n\n}\n\n\n\n\n\n\n\n\n\n\nLambdas\nÂ¶\n\n\nThe check does not currently report unsafe optional accesses in lambdas.\nA future version will expand the scope to lambdas, following the rules\noutlined above. It is best to follow the same principles when using\noptionals in lambdas.\n\n\n\n\n\n\nAccess with \noperator*()\n vs. \nvalue()\nÂ¶\n\n\nGiven that \nvalue()\n has well-defined behavior (either throwing an exception\nor terminating the program), why treat it the same as \noperator*()\n which\ncauses undefined behavior (UB)? That is, why is it considered unsafe to access\nan optional with \nvalue()\n, if itâs not provably populated with a value?  For\nthat matter, why is \nCHECK()\n followed by \noperator*()\n any better than\n\nvalue()\n, given that they are semantically equivalent (on configurations\nthat disable exceptions)?\n\n\nThe answer is that we assume most users do not realize the difference between\n\nvalue()\n and \noperator*()\n. Shifting to \noperator*()\n and some form of\nexplicit value-presence check or explicit program termination has two\nadvantages:\n\n\n\n\n\n\nReadability. The check, and any potential side effects like program\nshutdown, are very clear in the code. Separating access from checks can\nactually make the checks more obvious.\n\n\nPerformance. A single check can cover many or even all accesses within\nscope. This gives the user the best of both worlds â the safety of a\ndynamic check, but without incurring redundant costs.\n\n\n\n\n\n\n\n\n\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreSmartPointerDereference\nÂ¶\n\n\nIf set to \ntrue\n, the check ignores optionals that\nare reached through overloaded smart-pointer-like dereference (\noperator*\n,\n\noperator->\n) on classes other than the optional type itself. This helps\navoid false positives where the analysis cannot equate results across such\ncalls. This does not cover access through \noperator[]\n. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreValueCalls\nÂ¶\n\n\nIf set to \ntrue\n, the check does not diagnose calls\nto \noptional::value()\n. Diagnostics for \noperator*()\n and\n\noperator->()\n remain enabled. This is useful for codebases that\nintentionally rely on \nvalue()\n for defined, guarded access while still\nflagging UB-prone operator dereferences. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unchecked-optional-access.html"
  },
  {
    "name": "bugprone-unchecked-string-to-number-conversion",
    "description": "This check flags calls to string-to-number conversion functions that do not\nverify the validity of the conversion, such as \natoi()\n or \nscanf()\n. It\ndoes not flag calls to \nstrtol()\n, or other, related conversion functions\nthat do perform better error checking.\n\n#include\n \n<stdlib.h>\n\n\n\nvoid\n \nfunc\n(\nconst\n \nchar\n \n*\nbuff\n)\n \n{\n\n\n  \nint\n \nsi\n;\n\n\n\n  \nif\n \n(\nbuff\n)\n \n{\n\n\n    \nsi\n \n=\n \natoi\n(\nbuff\n);\n \n/* 'atoi' used to convert a string to an integer, but function will\n\n\n                         not report conversion errors; consider using 'strtol' instead. */\n\n\n  \n}\n \nelse\n \n{\n\n\n    \n/* Handle error */\n\n\n  \n}\n\n\n}\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C Coding Standard rule\n\nERR34-C. Detect errors when converting a string to a number\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unchecked-string-to-number-conversion.html"
  },
  {
    "name": "bugprone-undefined-memory-manipulation",
    "description": "Finds calls of memory manipulation functions \nmemset()\n, \nmemcpy()\n and\n\nmemmove()\n on non-TriviallyCopyable objects resulting in undefined behavior.\n\nUsing memory manipulation functions on non-TriviallyCopyable objects can lead\nto a range of subtle and challenging issues in C++ code. The most immediate\nconcern is the potential for undefined behavior, where the state of the object\nmay become corrupted or invalid. This can manifest as crashes, data corruption,\nor unexpected behavior at runtime, making it challenging to identify and\ndiagnose the root cause. Additionally, misuse of memory manipulation functions\ncan bypass essential object-specific operations, such as constructors and\ndestructors, leading to resource leaks or improper initialization.\n\nFor example, when using \nmemcpy\n to copy \nstd::string\n, pointer data is\nbeing copied, and it can result in a double free issue.\n\n#include\n \n<cstring>\n\n\n#include\n \n<string>\n\n\n\nint\n \nmain\n()\n \n{\n\n\n    \nstd\n::\nstring\n \nsource\n \n=\n \n\"Hello\"\n;\n\n\n    \nstd\n::\nstring\n \ndestination\n;\n\n\n\n    \nstd\n::\nmemcpy\n(\n&\ndestination\n,\n \n&\nsource\n,\n \nsizeof\n(\nstd\n::\nstring\n));\n\n\n\n    \n// Undefined behavior may occur here, during std::string destructor call.\n\n\n    \nreturn\n \n0\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/undefined-memory-manipulation.html"
  },
  {
    "name": "bugprone-undelegated-constructor",
    "description": "Finds creation of temporary objects in constructors that look like a\nfunction call to another constructor of the same class.\n\nThe user most likely meant to use a delegating constructor or base class\ninitializer.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/undelegated-constructor.html"
  },
  {
    "name": "bugprone-unhandled-exception-at-new",
    "description": "Finds calls to \nnew\n with missing exception handler for \nstd::bad_alloc\n.\n\nCalls to \nnew\n may throw exceptions of type \nstd::bad_alloc\n that should\nbe handled. Alternatively, the nonthrowing form of \nnew\n can be\nused. The check verifies that the exception is handled in the function\nthat calls \nnew\n.\n\nIf a nonthrowing version is used or the exception is allowed to propagate out\nof the function no warning is generated.\n\nThe exception handler is checked if it catches a \nstd::bad_alloc\n or\n\nstd::exception\n exception type, or all exceptions (catch-all).\nThe check assumes that any user-defined \noperator\n \nnew\n is either\n\nnoexcept\n or may throw an exception of type \nstd::bad_alloc\n (or one\nderived from it). Other exception class types are not taken into account.\n\nint\n \n*\nf\n()\n \nnoexcept\n \n{\n\n\n  \nint\n \n*\np\n \n=\n \nnew\n \nint\n[\n1000\n];\n \n// warning: missing exception handler for allocation failure at 'new'\n\n\n  \n// ...\n\n\n  \nreturn\n \np\n;\n\n\n}\n\nint\n \n*\nf1\n()\n \n{\n \n// not 'noexcept'\n\n\n  \nint\n \n*\np\n \n=\n \nnew\n \nint\n[\n1000\n];\n \n// no warning: exception can be handled outside\n\n\n                          \n// of this function\n\n\n  \n// ...\n\n\n  \nreturn\n \np\n;\n\n\n}\n\n\n\nint\n \n*\nf2\n()\n \nnoexcept\n \n{\n\n\n  \ntry\n \n{\n\n\n    \nint\n \n*\np\n \n=\n \nnew\n \nint\n[\n1000\n];\n \n// no warning: exception is handled\n\n\n    \n// ...\n\n\n    \nreturn\n \np\n;\n\n\n  \n}\n \ncatch\n \n(\nstd\n::\nbad_alloc\n \n&\n)\n \n{\n\n\n    \n// ...\n\n\n  \n}\n\n\n  \n// ...\n\n\n}\n\n\n\nint\n \n*\nf3\n()\n \nnoexcept\n \n{\n\n\n  \nint\n \n*\np\n \n=\n \nnew\n \n(\nstd\n::\nnothrow\n)\n \nint\n[\n1000\n];\n \n// no warning: \"nothrow\" is used\n\n\n  \n// ...\n\n\n  \nreturn\n \np\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unhandled-exception-at-new.html"
  },
  {
    "name": "bugprone-unhandled-self-assignment",
    "description": "cert-oop54-cpp\n redirects here as an alias for this check. For the CERT alias,\nthe \nWarnOnlyIfThisHasSuspiciousField\n option is set to \nfalse\n.\n\nFinds user-defined copy assignment operators which do not protect the code\nagainst self-assignment either by checking self-assignment explicitly or\nusing the copy-and-swap or the copy-and-move method.\n\nBy default, this check searches only those classes which have any pointer or C\narray field to avoid false positives. In case of a pointer or a C array, itâs\nlikely that self-copy assignment breaks the object if the copy assignment\noperator was not written with care.\n\nSee also:\n\nOOP54-CPP. Gracefully handle self-copy assignment\n\nA copy assignment operator must prevent that self-copy assignment ruins the\nobject state. A typical use case is when the class has a pointer field\nand the copy assignment operator first releases the pointed object and\nthen tries to assign it:\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \ndelete\n \np\n;\n\n\n    \np\n \n=\n \nnew\n \nint\n(\n*\nrhs\n.\np\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nThere are two common C++ patterns to avoid this problem. The first is\nthe self-assignment check:\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \nif\n(\nthis\n \n==\n \n&\nrhs\n)\n\n\n      \nreturn\n \n*\nthis\n;\n\n\n\n    \ndelete\n \np\n;\n\n\n    \np\n \n=\n \nnew\n \nint\n(\n*\nrhs\n.\np\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nThe second one is the copy-and-swap method when we create a temporary copy\n(using the copy constructor) and then swap this temporary object with \nthis\n:\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nvoid\n \nswap\n(\nT\n \n&\nrhs\n)\n \n{\n\n\n    \nusing\n \nstd\n::\nswap\n;\n\n\n    \nswap\n(\np\n,\n \nrhs\n.\np\n);\n\n\n  \n}\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \nT\n(\nrhs\n).\nswap\n(\n*\nthis\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nThere is a third pattern which is less common. Letâs call it the copy-and-move\nmethod when we create a temporary copy (using the copy constructor) and then move\nthis temporary object into \nthis\n (needs a move assignment operator):\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \nT\n \nt\n \n=\n \nrhs\n;\n\n\n    \n*\nthis\n \n=\n \nstd\n::\nmove\n(\nt\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n\n  \nT\n&\n \noperator\n=\n(\nT\n \n&&\nrhs\n)\n \n{\n\n\n    \np\n \n=\n \nrhs\n.\np\n;\n\n\n    \nrhs\n.\np\n \n=\n \nnullptr\n;\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnlyIfThisHasSuspiciousField\nÂ¶\n\n\nWhen \ntrue\n, the check will warn only if the container class of the copy\nassignment operator has any suspicious fields (pointer, C array and C++ smart\npointer).\nThis option is set to \ntrue\n by default.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unhandled-self-assignment.html"
  },
  {
    "name": "bugprone-unintended-char-ostream-output",
    "description": "Finds unintended character output from \nunsigned\n \nchar\n and \nsigned\n \nchar\n to\nan \nostream\n.\n\nNormally, when \nunsigned\n \nchar\n \n(uint8_t)\n or \nsigned\n \nchar\n \n(int8_t)\n is used,\nit is more likely a number than a character. However, when it is passed\ndirectly to \nstd::ostream\nâs \noperator<<\n, the result is the character\noutput instead of the numeric value. This often contradicts the developerâs\nintent to print integer values.\n\nuint8_t\n \nv\n \n=\n \n65\n;\n\n\nstd\n::\ncout\n \n<<\n \nv\n;\n \n// output 'A' instead of '65'\n\nThe check will suggest casting the value to an appropriate type to indicate the\nintent, by default, it will cast to \nunsigned\n \nint\n for \nunsigned\n \nchar\n and\n\nint\n for \nsigned\n \nchar\n.\n\nstd\n::\ncout\n \n<<\n \nstatic_cast\n<\nunsigned\n \nint\n>\n(\nv\n);\n \n// when v is unsigned char\n\n\nstd\n::\ncout\n \n<<\n \nstatic_cast\n<\nint\n>\n(\nv\n);\n \n// when v is signed char\n\nTo avoid lengthy cast statements, add prefix \n+\n to the variable can\nalso suppress warnings because unary expression will promote the value\nto an \nint\n.\n\nstd\n::\ncout\n \n<<\n \n+\nv\n;\n\nOr cast to char to explicitly indicate that output should be a character.\n\nstd\n::\ncout\n \n<<\n \nstatic_cast\n<\nchar\n>\n(\nv\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of type names that will be treated like the \nchar\n\ntype: the check will not report variables declared with with these types or\nexplicit cast expressions to these types. Note that this distinguishes type\naliases from the original type, so specifying e.g. \nunsigned\n \nchar\n here\nwill not suppress reports about \nuint8_t\n even if it is defined as a\n\ntypedef\n alias for \nunsigned\n \nchar\n.\nDefault is \nunsigned char;signed char\n.\n\n\n\n\n\n\n\n\nCastTypeName\nÂ¶\n\n\nWhen \nCastTypeName\n is specified, the fix-it will use \nCastTypeName\n as the\ncast target type. Otherwise, fix-it will automatically infer the type.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unintended-char-ostream-output.html"
  },
  {
    "name": "bugprone-unique-ptr-array-mismatch",
    "description": "Finds initializations of C++ unique pointers to non-array type that are\ninitialized with an array.\n\nIf a pointer \nstd::unique_ptr<T>\n is initialized with a new-expression\n\nnew\n \nT[]\n the memory is not deallocated correctly. A plain \ndelete\n is used\nin this case to deallocate the target memory. Instead a \ndelete[]\n call is\nneeded. A \nstd::unique_ptr<T[]>\n uses the correct delete operator. The check\ndoes not emit warning if an \nunique_ptr\n with user-specified deleter type is\nused.\n\nThe check offers replacement of \nunique_ptr<T>\n to \nunique_ptr<T[]>\n if it\nis used at a single variable declaration (one variable in one statement).\n\nExample:\n\nstd\n::\nunique_ptr\n<\nFoo\n>\n \nx\n(\nnew\n \nFoo\n[\n10\n]);\n \n// -> std::unique_ptr<Foo[]> x(new Foo[10]);\n\n\n//                     ^ warning: unique pointer to non-array is initialized with array\n\n\nstd\n::\nunique_ptr\n<\nFoo\n>\n \nx1\n(\nnew\n \nFoo\n),\n \nx2\n(\nnew\n \nFoo\n[\n10\n]);\n \n// no replacement\n\n\n//                                   ^ warning: unique pointer to non-array is initialized with array\n\n\n\nD\n \nd\n;\n\n\nstd\n::\nunique_ptr\n<\nFoo\n,\n \nD\n>\n \nx3\n(\nnew\n \nFoo\n[\n10\n],\n \nd\n);\n \n// no warning (custom deleter used)\n\n\n\nstruct\n \nS\n \n{\n\n\n  \nstd\n::\nunique_ptr\n<\nFoo\n>\n \nx\n(\nnew\n \nFoo\n[\n10\n]);\n \n// no replacement in this case\n\n\n  \n//                     ^ warning: unique pointer to non-array is initialized with array\n\n\n};\n\nThis check partially covers the CERT C++ Coding Standard rule\n\nMEM51-CPP. Properly deallocate dynamically allocated resources\n\nHowever, only the \nstd::unique_ptr\n case is detected by this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unique-ptr-array-mismatch.html"
  },
  {
    "name": "bugprone-unsafe-functions",
    "description": "Checks for functions that have safer, more secure replacements available, or\nare considered deprecated due to design flaws.\nThe check heavily relies on the functions from the\n\nAnnex K.\n âBounds-checking interfacesâ of C11.\n\nThe check implements the following rules from the CERT C Coding Standard:\n\n\nRecommendation \nMSC24-C. Do not use deprecated or obsolescent functions\n.\n\n\nRule \nMSC33-C. Do not pass invalid data to the asctime() function\n.\n\ncert-msc24-c\n and \ncert-msc33-c\n redirect here as aliases of this check.\n\nUnsafe functions\nÂ¶\n\n\nThe following functions are reported if \nReportDefaultFunctions\n\nis enabled.\n\n\nIf \nAnnex K.\n is available, a replacement from \nAnnex K.\n is suggested for the\nfollowing functions:\n\n\nasctime\n, \nasctime_r\n, \nbsearch\n, \nctime\n, \nfopen\n, \nfprintf\n,\n\nfreopen\n, \nfscanf\n, \nfwprintf\n, \nfwscanf\n, \ngetenv\n, \ngets\n,\n\ngmtime\n, \nlocaltime\n, \nmbsrtowcs\n, \nmbstowcs\n, \nmemcpy\n,\n\nmemmove\n, \nmemset\n, \nprintf\n, \nqsort\n, \nscanf\n,  \nsnprintf\n,\n\nsprintf\n,  \nsscanf\n, \nstrcat\n, \nstrcpy\n, \nstrerror\n, \nstrlen\n,\n\nstrncat\n, \nstrncpy\n, \nstrtok\n, \nswprintf\n, \nswscanf\n, \nvfprintf\n,\n\nvfscanf\n, \nvfwprintf\n, \nvfwscanf\n, \nvprintf\n, \nvscanf\n,\n\nvsnprintf\n, \nvsprintf\n, \nvsscanf\n, \nvswprintf\n, \nvswscanf\n,\n\nvwprintf\n, \nvwscanf\n, \nwcrtomb\n, \nwcscat\n, \nwcscpy\n,\n\nwcslen\n, \nwcsncat\n, \nwcsncpy\n, \nwcsrtombs\n, \nwcstok\n, \nwcstombs\n,\n\nwctomb\n, \nwmemcpy\n, \nwmemmove\n, \nwprintf\n, \nwscanf\n.\n\n\nIf \nAnnex K.\n is not available, replacements are suggested only for the\nfollowing functions from the previous list:\n\n\n\n\n\n\nasctime\n, \nasctime_r\n, suggested replacement: \nstrftime\n\n\ngets\n, suggested replacement: \nfgets\n\n\n\n\n\n\nThe following functions are always checked, regardless of \nAnnex K\n\navailability:\n\n\n\n\n\n\nrewind\n, suggested replacement: \nfseek\n\n\nsetbuf\n, suggested replacement: \nsetvbuf\n\n\nstd::get_temporary_buffer\n, suggested replacement: âplainâ allocation\nwith \noperator\n \nnew[]\n\n\n\n\n\n\nIf \nReportMoreUnsafeFunctions\n is enabled,\nthe following functions are also checked:\n\n\n\n\n\n\nbcmp\n, suggested replacement: \nmemcmp\n\n\nbcopy\n, suggested replacement: \nmemcpy_s\n if \nAnnex K\n is available,\nor \nmemcpy\n\n\nbzero\n, suggested replacement: \nmemset_s\n if \nAnnex K\n is available,\nor \nmemset\n\n\ngetpw\n, suggested replacement: \ngetpwuid\n\n\nvfork\n, suggested replacement: \nposix_spawn\n\n\n\n\n\n\nAlthough mentioned in the associated CERT rules, the following functions are\n\nignored\n by the check:\n\n\natof\n, \natoi\n, \natol\n, \natoll\n, \ntmpfile\n.\n\n\nThe availability of \nAnnex K\n is determined based on the following macros:\n\n\n\n\n\n\n__STDC_LIB_EXT1__\n: feature macro, which indicates the presence of\n\nAnnex K. âBounds-checking interfacesâ\n in the library implementation\n\n\n__STDC_WANT_LIB_EXT1__\n: user-defined macro, which indicates that the\nuser requests the functions from \nAnnex K.\n to be defined.\n\n\n\n\n\n\nBoth macros have to be defined to suggest replacement functions from \nAnnex K.\n\n\n__STDC_LIB_EXT1__\n is defined by the library implementation, and\n\n__STDC_WANT_LIB_EXT1__\n must be defined to \n1\n by the user \nbefore\n\nincluding any system headers.\n\nCustom functions\nÂ¶\n\n\nThe option \nCustomFunctions\n allows the user to define custom functions\nto be checked. The format is the following, without newlines:\n\n\nbugprone\n-\nunsafe\n-\nfunctions\n.\nCustomFunctions\n=\n\"\n\n  \nfunctionRegex1\n[,\n \nreplacement1\n[,\n \nreason1\n]];\n\n  \nfunctionRegex2\n[,\n \nreplacement2\n[,\n \nreason2\n]];\n\n  \n...\n\n\n\"\n\n\n\n\n\n\nThe functions are matched using POSIX extended regular expressions.\n\n(Note: The regular expressions do not support negative\n \n(?!)\n \nmatches.)\n\n\nThe \nreason\n is optional and is used to provide additional information about\nthe reasoning behind the replacement. The default reason is\n\nis marked as unsafe\n.\n\n\nIf \nreplacement\n is empty, the default text \nit should not be used\n will be\nshown instead of the suggestion for a replacement.\n\n\nIf the \nreason\n starts with the character \n>\n, the reason becomes fully\ncustom. The default suffix is disabled even if a \nreplacement\n is present,\nand only the reason message is shown after the matched function, to allow\nbetter control over the suggestions. (The starting \n>\n and whitespace\ndirectly after it are trimmed from the message.)\n\n\nAs an example, the following configuration matches only the function\n\noriginal\n in the default namespace. A similar diagnostic can also be printed\nusing a fully custom reason.\n\n\n// bugprone-unsafe-functions.CustomFunctions:\n\n\n//   ^original$, replacement, is deprecated;\n\n\n// Using the fully custom message syntax:\n\n\n//   ^suspicious$,,> should be avoided if possible.\n\n\noriginal\n();\n \n// warning: function 'original' is deprecated; 'replacement' should be used instead.\n\n\nsuspicious\n();\n \n// warning: function 'suspicious' should be avoided if possible.\n\n\n::\nstd\n::\noriginal\n();\n \n// no-warning\n\n\noriginal_function\n();\n \n// no-warning\n\n\n\n\n\n\nIf the regular expression contains the character \n:\n, it is matched against\nthe qualified name (i.e. \nstd::original\n), otherwise the regex is matched\nagainst the unqualified name (\noriginal\n). If the regular expression starts\nwith \n::\n (or \n^::\n), it is matched against the fully qualified name\n(\n::std::original\n).\n\n\nOne of the use cases for fully custom messages is suggesting compiler options\nand warning flags:\n\n\n// bugprone-unsafe-functions.CustomFunctions:\n\n\n//   ^memcpy$,,>is recommended to have compiler hardening using '_FORTIFY_SOURCE';\n\n\n//   ^printf$,,>is recommended to have the '-Werror=format-security' compiler warning flag;\n\n\n\nmemcpy\n(\ndest\n,\n \nsrc\n,\n \n999'999\n);\n \n// warning: function 'memcpy' is recommended to have compiler hardening using '_FORTIFY_SOURCE'\n\n\nprintf\n(\nraw_str\n);\n \n// warning: function 'printf' is recommended to have the '-Werror=format-security' compiler warning flag\n\n\n\n\n\n\n\n\nNote\n\n\nFully qualified names can contain template parameters on certain C++ classes,\nbut not on C++ functions. Type aliases are resolved before matching.\n\n\nAs an example, the member function \nopen\n in the class \nstd::ifstream\n\nhas a fully qualified name of \n::std::basic_ifstream<char>::open\n.\n\n\nThe example could also be matched with the regex\n\n::std::basic_ifstream<[^>]*>::open\n, which matches all potential template\nparameters, but does not match nested template classes.\n\nOptions\nÂ¶\n\n\n\n\n\n\nReportMoreUnsafeFunctions\nÂ¶\n\n\nWhen \ntrue\n, additional functions from widely used APIs (such as POSIX) are\nadded to the list of reported functions.\nSee the main documentation of the check for the complete list as to what\nthis option enables.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nReportDefaultFunctions\nÂ¶\n\n\nWhen \ntrue\n, the check reports the default set of functions.\nConsider changing the setting to false if you only want to see custom\nfunctions matched via \ncustom functions\n.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nCustomFunctions\nÂ¶\n\n\nA semicolon-separated list of custom functions to be matched. A matched\nfunction contains a regular expression, an optional name of the replacement\nfunction, and an optional reason, separated by comma. For more information,\nsee \nCustom functions\n.\n\nExamples\nÂ¶\n\n\n#ifndef __STDC_LIB_EXT1__\n\n\n#error \"Annex K is not supported by the current standard library implementation.\"\n\n\n#endif\n\n\n\n#define __STDC_WANT_LIB_EXT1__ 1\n\n\n\n#include\n \n<string.h>\n // Defines functions from Annex K.\n\n\n#include\n \n<stdio.h>\n\n\n\nenum\n \n{\n \nBUFSIZE\n \n=\n \n32\n \n};\n\n\n\nvoid\n \nUnsafe\n(\nconst\n \nchar\n \n*\nMsg\n)\n \n{\n\n\n  \nstatic\n \nconst\n \nchar\n \nPrefix\n[]\n \n=\n \n\"Error: \"\n;\n\n\n  \nstatic\n \nconst\n \nchar\n \nSuffix\n[]\n \n=\n \n\"\n\\n\n\"\n;\n\n\n  \nchar\n \nBuf\n[\nBUFSIZE\n]\n \n=\n \n{\n0\n};\n\n\n\n  \nstrcpy\n(\nBuf\n,\n \nPrefix\n);\n \n// warning: function 'strcpy' is not bounds-checking; 'strcpy_s' should be used instead.\n\n\n  \nstrcat\n(\nBuf\n,\n \nMsg\n);\n    \n// warning: function 'strcat' is not bounds-checking; 'strcat_s' should be used instead.\n\n\n  \nstrcat\n(\nBuf\n,\n \nSuffix\n);\n \n// warning: function 'strcat' is not bounds-checking; 'strcat_s' should be used instead.\n\n\n  \nif\n \n(\nfputs\n(\nbuf\n,\n \nstderr\n)\n \n<\n \n0\n)\n \n{\n\n\n    \n// error handling\n\n\n    \nreturn\n;\n\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nUsingSafeFunctions\n(\nconst\n \nchar\n \n*\nMsg\n)\n \n{\n\n\n  \nstatic\n \nconst\n \nchar\n \nPrefix\n[]\n \n=\n \n\"Error: \"\n;\n\n\n  \nstatic\n \nconst\n \nchar\n \nSuffix\n[]\n \n=\n \n\"\n\\n\n\"\n;\n\n\n  \nchar\n \nBuf\n[\nBUFSIZE\n]\n \n=\n \n{\n0\n};\n\n\n\n  \nif\n \n(\nstrcpy_s\n(\nBuf\n,\n \nBUFSIZE\n,\n \nPrefix\n)\n \n!=\n \n0\n)\n \n{\n\n\n    \n// error handling\n\n\n    \nreturn\n;\n\n\n  \n}\n\n\n\n  \nif\n \n(\nstrcat_s\n(\nBuf\n,\n \nBUFSIZE\n,\n \nMsg\n)\n \n!=\n \n0\n)\n \n{\n\n\n    \n// error handling\n\n\n    \nreturn\n;\n\n\n  \n}\n\n\n\n  \nif\n \n(\nstrcat_s\n(\nBuf\n,\n \nBUFSIZE\n,\n \nSuffix\n)\n \n!=\n \n0\n)\n \n{\n\n\n    \n// error handling\n\n\n    \nreturn\n;\n\n\n  \n}\n\n\n\n  \nif\n \n(\nfputs\n(\nBuf\n,\n \nstderr\n)\n \n<\n \n0\n)\n \n{\n\n\n    \n// error handling\n\n\n    \nreturn\n;\n\n\n  \n}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unsafe-functions.html"
  },
  {
    "name": "bugprone-unused-local-non-trivial-variable",
    "description": "Warns when a local non trivial variable is unused within a function.\nThe following types of variables are excluded from this check:\n\ntrivial and trivially copyable\n\n\nreferences and pointers\n\n\nexception variables in catch clauses\n\n\nstatic or thread local\n\n\nstructured bindings\n\n\nvariables with \n[[maybe_unused]]\n attribute\n\n\nname-independent variables\n\nThis check can be configured to warn on all non-trivial variables by setting\n\nIncludeTypes\n to \n.*\n, and excluding specific types using \nExcludeTypes\n.\n\nIn the this example, \nmy_lock\n would generate a warning that it is unused.\n\nstd\n::\nmutex\n \nmy_lock\n;\n\n\n// my_lock local variable is never used\n\nIn the next example, \nfuture2\n would generate a warning that it is unused.\n\nstd\n::\nfuture\n<\nMyObject\n>\n \nfuture1\n;\n\n\nstd\n::\nfuture\n<\nMyObject\n>\n \nfuture2\n;\n\n\n// ...\n\n\nMyObject\n \nfoo\n \n=\n \nfuture1\n.\nget\n();\n\n\n// future2 is not used.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeTypes\nÂ¶\n\n\nSemicolon-separated list of regular expressions matching types of variables\nto check. By default the following types are checked:\n\n\n\n\n::std::.*mutex\n\n\n::std::future\n\n\n::std::basic_string\n\n\n::std::basic_regex\n\n\n::std::basic_istringstream\n\n\n::std::basic_stringstream\n\n\n::std::bitset\n\n\n::std::filesystem::path\n\n\n\n\n\n\n\n\n\n\nExcludeTypes\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching types that are\nexcluded from the \nIncludeTypes\n matches. By default it is an empty list.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unused-local-non-trivial-variable.html"
  },
  {
    "name": "bugprone-unused-raii",
    "description": "Finds temporaries that look like RAII objects.\n\nThe canonical example for this is a scoped lock.\n\n{\n\n\n  \nscoped_lock\n(\n&\nglobal_mutex\n);\n\n\n  \ncritical_section\n();\n\n\n}\n\nThe destructor of the scoped_lock is called before the \ncritical_section\n is\nentered, leaving it unprotected.\n\nWe apply a number of heuristics to reduce the false positive count of this\ncheck:\n\nIgnore code expanded from macros. Testing frameworks make heavy use of this.\n\n\nIgnore types with trivial destructors. They are very unlikely to be RAII\nobjects and thereâs no difference when they are deleted.\n\n\nIgnore objects at the end of a compound statement (doesnât change behavior).\n\n\nIgnore objects returned from a call.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unused-raii.html"
  },
  {
    "name": "bugprone-unused-return-value",
    "description": "Warns on unused function return values. The checked functions can be\nconfigured.\n\nOperator overloading with assignment semantics are ignored.\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckedFunctions\nÂ¶\n\n\nSemicolon-separated list of functions to check.\nThis parameter supports regexp. The function is checked if the name\nand scope matches, with any arguments.\nBy default the following functions are checked:\n\n^::std::async$,\n \n^::std::launder$,\n \n^::std::remove$,\n \n^::std::remove_if$,\n\n\n^::std::unique$,\n \n^::std::unique_ptr::release$,\n \n^::std::basic_string::empty$,\n\n\n^::std::vector::empty$,\n \n^::std::back_inserter$,\n \n^::std::distance$,\n\n\n^::std::find$,\n \n^::std::find_if$,\n \n^::std::inserter$,\n \n^::std::lower_bound$,\n\n\n^::std::make_pair$,\n \n^::std::map::count$,\n \n^::std::map::find$,\n\n\n^::std::map::lower_bound$,\n \n^::std::multimap::equal_range$,\n\n\n^::std::multimap::upper_bound$,\n \n^::std::set::count$,\n \n^::std::set::find$,\n\n\n^::std::setfill$,\n \n^::std::setprecision$,\n \n^::std::setw$,\n \n^::std::upper_bound$,\n\n\n^::std::vector::at$,\n \n^::bsearch$,\n \n^::ferror$,\n \n^::feof$,\n \n^::isalnum$,\n\n\n^::isalpha$,\n \n^::isblank$,\n \n^::iscntrl$,\n \n^::isdigit$,\n \n^::isgraph$,\n \n^::islower$,\n\n\n^::isprint$,\n \n^::ispunct$,\n \n^::isspace$,\n \n^::isupper$,\n \n^::iswalnum$,\n\n\n^::iswprint$,\n \n^::iswspace$,\n \n^::isxdigit$,\n \n^::memchr$,\n \n^::memcmp$,\n \n^::strcmp$,\n\n\n^::strcoll$,\n \n^::strncmp$,\n \n^::strpbrk$,\n \n^::strrchr$,\n \n^::strspn$,\n \n^::strstr$,\n\n\n^::wcscmp$,\n \n^::access$,\n \n^::bind$,\n \n^::connect$,\n \n^::difftime$,\n \n^::dlsym$,\n\n\n^::fnmatch$,\n \n^::getaddrinfo$,\n \n^::getopt$,\n \n^::htonl$,\n \n^::htons$,\n\n\n^::iconv_open$,\n \n^::inet_addr$,\n \nisascii$,\n \nisatty$,\n \n^::mmap$,\n \n^::newlocale$,\n\n\n^::openat$,\n \n^::pathconf$,\n \n^::pthread_equal$,\n \n^::pthread_getspecific$,\n\n\n^::pthread_mutex_trylock$,\n \n^::readdir$,\n \n^::readlink$,\n \n^::recvmsg$,\n\n\n^::regexec$,\n \n^::scandir$,\n \n^::semget$,\n \n^::setjmp$,\n \n^::shm_open$,\n \n^::shmget$,\n\n\n^::sigismember$,\n \n^::strcasecmp$,\n \n^::strsignal$,\n \n^::ttyname$\n\n\n\n\nstd::async()\n. Not using the return value makes the call synchronous.\n\n\nstd::launder()\n. Not using the return value usually means that the\nfunction interface was misunderstood by the programmer. Only the returned\npointer is âlaunderedâ, not the argument.\n\n\nstd::remove()\n, \nstd::remove_if()\n and \nstd::unique()\n. The returned\niterator indicates the boundary between elements to keep and elements to be\nremoved. Not using the return value means that the information about which\nelements to remove is lost.\n\n\nstd::unique_ptr::release()\n. Not using the return value can lead to\nresource leaks if the same pointer isnât stored anywhere else. Often,\nignoring the \nrelease()\n return value indicates that the programmer\nconfused the function with \nreset()\n.\n\n\nstd::basic_string::empty()\n and \nstd::vector::empty()\n. Not using the\nreturn value often indicates that the programmer confused the function with\n\nclear()\n.\n\n\n\n\n\n\n\n\n\n\nCheckedReturnTypes\nÂ¶\n\n\nSemicolon-separated list of function return types to check.\nBy default the following function return types are checked:\n\n^::std::error_code$\n, \n^::std::error_condition$\n, \n^::std::errc$\n,\n\n^::std::expected$\n, \n^::boost::system::error_code$\n\n\n\n\n\n\n\n\nAllowCastToVoid\nÂ¶\n\n\nControls whether casting return values to \nvoid\n is permitted. Default: \nfalse\n.\n\n\n\n\ncert-err33-c\n is an alias of this check that checks a\nfixed and large set of standard library functions.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unused-return-value.html"
  },
  {
    "name": "bugprone-use-after-move",
    "description": "Warns if an object is used after it has been moved, for example:\n\nstd\n::\nstring\n \nstr\n \n=\n \n\"Hello, world!\n\\n\n\"\n;\n\n\nstd\n::\nvector\n<\nstd\n::\nstring\n>\n \nmessages\n;\n\n\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\nstd\n::\ncout\n \n<<\n \nstr\n;\n\nThe last line will trigger a warning that \nstr\n is used after it has been\nmoved.\n\nThe check does not trigger a warning if the object is reinitialized after the\nmove and before the use. For example, no warning will be output for this code:\n\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\nstr\n \n=\n \n\"Greetings, stranger!\n\\n\n\"\n;\n\n\nstd\n::\ncout\n \n<<\n \nstr\n;\n\nSubsections below explain more precisely what exactly the check considers to be\na move, use, and reinitialization.\n\nThe check takes control flow into account. A warning is only emitted if the use\ncan be reached from the move. This means that the following code does not\nproduce a warning:\n\nif\n \n(\ncondition\n)\n \n{\n\n\n  \nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n}\n \nelse\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \nstr\n;\n\n\n}\n\nOn the other hand, the following code does produce a warning:\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \n++\ni\n)\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \nstr\n;\n\n\n  \nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n}\n\n(The use-after-move happens on the second iteration of the loop.)\n\nIn some cases, the check may not be able to detect that two branches are\nmutually exclusive. For example (assuming that \ni\n is an int):\n\nif\n \n(\ni\n \n==\n \n1\n)\n \n{\n\n\n  \nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n}\n\n\nif\n \n(\ni\n \n==\n \n2\n)\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \nstr\n;\n\n\n}\n\nIn this case, the check will erroneously produce a warning, even though it is\nnot possible for both the move and the use to be executed. More formally, the\nanalysis is \nflow-sensitive but not path-sensitive\n.\n\nSilencing erroneous warnings\nÂ¶\n\n\nAn erroneous warning can be silenced by reinitializing the object after the\nmove:\n\n\nif\n \n(\ni\n \n==\n \n1\n)\n \n{\n\n\n  \nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n  \nstr\n \n=\n \n\"\"\n;\n\n\n}\n\n\nif\n \n(\ni\n \n==\n \n2\n)\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \nstr\n;\n\n\n}\n\n\n\n\n\n\nIf you want to avoid the overhead of actually reinitializing the object,\nyou can create a dummy function that causes the check to assume the object\nwas reinitialized:\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nvoid\n \nIS_INITIALIZED\n(\nT\n&\n)\n \n{}\n\n\n\n\n\n\nYou can use this as follows:\n\n\nif\n \n(\ni\n \n==\n \n1\n)\n \n{\n\n\n  \nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n}\n\n\nif\n \n(\ni\n \n==\n \n2\n)\n \n{\n\n\n  \nIS_INITIALIZED\n(\nstr\n);\n\n\n  \nstd\n::\ncout\n \n<<\n \nstr\n;\n\n\n}\n\n\n\n\n\n\nThe check will not output a warning in this case because passing the object\nto a function as a non-const pointer or reference counts as a reinitialization\n(see section \nReinitialization\n below).\n\nUnsequenced moves, uses, and reinitializations\nÂ¶\n\n\nIn many cases, C++ does not make any guarantees about the order in which\nsub-expressions of a statement are evaluated. This means that in code like the\nfollowing, it is not guaranteed whether the use will happen before or after the\nmove:\n\n\nvoid\n \nf\n(\nint\n \ni\n,\n \nstd\n::\nvector\n<\nint\n>\n \nv\n);\n\n\nstd\n::\nvector\n<\nint\n>\n \nv\n \n=\n \n{\n \n1\n,\n \n2\n,\n \n3\n \n};\n\n\nf\n(\nv\n[\n1\n],\n \nstd\n::\nmove\n(\nv\n));\n\n\n\n\n\n\nIn this kind of situation, the check will note that the use and move are\nunsequenced.\n\n\nThe check will also take sequencing rules into account when reinitializations\noccur in the same statement as moves or uses. A reinitialization is only\nconsidered to reinitialize a variable if it is guaranteed to be evaluated after\nthe move and before the use.\n\nMove\nÂ¶\n\n\nThe check currently only considers calls of \nstd::move\n on local variables or\nfunction parameters. It does not check moves of member variables or global\nvariables.\n\n\nAny call of \nstd::move\n on a variable is considered to cause a move of that\nvariable, even if the result of \nstd::move\n is not passed to an rvalue\nreference parameter.\n\n\nThis means that the check will flag a use-after-move even on a type that does\nnot define a move constructor or move assignment operator. This is intentional.\nDevelopers may use \nstd::move\n on such a type in the expectation that the\ntype will add move semantics in the future. If such a \nstd::move\n has the\npotential to cause a use-after-move, we want to warn about it even if the type\ndoes not implement move semantics yet.\n\n\nFurthermore, if the result of \nstd::move\n \nis\n passed to an rvalue reference\nparameter, this will always be considered to cause a move, even if the function\nthat consumes this parameter does not move from it, or if it does so only\nconditionally. For example, in the following situation, the check will assume\nthat a move always takes place:\n\n\nstd\n::\nvector\n<\nstd\n::\nstring\n>\n \nmessages\n;\n\n\nvoid\n \nf\n(\nstd\n::\nstring\n \n&&\nstr\n)\n \n{\n\n\n  \n// Only remember the message if it isn't empty.\n\n\n  \nif\n \n(\n!\nstr\n.\nempty\n())\n \n{\n\n\n    \nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n  \n}\n\n\n}\n\n\nstd\n::\nstring\n \nstr\n \n=\n \n\"\"\n;\n\n\nf\n(\nstd\n::\nmove\n(\nstr\n));\n\n\n\n\n\n\nThe check will assume that the last line causes a move, even though, in this\nparticular case, it does not. Again, this is intentional.\n\n\nThere is one special case: A call to \nstd::move\n inside a \ntry_emplace\n\ncall is conservatively assumed not to move. This is to avoid spurious warnings,\nas the check has no way to reason about the \nbool\n returned by \ntry_emplace\n.\n\n\nWhen analyzing the order in which moves, uses and reinitializations happen (see\nsection \nUnsequenced moves, uses, and reinitializations\n), the move is assumed\nto occur in whichever function the result of the \nstd::move\n is passed to.\n\n\nThe check also handles perfect-forwarding with \nstd::forward\n so the\nfollowing code will also trigger a use-after-move warning.\n\n\nvoid\n \nconsume\n(\nint\n);\n\n\n\nvoid\n \nf\n(\nint\n&&\n \ni\n)\n \n{\n\n\n  \nconsume\n(\nstd\n::\nforward\n<\nint\n>\n(\ni\n));\n\n\n  \nconsume\n(\nstd\n::\nforward\n<\nint\n>\n(\ni\n));\n \n// use-after-move\n\n\n}\n\nUse\nÂ¶\n\n\nAny occurrence of the moved variable that is not a reinitialization (see below)\nis considered to be a use.\n\n\nAn exception to this are objects of type \nstd::unique_ptr\n,\n\nstd::shared_ptr\n, \nstd::weak_ptr\n, \nstd::optional\n, and \nstd::any\n.\nAn exception to this are objects of type \nstd::unique_ptr\n,\n\nstd::shared_ptr\n, \nstd::weak_ptr\n, \nstd::optional\n, and \nstd::any\n,\nwhich can be reinitialized via \nreset\n. For smart pointers specifically, the\nmoved-from objects have a well-defined state of being \nnullptr``s,\n \nand\n \nonly\n\n\n``operator*\n, \noperator->\n and \noperator[]\n are considered bad accesses as\nthey would be dereferencing a \nnullptr\n.\n\n\nIf multiple uses occur after a move, only the first of these is flagged.\n\nReinitialization\nÂ¶\n\n\nThe check considers a variable to be reinitialized in the following cases:\n\n\n\n\n\n\nThe variable occurs on the left-hand side of an assignment.\n\n\nThe variable is passed to a function as a non-const pointer or non-const\nlvalue reference. (It is assumed that the variable may be an out-parameter\nfor the function.)\n\n\nclear()\n or \nassign()\n is called on the variable and the variable is\nof     one of the standard container types \nbasic_string\n, \nvector\n,\n\ndeque\n, \nforward_list\n, \nlist\n, \nset\n, \nmap\n, \nmultiset\n,\n\nmultimap\n, \nunordered_set\n, \nunordered_map\n, \nunordered_multiset\n,\n\nunordered_multimap\n.\n\n\nreset()\n is called on the variable and the variable is of type\n\nstd::unique_ptr\n, \nstd::shared_ptr\n, \nstd::weak_ptr\n,\n\nstd::optional\n, or \nstd::any\n.\n\n\nA member function marked with the \n[[clang::reinitializes]]\n attribute is\ncalled on the variable.\n\n\n\n\n\n\nIf the variable in question is a struct and an individual member variable of\nthat struct is written to, the check does not consider this to be a\nreinitialization â even if, eventually, all member variables of the struct are\nwritten to. For example:\n\n\nstruct\n \nS\n \n{\n\n\n  \nstd\n::\nstring\n \nstr\n;\n\n\n  \nint\n \ni\n;\n\n\n};\n\n\nS\n \ns\n \n=\n \n{\n \n\"Hello, world!\n\\n\n\"\n,\n \n42\n \n};\n\n\nS\n \ns_other\n \n=\n \nstd\n::\nmove\n(\ns\n);\n\n\ns\n.\nstr\n \n=\n \n\"Lorem ipsum\"\n;\n\n\ns\n.\ni\n \n=\n \n99\n;\n\n\n\n\n\n\nThe check will not consider \ns\n to be reinitialized after the last line;\ninstead, the line that assigns to \ns.str\n will be flagged as a use-after-move.\nThis is intentional as this pattern of reinitializing a struct is error-prone.\nFor example, if an additional member variable is added to \nS\n, it is easy to\nforget to add the reinitialization for this additional member. Instead, it is\nsafer to assign to the entire struct in one go, and this will also avoid the\nuse-after-move warning.\n\nOptions\nÂ¶\n\n\n\n\n\n\nInvalidationFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching names of functions\nthat cause their first arguments to be invalidated (e.g., closing a handle).\nFor member functions, the first argument is considered to be the implicit\nobject argument (\nthis\n). Default value is an empty string.\n\n\n\n\n\n\n\n\nReinitializationFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching names of functions\nthat reinitialize the object. For member functions, the implicit object\nargument (\n*this\n) is considered to be reinitialized. For non-member or\nstatic member functions, the first argument is considered to be\nreinitialized. Default value is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/use-after-move.html"
  },
  {
    "name": "bugprone-virtual-near-miss",
    "description": "Warn if a function is a near miss (i.e. the name is very similar and\nthe function signature is the same) to a virtual function from a base\nclass.\n\nExample:\n\nstruct\n \nBase\n \n{\n\n\n  \nvirtual\n \nvoid\n \nfunc\n();\n\n\n};\n\n\n\nstruct\n \nDerived\n \n:\n \nBase\n \n{\n\n\n  \nvirtual\n \nvoid\n \nfunk\n();\n\n\n  \n// warning: 'Derived::funk' has a similar name and the same signature as virtual method 'Base::func'; did you mean to override it?\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/virtual-near-miss.html"
  },
  {
    "name": "cert-err33-c",
    "description": "Warns on unused function return values. Many of the standard library functions\nreturn a value that indicates if the call was successful. Ignoring the returned\nvalue can cause unexpected behavior if an error has occurred. The following\nfunctions are checked:\n\naligned_alloc()\n\n\nasctime_s()\n\n\nat_quick_exit()\n\n\natexit()\n\n\nbsearch()\n\n\nbsearch_s()\n\n\nbtowc()\n\n\nc16rtomb()\n\n\nc32rtomb()\n\n\ncalloc()\n\n\nclock()\n\n\ncnd_broadcast()\n\n\ncnd_init()\n\n\ncnd_signal()\n\n\ncnd_timedwait()\n\n\ncnd_wait()\n\n\nctime_s()\n\n\nfclose()\n\n\nfflush()\n\n\nfgetc()\n\n\nfgetpos()\n\n\nfgets()\n\n\nfgetwc()\n\n\nfopen()\n\n\nfopen_s()\n\n\nfprintf()\n\n\nfprintf_s()\n\n\nfputc()\n\n\nfputs()\n\n\nfputwc()\n\n\nfputws()\n\n\nfread()\n\n\nfreopen()\n\n\nfreopen_s()\n\n\nfscanf()\n\n\nfscanf_s()\n\n\nfseek()\n\n\nfsetpos()\n\n\nftell()\n\n\nfwprintf()\n\n\nfwprintf_s()\n\n\nfwrite()\n\n\nfwscanf()\n\n\nfwscanf_s()\n\n\ngetc()\n\n\ngetchar()\n\n\ngetenv()\n\n\ngetenv_s()\n\n\ngets_s()\n\n\ngetwc()\n\n\ngetwchar()\n\n\ngmtime()\n\n\ngmtime_s()\n\n\nlocaltime()\n\n\nlocaltime_s()\n\n\nmalloc()\n\n\nmbrtoc16()\n\n\nmbrtoc32()\n\n\nmbsrtowcs()\n\n\nmbsrtowcs_s()\n\n\nmbstowcs()\n\n\nmbstowcs_s()\n\n\nmemchr()\n\n\nmktime()\n\n\nmtx_init()\n\n\nmtx_lock()\n\n\nmtx_timedlock()\n\n\nmtx_trylock()\n\n\nmtx_unlock()\n\n\nprintf_s()\n\n\nputc()\n\n\nputwc()\n\n\nraise()\n\n\nrealloc()\n\n\nremove()\n\n\nrename()\n\n\nsetlocale()\n\n\nsetvbuf()\n\n\nscanf()\n\n\nscanf_s()\n\n\nsignal()\n\n\nsnprintf()\n\n\nsnprintf_s()\n\n\nsprintf()\n\n\nsprintf_s()\n\n\nsscanf()\n\n\nsscanf_s()\n\n\nstrchr()\n\n\nstrerror_s()\n\n\nstrftime()\n\n\nstrpbrk()\n\n\nstrrchr()\n\n\nstrstr()\n\n\nstrtod()\n\n\nstrtof()\n\n\nstrtoimax()\n\n\nstrtok()\n\n\nstrtok_s()\n\n\nstrtol()\n\n\nstrtold()\n\n\nstrtoll()\n\n\nstrtoumax()\n\n\nstrtoul()\n\n\nstrtoull()\n\n\nstrxfrm()\n\n\nswprintf()\n\n\nswprintf_s()\n\n\nswscanf()\n\n\nswscanf_s()\n\n\nthrd_create()\n\n\nthrd_detach()\n\n\nthrd_join()\n\n\nthrd_sleep()\n\n\ntime()\n\n\ntimespec_get()\n\n\ntmpfile()\n\n\ntmpfile_s()\n\n\ntmpnam()\n\n\ntmpnam_s()\n\n\ntss_create()\n\n\ntss_get()\n\n\ntss_set()\n\n\nungetc()\n\n\nungetwc()\n\n\nvfprintf()\n\n\nvfprintf_s()\n\n\nvfscanf()\n\n\nvfscanf_s()\n\n\nvfwprintf()\n\n\nvfwprintf_s()\n\n\nvfwscanf()\n\n\nvfwscanf_s()\n\n\nvprintf_s()\n\n\nvscanf()\n\n\nvscanf_s()\n\n\nvsnprintf()\n\n\nvsnprintf_s()\n\n\nvsprintf()\n\n\nvsprintf_s()\n\n\nvsscanf()\n\n\nvsscanf_s()\n\n\nvswprintf()\n\n\nvswprintf_s()\n\n\nvswscanf()\n\n\nvswscanf_s()\n\n\nvwprintf_s()\n\n\nvwscanf()\n\n\nvwscanf_s()\n\n\nwcrtomb()\n\n\nwcschr()\n\n\nwcsftime()\n\n\nwcspbrk()\n\n\nwcsrchr()\n\n\nwcsrtombs()\n\n\nwcsrtombs_s()\n\n\nwcsstr()\n\n\nwcstod()\n\n\nwcstof()\n\n\nwcstoimax()\n\n\nwcstok()\n\n\nwcstok_s()\n\n\nwcstol()\n\n\nwcstold()\n\n\nwcstoll()\n\n\nwcstombs()\n\n\nwcstombs_s()\n\n\nwcstoumax()\n\n\nwcstoul()\n\n\nwcstoull()\n\n\nwcsxfrm()\n\n\nwctob()\n\n\nwctrans()\n\n\nwctype()\n\n\nwmemchr()\n\n\nwprintf_s()\n\n\nwscanf()\n\n\nwscanf_s()\n\nThis check is an alias of check \nbugprone-unused-return-value\n with a fixed set of functions.\n\nSuppressing issues by casting to \nvoid\n is enabled by default and can be\ndisabled by setting \nAllowCastToVoid\n option to \nfalse\n.\n\nThe check corresponds to a part of CERT C Coding Standard rule \nERR33-C.\nDetect and handle standard library errors\n.\nThe list of checked functions is taken from the rule, with following exception:\n\nThe check can not differentiate if a function is called with \nNULL\n\nargument. Therefore the following functions are not checked:\n\nmblen\n, \nmbrlen\n, \nmbrtowc\n, \nmbtowc\n, \nwctomb\n, \nwctomb_s",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err33-c.html"
  },
  {
    "name": "cert-err60-cpp",
    "description": "The \ncert-err60-cpp\n check is an alias, please see\n\nbugprone-exception-copy-constructor-throws\n\nfor more information.\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nERR60-CPP. Exception objects must be nothrow copy constructible\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err60-cpp.html"
  },
  {
    "name": "cert-flp30-c",
    "description": "The \ncert-flp30-c\n check is an alias, please see\n\nbugprone-float-loop-counter\n\nfor more information\n\nThis check corresponds to the CERT C Coding Standard rule\n\nFLP30-C. Do not use floating-point variables as loop counters\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/flp30-c.html"
  },
  {
    "name": "cert-msc50-cpp",
    "description": "The \ncert-msc50-cpp\n check is an alias, please see\n\nmisc-predictable-rand\n for more information.\n\nThis check corresponds to the CERT C Coding Standard rule\n\nMSC50-CPP. Do not use std::rand() for generating pseudorandom numbers\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/msc50-cpp.html"
  },
  {
    "name": "cert-oop58-cpp",
    "description": "The \ncert-oop58-cpp\n check is an alias, please see\n\nbugprone-copy-constructor-mutates-argument\n\nfor more information.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/oop58-cpp.html"
  },
  {
    "name": "concurrency-mt-unsafe",
    "description": "Checks for some thread-unsafe functions against a black list of\nknown-to-be-unsafe functions. Usually they access static variables without\nsynchronization (e.g. gmtime(3)) or utilize signals in a racy way.\nThe set of functions to check is specified with the \nFunctionSet\n option.\n\nNote that using some thread-unsafe functions may be still valid in\nconcurrent programming if only a single thread is used (e.g. setenv(3)),\nhowever, some functions may track a state in global variables which\nwould be clobbered by subsequent (non-parallel, but concurrent) calls to\na related function. E.g. the following code suffers from unprotected\naccesses to a global state:\n\n// getnetent(3) maintains global state with DB connection, etc.\n\n\n// If a concurrent green thread calls getnetent(3), the global state is corrupted.\n\n\nnetent\n \n=\n \ngetnetent\n();\n\n\nyield\n();\n\n\nnetent\n \n=\n \ngetnetent\n();\n\nExamples:\n\ntm\n \n=\n \ngmtime\n(\ntimep\n);\n \n// uses a global buffer\n\n\n\nsleep\n(\n1\n);\n \n// implementation may use SIGALRM\n\nOptions\nÂ¶\n\n\n\n\n\n\nFunctionSet\nÂ¶\n\n\nSpecifies which functions in libc should be considered thread-safe,\npossible values are \nposix\n, \nglibc\n, or \nany\n.\n\n\nposix\n means POSIX defined thread-unsafe functions. POSIX.1-2001\nin â2.9.1 Thread-Safetyâ defines that all functions specified in the\nstandard are thread-safe except a predefined list of thread-unsafe\nfunctions.\n\n\nGlibc defines some of them as thread-safe (e.g. dirname(3)), but adds\nnon-POSIX thread-unsafe ones (e.g. getopt_long(3)). Glibcâs list is\ncompiled from GNU web documentation with a search for MT-Safe tag:\n\nhttps://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html\n\n\nIf you want to identify thread-unsafe API for at least one libc or\nunsure which libc will be used, use \nany\n (default).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/concurrency/mt-unsafe.html"
  },
  {
    "name": "concurrency-thread-canceltype-asynchronous",
    "description": "Finds \npthread_setcanceltype\n function calls where a threadâs cancellation\ntype is set to asynchronous. Asynchronous cancellation type\n(\nPTHREAD_CANCEL_ASYNCHRONOUS\n) is generally unsafe, use type\n\nPTHREAD_CANCEL_DEFERRED\n instead which is the default. Even with deferred\ncancellation, a cancellation point in an asynchronous signal handler may still\nbe acted upon and the effect is as if it was an asynchronous cancellation.\n\npthread_setcanceltype\n(\nPTHREAD_CANCEL_ASYNCHRONOUS\n,\n \n&\noldtype\n);\n\nThis check corresponds to the CERT C Coding Standard rule\n\nPOS47-C. Do not use threads that can be canceled asynchronously\n.\n\ncert-pos47-c\n redirects here as an alias of this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/concurrency/thread-canceltype-asynchronous.html"
  },
  {
    "name": "cppcoreguidelines-avoid-capturing-lambda-coroutines",
    "description": "Flags C++20 coroutine lambdas with non-empty capture lists that may cause\nuse-after-free errors and suggests avoiding captures or ensuring the lambda\nclosure object has a guaranteed lifetime.\n\nThis check implements \nCP.51\n\nfrom the C++ Core Guidelines.\n\nUsing coroutine lambdas with non-empty capture lists can be risky, as capturing\nvariables can lead to accessing freed memory after the first suspension point.\nThis issue can occur even with refcounted smart pointers and copyable types.\nWhen a lambda expression creates a coroutine, it results in a closure object\nwith storage, which is often on the stack and will eventually go out of scope.\nWhen the closure object goes out of scope, its captures also go out of scope.\nWhile normal lambdas finish executing before this happens, coroutine lambdas\nmay resume from suspension after the closure object has been destructed,\nresulting in use-after-free memory access for all captures.\n\nConsider the following example:\n\nint\n \nvalue\n \n=\n \nget_value\n();\n\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nsharedFoo\n \n=\n \nget_foo\n();\n\n\n{\n\n\n    \nconst\n \nauto\n \nlambda\n \n=\n \n[\nvalue\n,\n \nsharedFoo\n]()\n \n->\n \nstd\n::\nfuture\n<\nvoid\n>\n\n\n    \n{\n\n\n        \nco_await\n \nsomething\n();\n\n\n        \n// \"sharedFoo\" and \"value\" have already been destroyed\n\n\n        \n// the \"shared\" pointer didn't accomplish anything\n\n\n    \n};\n\n\n    \nlambda\n();\n\n\n}\n \n// the lambda closure object has now gone out of scope\n\nIn this example, the lambda object is defined with two captures: value and\n\nsharedFoo\n. When \nlambda()\n is called, the lambda object is created on the\nstack, and the captures are copied into the closure object. When the coroutine\nis suspended, the lambda object goes out of scope, and the closure object is\ndestroyed. When the coroutine is resumed, the captured variables may have been\ndestroyed, resulting in use-after-free bugs.\n\nIn conclusion, the use of coroutine lambdas with non-empty capture lists can\nlead to use-after-free errors when resuming the coroutine after the closure\nobject has been destroyed. This check helps prevent such errors by flagging\nC++20 coroutine lambdas with non-empty capture lists and suggesting avoiding\ncaptures or ensuring the lambda closure object has a guaranteed lifetime.\n\nFollowing these guidelines can help ensure the safe and reliable use of\ncoroutine lambdas in C++ code.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-capturing-lambda-coroutines.html"
  },
  {
    "name": "cppcoreguidelines-avoid-const-or-ref-data-members",
    "description": "This check warns when structs or classes that are copyable or movable, and have\nconst-qualified or reference (lvalue or rvalue) data members. Having such\nmembers is rarely useful, and makes the class only copy-constructible but not\ncopy-assignable.\n\nExamples:\n\n// Bad, const-qualified member\n\n\nstruct\n \nConst\n \n{\n\n\n  \nconst\n \nint\n \nx\n;\n\n\n}\n\n\n\n// Good:\n\n\nclass\n \nFoo\n \n{\n\n\n \npublic\n:\n\n\n  \nint\n \nget\n()\n \nconst\n \n{\n \nreturn\n \nx\n;\n \n}\n\n\n \nprivate\n:\n\n\n  \nint\n \nx\n;\n\n\n};\n\n\n\n// Bad, lvalue reference member\n\n\nstruct\n \nRef\n \n{\n\n\n  \nint\n&\n \nx\n;\n\n\n};\n\n\n\n// Good:\n\n\nstruct\n \nFoo\n \n{\n\n\n  \nint\n*\n \nx\n;\n\n\n  \nstd\n::\nunique_ptr\n<\nint\n>\n \nx\n;\n\n\n  \nstd\n::\nshared_ptr\n<\nint\n>\n \nx\n;\n\n\n  \ngsl\n::\nnot_null\n<\nint\n*>\n \nx\n;\n\n\n};\n\n\n\n// Bad, rvalue reference member\n\n\nstruct\n \nRefRef\n \n{\n\n\n  \nint\n&&\n \nx\n;\n\n\n};\n\nThis check implements \nC.12\n\nfrom the C++ Core Guidelines.\n\nFurther reading:\n\nData members: Never const\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-const-or-ref-data-members.html"
  },
  {
    "name": "cppcoreguidelines-avoid-do-while",
    "description": "Warns when using \ndo-while\n loops. They are less readable than plain\n\nwhile\n loops, since the termination condition is at the end and the\ncondition is not checked prior to the first iteration.\nThis can lead to subtle bugs.\n\nThis check implements \nES.75\n\nfrom the C++ Core Guidelines.\n\nExamples:\n\nint\n \nx\n;\n\n\ndo\n \n{\n\n\n    \nstd\n::\ncin\n \n>>\n \nx\n;\n\n\n    \n// ...\n\n\n}\n \nwhile\n \n(\nx\n \n<\n \n0\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIgnore the check when analyzing macros. This is useful for safely defining function-like macros:\n\n\n#define FOO_BAR(x) \\\n\n\ndo { \\\n\n\n  foo(x); \\\n\n\n  bar(x); \\\n\n\n} while(0)\n\n\n\n\n\n\nDefaults to \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-do-while.html"
  },
  {
    "name": "cppcoreguidelines-avoid-goto",
    "description": "The usage of \ngoto\n for control flow is error prone and should be replaced\nwith looping constructs. Only forward jumps in nested loops are accepted.\n\nThis check implements \nES.76\n\nfrom the C++ Core Guidelines and\n\n6.3.1\n\nfrom High Integrity C++ Coding Standard.\n\nFor more information on why to avoid programming\nwith \ngoto\n you can read the famous paper \nA Case against the GO TO Statement.\n.\n\nThe check diagnoses \ngoto\n for backward jumps in every language mode. These\nshould be replaced with \nC/C++\n looping constructs.\n\n// Bad, handwritten for loop.\n\n\nint\n \ni\n \n=\n \n0\n;\n\n\n// Jump label for the loop\n\n\nloop_start\n:\n\n\ndo_some_operation\n();\n\n\n\nif\n \n(\ni\n \n<\n \n100\n)\n \n{\n\n\n  \n++\ni\n;\n\n\n  \ngoto\n \nloop_start\n;\n\n\n}\n\n\n\n// Better\n\n\nfor\n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \n++\ni\n)\n\n\n  \ndo_some_operation\n();\n\nModern C++ needs \ngoto\n only to jump out of nested loops.\n\nfor\n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n100\n;\n \n++\ni\n)\n \n{\n\n\n  \nfor\n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \n100\n;\n \n++\nj\n)\n \n{\n\n\n    \nif\n \n(\ni\n \n*\n \nj\n \n>\n \n500\n)\n\n\n      \ngoto\n \nearly_exit\n;\n\n\n  \n}\n\n\n}\n\n\n\nearly_exit\n:\n\n\nsome_operation\n();\n\nAll other uses of \ngoto\n are diagnosed in \nC++\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not warn if a \ngoto\n statement is\nexpanded from a macro. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-goto.html"
  },
  {
    "name": "cppcoreguidelines-avoid-non-const-global-variables",
    "description": "Finds non-const global variables as described in \nI.2\n\nof C++ Core Guidelines.\nAs \nR.6\n\nof C++ Core Guidelines is a duplicate of rule \nI.2\n\nit also covers that rule.\n\nchar\n \na\n;\n  \n// Warns!\n\n\nconst\n \nchar\n \nb\n \n=\n  \n0\n;\n\n\n\nnamespace\n \nsome_namespace\n\n\n{\n\n\n    \nchar\n \nc\n;\n  \n// Warns!\n\n\n    \nconst\n \nchar\n \nd\n \n=\n \n0\n;\n\n\n}\n\n\n\nchar\n \n*\n \nc_ptr1\n \n=\n \n&\nsome_namespace\n::\nc\n;\n  \n// Warns!\n\n\nchar\n \n*\nconst\n \nc_const_ptr\n \n=\n \n&\nsome_namespace\n::\nc\n;\n  \n// Warns!\n\n\nchar\n \n&\n \nc_reference\n \n=\n \nsome_namespace\n::\nc\n;\n  \n// Warns!\n\n\n\nclass\n \nFoo\n  \n// No Warnings inside Foo, only namespace scope is covered\n\n\n{\n\n\npublic\n:\n\n\n    \nchar\n \ne\n \n=\n \n0\n;\n\n\n    \nconst\n \nchar\n \nf\n \n=\n \n0\n;\n\n\nprotected\n:\n\n\n    \nchar\n \ng\n \n=\n \n0\n;\n\n\nprivate\n:\n\n\n    \nchar\n \nh\n \n=\n \n0\n;\n\n\n};\n\nThe variables \na\n, \nc\n, \nc_ptr1\n, \nc_const_ptr\n and \nc_reference\n\nwill all generate warnings since they are either a non-const globally accessible\nvariable, a pointer or a reference providing global access to non-const data\nor both.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowInternalLinkage\nÂ¶\n\n\nWhen set to \ntrue\n, static non-const variables and variables in anonymous\nnamespaces will not generate a warning. The default value is \nfalse\n.\n\n\n\n\n\n\n\n\nAllowThreadLocal\nÂ¶\n\n\nWhen set to \ntrue\n, non-const global variables with thread-local storage\nduration will not generate a warning. The default value is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-non-const-global-variables.html"
  },
  {
    "name": "cppcoreguidelines-avoid-reference-coroutine-parameters",
    "description": "Warns when a coroutine accepts reference parameters. After a coroutine suspend\npoint, references could be dangling and no longer valid. Instead, pass\nparameters as values.\n\nExamples:\n\nstd\n::\nfuture\n<\nint\n>\n \nsomeCoroutine\n(\nint\n&\n \nval\n)\n \n{\n\n\n  \nco_await\n \n...;\n\n\n  \n// When the coroutine is resumed, 'val' might no longer be valid.\n\n\n  \nif\n \n(\nval\n)\n \n...\n\n\n}\n\nThis check implements \nCP.53\n\nfrom the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-reference-coroutine-parameters.html"
  },
  {
    "name": "cppcoreguidelines-init-variables",
    "description": "Checks whether there are local variables that are declared without an initial\nvalue. These may lead to unexpected behavior if there is a code path that reads\nthe variable before assigning to it.\n\nThis rule is part of the \nType safety (Type.5)\n\nprofile and \nES.20\n\nfrom the C++ Core Guidelines.\n\nOnly integers, booleans, floats, doubles and pointers are checked. The fix\noption initializes all detected values with the value of zero. An exception is\nfloat and double types, which are initialized to NaN.\n\nAs an example a function that looks like this:\n\nvoid\n \nfunction\n()\n \n{\n\n\n  \nint\n \nx\n;\n\n\n  \nchar\n \n*\ntxt\n;\n\n\n  \ndouble\n \nd\n;\n\n\n\n  \n// Rest of the function.\n\n\n}\n\nWould be rewritten to look like this:\n\n#include\n \n<math.h>\n\n\n\nvoid\n \nfunction\n()\n \n{\n\n\n  \nint\n \nx\n \n=\n \n0\n;\n\n\n  \nchar\n \n*\ntxt\n \n=\n \nnullptr\n;\n\n\n  \ndouble\n \nd\n \n=\n \nNAN\n;\n\n\n\n  \n// Rest of the function.\n\n\n}\n\nIt warns for the uninitialized enum case, but without a FixIt:\n\nenum\n \nA\n \n{\nA1\n,\n \nA2\n,\n \nA3\n};\n\n\nenum\n \nA_c\n \n:\n \nchar\n \n{\n \nA_c1\n,\n \nA_c2\n,\n \nA_c3\n \n};\n\n\nenum\n \nclass\n \nB\n \n{\n \nB1\n,\n \nB2\n,\n \nB3\n \n};\n\n\nenum\n \nclass\n \nB_i\n \n:\n \nint\n \n{\n \nB_i1\n,\n \nB_i2\n,\n \nB_i3\n \n};\n\n\nvoid\n \nfunction\n()\n \n{\n\n\n  \nA\n \na\n;\n     \n// Warning: variable 'a' is not initialized\n\n\n  \nA_c\n \na_c\n;\n \n// Warning: variable 'a_c' is not initialized\n\n\n  \nB\n \nb\n;\n     \n// Warning: variable 'b' is not initialized\n\n\n  \nB_i\n \nb_i\n;\n \n// Warning: variable 'b_i' is not initialized\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nMathHeader\nÂ¶\n\n\nA string specifying the header to include to get the definition of \nNAN\n.\nDefault is \n<math.h>\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/init-variables.html"
  },
  {
    "name": "cppcoreguidelines-interfaces-global-init",
    "description": "This check flags initializers of globals that access extern objects,\nand therefore can lead to order-of-initialization problems.\n\nThis check implements \nI.22\n\nfrom the C++ Core Guidelines.\n\nNote that currently this does not flag calls to non-constexpr functions, and\ntherefore globals could still be accessed from functions themselves.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/interfaces-global-init.html"
  },
  {
    "name": "cppcoreguidelines-macro-usage",
    "description": "Finds macro usage that is considered problematic because better language\nconstructs exist for the task.\n\nThe relevant sections in the C++ Core Guidelines are\n\nES.31\n, and\n\nES.32\n.\n\nExamples:\n\n#define C 0\n\n\n#define F1(x, y) ((a) > (b) ? (a) : (b))\n\n\n#define F2(...) (__VA_ARGS__)\n\n\n#define F3(x, y) x##y\n\n\n#define COMMA ,\n\n\n#define NORETURN [[noreturn]]\n\n\n#define DEPRECATED attribute((deprecated))\n\n\n#if LIB_EXPORTS\n\n\n#define DLLEXPORTS __declspec(dllexport)\n\n\n#else\n\n\n#define DLLEXPORTS __declspec(dllimport)\n\n\n#endif\n\nresults in the following warnings:\n\n4\n \nwarnings\n \ngenerated\n.\n\n\ntest\n.\ncpp\n:\n1\n:\n9\n:\n \nwarning\n:\n \nmacro\n \n'C'\n \nused\n \nto\n \ndeclare\n \na\n \nconstant\n;\n \nconsider\n \nusing\n \na\n \n'constexpr'\n \nconstant\n \n[\ncppcoreguidelines\n-\nmacro\n-\nusage\n]\n\n\n#define C 0\n\n        \n^\n\n\ntest\n.\ncpp\n:\n2\n:\n9\n:\n \nwarning\n:\n \nfunction\n-\nlike\n \nmacro\n \n'F1'\n \nused\n;\n \nconsider\n \na\n \n'constexpr'\n \ntemplate\n \nfunction\n \n[\ncppcoreguidelines\n-\nmacro\n-\nusage\n]\n\n\n#define F1(x, y) ((a) > (b) ? (a) : (b))\n\n        \n^\n\n\ntest\n.\ncpp\n:\n3\n:\n9\n:\n \nwarning\n:\n \nvariadic\n \nmacro\n \n'F2'\n \nused\n;\n \nconsider\n \nusing\n \na\n \n'constexpr'\n \nvariadic\n \ntemplate\n \nfunction\n \n[\ncppcoreguidelines\n-\nmacro\n-\nusage\n]\n\n\n#define F2(...) (__VA_ARGS__)\n\n        \n^\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowedRegexp\nÂ¶\n\n\nA regular expression to filter allowed macros. For example\n\nDEBUG*|LIBTORRENT*|TORRENT*|UNI*\n could be applied to filter \nlibtorrent\n.\nDefault value is \n^DEBUG_*\n.\n\n\n\n\n\n\n\n\nCheckCapsOnly\nÂ¶\n\n\nBoolean flag to warn on all macros except those with CAPS_ONLY names.\nThis option is intended to ease introduction of this check into older\ncode bases. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreCommandLineMacros\nÂ¶\n\n\nBoolean flag to toggle ignoring command-line-defined macros.\nDefault value is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/macro-usage.html"
  },
  {
    "name": "cppcoreguidelines-misleading-capture-default-by-value",
    "description": "Warns when lambda specify a by-value capture default and capture \nthis\n.\n\nBy-value capture defaults in member functions can be misleading about whether\ndata members are captured by value or reference. This occurs because specifying\nthe capture default \n[=]\n actually captures the \nthis\n pointer by value,\nnot the data members themselves. As a result, data members are still indirectly\naccessed via the captured \nthis\n pointer, which essentially means they are\nbeing accessed by reference. Therefore, even when using \n[=]\n, data members\nare effectively captured by reference, which might not align with the userâs\nexpectations.\n\nExamples:\n\nstruct\n \nAClass\n \n{\n\n\n  \nint\n \nmember\n;\n\n\n  \nvoid\n \nmisleadingLogic\n()\n \n{\n\n\n    \nint\n \nlocal\n \n=\n \n0\n;\n\n\n    \nmember\n \n=\n \n0\n;\n\n\n    \nauto\n \nf\n \n=\n \n[\n=\n]()\n \nmutable\n \n{\n\n\n      \nlocal\n \n+=\n \n1\n;\n\n\n      \nmember\n \n+=\n \n1\n;\n\n\n    \n};\n\n\n    \nf\n();\n\n\n    \n// Here, local is 0 but member is 1\n\n\n  \n}\n\n\n\n  \nvoid\n \nclearLogic\n()\n \n{\n\n\n    \nint\n \nlocal\n \n=\n \n0\n;\n\n\n    \nmember\n \n=\n \n0\n;\n\n\n    \nauto\n \nf\n \n=\n \n[\nthis\n,\n \nlocal\n]()\n \nmutable\n \n{\n\n\n      \nlocal\n \n+=\n \n1\n;\n\n\n      \nmember\n \n+=\n \n1\n;\n\n\n    \n};\n\n\n    \nf\n();\n\n\n    \n// Here, local is 0 but member is 1\n\n\n  \n}\n\n\n};\n\nThis check implements \nF.54\n\nfrom the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/misleading-capture-default-by-value.html"
  },
  {
    "name": "cppcoreguidelines-missing-std-forward",
    "description": "Warns when a forwarding reference parameter is not forwarded inside the\nfunction body.\n\nExample:\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nvoid\n \nwrapper\n(\nT\n&&\n \nt\n)\n \n{\n\n\n  \nimpl\n(\nstd\n::\nforward\n<\nT\n>\n(\nt\n),\n \n1\n,\n \n2\n);\n \n// Correct\n\n\n}\n\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nvoid\n \nwrapper2\n(\nT\n&&\n \nt\n)\n \n{\n\n\n  \nimpl\n(\nt\n,\n \n1\n,\n \n2\n);\n \n// Oops - should use std::forward<T>(t)\n\n\n}\n\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nvoid\n \nwrapper3\n(\nT\n&&\n \nt\n)\n \n{\n\n\n  \nimpl\n(\nstd\n::\nmove\n(\nt\n),\n \n1\n,\n \n2\n);\n \n// Also buggy - should use std::forward<T>(t)\n\n\n}\n\n\n\ntemplate\n \n<\nclass\n \nF\n>\n\n\nvoid\n \nwrapper_function\n(\nF\n&&\n \nf\n)\n \n{\n\n\n  \nstd\n::\nforward\n<\nF\n>\n(\nf\n)(\n1\n,\n \n2\n);\n \n// Correct\n\n\n}\n\n\n\ntemplate\n \n<\nclass\n \nF\n>\n\n\nvoid\n \nwrapper_function2\n(\nF\n&&\n \nf\n)\n \n{\n\n\n  \nf\n(\n1\n,\n \n2\n);\n \n// Incorrect - may not invoke the desired qualified function operator\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nForwardFunction\nÂ¶\n\n\nSpecify the function used for forwarding. Default is \n::std::forward\n.\n\n\n\n\nThis check implements \nF.19\n\nfrom the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/missing-std-forward.html"
  },
  {
    "name": "cppcoreguidelines-no-malloc",
    "description": "This check handles C-Style memory management using \nmalloc()\n, \nrealloc()\n,\n\ncalloc()\n and \nfree()\n. It warns about its use and tries to suggest the\nuse of an appropriate RAII object.\nFurthermore, it can be configured to check against a user-specified list of\nfunctions that are used for memory management (e.g. \nposix_memalign()\n).\n\nThis check implements \nR.10\n\nfrom the C++ Core Guidelines.\n\nThere is no attempt made to provide fix-it hints, since manual resource\nmanagement isnât easily transformed automatically into RAII.\n\n// Warns each of the following lines.\n\n\n// Containers like std::vector or std::string should be used.\n\n\nchar\n*\n \nsome_string\n \n=\n \n(\nchar\n*\n)\n \nmalloc\n(\nsizeof\n(\nchar\n)\n \n*\n \n20\n);\n\n\nchar\n*\n \nsome_string\n \n=\n \n(\nchar\n*\n)\n \nrealloc\n(\nsizeof\n(\nchar\n)\n \n*\n \n30\n);\n\n\nfree\n(\nsome_string\n);\n\n\n\nint\n*\n \nint_array\n \n=\n \n(\nint\n*\n)\n \ncalloc\n(\n30\n,\n \nsizeof\n(\nint\n));\n\n\n\n// Rather use a smartpointer or stack variable.\n\n\nstruct\n \nsome_struct\n*\n \ns\n \n=\n \n(\nstruct\n \nsome_struct\n*\n)\n \nmalloc\n(\nsizeof\n(\nstruct\n \nsome_struct\n));\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllocations\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of memory allocation functions.\nDefaults to \n::malloc;::calloc\n.\n\n\n\n\n\n\n\n\nDeallocations\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of memory allocation functions.\nDefaults to \n::free\n.\n\n\n\n\n\n\n\n\nReallocations\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of memory allocation functions.\nDefaults to \n::realloc\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/no-malloc.html"
  },
  {
    "name": "cppcoreguidelines-no-suspend-with-lock",
    "description": "Flags coroutines that suspend while a lock guard is in scope at the\nsuspension point.\n\nWhen a coroutine suspends, any mutexes held by the coroutine will remain\nlocked until the coroutine resumes and eventually destructs the lock guard.\nThis can lead to long periods with a mutex held and runs the risk of deadlock.\n\nInstead, locks should be released before suspending a coroutine.\n\nThis check only checks suspending coroutines while a lock_guard is in scope;\nit does not consider manual locking or unlocking of mutexes, e.g., through\ncalls to \nstd::mutex::lock()\n.\n\nExamples:\n\nfuture\n \nbad_coro\n()\n \n{\n\n\n  \nstd\n::\nlock_guard\n \nlock\n{\nmtx\n};\n\n\n  \n++\nsome_counter\n;\n\n\n  \nco_await\n \nsomething\n();\n \n// Suspending while holding a mutex\n\n\n}\n\n\n\nfuture\n \ngood_coro\n()\n \n{\n\n\n  \n{\n\n\n    \nstd\n::\nlock_guard\n \nlock\n{\nmtx\n};\n\n\n    \n++\nsome_counter\n;\n\n\n  \n}\n\n\n  \n// Destroy the lock_guard to release the mutex before suspending the coroutine\n\n\n  \nco_await\n \nsomething\n();\n \n// Suspending while holding a mutex\n\n\n}\n\nThis check implements \nCP.52\n\nfrom the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/no-suspend-with-lock.html"
  },
  {
    "name": "cppcoreguidelines-owning-memory",
    "description": "This check implements the type-based semantics of \ngsl::owner<T*>\n, which\nallows static analysis on code, that uses raw pointers to handle resources\nlike dynamic memory, but wonât introduce RAII concepts.\n\nThis check implements \nI.11\n,\n\nC.33\n,\n\nR.3\n\nand \nGSL.Views\n\nfrom the C++ Core Guidelines.\nThe definition of a \ngsl::owner<T*>\n is straight forward\n\nnamespace\n \ngsl\n \n{\n \ntemplate\n \n<\ntypename\n \nT\n>\n \nowner\n \n=\n \nT\n;\n \n}\n\nIt is therefore simple to introduce the owner even without using an implementation of\nthe \nGuideline Support Library\n.\n\nAll checks are purely type based and not (yet) flow sensitive.\n\nThe following examples will demonstrate the correct and incorrect\ninitializations of owners, assignment is handled the same way.\nNote that both \nnew\n and \nmalloc()\n-like resource functions are\nconsidered to produce resources.\n\n// Creating an owner with factory functions is checked.\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nfunction_that_returns_owner\n()\n \n{\n \nreturn\n \ngsl\n::\nowner\n<\nint\n*>\n(\nnew\n \nint\n(\n42\n));\n \n}\n\n\n\n// Dynamic memory must be assigned to an owner\n\n\nint\n*\n \nSomething\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// BAD, will be caught\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// Good\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n[\n42\n];\n \n// Good as well\n\n\n\n// Returned owner must be assigned to an owner\n\n\nint\n*\n \nSomething\n \n=\n \nfunction_that_returns_owner\n();\n \n// Bad, factory function\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nfunction_that_returns_owner\n();\n \n// Good, result lands in owner\n\n\n\n// Something not a resource or owner should not be assigned to owners\n\n\nint\n \nStack\n \n=\n \n42\n;\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwned\n \n=\n \n&\nStack\n;\n \n// Bad, not a resource assigned\n\nIn the case of dynamic memory as resource, only \ngsl::owner<T*>\n variables are allowed\nto be deleted.\n\n// Example Bad, non-owner as resource handle, will be caught.\n\n\nint\n*\n \nNonOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// First warning here, since new must land in an owner\n\n\ndelete\n \nNonOwner\n;\n \n// Second warning here, since only owners are allowed to be deleted\n\n\n\n// Example Good, Ownership correctly stated\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// Good\n\n\ndelete\n \nOwner\n;\n \n// Good as well, statically enforced, that only owners get deleted\n\nThe check will furthermore ensure, that functions, that expect a\n\ngsl::owner<T*>\n as argument get called with either a \ngsl::owner<T*>\n or\na newly created resource.\n\nvoid\n \nexpects_owner\n(\ngsl\n::\nowner\n<\nint\n*>\n \no\n)\n \n{\n \ndelete\n \no\n;\n \n}\n\n\n\n// Bad Code\n\n\nint\n \nNonOwner\n \n=\n \n42\n;\n\n\nexpects_owner\n(\n&\nNonOwner\n);\n \n// Bad, will get caught\n\n\n\n// Good Code\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n\n\nexpects_owner\n(\nOwner\n);\n \n// Good\n\n\nexpects_owner\n(\nnew\n \nint\n(\n42\n));\n \n// Good as well, recognized created resource\n\n\n\n// Port legacy code for better resource-safety\n\n\ngsl\n::\nowner\n<\nFILE\n*>\n \nFile\n \n=\n \nfopen\n(\n\"my_file.txt\"\n,\n \n\"rw+\"\n);\n\n\nFILE\n*\n \nBadFile\n \n=\n \nfopen\n(\n\"another_file.txt\"\n,\n \n\"w\"\n);\n \n// Bad, warned\n\n\n\n// ... use the file\n\n\n\nfclose\n(\nFile\n);\n \n// Ok, File is annotated as 'owner<>'\n\n\nfclose\n(\nBadFile\n);\n \n// BadFile is not an 'owner<>', will be warned\n\nOptions\nÂ¶\n\n\n\n\n\n\nLegacyResourceProducers\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of legacy functions that create\nresources but cannot introduce \ngsl::owner<>\n.\nDefaults to \n::malloc;::aligned_alloc;::realloc;::calloc;::fopen;::freopen;::tmpfile\n.\n\n\n\n\n\n\n\n\nLegacyResourceConsumers\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of legacy functions expecting\nresource owners as pointer arguments but cannot introduce \ngsl::owner<>\n.\nDefaults to \n::free;::realloc;::freopen;::fclose\n.\n\nLimitations\nÂ¶\n\n\nUsing \ngsl::owner<T*>\n in a typedef or alias is not handled correctly.\n\n\nusing\n \nheap_int\n \n=\n \ngsl\n::\nowner\n<\nint\n*>\n;\n\n\nheap_int\n \nallocated\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// False positive!\n\n\n\n\n\n\nThe \ngsl::owner<T*>\n is declared as a templated type alias.\nIn template functions and classes, like in the example below, the information\nof the type aliases gets lost. Therefore using \ngsl::owner<T*>\n in a heavy templated\ncode base might lead to false positives.\n\n\nKnown code constructs that do not get diagnosed correctly are:\n\n\n\n\nstd::exchange\n\n\nstd::vector<gsl::owner<T*>>\n\n\n\n\n// This template function works as expected. Type information doesn't get lost.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \ndelete_owner\n(\ngsl\n::\nowner\n<\nT\n*>\n \nowned_object\n)\n \n{\n\n\n  \ndelete\n \nowned_object\n;\n \n// Everything alright\n\n\n}\n\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nfunction_that_returns_owner\n()\n \n{\n \nreturn\n \ngsl\n::\nowner\n<\nint\n*>\n(\nnew\n \nint\n(\n42\n));\n \n}\n\n\n\n// Type deduction does not work for auto variables.\n\n\n// This is caught by the check and will be noted accordingly.\n\n\nauto\n \nOwnedObject\n \n=\n \nfunction_that_returns_owner\n();\n \n// Type of OwnedObject will be int*\n\n\n\n// Problematic function template that looses the typeinformation on owner\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nbad_template_function\n(\nT\n \nsome_object\n)\n \n{\n\n\n  \n// This line will trigger the warning, that a non-owner is assigned to an owner\n\n\n  \ngsl\n::\nowner\n<\nT\n*>\n \nnew_owner\n \n=\n \nsome_object\n;\n\n\n}\n\n\n\n// Calling the function with an owner still yields a false positive.\n\n\nbad_template_function\n(\ngsl\n::\nowner\n<\nint\n*>\n(\nnew\n \nint\n(\n42\n)));\n\n\n\n\n// The same issue occurs with templated classes like the following.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nclass\n \nOwnedValue\n \n{\n\n\npublic\n:\n\n\n  \nconst\n \nT\n \ngetValue\n()\n \nconst\n \n{\n \nreturn\n \n_val\n;\n \n}\n\n\nprivate\n:\n\n\n  \nT\n \n_val\n;\n\n\n};\n\n\n\n// Code, that yields a false positive.\n\n\nOwnedValue\n<\ngsl\n::\nowner\n<\nint\n*>>\n \nOwner\n(\nnew\n \nint\n(\n42\n));\n \n// Type deduction yield T -> int *\n\n\n// False positive, getValue returns int* and not gsl::owner<int*>\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwnedInt\n \n=\n \nOwner\n.\ngetValue\n();\n\n\n\n\n\n\nAnother limitation of the current implementation is only the type based\nchecking. Suppose you have code like the following:\n\n\n// Two owners with assigned resources\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner1\n \n=\n \nnew\n \nint\n(\n42\n);\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner2\n \n=\n \nnew\n \nint\n(\n42\n);\n\n\n\nOwner2\n \n=\n \nOwner1\n;\n \n// Conceptual Leak of initial resource of Owner2!\n\n\nOwner1\n \n=\n \nnullptr\n;\n\n\n\n\n\n\nThe semantic of a \ngsl::owner<T*>\n is mostly like a \nstd::unique_ptr<T>\n,\ntherefore assignment of two \ngsl::owner<T*>\n is considered a move, which\nrequires that the resource \nOwner2\n must have been released before the\nassignment. This kind of condition could be caught in later improvements of\nthis check with flowsensitive analysis. Currently, the \nClang Static Analyzer\n\ncatches this bug for dynamic memory, but not for general types of resources.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/owning-memory.html"
  },
  {
    "name": "cppcoreguidelines-prefer-member-initializer",
    "description": "Finds member initializations in the constructor body which can be  converted\ninto member initializers of the constructor instead. This not only improves\nthe readability of the code but also positively affects its performance.\nClass-member assignments inside a control statement or following the first\ncontrol statement are ignored.\n\nThis check implements \nC.49\n\nfrom the C++ Core Guidelines.\n\nPlease note, that this check does not enforce rule \nC.48\n\nfrom the C++ Core Guidelines. For that purpose\nsee check \nmodernize-use-default-member-init\n.\n\nExample 1\nÂ¶\n\n\nclass\n \nC\n \n{\n\n\n  \nint\n \nn\n;\n\n\n  \nint\n \nm\n;\n\n\npublic\n:\n\n\n  \nC\n()\n \n{\n\n\n    \nn\n \n=\n \n1\n;\n \n// Literal in default constructor\n\n\n    \nif\n \n(\ndice\n())\n\n\n      \nreturn\n;\n\n\n    \nm\n \n=\n \n1\n;\n\n\n  \n}\n\n\n};\n\n\n\n\n\n\nHere \nn\n can be initialized in the constructor initializer list, unlike\n\nm\n, as \nm\nâs initialization follows a control statement (\nif\n):\n\n\nclass\n \nC\n \n{\n\n\n  \nint\n \nn\n;\n\n\n  \nint\n \nm\n;\n\n\npublic\n:\n\n\n  \nC\n()\n:\n \nn\n(\n1\n)\n \n{\n\n\n    \nif\n \n(\ndice\n())\n\n\n      \nreturn\n;\n\n\n    \nm\n \n=\n \n1\n;\n\n\n  \n}\n\n\n};\n\nExample 2\nÂ¶\n\n\nclass\n \nC\n \n{\n\n\n  \nint\n \nn\n;\n\n\n  \nint\n \nm\n;\n\n\npublic\n:\n\n\n  \nC\n(\nint\n \nnn\n,\n \nint\n \nmm\n)\n \n{\n\n\n    \nn\n \n=\n \nnn\n;\n \n// Neither default constructor nor literal\n\n\n    \nif\n \n(\ndice\n())\n\n\n      \nreturn\n;\n\n\n    \nm\n \n=\n \nmm\n;\n\n\n  \n}\n\n\n};\n\n\n\n\n\n\nHere \nn\n can be initialized in the constructor initializer list, unlike\n\nm\n, as \nm\nâs initialization follows a control statement (\nif\n):\n\n\nC\n(\nint\n \nnn\n,\n \nint\n \nmm\n)\n \n:\n \nn\n(\nnn\n)\n \n{\n\n\n  \nif\n \n(\ndice\n())\n\n\n    \nreturn\n;\n\n\n  \nm\n \n=\n \nmm\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/prefer-member-initializer.html"
  },
  {
    "name": "cppcoreguidelines-pro-bounds-array-to-pointer-decay",
    "description": "This check flags all array to pointer decays.\n\nPointers should not be used as arrays. \nspan<T>\n is a bounds-checked, safe\nalternative to using pointers to access arrays.\n\nThis rule is part of the \nBounds safety (Bounds 3)\n\nprofile from the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-bounds-array-to-pointer-decay.html"
  },
  {
    "name": "cppcoreguidelines-pro-bounds-avoid-unchecked-container-access",
    "description": "Finds calls to \noperator[]\n in STL containers and suggests replacing them\nwith safe alternatives.\nSafe alternatives include STL \nat\n or GSL \nat\n functions, \nbegin()\n or\n\nend()\n functions, \nrange-for\n loops, \nstd::span\n, or an appropriate\nfunction from \n<algorithms>\n.\n\nFor example, both\n\nstd\n::\nvector\n<\nint\n>\n \na\n;\n\n\nint\n \nb\n \n=\n \na\n[\n4\n];\n\nand\n\nstd\n::\nunique_ptr\n<\nvector\n>\n \na\n;\n\n\nint\n \nb\n \n=\n \na\n[\n0\n];\n\nwill generate a warning.\n\nSTL containers for which \noperator[]\n is well-defined for all inputs are\nexcluded from this check (e.g.: \nstd::map::operator[]\n).\n\nThis check enforces part of the \nSL.con.3\n\nguideline and is part of the \nBounds Safety (Bounds 4)\n\nprofile from the C++ Core Guidelines.\n\nOptions\nÂ¶\n\n\n\n\n\n\nExcludeClasses\nÂ¶\n\n\nSemicolon-separated list of regular expressions matching class names that\noverwrites the default exclusion list. The default is:\n\n::std::map;::std::unordered_map;::std::flat_map\n.\n\n\n\n\n\n\n\n\nFixMode\nÂ¶\n\n\nDetermines what fixes are suggested. Either \nnone\n, \nat\n (use\n\na.at(index)\n if a fitting function exists) or \nfunction\n (use a\nfunction \nf(a,\n \nindex)\n). The default is \nnone\n.\n\n\n\n\n\n\n\n\nFixFunction\nÂ¶\n\n\nThe function to use in the \nfunction\n mode. For C++23 and beyond, the\npassed function must support the empty subscript operator, i.e., the case\nwhere \na[]\n becomes \nf(a)\n. \nFixFunctionEmptyArgs\n can be\nused to override the suggested function in that case. The default is \ngsl::at\n.\n\n\n\n\n\n\n\n\nFixFunctionEmptyArgs\nÂ¶\n\n\nThe function to use in the \nfunction\n mode for the empty subscript operator\ncase in C++23 and beyond only. If no fixes should be made for empty\nsubscript operators, pass an empty string. In that case, only the warnings\nwill be printed. The default is the value of \nFixFunction\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-bounds-avoid-unchecked-container-access.html"
  },
  {
    "name": "cppcoreguidelines-pro-bounds-constant-array-index",
    "description": "This check flags all array subscript expressions on static arrays and\n\nstd::arrays\n that either do not have a constant integer expression index or\nare out of bounds (for \nstd::array\n). For out-of-bounds checking of static\narrays, see the \n-Warray-bounds\n Clang diagnostic.\n\nThis rule is part of the \nBounds safety (Bounds 2)\n\nprofile from the C++ Core Guidelines.\n\nOptionally, this check can generate fixes using \ngsl::at\n for indexing.\n\nOptions\nÂ¶\n\n\n\n\n\n\nGslHeader\nÂ¶\n\n\nThe check can generate fixes after this option has been set to the name of\nthe include file that contains \ngsl::at()\n, e.g. \nâgsl/gsl.hâ\n.\nDefault is an empty string.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-bounds-constant-array-index.html"
  },
  {
    "name": "cppcoreguidelines-pro-bounds-pointer-arithmetic",
    "description": "This check flags all usage of pointer arithmetic, because it could lead to an\ninvalid pointer. Subtraction of two pointers is not flagged by this check.\n\nPointers should only refer to single objects, and pointer arithmetic is fragile\nand easy to get wrong. \nspan<T>\n is a bounds-checked, safe type for accessing\narrays of data.\n\nThis rule is part of the \nBounds safety (Bounds 1)\n\nprofile from the C++ Core Guidelines.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowIncrementDecrementOperators\nÂ¶\n\n\nWhen enabled, the check will allow using the prefix/postfix increment or\ndecrement operators on pointers. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-bounds-pointer-arithmetic.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-const-cast",
    "description": "Imposes limitations on the use of \nconst_cast\n within C++ code. It depends on\nthe \nStrictMode\n option setting to determine whether it should flag all\ninstances of \nconst_cast\n or only those that remove either \nconst\n or\n\nvolatile\n qualifier.\n\nModifying a variable that has been declared as \nconst\n in C++ is generally\nconsidered undefined behavior, and this remains true even when using\n\nconst_cast\n. In C++, the \nconst\n qualifier indicates that a variable is\nintended to be read-only, and the compiler enforces this by disallowing any\nattempts to change the value of that variable.\n\nRemoving the \nvolatile\n qualifier in C++ can have serious consequences. This\nqualifier indicates that a variableâs value can change unpredictably, and\nremoving it may lead to undefined behavior, optimization problems, and\ndebugging challenges. Itâs essential to retain the \nvolatile\n qualifier in\nsituations where the variableâs volatility is a crucial aspect of program\ncorrectness and reliability.\n\nThis rule is part of the \nType safety (Type 3)\n\nprofile and \nES.50: Donât cast away const\n\nrule from the C++ Core Guidelines.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen this setting is set to \ntrue\n, it means that any usage of \nconst_cast\n\nis not allowed. On the other hand, when itâs set to \nfalse\n, it permits\ncasting to \nconst\n or \nvolatile\n types. Default value is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-const-cast.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-cstyle-cast",
    "description": "This check flags all use of C-style casts that perform a \nstatic_cast\n\ndowncast, \nconst_cast\n, or \nreinterpret_cast\n.\n\nUse of these casts can violate type safety and cause the program to access a\nvariable that is actually of type X to be accessed as if it were of an\nunrelated type Z. Note that a C-style \n(T)expression\n cast means to perform\nthe first of the following that is possible: a \nconst_cast\n, a\n\nstatic_cast\n, a \nstatic_cast\n followed by a \nconst_cast\n, a\n\nreinterpret_cast\n, or a \nreinterpret_cast\n followed by a \nconst_cast\n.\nThis rule bans \n(T)expression\n only when used to perform an unsafe cast.\n\nThis rule is part of the \nType safety (Type.4)\n\nprofile from the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-cstyle-cast.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-member-init",
    "description": "The check flags user-provided constructor definitions that do not\ninitialize all fields that would be left in an undefined state by\ndefault construction, e.g. builtins, pointers and record types without\nuser-provided default constructors containing at least one such\ntype. If these fields arenât initialized, the constructor will leave\nsome of the memory in an undefined state.\n\nFor C++11 it suggests fixes to add in-class field initializers. For\nolder versions it inserts the field initializers into the constructor\ninitializer list. It will also initialize any direct base classes that\nneed to be zeroed in the constructor initializer list.\n\nThe check takes assignment of fields in the constructor body into\naccount but generates false positives for fields initialized in\nmethods invoked in the constructor body.\n\nThe check also flags variables with automatic storage duration that have record\ntypes without a user-provided constructor and are not initialized. The\nsuggested fix is to zero initialize the variable via \n{}\n for C++11 and\nbeyond or \n=\n \n{}\n for older language versions.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreArrays\nÂ¶\n\n\nIf set to \ntrue\n, the check will not warn about array members that are not\nzero-initialized during construction. For performance critical code, it may\nbe important to not initialize fixed-size array members. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nUseAssignment\nÂ¶\n\n\nIf set to \ntrue\n, the check will provide fix-its with literal initializers\n( \nint\n \ni\n \n=\n \n0;\n ) instead of curly braces ( \nint\n \ni{};\n ).\nDefault is \nfalse\n.\n\n\n\n\nThis rule is part of the \nType safety (Type.6)\n\nprofile from the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-member-init.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-reinterpret-cast",
    "description": "This check flags all uses of \nreinterpret_cast\n in C++ code.\n\nUse of these casts can violate type safety and cause the program to access a\nvariable that is actually of type \nX\n to be accessed as if it were of an\nunrelated type \nZ\n.\n\nThis rule is part of the \nType safety (Type.1.1)\n\nprofile from the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-reinterpret-cast.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-static-cast-downcast",
    "description": "This check flags all usages of \nstatic_cast\n, where a base class is casted to\na derived class. In those cases, a fix-it is provided to convert the cast to a\n\ndynamic_cast\n.\n\nUse of these casts can violate type safety and cause the program to access a\nvariable that is actually of type \nX\n to be accessed as if it were of an\nunrelated type \nZ\n.\n\nThis rule is part of the \nType safety (Type.2)\n\nprofile from the C++ Core Guidelines.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen set to \nfalse\n, no warnings are emitted for casts on non-polymorphic\ntypes. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-static-cast-downcast.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-union-access",
    "description": "This check flags all access to members of unions. Passing unions as a whole is\nnot flagged.\n\nReading from a union member assumes that member was the last one written, and\nwriting to a union member assumes another member with a nontrivial destructor\nhad its destructor called. This is fragile because it cannot generally be\nenforced to be safe in the language and so relies on programmer discipline to\nget it right.\n\nThis rule is part of the \nType safety (Type.7)\n\nprofile from the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-union-access.html"
  },
  {
    "name": "cppcoreguidelines-pro-type-vararg",
    "description": "This check flags all calls to c-style vararg functions and all use of\n\nva_arg\n.\n\nTo allow for SFINAE use of vararg functions, a call is not flagged if a literal\n0 is passed as the only vararg argument or function is used in unevaluated\ncontext.\n\nPassing to varargs assumes the correct type will be read. This is fragile\nbecause it cannot generally be enforced to be safe in the language and so\nrelies on programmer discipline to get it right.\n\nThis rule is part of the \nType safety (Type.8)\n\nprofile from the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-vararg.html"
  },
  {
    "name": "cppcoreguidelines-rvalue-reference-param-not-moved",
    "description": "Warns when an rvalue reference function parameter is never moved within\nthe function body.\n\nRvalue reference parameters indicate a parameter that should be moved with\n\nstd::move\n from within the function body. Any such parameter that is\nnever moved is confusing and potentially indicative of a buggy program.\n\nExample:\n\nvoid\n \nlogic\n(\nstd\n::\nstring\n&&\n \nInput\n)\n \n{\n\n\n  \nstd\n::\nstring\n \nCopy\n(\nInput\n);\n \n// Oops - forgot to std::move\n\n\n}\n\nNote that parameters that are unused and marked as such will not be diagnosed.\n\nExample:\n\nvoid\n \nconditional_use\n([[\nmaybe_unused\n]]\n \nstd\n::\nstring\n&&\n \nInput\n)\n \n{\n\n\n  \n// No diagnostic here since Input is unused and marked as such\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowPartialMove\nÂ¶\n\n\n\n\nIf set to \ntrue\n, the check accepts \nstd::move\n calls containing any\nsubexpression containing the parameter. CppCoreGuideline F.18 officially\nmandates that the parameter itself must be moved. Default is \nfalse\n.\n\n\n\n\n// 'p' is flagged by this check if and only if AllowPartialMove is false\n\n\nvoid\n \nmove_members_of\n(\npair\n<\nObj\n,\n \nObj\n>&&\n \np\n)\n \n{\n\n\n  \npair\n<\nObj\n,\n \nObj\n>\n \nother\n;\n\n\n  \nother\n.\nfirst\n \n=\n \nstd\n::\nmove\n(\np\n.\nfirst\n);\n\n\n  \nother\n.\nsecond\n \n=\n \nstd\n::\nmove\n(\np\n.\nsecond\n);\n\n\n}\n\n\n\n// 'p' is never flagged by this check\n\n\nvoid\n \nmove_whole_pair\n(\npair\n<\nObj\n,\n \nObj\n>&&\n \np\n)\n \n{\n\n\n  \npair\n<\nObj\n,\n \nObj\n>\n \nother\n \n=\n \nstd\n::\nmove\n(\np\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nIgnoreUnnamedParams\nÂ¶\n\n\nIf set to \ntrue\n, the check ignores unnamed rvalue reference parameters.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreNonDeducedTemplateTypes\nÂ¶\n\n\n\n\nIf set to \ntrue\n, the check ignores non-deduced template type rvalue\nreference parameters. Default is \nfalse\n.\n\n\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nstruct\n \nSomeClass\n \n{\n\n\n  \n// Below, 'T' is not deduced and 'T&&' is an rvalue reference type.\n\n\n  \n// This will be flagged if and only if IgnoreNonDeducedTemplateTypes is\n\n\n  \n// false. One suggested fix would be to specialize the class for 'T' and\n\n\n  \n// 'T&' separately (e.g., see std::future), or allow only one of 'T' or\n\n\n  \n// 'T&' instantiations of SomeClass (e.g., see std::optional).\n\n\n  \nSomeClass\n(\nT\n&&\n \nt\n)\n \n{\n \n}\n\n\n};\n\n\n\n// Never flagged, since 'T' is a forwarding reference in a deduced context\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nvoid\n \nforwarding_ref\n(\nT\n&&\n \nt\n)\n \n{\n\n\n  \nT\n \nother\n \n=\n \nstd\n::\nforward\n<\nT\n>\n(\nt\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nMoveFunction\nÂ¶\n\n\nSpecify the function used for moving. Default is \n::std::move\n.\n\n\n\n\nThis check implements \nF.18\n\nfrom the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/rvalue-reference-param-not-moved.html"
  },
  {
    "name": "cppcoreguidelines-slicing",
    "description": "Flags slicing of member variables or vtable. Slicing happens when copying a\nderived object into a base object: the members of the derived object (both\nmember variables and virtual member functions) will be discarded. This can be\nmisleading especially for member function slicing, for example:\n\nstruct\n \nB\n \n{\n \nint\n \na\n;\n \nvirtual\n \nint\n \nf\n();\n \n};\n\n\nstruct\n \nD\n \n:\n \nB\n \n{\n \nint\n \nb\n;\n \nint\n \nf\n()\n \noverride\n;\n \n};\n\n\n\nvoid\n \nuse\n(\nB\n \nb\n)\n \n{\n  \n// Missing reference, intended?\n\n\n  \nb\n.\nf\n();\n  \n// Calls B::f.\n\n\n}\n\n\n\nD\n \nd\n;\n\n\nuse\n(\nd\n);\n  \n// Slice.\n\nThis check implements \nES.63\n\nand \nC.145\n\nfrom the C++ Core Guidelines.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/slicing.html"
  },
  {
    "name": "cppcoreguidelines-special-member-functions",
    "description": "The check finds classes where some but not all of the special member functions\nare defined.\n\nBy default the compiler defines a copy constructor, copy assignment operator,\nmove constructor, move assignment operator and destructor. The default can be\nsuppressed by explicit user-definitions. The relationship between which\nfunctions will be suppressed by definitions of other functions is complicated\nand it is advised that all five are defaulted or explicitly defined.\n\nNote that defining a function with \n=\n \ndelete\n is considered to be a\ndefinition.\n\nThis check implements \nC.21\n\nfrom the C++ Core Guidelines.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowSoleDefaultDtor\nÂ¶\n\n\nWhen set to \ntrue\n (default is \nfalse\n), this check will only trigger on\ndestructors if they are defined and not defaulted.\n\n\nstruct\n \nA\n \n{\n \n// This is fine.\n\n\n  \nvirtual\n \n~\nA\n()\n \n=\n \ndefault\n;\n\n\n};\n\n\n\nstruct\n \nB\n \n{\n \n// This is not fine.\n\n\n  \n~\nB\n()\n \n{}\n\n\n};\n\n\n\nstruct\n \nC\n \n{\n\n\n  \n// This is not checked, because the destructor might be defaulted in\n\n\n  \n// another translation unit.\n\n\n  \n~\nC\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowMissingMoveFunctions\nÂ¶\n\n\nWhen set to \ntrue\n (default is \nfalse\n), this check doesnât flag classes\nwhich define no move operations at all. It still flags classes which define\nonly one of either move constructor or move assignment operator. With this\noption enabled, the following class wonât be flagged:\n\n\nstruct\n \nA\n \n{\n\n\n  \nA\n(\nconst\n \nA\n&\n);\n\n\n  \nA\n&\n \noperator\n=\n(\nconst\n \nA\n&\n);\n\n\n  \n~\nA\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowMissingMoveFunctionsWhenCopyIsDeleted\nÂ¶\n\n\nWhen set to \ntrue\n (default is \nfalse\n), this check doesnât flag classes\nwhich define deleted copy operations but donât define move operations. This\nflag is related to Google C++ Style Guide \nCopyable and Movable Types\n.\nWith this option enabled, the following class wonât be flagged:\n\n\nstruct\n \nA\n \n{\n\n\n  \nA\n(\nconst\n \nA\n&\n)\n \n=\n \ndelete\n;\n\n\n  \nA\n&\n \noperator\n=\n(\nconst\n \nA\n&\n)\n \n=\n \ndelete\n;\n\n\n  \n~\nA\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowImplicitlyDeletedCopyOrMove\nÂ¶\n\n\nWhen set to \ntrue\n (default is \nfalse\n), this check doesnât flag classes\nwhich implicitly delete copy or move operations.\nWith this option enabled, the following class wonât be flagged:\n\n\nstruct\n \nA\n \n:\n \nboost\n::\nnoncopyable\n \n{\n\n\n  \n~\nA\n()\n \n{\n \nstd\n::\ncout\n \n<<\n \n\"dtor\n\\n\n\"\n;\n \n}\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings for classes defined\ninside macros. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"
  },
  {
    "name": "cppcoreguidelines-use-enum-class",
    "description": "Finds unscoped (non-class) \nenum\n declarations and suggests using\n\nenum\n \nclass\n instead.\n\nThis check implements \nEnum.3\n\nfrom the C++ Core Guidelines.â\n\nExample:\n\nenum\n \nE\n \n{};\n        \n// use \"enum class E {};\" instead\n\n\nenum\n \nclass\n \nE\n \n{};\n  \n// OK\n\n\n\nstruct\n \nS\n \n{\n\n\n    \nenum\n \nE\n \n{};\n    \n// use \"enum class E {};\" instead\n\n\n                  \n// OK with option IgnoreUnscopedEnumsInClasses\n\n\n};\n\n\n\nnamespace\n \nN\n \n{\n\n\n    \nenum\n \nE\n \n{};\n    \n// use \"enum class E {};\" instead\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreUnscopedEnumsInClasses\nÂ¶\n\n\nWhen \ntrue\n, ignores unscoped \nenum\n declarations in classes.\nDefault is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/use-enum-class.html"
  },
  {
    "name": "cppcoreguidelines-virtual-class-destructor",
    "description": "Finds virtual classes whose destructor is neither public and virtual\nnor protected and non-virtual. A virtual classâs destructor should be specified\nin one of these ways to prevent undefined behavior.\n\nThis check implements\n\nC.35\n\nfrom the C++ Core Guidelines.\n\nNote that this check will diagnose a class with a virtual method regardless of\nwhether the class is used as a base class or not.\n\nFixes are available for user-declared and implicit destructors that are either\npublic and non-virtual or protected and virtual. No fixes are offered for\nprivate destructors. There, the decision whether to make them private and\nvirtual or protected and non-virtual depends on the use case and is thus left\nto the user.\n\nExample\nÂ¶\n\n\nFor example, the following classes/structs get flagged by the check since they\nviolate guideline \nC.35\n:\n\n\nstruct\n \nFoo\n \n{\n        \n// NOK, protected destructor should not be virtual\n\n\n  \nvirtual\n \nvoid\n \nf\n();\n\n\nprotected\n:\n\n\n  \nvirtual\n \n~\nFoo\n(){}\n\n\n};\n\n\n\nclass\n \nBar\n \n{\n         \n// NOK, public destructor should be virtual\n\n\n  \nvirtual\n \nvoid\n \nf\n();\n\n\npublic\n:\n\n\n  \n~\nBar\n(){}\n\n\n};\n\n\n\n\n\n\nThis would be rewritten to look like this:\n\n\nstruct\n \nFoo\n \n{\n        \n// OK, destructor is not virtual anymore\n\n\n  \nvirtual\n \nvoid\n \nf\n();\n\n\nprotected\n:\n\n\n  \n~\nFoo\n(){}\n\n\n};\n\n\n\nclass\n \nBar\n \n{\n         \n// OK, destructor is now virtual\n\n\n  \nvirtual\n \nvoid\n \nf\n();\n\n\npublic\n:\n\n\n  \nvirtual\n \n~\nBar\n(){}\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"
  },
  {
    "name": "darwin-avoid-spinlock",
    "description": "Finds usages of \nOSSpinlock\n, which is deprecated due to potential livelock\nproblems.\n\nThis check will detect following function invocations:\n\nOSSpinlockLock\n\n\nOSSpinlockTry\n\n\nOSSpinlockUnlock\n\nThe corresponding information about the problem of \nOSSpinlock\n: \nhttps://blog.postmates.com/why-spinlocks-are-bad-on-ios-b69fc5221058",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/darwin/avoid-spinlock.html"
  },
  {
    "name": "darwin-dispatch-once-nonstatic",
    "description": "Finds declarations of \ndispatch_once_t\n variables without static or global\nstorage. The behavior of using \ndispatch_once_t\n predicates with automatic or\ndynamic storage is undefined by libdispatch, and should be avoided.\n\nIt is a common pattern to have functions initialize internal static or global\ndata once when the function runs, but programmers have been known to miss the\nstatic on the \ndispatch_once_t\n predicate, leading to an uninitialized flag\nvalue at the mercy of the stack.\n\nProgrammers have also been known to make \ndispatch_once_t\n variables be\nmembers of structs or classes, with the intent to lazily perform some expensive\nstruct or class member initialization only once; however, this violates the\nlibdispatch requirements.\n\nSee the discussion section of\n\nAppleâs dispatch_once documentation\n\nfor more information.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/darwin/dispatch-once-nonstatic.html"
  },
  {
    "name": "fuchsia-default-arguments-calls",
    "description": "Warns if a function or method is called with default arguments.\n\nFor example, given the declaration:\n\nint\n \nfoo\n(\nint\n \nvalue\n \n=\n \n5\n)\n \n{\n \nreturn\n \nvalue\n;\n \n}\n\nA function call expression that uses a default argument will be diagnosed.\nCalling it without defaults will not cause a warning:\n\nfoo\n();\n  \n// warning\n\n\nfoo\n(\n0\n);\n \n// no warning\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/default-arguments-calls.html"
  },
  {
    "name": "fuchsia-default-arguments-declarations",
    "description": "Warns if a function or method is declared with default parameters.\n\nFor example, the declaration:\n\nint\n \nfoo\n(\nint\n \nvalue\n \n=\n \n5\n)\n \n{\n \nreturn\n \nvalue\n;\n \n}\n\nwill cause a warning.\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/default-arguments-declarations.html"
  },
  {
    "name": "fuchsia-overloaded-operator",
    "description": "Warns if an operator is overloaded, except for the assignment (copy and move)\noperators.\n\nFor example:\n\nint\n \noperator\n+\n(\nint\n);\n     \n// Warning\n\n\n\nB\n \n&\noperator\n=\n(\nconst\n \nB\n \n&\nOther\n);\n  \n// No warning\n\n\nB\n \n&\noperator\n=\n(\nB\n \n&&\nOther\n)\n \n// No warning\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/overloaded-operator.html"
  },
  {
    "name": "fuchsia-statically-constructed-objects",
    "description": "Warns if global, non-trivial objects with static storage are constructed,\nunless the object is statically initialized with a \nconstexpr\n constructor\nor has no explicit constructor.\n\nFor example:\n\nclass\n \nA\n \n{};\n\n\n\nclass\n \nB\n \n{\n\n\npublic\n:\n\n\n  \nB\n(\nint\n \nVal\n)\n \n:\n \nVal\n(\nVal\n)\n \n{}\n\n\nprivate\n:\n\n\n  \nint\n \nVal\n;\n\n\n};\n\n\n\nclass\n \nC\n \n{\n\n\npublic\n:\n\n\n  \nconstexpr\n \nC\n(\nint\n \nVal\n)\n \n:\n \nVal\n(\nVal\n)\n \n{}\n\n\n  \nC\n(\nint\n \nVal1\n,\n \nint\n \nVal2\n)\n \n:\n \nVal\n(\nVal1\n+\nVal2\n)\n \n{}\n\n\n\nprivate\n:\n\n\n  \nint\n \nVal\n;\n\n\n};\n\n\n\nstatic\n \nA\n \na\n;\n         \n// No warning, as there is no explicit constructor\n\n\nstatic\n \nC\n \nc\n(\n0\n);\n      \n// No warning, as constructor is constexpr\n\n\n\nstatic\n \nB\n \nb\n(\n0\n);\n      \n// Warning, as constructor is not constexpr\n\n\nstatic\n \nC\n \nc2\n(\n0\n,\n \n1\n);\n  \n// Warning, as constructor is not constexpr\n\n\n\nstatic\n \nint\n \ni\n;\n       \n// No warning, as it is trivial\n\n\n\nextern\n \nint\n \nget_i\n();\n\n\nstatic\n \nC\n \nc3\n(\nget_i\n());\n// Warning, as the constructor is dynamically initialized\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/statically-constructed-objects.html"
  },
  {
    "name": "fuchsia-temporary-objects",
    "description": "Warns on construction of specific temporary objects in the Zircon kernel.\nIf the object should be flagged, the fully qualified type name must be\nexplicitly passed to the check.\n\nFor example, given the list of classes âFooâ and âNS::Barâ, all of the\nfollowing will trigger the warning:\n\nFoo\n();\n\n\nFoo\n \nF\n \n=\n \nFoo\n();\n\n\nfunc\n(\nFoo\n());\n\n\n\nnamespace\n \nNS\n \n{\n\n\n\nBar\n();\n\n\n\n}\n\nWith the same list, the following will not trigger the warning:\n\nFoo\n \nF\n;\n                 \n// Non-temporary construction okay\n\n\nFoo\n \nF\n(\nparam\n);\n          \n// Non-temporary construction okay\n\n\nFoo\n \n*\nF\n \n=\n \nnew\n \nFoo\n();\n    \n// New construction okay\n\n\n\nBar\n();\n                 \n// Not NS::Bar, so okay\n\n\nNS\n::\nBar\n \nB\n;\n             \n// Non-temporary construction okay\n\nNote that objects must be explicitly specified in order to be flagged,\nand so objects that inherit a specified object will not be flagged.\n\nThis check matches temporary objects without regard for inheritance and so a\nprohibited base class type does not similarly prohibit derived class types.\n\nclass\n \nDerived\n \n:\n \nFoo\n \n{}\n \n// Derived is not explicitly disallowed\n\n\nDerived\n();\n             \n// and so temporary construction is okay\n\nOptions\nÂ¶\n\n\n\n\n\n\nNames\nÂ¶\n\n\nA semi-colon-separated list of fully-qualified names of C++ classes that\nshould not be constructed as temporaries. Default is empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/temporary-objects.html"
  },
  {
    "name": "fuchsia-trailing-return",
    "description": "Functions that have trailing returns are disallowed, except for those using\n\ndecltype\n specifiers and lambda with otherwise unutterable return types.\n\nFor example:\n\n// No warning\n\n\nint\n \nadd_one\n(\nconst\n \nint\n \narg\n)\n \n{\n \nreturn\n \narg\n;\n \n}\n\n\n\n// Warning\n\n\nauto\n \nget_add_one\n()\n \n->\n \nint\n \n(\n*\n)(\nconst\n \nint\n)\n \n{\n\n\n  \nreturn\n \nadd_one\n;\n\n\n}\n\nExceptions are made for lambdas and \ndecltype\n specifiers:\n\n// No warning\n\n\nauto\n \nlambda\n \n=\n \n[](\ndouble\n \nx\n,\n \ndouble\n \ny\n)\n \n->\n \ndouble\n \n{\nreturn\n \nx\n \n+\n \ny\n;};\n\n\n\n// No warning\n\n\ntemplate\n \n<\ntypename\n \nT1\n,\n \ntypename\n \nT2\n>\n\n\nauto\n \nfn\n(\nconst\n \nT1\n \n&\nlhs\n,\n \nconst\n \nT2\n \n&\nrhs\n)\n \n->\n \ndecltype\n(\nlhs\n \n+\n \nrhs\n)\n \n{\n\n\n  \nreturn\n \nlhs\n \n+\n \nrhs\n;\n\n\n}\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/trailing-return.html"
  },
  {
    "name": "fuchsia-virtual-inheritance",
    "description": "Warns if classes are defined with virtual inheritance.\n\nFor example, classes should not be defined with virtual inheritance:\n\nclass\n \nB\n \n:\n \npublic\n \nvirtual\n \nA\n \n{};\n   \n// warning\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/fuchsia/virtual-inheritance.html"
  },
  {
    "name": "google-build-explicit-make-pair",
    "description": "Check that \nmake_pair\nâs template arguments are deduced.\n\nG++ 4.6 in C++11 mode fails badly if \nmake_pair\nâs template arguments are\nspecified explicitly, and such use isnât intended in any case.\n\nCorresponding cpplint.py check name: \nbuild/explicit_make_pair\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-explicit-make-pair.html"
  },
  {
    "name": "google-build-using-namespace",
    "description": "Finds \nusing\n \nnamespace\n directives.\n\nThe check implements the following rule of the\n\nGoogle C++ Style Guide\n:\n\nYou may not use a using-directive to make all names from a namespace\navailable.\n\n// Forbidden -- This pollutes the namespace.\n\n\nusing\n \nnamespace\n \nfoo\n;\n\nCorresponding cpplint.py check name: \nbuild/namespaces\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-using-namespace.html"
  },
  {
    "name": "google-default-arguments",
    "description": "Checks that default arguments are not given for virtual methods.\n\nSee \nhttps://google.github.io/styleguide/cppguide.html#Default_Arguments",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/default-arguments.html"
  },
  {
    "name": "google-explicit-constructor",
    "description": "Checks that constructors callable with a single argument and conversion\noperators are marked explicit to avoid the risk of unintentional implicit\nconversions.\n\nConsider this example:\n\nstruct\n \nS\n \n{\n\n\n  \nint\n \nx\n;\n\n\n  \noperator\n \nbool\n()\n \nconst\n \n{\n \nreturn\n \ntrue\n;\n \n}\n\n\n};\n\n\n\nbool\n \nf\n()\n \n{\n\n\n  \nS\n \na\n{\n1\n};\n\n\n  \nS\n \nb\n{\n2\n};\n\n\n  \nreturn\n \na\n \n==\n \nb\n;\n\n\n}\n\nThe function will return \ntrue\n, since the objects are implicitly converted\nto \nbool\n before comparison, which is unlikely to be the intent.\n\nThe check will suggest inserting \nexplicit\n before the constructor or\nconversion operator declaration. However, copy and move constructors should not\nbe explicit, as well as constructors taking a single \ninitializer_list\n\nargument.\n\nThis code:\n\nstruct\n \nS\n \n{\n\n\n  \nS\n(\nint\n \na\n);\n\n\n  \nexplicit\n \nS\n(\nconst\n \nS\n&\n);\n\n\n  \noperator\n \nbool\n()\n \nconst\n;\n\n\n  \n...\n\nwill become\n\nstruct\n \nS\n \n{\n\n\n  \nexplicit\n \nS\n(\nint\n \na\n);\n\n\n  \nS\n(\nconst\n \nS\n&\n);\n\n\n  \nexplicit\n \noperator\n \nbool\n()\n \nconst\n;\n\n\n  \n...\n\nSee \nhttps://google.github.io/styleguide/cppguide.html#Explicit_Constructors",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/explicit-constructor.html"
  },
  {
    "name": "google-global-names-in-headers",
    "description": "Flag global namespace pollution in header files. Right now it only triggers on\n\nusing\n declarations and directives.\n\nThe relevant style guide section is\n\nhttps://google.github.io/styleguide/cppguide.html#Namespaces\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/global-names-in-headers.html"
  },
  {
    "name": "google-objc-avoid-nsobject-new",
    "description": "Finds calls to \n+new\n or overrides of it, which are prohibited by the\nGoogle Objective-C style guide.\n\nThe Google Objective-C style guide forbids calling \n+new\n or overriding it in\nclass implementations, preferring \n+alloc\n and \n-init\n methods to\ninstantiate objects.\n\nAn example:\n\nNSDate\n \n*\nnow\n \n=\n \n[\nNSDate\n \nnew\n];\n\n\nFoo\n \n*\nbar\n \n=\n \n[\nFoo\n \nnew\n];\n\nInstead, code should use \n+alloc\n/\n-init\n or class factory methods.\n\nNSDate\n \n*\nnow\n \n=\n \n[\nNSDate\n \ndate\n];\n\n\nFoo\n \n*\nbar\n \n=\n \n[[\nFoo\n \nalloc\n]\n \ninit\n];\n\nThis check corresponds to the Google Objective-C Style Guide rule\n\nDo Not Use +new\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/objc-avoid-nsobject-new.html"
  },
  {
    "name": "google-objc-avoid-throwing-exception",
    "description": "Finds uses of throwing exceptions usages in Objective-C files.\n\nFor the same reason as the Google C++ style guide, we prefer not throwing\nexceptions from Objective-C code.\n\nThe corresponding C++ style guide rule:\n\nhttps://google.github.io/styleguide/cppguide.html#Exceptions\n\nInstead, prefer passing in \nNSError\n \n**\n and return \nBOOL\n to indicate\nsuccess or failure.\n\nA counterexample:\n\n-\n \n(\nvoid\n)\nreadFile\n \n{\n\n\n  \nif\n \n([\nself\n \nisError\n])\n \n{\n\n\n    \n@throw\n \n[\nNSException\n \nexceptionWithName\n:\n...];\n\n\n  \n}\n\n\n}\n\nInstead, returning an error via \nNSError\n \n**\n is preferred:\n\n-\n \n(\nBOOL\n)\nreadFileWithError:\n(\nNSError\n \n**\n)\nerror\n \n{\n\n\n  \nif\n \n([\nself\n \nisError\n])\n \n{\n\n\n    \n*\nerror\n \n=\n \n[\nNSError\n \nerrorWithDomain\n:\n...];\n\n\n    \nreturn\n \nNO\n;\n\n\n  \n}\n\n\n  \nreturn\n \nYES\n;\n\n\n}\n\nThe corresponding style guide rule:\n\nhttps://google.github.io/styleguide/objcguide.html#avoid-throwing-exceptions",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/objc-avoid-throwing-exception.html"
  },
  {
    "name": "google-objc-function-naming",
    "description": "Finds function declarations in Objective-C files that do not follow the pattern\ndescribed in the Google Objective-C Style Guide.\n\nThe corresponding style guide rule can be found here:\n\nhttps://google.github.io/styleguide/objcguide.html#function-names\n\nAll function names should be in Pascal case. Functions whose storage class is\nnot static should have an appropriate prefix.\n\nThe following code sample does not follow this pattern:\n\nstatic\n \nbool\n \nis_positive\n(\nint\n \ni\n)\n \n{\n \nreturn\n \ni\n \n>\n \n0\n;\n \n}\n\n\nbool\n \nIsNegative\n(\nint\n \ni\n)\n \n{\n \nreturn\n \ni\n \n<\n \n0\n;\n \n}\n\nThe sample above might be corrected to the following code:\n\nstatic\n \nbool\n \nIsPositive\n(\nint\n \ni\n)\n \n{\n \nreturn\n \ni\n \n>\n \n0\n;\n \n}\n\n\nbool\n \n*\nABCIsNegative\n(\nint\n \ni\n)\n \n{\n \nreturn\n \ni\n \n<\n \n0\n;\n \n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/objc-function-naming.html"
  },
  {
    "name": "google-objc-global-variable-declaration",
    "description": "Finds global variable declarations in Objective-C files that do not follow the\npattern of variable names in Googleâs Objective-C Style Guide.\n\nThe corresponding style guide rule:\n\nhttps://google.github.io/styleguide/objcguide.html#variable-names\n\nAll the global variables should follow the pattern of \ng[A-Z].*\n (variables)\nor \nk[A-Z].*\n (constants). The check will suggest a variable name that\nfollows the pattern if it can be inferred from the original name.\n\nFor code:\n\nstatic\n \nNSString\n*\n \nmyString\n \n=\n \n@\"hello\"\n;\n\nThe fix will be:\n\nstatic\n \nNSString\n*\n \ngMyString\n \n=\n \n@\"hello\"\n;\n\nAnother example of constant:\n\nstatic\n \nNSString\n*\n \nconst\n \nmyConstString\n \n=\n \n@\"hello\"\n;\n\nThe fix will be:\n\nstatic\n \nNSString\n*\n \nconst\n \nkMyConstString\n \n=\n \n@\"hello\"\n;\n\nHowever for code that prefixed with non-alphabetical characters like:\n\nstatic\n \nNSString\n*\n \n__anotherString\n \n=\n \n@\"world\"\n;\n\nThe check will give a warning message but will not be able to suggest\na fix. The user needs to fix it on their own.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/objc-global-variable-declaration.html"
  },
  {
    "name": "google-readability-avoid-underscore-in-googletest-name",
    "description": "Checks whether there are underscores in googletest test suite names and test\nnames in test macros:\n\nTEST\n\n\nTEST_F\n\n\nTEST_P\n\n\nTYPED_TEST\n\n\nTYPED_TEST_P\n\nThe \nFRIEND_TEST\n macro is not included.\n\nFor example:\n\nTEST\n(\nTestSuiteName\n,\n \nIllegal_TestName\n)\n \n{}\n\n\nTEST\n(\nIllegal_TestSuiteName\n,\n \nTestName\n)\n \n{}\n\nwould trigger the check. \nUnderscores are not allowed\n in test suite name nor\ntest names.\n\nThe \nDISABLED_\n prefix, which may be used to\n\ndisable test suites and individual tests\n, is removed from the test suite\nname and test name before checking for underscores.\n\nThis check does not propose any fixes.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/readability-avoid-underscore-in-googletest-name.html"
  },
  {
    "name": "google-readability-todo",
    "description": "Finds TODO comments without a username or bug number.\n\nThe relevant style guide section is\n\nhttps://google.github.io/styleguide/cppguide.html#TODO_Comments\n.\n\nCorresponding cpplint.py check: \nreadability/todo\n\nOptions\nÂ¶\n\n\n\n\n\n\nStyle\nÂ¶\n\n\nA string specifying the TODO style for fix-it hints. Accepted values are\n\nHyphen\n and \nParentheses\n. Default is \nHyphen\n.\n\n\n\n\nHyphen\n will format the fix-it as: \n//\n \nTODO:\n \nusername\n \n-\n \ndetails\n.\n\n\nParentheses\n will format the fix-it as: \n//\n \nTODO(username):\n \ndetails\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/readability-todo.html"
  },
  {
    "name": "google-runtime-float",
    "description": "Finds uses of \nlong\n \ndouble\n and suggests against their use due to lack of\nportability.\n\nThe corresponding style guide rule:\n\nhttps://google.github.io/styleguide/cppguide.html#Floating-Point_Types",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/runtime-float.html"
  },
  {
    "name": "google-runtime-int",
    "description": "Finds uses of \nshort\n, \nlong\n and \nlong\n \nlong\n and suggest replacing them\nwith \nu?intXX(_t)?\n.\n\nThe corresponding style guide rule:\n\nhttps://google.github.io/styleguide/cppguide.html#Integer_Types\n.\n\nCorresponding cpplint.py check: \nruntime/int\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nUnsignedTypePrefix\nÂ¶\n\n\nA string specifying the unsigned type prefix. Default is \nuint\n.\n\n\n\n\n\n\n\n\nSignedTypePrefix\nÂ¶\n\n\nA string specifying the signed type prefix. Default is \nint\n.\n\n\n\n\n\n\n\n\nTypeSuffix\nÂ¶\n\n\nA string specifying the type suffix. Default is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/runtime-int.html"
  },
  {
    "name": "google-runtime-operator",
    "description": "Finds overloads of unary \noperator\n \n&\n.\n\nhttps://google.github.io/styleguide/cppguide.html#Operator_Overloading\n\nCorresponding cpplint.py check name: \nruntime/operator\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/runtime-operator.html"
  },
  {
    "name": "google-upgrade-googletest-case",
    "description": "Finds uses of deprecated Google Test version 1.9 APIs with names containing\n\ncase\n and replaces them with equivalent APIs with \nsuite\n.\n\nAll names containing \ncase\n are being replaced to be consistent with the\nmeanings of âtest caseâ and âtest suiteâ as used by the International\nSoftware Testing Qualifications Board and ISO 29119.\n\nThe new names are a part of Google Test version 1.9 (release pending). It is\nrecommended that users update their dependency to version 1.9 and then use this\ncheck to remove deprecated names.\n\nThe affected APIs are:\n\nMember functions of \ntesting::Test\n, \ntesting::TestInfo\n,\n\ntesting::TestEventListener\n, \ntesting::UnitTest\n, and any type\ninheriting from these types\n\n\nThe macros \nTYPED_TEST_CASE\n, \nTYPED_TEST_CASE_P\n,\n\nREGISTER_TYPED_TEST_CASE_P\n, and \nINSTANTIATE_TYPED_TEST_CASE_P\n\n\nThe type alias \ntesting::TestCase\n\nExamples of fixes created by this check:\n\nclass\n \nFooTest\n \n:\n \npublic\n \ntesting\n::\nTest\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nvoid\n \nSetUpTestCase\n();\n\n\n  \nstatic\n \nvoid\n \nTearDownTestCase\n();\n\n\n};\n\n\n\nTYPED_TEST_CASE\n(\nBarTest\n,\n \nBarTypes\n);\n\nbecomes\n\nclass\n \nFooTest\n \n:\n \npublic\n \ntesting\n::\nTest\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nvoid\n \nSetUpTestSuite\n();\n\n\n  \nstatic\n \nvoid\n \nTearDownTestSuite\n();\n\n\n};\n\n\n\nTYPED_TEST_SUITE\n(\nBarTest\n,\n \nBarTypes\n);\n\nFor better consistency of user code, the check renames both virtual and\nnon-virtual member functions with matching names in derived types. The check\ntries to provide only a warning when a fix cannot be made safely, as is the case\nwith some template and macro uses.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/upgrade-googletest-case.html"
  },
  {
    "name": "hicpp-exception-baseclass",
    "description": "Ensure that every value that in a \nthrow\n expression is an instance of\n\nstd::exception\n.\n\nThis enforces \nrule 15.1\n\nof the High Integrity C++ Coding Standard.\n\nclass\n \ncustom_exception\n \n{};\n\n\n\nvoid\n \nthrowing\n()\n \nnoexcept\n(\nfalse\n)\n \n{\n\n\n  \n// Problematic throw expressions.\n\n\n  \nthrow\n \nint\n(\n42\n);\n\n\n  \nthrow\n \ncustom_exception\n();\n\n\n}\n\n\n\nclass\n \nmathematical_error\n \n:\n \npublic\n \nstd\n::\nexception\n \n{};\n\n\n\nvoid\n \nthrowing2\n()\n \nnoexcept\n(\nfalse\n)\n \n{\n\n\n  \n// These kind of throws are ok.\n\n\n  \nthrow\n \nmathematical_error\n();\n\n\n  \nthrow\n \nstd\n::\nruntime_error\n();\n\n\n  \nthrow\n \nstd\n::\nexception\n();\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/hicpp/exception-baseclass.html"
  },
  {
    "name": "hicpp-ignored-remove-result",
    "description": "Ensure that the result of \nstd::remove\n, \nstd::remove_if\n and \nstd::unique\n\nare not ignored according to\n\nrule 17.5.1\n.\n\nThe mutating algorithms \nstd::remove\n, \nstd::remove_if\n and both overloads\nof \nstd::unique\n operate by swapping or moving elements of the range they are\noperating over. On completion, they return an iterator to the last valid\nelement. In the majority of cases the correct behavior is to use this result as\nthe first operand in a call to \nstd::erase\n.\n\nThis check is a subset of \nbugprone-unused-return-value\n\nand depending on used options it can be superfluous to enable both checks.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowCastToVoid\nÂ¶\n\n\nControls whether casting return values to \nvoid\n is permitted. Default: \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/hicpp/ignored-remove-result.html"
  },
  {
    "name": "hicpp-multiway-paths-covered",
    "description": "This check discovers situations where code paths are not fully-covered.\nIt furthermore suggests using \nif\n instead of \nswitch\n if the code\nwill be more clear.\nThe \nrule 6.1.2\n\nand \nrule 6.1.4\n\nof the High Integrity C++ Coding Standard are enforced.\n\nif-else\n \nif\n chains that miss a final \nelse\n branch might lead to\nunexpected program execution and be the result of a logical error.\nIf the missing \nelse\n branch is intended you can leave it empty with\na clarifying comment.\nThis warning can be noisy on some code bases, so it is disabled by default.\n\nvoid\n \nf1\n()\n \n{\n\n\n  \nint\n \ni\n \n=\n \ndetermineTheNumber\n();\n\n\n\n   \nif\n(\ni\n \n>\n \n0\n)\n \n{\n\n\n     \n// Some Calculation\n\n\n   \n}\n \nelse\n \nif\n \n(\ni\n \n<\n \n0\n)\n \n{\n\n\n     \n// Precondition violated or something else.\n\n\n   \n}\n\n\n   \n// ...\n\n\n}\n\nSimilar arguments hold for \nswitch\n statements which do not cover all\npossible code paths.\n\n// The missing default branch might be a logical error. It can be kept empty\n\n\n// if there is nothing to do, making it explicit.\n\n\nvoid\n \nf2\n(\nint\n \ni\n)\n \n{\n\n\n  \nswitch\n \n(\ni\n)\n \n{\n\n\n  \ncase\n \n0\n:\n \n// something\n\n\n    \nbreak\n;\n\n\n  \ncase\n \n1\n:\n \n// something else\n\n\n    \nbreak\n;\n\n\n  \n}\n\n\n  \n// All other numbers?\n\n\n}\n\n\n\n// Violates this rule as well, but already emits a compiler warning (-Wswitch).\n\n\nenum\n \nColor\n \n{\n \nRed\n,\n \nGreen\n,\n \nBlue\n,\n \nYellow\n \n};\n\n\nvoid\n \nf3\n(\nenum\n \nColor\n \nc\n)\n \n{\n\n\n  \nswitch\n \n(\nc\n)\n \n{\n\n\n  \ncase\n \nRed\n:\n \n// We can't drive for now.\n\n\n    \nbreak\n;\n\n\n  \ncase\n \nGreen\n:\n  \n// We are allowed to drive.\n\n\n    \nbreak\n;\n\n\n  \n}\n\n\n  \n// Other cases missing\n\n\n}\n\nThe \nrule 6.1.4\n\nrequires every \nswitch\n statement to have at least two \ncase\n labels other than a \ndefault\n label.\nOtherwise, the \nswitch\n could be better expressed with an \nif\n statement.\nDegenerated \nswitch\n statements without any labels are caught as well.\n\n// Degenerated switch that could be better written as `if`\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\nswitch\n(\ni\n)\n \n{\n\n\n  \ncase\n \n1\n:\n \n// do something here\n\n\n  \ndefault\n:\n \n// do something else here\n\n\n}\n\n\n\n// Should rather be the following:\n\n\nif\n \n(\ni\n \n==\n \n1\n)\n \n{\n\n\n  \n// do something here\n\n\n}\n\n\nelse\n \n{\n\n\n  \n// do something here\n\n\n}\n\n// A completely degenerated switch will be diagnosed.\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\nswitch\n(\ni\n)\n \n{}\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnMissingElse\nÂ¶\n\n\nBoolean flag that activates a warning for missing \nelse\n branches.\nDefault is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/hicpp/multiway-paths-covered.html"
  },
  {
    "name": "hicpp-no-assembler",
    "description": "Checks for assembler statements. Use of inline assembly should be avoided since\nit restricts the portability of the code.\n\nThis enforces \nrule 7.5.1\n\nof the High Integrity C++ Coding Standard.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/hicpp/no-assembler.html"
  },
  {
    "name": "hicpp-signed-bitwise",
    "description": "Finds uses of bitwise operations on signed integer types, which may lead to\nundefined or implementation defined behavior.\n\nThe according rule is defined in the \nHigh Integrity C++ Standard, Section 5.6.1\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnorePositiveIntegerLiterals\nÂ¶\n\n\nIf this option is set to \ntrue\n, the check will not warn on bitwise operations with positive integer literals, e.g. \n~0\n, \n2 << 1\n, etc.\nDefault value is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/hicpp/signed-bitwise.html"
  },
  {
    "name": "linuxkernel-must-check-errs",
    "description": "Checks Linux kernel code to see if it uses the results from the functions in\n\nlinux/err.h\n. Also checks to see if code uses the results from functions\nthat directly return a value from one of these error functions.\n\nThis is important in the Linux kernel because \nERR_PTR\n, \nPTR_ERR\n,\n\nIS_ERR\n, \nIS_ERR_OR_NULL\n, \nERR_CAST\n, and \nPTR_ERR_OR_ZERO\n return\nvalues must be checked, since positive pointers and negative error codes are\nbeing used in the same context. These functions are marked with\n\n__attribute__((warn_unused_result))\n, but some kernel versions do not have\nthis warning enabled for clang.\n\nExamples:\n\n/* Trivial unused call to an ERR function */\n\n\nPTR_ERR_OR_ZERO\n(\nsome_function_call\n());\n\n\n\n/* A function that returns ERR_PTR. */\n\n\nvoid\n \n*\nfn\n()\n \n{\n \nERR_PTR\n(\n-\nEINVAL\n);\n \n}\n\n\n\n/* An invalid use of fn. */\n\n\nfn\n();",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/linuxkernel/must-check-errs.html"
  },
  {
    "name": "llvm-header-guard",
    "description": "Finds and fixes header guards that do not adhere to LLVM style.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/header-guard.html"
  },
  {
    "name": "llvm-include-order",
    "description": "Checks the correct order of \n#includes\n.\n\nSee \nhttps://llvm.org/docs/CodingStandards.html#include-style",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/include-order.html"
  },
  {
    "name": "llvm-namespace-comment",
    "description": "google-readability-namespace-comments\n redirects here as an alias for this\ncheck.\n\nChecks that long namespaces have a closing comment.\n\nhttps://llvm.org/docs/CodingStandards.html#namespace-indentation\n\nhttps://google.github.io/styleguide/cppguide.html#Namespaces\n\nnamespace\n \nn1\n \n{\n\n\nvoid\n \nf\n();\n\n\n}\n\n\n\n// becomes\n\n\n\nnamespace\n \nn1\n \n{\n\n\nvoid\n \nf\n();\n\n\n}\n  \n// namespace n1\n\nOptions\nÂ¶\n\n\n\n\n\n\nShortNamespaceLines\nÂ¶\n\n\nRequires the closing brace of the namespace definition to be followed by a\nclosing comment if the body of the namespace has more than\n\nShortNamespaceLines\n lines of code. The value is an unsigned integer that\ndefaults to \n1U\n.\n\n\n\n\n\n\n\n\nSpacesBeforeComments\nÂ¶\n\n\nAn unsigned integer specifying the number of spaces before the comment\nclosing a namespace definition. Default is \n1U\n.\n\n\n\n\n\n\n\n\nAllowOmittingNamespaceComments\nÂ¶\n\n\nWhen \ntrue\n, the check will accept if no namespace comment is present.\nThe check will only fail if the specified namespace comment is different\nthan expected. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/namespace-comment.html"
  },
  {
    "name": "llvm-prefer-isa-or-dyn-cast-in-conditionals",
    "description": "Looks at conditionals and finds and replaces cases of \ncast<>\n,\nwhich will assert rather than return a null pointer, and\n\ndyn_cast<>\n where the return value is not captured. Additionally,\nfinds and replaces cases that match the pattern \nvar\n \n&&\n\n\nisa<X>(var)\n, where \nvar\n is evaluated twice.\n\n// Finds these:\n\n\nif\n \n(\nauto\n \nx\n \n=\n \ncast\n<\nX\n>\n(\ny\n))\n \n{}\n\n\n// is replaced by:\n\n\nif\n \n(\nauto\n \nx\n \n=\n \ndyn_cast\n<\nX\n>\n(\ny\n))\n \n{}\n\n\n\nif\n \n(\ncast\n<\nX\n>\n(\ny\n))\n \n{}\n\n\n// is replaced by:\n\n\nif\n \n(\nisa\n<\nX\n>\n(\ny\n))\n \n{}\n\n\n\nif\n \n(\ndyn_cast\n<\nX\n>\n(\ny\n))\n \n{}\n\n\n// is replaced by:\n\n\nif\n \n(\nisa\n<\nX\n>\n(\ny\n))\n \n{}\n\n\n\nif\n \n(\nvar\n \n&&\n \nisa\n<\nT\n>\n(\nvar\n))\n \n{}\n\n\n// is replaced by:\n\n\nif\n \n(\nisa_and_nonnull\n<\nT\n>\n(\nvar\n.\nfoo\n()))\n \n{}\n\n\n\n// Other cases are ignored, e.g.:\n\n\nif\n \n(\nauto\n \nf\n \n=\n \ncast\n<\nZ\n>\n(\ny\n)\n->\nfoo\n())\n \n{}\n\n\nif\n \n(\ncast\n<\nZ\n>\n(\ny\n)\n->\nfoo\n())\n \n{}\n\n\nif\n \n(\nX\n.\ncast\n(\ny\n))\n \n{}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/prefer-isa-or-dyn-cast-in-conditionals.html"
  },
  {
    "name": "llvm-prefer-register-over-unsigned",
    "description": "Finds historical use of \nunsigned\n to hold vregs and physregs and rewrites\nthem to use \nRegister\n.\n\nCurrently this works by finding all variables of unsigned integer type whose\ninitializer begins with an implicit cast from \nRegister\n to \nunsigned\n.\n\nvoid\n \nexample\n(\nMachineOperand\n \n&\nMO\n)\n \n{\n\n\n  \nunsigned\n \nReg\n \n=\n \nMO\n.\ngetReg\n();\n\n\n  \n...\n\n\n}\n\nbecomes:\n\nvoid\n \nexample\n(\nMachineOperand\n \n&\nMO\n)\n \n{\n\n\n  \nRegister\n \nReg\n \n=\n \nMO\n.\ngetReg\n();\n\n\n  \n...\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/prefer-register-over-unsigned.html"
  },
  {
    "name": "llvm-prefer-static-over-anonymous-namespace",
    "description": "Finds function and variable declarations inside anonymous namespace and\nsuggests replacing them with \nstatic\n declarations.\n\nThe \nLLVM Coding Standards\n\nrecommend keeping anonymous namespaces as small as possible and only use them\nfor class declarations. For functions and variables the \nstatic\n specifier\nshould be preferred for restricting visibility.\n\nFor example non-compliant code:\n\nnamespace\n \n{\n\n\n\nclass\n \nStringSort\n \n{\n\n\npublic\n:\n\n\n  \nStringSort\n(...)\n\n\n  \nbool\n \noperator\n<\n(\nconst\n \nchar\n \n*\nRHS\n)\n \nconst\n;\n\n\n};\n\n\n\n// warning: place method definition outside of an anonymous namespace\n\n\nbool\n \nStringSort\n::\noperator\n<\n(\nconst\n \nchar\n \n*\nRHS\n)\n \nconst\n \n{}\n\n\n\n// warning: prefer using 'static' for restricting visibility\n\n\nvoid\n \nrunHelper\n()\n \n{}\n\n\n\n// warning: prefer using 'static' for restricting visibility\n\n\nint\n \nmyVariable\n \n=\n \n42\n;\n\n\n\n}\n\nShould become:\n\n// Small anonymous namespace for class declaration\n\n\nnamespace\n \n{\n\n\n\nclass\n \nStringSort\n \n{\n\n\npublic\n:\n\n\n  \nStringSort\n(...)\n\n\n  \nbool\n \noperator\n<\n(\nconst\n \nchar\n \n*\nRHS\n)\n \nconst\n;\n\n\n};\n\n\n\n}\n\n\n\n// placed method definition outside of the anonymous namespace\n\n\nbool\n \nStringSort\n::\noperator\n<\n(\nconst\n \nchar\n \n*\nRHS\n)\n \nconst\n \n{}\n\n\n\n// used 'static' instead of an anonymous namespace\n\n\nstatic\n \nvoid\n \nrunHelper\n()\n \n{}\n\n\n\n// used 'static' instead of an anonymous namespace\n\n\nstatic\n \nint\n \nmyVariable\n \n=\n \n42\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowVariableDeclarations\nÂ¶\n\n\nWhen \ntrue\n, allow variable declarations to be in anonymous namespace.\nDefault value is \ntrue\n.\n\n\n\n\n\n\n\n\nAllowMemberFunctionsInClass\nÂ¶\n\n\nWhen \ntrue\n, only methods defined in anonymous namespace outside of the\ncorresponding class will be warned. Default value is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/prefer-static-over-anonymous-namespace.html"
  },
  {
    "name": "llvm-twine-local",
    "description": "Looks for local \nTwine\n variables which are prone to use after frees and\nshould be generally avoided.\n\nstatic\n \nTwine\n \nMoo\n \n=\n \nTwine\n(\n\"bark\"\n)\n \n+\n \n\"bah\"\n;\n\n\n\n// becomes\n\n\n\nstatic\n \nstd\n::\nstring\n \nMoo\n \n=\n \n(\nTwine\n(\n\"bark\"\n)\n \n+\n \n\"bah\"\n).\nstr\n();\n\nThe \nTwine\n does not own the memory of its contents, so it is not\nrecommended to use \nTwine\n created from temporary strings or string literals.\n\nstatic\n \nTwine\n \ngetModuleIdentifier\n(\nStringRef\n \nmoduleName\n)\n \n{\n\n\n  \nreturn\n \nmoduleName\n \n+\n \n\"_module\"\n;\n\n\n}\n\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nTwine\n \nresult\n \n=\n \ngetModuleIdentifier\n(\nstd\n::\nstring\n{\n\"abc\"\n}\n \n+\n \n\"def\"\n);\n\n\n  \n// temporary std::string is destroyed here, result is dangling\n\n\n}\n\nAfter applying this fix-it hints, the code will use \nstd::string\n instead of\n\nTwine\n for local variables. However, \nTwine\n has lots of methods that\nare incompatible with \nstd::string\n, so the user may need to adjust the code\nmanually after applying the fix-it hints.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/twine-local.html"
  },
  {
    "name": "llvm-type-switch-case-types",
    "description": "Finds \nllvm::TypeSwitch::Case\n calls with redundant explicit template\narguments that can be inferred from the lambda parameter type.\n\nThis check identifies two patterns:\n\nRedundant explicit type\n: When the lambda parameter type matches the\n\nCase\n template argument, the explicit type can be removed.\n\n\nAuto parameter with explicit type\n: When a lambda uses \nauto\n but\n\nCase\n has an explicit template argument, suggests using an explicit\ntype in the lambda instead.\n\nExample\nÂ¶\n\n\nllvm\n::\nTypeSwitch\n<\nBase\n \n*\n,\n \nint\n>\n(\nbase\n)\n\n\n    \n.\nCase\n<\nDerivedA\n>\n([](\nDerivedA\n \n*\na\n)\n \n{\n \nreturn\n \n1\n;\n \n})\n \n// Redundant.\n\n\n    \n.\nCase\n<\nDerivedB\n>\n([](\nauto\n \nb\n)\n \n{\n \nreturn\n \n2\n;\n \n});\n     \n// `auto` with explicit type.\n\n\n\n\n\n\nTransforms to:\n\n\nllvm\n::\nTypeSwitch\n<\nBase\n \n*\n,\n \nint\n>\n(\nbase\n)\n\n\n    \n.\nCase\n([](\nDerivedA\n \n*\na\n)\n \n{\n \nreturn\n \n1\n;\n \n})\n       \n// Type inferred from lambda.\n\n\n    \n.\nCase\n<\nDerivedB\n>\n([](\nauto\n \nb\n)\n \n{\n \nreturn\n \n2\n;\n \n});\n \n// Warning only.\n\n\n\n\n\n\nNote: The second case (\nauto\n parameter) only emits a warning without a\nfix-it, because the deduced type of \nauto\n depends on \ndyn_cast\n behavior\nwhich varies between pointer types and MLIR handle types.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/type-switch-case-types.html"
  },
  {
    "name": "llvm-use-new-mlir-op-builder",
    "description": "Checks for uses of MLIRâs old/to be deprecated \nOpBuilder::create<T>\n form\nand suggests using \nT::create\n instead.\n\nExample\nÂ¶\n\n\nbuilder\n.\ncreate\n<\nFooOp\n>\n(\nbuilder\n.\ngetUnknownLoc\n(),\n \n\"baz\"\n);\n\n\n\n\n\n\nTransforms to:\n\n\nFooOp\n::\ncreate\n(\nbuilder\n,\n \nbuilder\n.\ngetUnknownLoc\n(),\n \n\"baz\"\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/use-new-mlir-op-builder.html"
  },
  {
    "name": "llvm-use-ranges",
    "description": "Finds calls to STL library iterator algorithms that could be replaced with\nLLVM range-based algorithms from \nllvm/ADT/STLExtras.h\n.\n\nExample\nÂ¶\n\n\nauto\n \nit\n \n=\n \nstd\n::\nfind\n(\nvec\n.\nbegin\n(),\n \nvec\n.\nend\n(),\n \nvalue\n);\n\n\nbool\n \nall\n \n=\n \nstd\n::\nall_of\n(\nvec\n.\nbegin\n(),\n \nvec\n.\nend\n(),\n\n\n                       \n[](\nint\n \nx\n)\n \n{\n \nreturn\n \nx\n \n>\n \n0\n;\n \n});\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nit\n \n=\n \nllvm\n::\nfind\n(\nvec\n,\n \nvalue\n);\n\n\nbool\n \nall\n \n=\n \nllvm\n::\nall_of\n(\nvec\n,\n \n[](\nint\n \nx\n)\n \n{\n \nreturn\n \nx\n \n>\n \n0\n;\n \n});\n\nSupported algorithms\nÂ¶\n\n\nCalls to the following STL algorithms are checked:\n\n\nstd::accumulate\n,\n\nstd::adjacent_find\n,\n\nstd::all_of\n,\n\nstd::any_of\n,\n\nstd::binary_search\n,\n\nstd::copy_if\n,\n\nstd::copy\n,\n\nstd::count_if\n,\n\nstd::count\n,\n\nstd::equal\n,\n\nstd::fill\n,\n\nstd::find_if_not\n,\n\nstd::find_if\n,\n\nstd::find\n,\n\nstd::for_each\n,\n\nstd::includes\n,\n\nstd::is_sorted\n,\n\nstd::lower_bound\n,\n\nstd::max_element\n,\n\nstd::min_element\n,\n\nstd::mismatch\n,\n\nstd::none_of\n,\n\nstd::partition_point\n,\n\nstd::partition\n,\n\nstd::remove_if\n,\n\nstd::replace_copy_if\n,\n\nstd::replace_copy\n,\n\nstd::replace\n,\n\nstd::search\n,\n\nstd::stable_sort\n,\n\nstd::transform\n,\n\nstd::uninitialized_copy\n,\n\nstd::unique\n,\n\nstd::upper_bound\n.\n\n\nThe check will add the necessary \n#include\n \n\"llvm/ADT/STLExtras.h\"\n directive\nwhen applying fixes.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/use-ranges.html"
  },
  {
    "name": "llvm-use-vector-utils",
    "description": "Finds calls to \nllvm::to_vector\n with \nllvm::map_range\n or\n\nllvm::make_filter_range\n that can be replaced with the more concise\n\nllvm::map_to_vector\n and \nllvm::filter_to_vector\n utilities from\n\nllvm/ADT/SmallVectorExtras.h\n.\n\nThe check will add the necessary \n#include\n \n\"llvm/ADT/SmallVectorExtras.h\"\n\ndirective when applying fixes.\n\nExample\nÂ¶\n\n\nauto\n \nv1\n \n=\n \nllvm\n::\nto_vector\n(\nllvm\n::\nmap_range\n(\ncontainer\n,\n \nfunc\n));\n\n\nauto\n \nv2\n \n=\n \nllvm\n::\nto_vector\n(\nllvm\n::\nmake_filter_range\n(\ncontainer\n,\n \npred\n));\n\n\nauto\n \nv3\n \n=\n \nllvm\n::\nto_vector\n<\n4\n>\n(\nllvm\n::\nmap_range\n(\ncontainer\n,\n \nfunc\n));\n\n\nauto\n \nv4\n \n=\n \nllvm\n::\nto_vector\n<\n4\n>\n(\nllvm\n::\nmake_filter_range\n(\ncontainer\n,\n \npred\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nv1\n \n=\n \nllvm\n::\nmap_to_vector\n(\ncontainer\n,\n \nfunc\n);\n\n\nauto\n \nv2\n \n=\n \nllvm\n::\nfilter_to_vector\n(\ncontainer\n,\n \npred\n);\n\n\nauto\n \nv3\n \n=\n \nllvm\n::\nmap_to_vector\n<\n4\n>\n(\ncontainer\n,\n \nfunc\n);\n\n\nauto\n \nv4\n \n=\n \nllvm\n::\nfilter_to_vector\n<\n4\n>\n(\ncontainer\n,\n \npred\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvm/use-vector-utils.html"
  },
  {
    "name": "llvmlibc-callee-namespace",
    "description": "Checks all calls resolve to functions within correct namespace.\n\n// Implementation inside the LIBC_NAMESPACE namespace.\n\n\n// Correct if:\n\n\n// - LIBC_NAMESPACE is a macro\n\n\n// - LIBC_NAMESPACE expansion starts with `__llvm_libc`\n\n\nnamespace\n \nLIBC_NAMESPACE\n \n{\n\n\n\n// Allow calls with the fully qualified name.\n\n\nLIBC_NAMESPACE\n::\nstrlen\n(\n\"hello\"\n);\n\n\n\n// Allow calls to compiler provided functions.\n\n\n(\nvoid\n)\n__builtin_abs\n(\n-1\n);\n\n\n\n// Bare calls are allowed as long as they resolve to the correct namespace.\n\n\nstrlen\n(\n\"world\"\n);\n\n\n\n// Disallow calling into functions in the global namespace.\n\n\n::\nstrlen\n(\n\"!\"\n);\n\n\n\n}\n \n// namespace LIBC_NAMESPACE",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvmlibc/callee-namespace.html"
  },
  {
    "name": "llvmlibc-implementation-in-namespace",
    "description": "Checks that all declarations in the llvm-libc implementation are within the\ncorrect namespace.\n\n// Implementation inside the LIBC_NAMESPACE_DECL namespace.\n\n\n// Correct if:\n\n\n// - LIBC_NAMESPACE_DECL is a macro\n\n\n// - LIBC_NAMESPACE_DECL expansion starts with `[[gnu::visibility(\"hidden\")]] __llvm_libc`\n\n\nnamespace\n \nLIBC_NAMESPACE_DECL\n \n{\n\n\n    \nvoid\n \nLLVM_LIBC_ENTRYPOINT\n(\nstrcpy\n)(\nchar\n \n*\ndest\n,\n \nconst\n \nchar\n \n*\nsrc\n)\n \n{}\n\n\n    \n// Namespaces within LIBC_NAMESPACE_DECL namespace are allowed.\n\n\n    \nnamespace\n \ninner\n \n{\n\n\n        \nint\n \nlocalVar\n \n=\n \n0\n;\n\n\n    \n}\n\n\n    \n// Functions with C linkage are allowed.\n\n\n    \nextern\n \n\"C\"\n \nvoid\n \nstr_fuzz\n()\n \n{}\n\n\n}\n\n\n\n// Incorrect: implementation not in the LIBC_NAMESPACE_DECL namespace.\n\n\nvoid\n \nLLVM_LIBC_ENTRYPOINT\n(\nstrcpy\n)(\nchar\n \n*\ndest\n,\n \nconst\n \nchar\n \n*\nsrc\n)\n \n{}\n\n\n\n// Incorrect: outer most namespace is not the LIBC_NAMESPACE_DECL macro.\n\n\nnamespace\n \nsomething_else\n \n{\n\n\n    \nvoid\n \nLLVM_LIBC_ENTRYPOINT\n(\nstrcpy\n)(\nchar\n \n*\ndest\n,\n \nconst\n \nchar\n \n*\nsrc\n)\n \n{}\n\n\n}\n\n\n\n// Incorrect: outer most namespace expansion does not start with `[[gnu::visibility(\"hidden\")]] __llvm_libc`.\n\n\n#define LIBC_NAMESPACE_DECL custom_namespace\n\n\nnamespace\n \nLIBC_NAMESPACE_DECL\n \n{\n\n\n    \nvoid\n \nLLVM_LIBC_ENTRYPOINT\n(\nstrcpy\n)(\nchar\n \n*\ndest\n,\n \nconst\n \nchar\n \n*\nsrc\n)\n \n{}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvmlibc/implementation-in-namespace.html"
  },
  {
    "name": "llvmlibc-inline-function-decl",
    "description": "Checks that all implicitly and explicitly inline functions in header files are\ntagged with the \nLIBC_INLINE\n macro, except for functions implicit to classes\nor deleted functions.\nSee the \nlibc style guide\n for more\ninformation about this macro.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvmlibc/inline-function-decl.html"
  },
  {
    "name": "llvmlibc-restrict-system-libc-headers",
    "description": "Finds includes of system libc headers not provided by the compiler within\nllvm-libc implementations.\n\n#include\n \n<stdio.h>\n            // Not allowed because it is part of system libc.\n\n\n#include\n \n<stddef.h>\n           // Allowed because it is provided by the compiler.\n\n\n#include\n \n\"internal/stdio.h\"\n   // Allowed because it is NOT part of system libc.\n\nThis check is necessary because accidentally including system libc headers can\nlead to subtle and hard to detect bugs. For example consider a system libc\nwhose \ndirent\n struct has slightly different field ordering than llvm-libc.\nWhile this will compile successfully, this can cause issues during runtime\nbecause they are ABI incompatible.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludes\nÂ¶\n\n\nA string containing a comma separated glob list of allowed include\nfilenames. Similar to the -checks glob list for running clang-tidy itself,\nthe two wildcard characters are \n*\n and \n-\n, to include and exclude globs,\nrespectively. The default is \n-*\n, which disallows all includes.\n\n\nThis can be used to allow known safe includes such as Linux development\nheaders. See \nportability-restrict-system-includes\n for more\ndetails.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/llvmlibc/restrict-system-libc-headers.html"
  },
  {
    "name": "misc-anonymous-namespace-in-header",
    "description": "Finds anonymous namespaces in headers.\n\nAnonymous namespaces in headers can lead to One Definition Rule (ODR)\nviolations because each translation unit including the header will get its\nown unique version of the symbols. This increases binary size and can cause\nconfusing link-time errors.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nDCL59-CPP. Do not define an unnamed namespace in a header file\n.\n\n\nCorresponding cpplint.py check name: \nbuild/namespaces\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/anonymous-namespace-in-header.html"
  },
  {
    "name": "misc-confusable-identifiers",
    "description": "Warn about confusable identifiers, i.e. identifiers that are visually close to\neach other, but use different Unicode characters. This detects a potential\nattack described in \nCVE-2021-42574\n.\n\nExample:\n\nint fo; // Initial character is U+0066 (LATIN SMALL LETTER F).\nint ðo; // Initial character is U+1D41F (MATHEMATICAL BOLD SMALL F) not U+0066 (LATIN SMALL LETTER F).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/confusable-identifiers.html"
  },
  {
    "name": "misc-const-correctness",
    "description": "Finds local variables and function parameters which could be declared as\n\nconst\n but are not.\n\nDeclaring variables as \nconst\n is required or recommended by many coding\nguidelines, such as:\n\nES.25\n\nfrom the C++ Core Guidelines.\n\nPlease note that this checkâs analysis is type-based only. Variables that are\nnot modified but used to create a non-const handle that might escape the scope\nare not diagnosed as potential \nconst\n.\n\n// Declare a variable, which is not ``const`` ...\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n// but use it as read-only. This means that `i` can be declared ``const``.\n\n\nint\n \nresult\n \n=\n \ni\n \n*\n \ni\n;\n       \n// Before transformation\n\n\nint\n \nconst\n \nresult\n \n=\n \ni\n \n*\n \ni\n;\n \n// After transformation\n\nThe check can analyze values, pointers and references and pointees:\n\n// Normal values like built-ins or objects.\n\n\nint\n \npotential_const_int\n \n=\n \n42\n;\n       \n// Before transformation\n\n\nint\n \nconst\n \npotential_const_int\n \n=\n \n42\n;\n \n// After transformation\n\n\nint\n \ncopy_of_value\n \n=\n \npotential_const_int\n;\n\n\n\nMyClass\n \ncould_be_const\n;\n       \n// Before transformation\n\n\nMyClass\n \nconst\n \ncould_be_const\n;\n \n// After transformation\n\n\ncould_be_const\n.\nconst_qualified_method\n();\n\n\n\n// References can be declared const as well.\n\n\nint\n \n&\nreference_value\n \n=\n \npotential_const_int\n;\n       \n// Before transformation\n\n\nint\n \nconst\n&\n \nreference_value\n \n=\n \npotential_const_int\n;\n \n// After transformation\n\n\nint\n \nanother_copy\n \n=\n \nreference_value\n;\n\n\n\n// The similar semantics of pointers are analyzed.\n\n\nint\n \n*\npointer_variable\n \n=\n \n&\npotential_const_int\n;\n \n// Before transformation\n\n\nint\n \nconst\n*\nconst\n \npointer_variable\n \n=\n \n&\npotential_const_int\n;\n \n// After transformation, both pointer itself and pointee are supported.\n\n\nint\n \nlast_copy\n \n=\n \n*\npointer_variable\n;\n\nThe automatic code transformation is only applied to variables that are\ndeclared in single declarations. You may want to prepare your code base with\n\nreadability-isolate-declaration\n first.\n\nNote that there is the check\n\ncppcoreguidelines-avoid-non-const-global-variables\n\nto enforce \nconst\n correctness on all globals.\n\nLimitations\nÂ¶\n\n\nThe check does not run on \nC\n code.\n\n\nThe check will not analyze templated variables, template functions or variables\nthat are instantiation dependent. Different instantiations can result\nin different \nconst\n correctness properties and in general it is not\npossible to find all instantiations of a template. The template might\nbe used differently in an independent translation unit.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAnalyzeValues\nÂ¶\n\n\nEnable or disable the analysis of ordinary value variables, like\n\nint\n \ni\n \n=\n \n42;\n. Default is \ntrue\n.\n\n\n// Warning\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n// No warning\n\n\nint\n \nconst\n \ni\n \n=\n \n42\n;\n\n\n\n// Warning\n\n\nint\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n// No warning\n\n\nint\n \nconst\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzeReferences\nÂ¶\n\n\nEnable or disable the analysis of reference variables, like\n\nint\n \n&ref\n \n=\n \ni;\n. Default is \ntrue\n.\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n// Warning\n\n\nint\n&\n \nref\n \n=\n \ni\n;\n\n\n// No warning\n\n\nint\n \nconst\n&\n \nref\n \n=\n \ni\n;\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzePointers\nÂ¶\n\n\nEnable or disable the analysis of pointers variables, like\n\nint\n \n*ptr\n \n=\n \n&i;\n. For specific checks, see\n\nWarnPointersAsValues\n and \nWarnPointersAsPointers\n.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nAnalyzeParameters\nÂ¶\n\n\nEnable or disable the analysis of function parameters, like\n\nvoid\n \nfoo(int*\n \nptr)\n. Only reference and pointer parameters are analyzed.\nCurrently, member functions (including constructors) and lambdas are excluded\nfrom the analysis. Default is \ntrue\n.\n\n\n// Warning\n\n\nvoid\n \nfunction\n(\nint\n&\n \nparam\n)\n \n{}\n\n\n// No warning\n\n\nvoid\n \nfunction\n(\nconst\n \nint\n&\n \nparam\n)\n \n{}\n\n\n\n\n\n\n\n\n\n\n\n\nWarnPointersAsValues\nÂ¶\n\n\nThis option enables the suggestion for \nconst\n of the pointer itself.\nPointer values have two possibilities to be \nconst\n, the pointer\nand the value pointing to. Default is \nfalse\n.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Warning\n\n\nconst\n \nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// No warning\n\n\nconst\n \nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n\n\n\n\n\n\n\n\n\nWarnPointersAsPointers\nÂ¶\n\n\nThis option enables the suggestion for \nconst\n of the value pointing to.\nDefault is \ntrue\n.\n\n\nRequires \nAnalyzePointers\n to be \ntrue\n.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// No warning\n\n\nconst\n \nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// Warning\n\n\nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformValues\nÂ¶\n\n\nProvides fixit-hints for value types that automatically add \nconst\n if\nits a single declaration. Default is \ntrue\n.\n\n\n// Before\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n// After\n\n\nint\n \nconst\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Before\n\n\nint\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n// After\n\n\nint\n \nconst\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n\n// Result is modified later in its life-time. No diagnostic and fixit hint will be emitted.\n\n\nint\n \nresult\n \n=\n \nvalue\n \n*\n \n3\n;\n\n\nresult\n \n-=\n \n10\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformReferences\nÂ¶\n\n\nProvides fixit-hints for reference types that automatically add \nconst\n if\nits a single declaration. Default is \ntrue\n.\n\n\n// This variable could still be a constant. But because there is a non-const reference to\n\n\n// it, it can not be transformed (yet).\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n// The reference 'ref_value' is not modified and can be made 'const int &ref_value = value;'\n\n\n// Before\n\n\nint\n \n&\nref_value\n \n=\n \nvalue\n;\n\n\n// After\n\n\nint\n \nconst\n \n&\nref_value\n \n=\n \nvalue\n;\n\n\n\n// Result is modified later in its life-time. No diagnostic and fixit hint will be emitted.\n\n\nint\n \nresult\n \n=\n \nref_value\n \n*\n \n3\n;\n\n\nresult\n \n-=\n \n10\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformPointersAsValues\nÂ¶\n\n\nProvides fixit-hints for pointers if their pointee is not changed. This does\nnot analyze if the value-pointed-to is unchanged! Default is \nfalse\n.\n\n\nRequires âWarnPointersAsValuesâ to be âtrueâ.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Before\n\n\nconst\n \nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// After\n\n\nconst\n \nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n// Before\n\n\nconst\n \nint\n \n*\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n// After\n\n\nconst\n \nint\n \n*\nconst\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n\n// Before\n\n\nint\n \n*\nptr_value\n \n=\n \n&\nvalue\n;\n\n\n// After\n\n\nint\n \n*\nconst\n \nptr_value\n \n=\n \n&\nvalue\n;\n\n\n\nint\n \nresult\n \n=\n \n100\n \n*\n \n(\n*\nptr_value\n);\n \n// Does not modify the pointer itself.\n\n\n// This modification of the pointee is still allowed and not diagnosed.\n\n\n*\nptr_value\n \n=\n \n0\n;\n\n\n\n// The following pointer may not become a 'int *const'.\n\n\nint\n \n*\nchanging_pointee\n \n=\n \n&\nvalue\n;\n\n\nchanging_pointee\n \n=\n \n&\nresult\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformPointersAsPointers\nÂ¶\n\n\nProvides fix-it hints for pointers if the value it pointing to is not changed.\nDefault is \nfalse\n.\n\n\nRequires \nWarnPointersAsPointers\n to be \ntrue\n.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Before\n\n\nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// After\n\n\nconst\n \nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n// Before\n\n\nint\n \n*\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n// After\n\n\nconst\n \nint\n \n*\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types that will be excluded from\nconst-correctness checking. Regular expressions are accepted, e.g.\n\n[Rr]ef(erence)?$\n matches every type with suffix \nRef\n, \nref\n,\n\nReference\n and \nreference\n. If a name in the list contains the sequence\n\n::\n, it is matched against the qualified type name\n(i.e. \nnamespace::Type\n), otherwise it is matched against only the type\nname (i.e. \nType\n). Default is empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/const-correctness.html"
  },
  {
    "name": "misc-coroutine-hostile-raii",
    "description": "Detects when objects of certain hostile RAII types persists across suspension\npoints in a coroutine. Such hostile types include scoped-lockable types and\ntypes belonging to a configurable denylist.\n\nSome objects require that they be destroyed on the same thread that created\nthem. Traditionally this requirement was often phrased as âmust be a local\nvariableâ, under the assumption that local variables always work this way.\nHowever this is incorrect with C++20 coroutines, since an intervening\n\nco_await\n may cause the coroutine to suspend and later be resumed on\nanother thread.\n\nThe lifetime of an object that requires being destroyed on the same thread\nmust not encompass a \nco_await\n or \nco_yield\n point. If you create/destroy\nan object, you must do so without allowing the coroutine to suspend in the\nmeantime.\n\nFollowing types are considered as hostile:\n\nScoped-lockable types: A scoped-lockable object persisting across a\nsuspension point is problematic as the lock held by this object could\nbe unlocked by a different thread. This would be undefined behaviour.\nThis includes all types annotated with the \nscoped_lockable\n attribute.\n\n\nTypes belonging to a configurable denylist.\n\n// Call some async API while holding a lock.\n\n\ntask\n \ncoro\n()\n \n{\n\n\n  \nconst\n \nstd\n::\nlock_guard\n \nl\n(\n&\nmu_\n);\n\n\n\n  \n// Oops! The async Bar function may finish on a different\n\n\n  \n// thread from the one that created the lock_guard (and called\n\n\n  \n// Mutex::Lock). After suspension, Mutex::Unlock will be called on the wrong thread.\n\n\n  \nco_await\n \nBar\n();\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nRAIITypesList\nÂ¶\n\n\nA semicolon-separated list of qualified types which should not be allowed to\npersist across suspension points.\nEg: \nmy::lockable;a::b;::my::other::lockable\n\nThe default value of this option is \nstd::lock_guard;std::scoped_lock\n.\n\n\n\n\n\n\n\n\nAllowedAwaitablesList\nÂ¶\n\n\nA semicolon-separated list of qualified types of awaitables types which can\nbe safely awaited while having hostile RAII objects in scope.\n\n\nco_await\n-ing an expression of \nawaitable\n type is considered\nsafe if the \nawaitable\n type is part of this list.\nRAII objects persisting across such a \nco_await\n expression are\nconsidered safe and hence are not flagged.\n\n\nExample usage:\n\n\n// Consider option AllowedAwaitablesList = \"safe_awaitable\"\n\n\nstruct\n \nsafe_awaitable\n \n{\n\n\n  \nbool\n \nawait_ready\n()\n \nnoexcept\n \n{\n \nreturn\n \nfalse\n;\n \n}\n\n\n  \nvoid\n \nawait_suspend\n(\nstd\n::\ncoroutine_handle\n<>\n)\n \nnoexcept\n \n{}\n\n\n  \nvoid\n \nawait_resume\n()\n \nnoexcept\n \n{}\n\n\n};\n\n\nauto\n \nwait\n()\n \n{\n \nreturn\n \nsafe_awaitable\n{};\n \n}\n\n\n\ntask\n \ncoro\n()\n \n{\n\n\n  \n// This persists across both the co_await's but is not flagged\n\n\n  \n// because the awaitable is considered safe to await on.\n\n\n  \nconst\n \nstd\n::\nlock_guard\n \nl\n(\n&\nmu_\n);\n\n\n  \nco_await\n \nsafe_awaitable\n{};\n\n\n  \nco_await\n \nwait\n();\n\n\n}\n\n\n\n\n\n\nEg: \nmy::safe::awaitable;other::awaitable\n\nDefault is an empty string.\n\n\n\n\n\n\n\n\nAllowedCallees\nÂ¶\n\n\nA semicolon-separated list of callee function names which can\nbe safely awaited while having hostile RAII objects in scope.\nExample usage:\n\n\n// Consider option AllowedCallees = \"noop\"\n\n\ntask\n \nnoop\n()\n \n{\n \nco_return\n;\n \n}\n\n\n\ntask\n \ncoro\n()\n \n{\n\n\n  \n// This persists across the co_await but is not flagged\n\n\n  \n// because the awaitable is considered safe to await on.\n\n\n  \nconst\n \nstd\n::\nlock_guard\n \nl\n(\n&\nmu_\n);\n\n\n  \nco_await\n \nnoop\n();\n\n\n}\n\n\n\n\n\n\nEg: \nmy::safe::await;other::await\n\nDefault is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/coroutine-hostile-raii.html"
  },
  {
    "name": "misc-definitions-in-headers",
    "description": "Finds non-extern non-inline function and variable definitions in header files,\nwhich can lead to potential ODR violations in case these headers are included\nfrom multiple translation units.\n\n// Foo.h\n\n\nint\n \na\n \n=\n \n1\n;\n \n// Warning: variable definition.\n\n\nextern\n \nint\n \nd\n;\n \n// OK: extern variable.\n\n\n\nnamespace\n \nN\n \n{\n\n\n  \nint\n \ne\n \n=\n \n2\n;\n \n// Warning: variable definition.\n\n\n}\n\n\n\n// Warning: variable definition.\n\n\nconst\n \nchar\n*\n \nstr\n \n=\n \n\"foo\"\n;\n\n\n\n// OK: internal linkage variable definitions are ignored for now.\n\n\n// Although these might also cause ODR violations, we can be less certain and\n\n\n// should try to keep the false-positive rate down.\n\n\nstatic\n \nint\n \nb\n \n=\n \n1\n;\n\n\nconst\n \nint\n \nc\n \n=\n \n1\n;\n\n\nconst\n \nchar\n*\n \nconst\n \nstr2\n \n=\n \n\"foo\"\n;\n\n\nconstexpr\n \nint\n \nk\n \n=\n \n1\n;\n\n\nnamespace\n \n{\n \nint\n \nx\n \n=\n \n1\n;\n \n}\n\n\n\n// Warning: function definition.\n\n\nint\n \ng\n()\n \n{\n\n\n  \nreturn\n \n1\n;\n\n\n}\n\n\n\n// OK: inline function definition is allowed to be defined multiple times.\n\n\ninline\n \nint\n \ne\n()\n \n{\n\n\n  \nreturn\n \n1\n;\n\n\n}\n\n\n\nclass\n \nA\n \n{\n\n\npublic\n:\n\n\n  \nint\n \nf1\n()\n \n{\n \nreturn\n \n1\n;\n \n}\n \n// OK: implicitly inline member function definition is allowed.\n\n\n  \nint\n \nf2\n();\n\n\n\n  \nstatic\n \nint\n \nd\n;\n\n\n};\n\n\n\n// Warning: not an inline member function definition.\n\n\nint\n \nA::f2\n()\n \n{\n \nreturn\n \n1\n;\n \n}\n\n\n\n// OK: class static data member declaration is allowed.\n\n\nint\n \nA\n::\nd\n \n=\n \n1\n;\n\n\n\n// OK: function template is allowed.\n\n\ntemplate\n<\ntypename\n \nT\n>\n\n\nT\n \nf3\n()\n \n{\n\n\n  \nT\n \na\n \n=\n \n1\n;\n\n\n  \nreturn\n \na\n;\n\n\n}\n\n\n\n// Warning: full specialization of a function template is not allowed.\n\n\ntemplate\n \n<>\n\n\nint\n \nf3\n()\n \n{\n\n\n  \nint\n \na\n \n=\n \n1\n;\n\n\n  \nreturn\n \na\n;\n\n\n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nB\n \n{\n\n\n  \nvoid\n \nf1\n();\n\n\n};\n\n\n\n// OK: member function definition of a class template is allowed.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nB\n<\nT\n>::\nf1\n()\n \n{}\n\n\n\nclass\n \nCE\n \n{\n\n\n  \nconstexpr\n \nstatic\n \nint\n \ni\n \n=\n \n5\n;\n \n// OK: inline variable definition.\n\n\n};\n\n\n\ninline\n \nint\n \ni\n \n=\n \n5\n;\n \n// OK: inline variable definition.\n\n\n\nconstexpr\n \nint\n \nf10\n()\n \n{\n \nreturn\n \n0\n;\n \n}\n \n// OK: constexpr function implies inline.\n\n\n\n// OK: C++14 variable templates are inline.\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nconstexpr\n \nT\n \npi\n \n=\n \nT\n(\n3.1415926L\n);\n\nWhen \nclang-tidy\n is invoked with the \nâfix-notes\n option, this check\nprovides fixes that automatically add the \ninline\n keyword to discovered\nfunctions. Please note that the addition of the \ninline\n keyword to variables\nis not currently supported by this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/definitions-in-headers.html"
  },
  {
    "name": "misc-header-include-cycle",
    "description": "Check detects cyclic \n#include\n dependencies between user-defined headers.\n\n// Header A.hpp\n\n\n#pragma once\n\n\n#include\n \n\"B.hpp\"\n\n\n\n// Header B.hpp\n\n\n#pragma once\n\n\n#include\n \n\"C.hpp\"\n\n\n\n// Header C.hpp\n\n\n#pragma once\n\n\n#include\n \n\"A.hpp\"\n\n\n\n// Include chain: A->B->C->A\n\nHeader files are a crucial part of many C++ programs as they provide a way to\norganize declarations and definitions shared across multiple source files.\nHowever, header files can also create problems when they become entangled\nin complex dependency cycles. Such cycles can cause issues with compilation\ntimes, unnecessary rebuilds, and make it harder to understand the overall\nstructure of the code.\n\nTo address these issues, a check has been developed to detect cyclic\ndependencies between header files, also known as âinclude cyclesâ.\nAn include cycle occurs when a header file \nA\n includes header file \nB\n,\nand \nB\n (or any subsequent included header file) includes back header file \nA\n,\nresulting in a circular dependency cycle.\n\nThis check operates at the preprocessor level and specifically analyzes\nuser-defined headers and their dependencies. It focuses solely on detecting\ninclude cycles while disregarding other types or function dependencies.\nThis specialized analysis helps identify and prevent issues related to header\nfile organization.\n\nBy detecting include cycles early in the development process, developers can\nidentify and resolve these issues before they become more difficult and\ntime-consuming to fix. This can lead to faster compile times, improved code\nquality, and a more maintainable codebase overall. Additionally, by ensuring\nthat header files are organized in a way that avoids cyclic dependencies,\ndevelopers can make their code easier to understand and modify over time.\n\nItâs worth noting that only user-defined headers their dependencies are\nanalyzed, system includes such as standard library headers and third-party\nlibrary headers are excluded. System includes are usually well-designed and\nfree of include cycles, and ignoring them helps to focus on potential issues\nwithin the projectâs own codebase. This limitation doesnât diminish the\nability to detect \n#include\n cycles within the analyzed code.\n\nDevelopers should carefully review any warnings or feedback provided by this\nsolution. While the analysis aims to identify and prevent include cycles, there\nmay be situations where exceptions or modifications are necessary. Itâs\nimportant to exercise judgment and consider the specific context of the\ncodebase when making adjustments.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredFilesList\nÂ¶\n\n\nProvides a way to exclude specific files/headers from the warnings raised by\na check. This can be achieved by specifying a semicolon-separated list of\nregular expressions or filenames. This option can be used as an alternative\nto \n//NOLINT\n when using it is not possible.\nThe default value of this option is an empty string, indicating that no\nfiles are ignored by default.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/header-include-cycle.html"
  },
  {
    "name": "misc-include-cleaner",
    "description": "Checks for unused and missing includes. Generates findings only for\nthe main file of a translation unit.\nFindings correspond to \nhttps://clangd.llvm.org/design/include-cleaner\n.\n\nExample:\n\n// foo.h\n\n\nclass\n \nFoo\n{};\n\n\n// bar.h\n\n\n#include\n \n\"baz.h\"\n\n\nclass\n \nBar\n{};\n\n\n// baz.h\n\n\nclass\n \nBaz\n{};\n\n\n// main.cc\n\n\n#include\n \n\"bar.h\"\n // OK: uses class Bar from bar.h\n\n\n#include\n \n\"foo.h\"\n // warning: unused include \"foo.h\"\n\n\nBar\n \nbar\n;\n\n\nBaz\n \nbaz\n;\n \n// warning: missing include \"baz.h\"\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreHeaders\nÂ¶\n\n\nA semicolon-separated list of regexes to disable insertion/removal of header\nfiles that match this regex as a suffix.  E.g., \nfoo/.*\n disables\ninsertion/removal for all headers under the directory \nfoo\n. Default is an\nempty string, no headers will be ignored.\n\n\n\n\n\n\n\n\nDeduplicateFindings\nÂ¶\n\n\nA boolean that controls whether the check should deduplicate findings for the\nsame symbol. Defaults to \ntrue\n.\n\n\n\n\n\n\n\n\nUnusedIncludes\nÂ¶\n\n\nA boolean that controls whether the check should report unused includes\n(includes that are not used directly). Defaults to \ntrue\n.\n\n\n\n\n\n\n\n\nMissingIncludes\nÂ¶\n\n\nA boolean that controls whether the check should report missing includes\n(header files from which symbols are used but which are not directly included).\nDefaults to \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/include-cleaner.html"
  },
  {
    "name": "misc-misleading-bidirectional",
    "description": "Warns about unterminated bidirectional unicode sequence, detecting potential attack\nas described in the \nTrojan Source\n attack.\n\nExample:\n\n#include\n \n<iostream>\n\n\n\nint\n \nmain\n()\n \n{\n\n\n    \nbool\n \nisAdmin\n \n=\n \nfalse\n;\n\n\n    \n/*â® } â¦if (isAdmin)â© â¦ begin admins only */\n\n\n        \nstd\n::\ncout\n \n<<\n \n\"You are an admin.\n\\n\n\"\n;\n\n\n    \n/* end admins only â® { â¦*/\n\n\n    \nreturn\n \n0\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/misleading-bidirectional.html"
  },
  {
    "name": "misc-misleading-identifier",
    "description": "Finds identifiers that contain Unicode characters with right-to-left direction,\nwhich can be confusing as they may change the understanding of a whole\nstatement line, as described in \nTrojan Source\n.\n\nAn example of such misleading code follows:\n\n#include <stdio.h>\n\nshort int × = (short int)0;\nshort int × = (short int)12345;\n\nint main() {\n  int × = ×; // a local variable, set to zero?\n  printf(\"× is %d\\n\", ×);\n  printf(\"× is %d\\n\", ×);\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/misleading-identifier.html"
  },
  {
    "name": "misc-misplaced-const",
    "description": "This check diagnoses when a \nconst\n qualifier is applied to a \ntypedef\n/\n\nusing\n to a pointer type rather than to the pointee, because such constructs\nare often misleading to developers because the \nconst\n applies to the pointer\nrather than the pointee.\n\nFor instance, in the following code, the resulting type is \nint\n \n*\n \nconst\n\nrather than \nconst\n \nint\n \n*\n:\n\ntypedef\n \nint\n \n*\nint_ptr\n;\n\n\nvoid\n \nf\n(\nconst\n \nint_ptr\n \nptr\n)\n \n{\n\n\n  \n*\nptr\n \n=\n \n0\n;\n \n// potentially quite unexpectedly the int can be modified here\n\n\n  \nptr\n \n=\n \n0\n;\n \n// does not compile\n\n\n}\n\nThe check does not diagnose when the underlying \ntypedef\n/\nusing\n type is a\npointer to a \nconst\n type or a function pointer type. This is because the\n\nconst\n qualifier is less likely to be mistaken because it would be redundant\n(or disallowed) on the underlying pointee type.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/misplaced-const.html"
  },
  {
    "name": "misc-multiple-inheritance",
    "description": "Warns if a class inherits from multiple classes that are not pure virtual.\n\nFor example, declaring a class that inherits from multiple concrete classes is\ndisallowed:\n\nclass\n \nBase_A\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nint\n \nfoo\n()\n \n{\n \nreturn\n \n0\n;\n \n}\n\n\n};\n\n\n\nclass\n \nBase_B\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nint\n \nbar\n()\n \n{\n \nreturn\n \n0\n;\n \n}\n\n\n};\n\n\n\n// Warning\n\n\nclass\n \nBad_Child1\n \n:\n \npublic\n \nBase_A\n,\n \nBase_B\n \n{};\n\nA class that inherits from a pure virtual is allowed:\n\nclass\n \nInterface_A\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nint\n \nfoo\n()\n \n=\n \n0\n;\n\n\n};\n\n\n\nclass\n \nInterface_B\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nint\n \nbar\n()\n \n=\n \n0\n;\n\n\n};\n\n\n\n// No warning\n\n\nclass\n \nGood_Child1\n \n:\n \npublic\n \nInterface_A\n,\n \nInterface_B\n \n{\n\n\n  \nvirtual\n \nint\n \nfoo\n()\n \noverride\n \n{\n \nreturn\n \n0\n;\n \n}\n\n\n  \nvirtual\n \nint\n \nbar\n()\n \noverride\n \n{\n \nreturn\n \n0\n;\n \n}\n\n\n};\n\nReferences\nÂ¶\n\n\nSee the features disallowed in Fuchsia at \nhttps://fuchsia.dev/fuchsia-src/development/languages/c-cpp/cxx?hl=en",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/multiple-inheritance.html"
  },
  {
    "name": "misc-new-delete-overloads",
    "description": "cert-dcl54-cpp\n redirects here as an alias for this check.\n\nThe check flags overloaded operator \nnew()\n and operator \ndelete()\n\nfunctions that do not have a corresponding free store function defined within\nthe same scope.\nFor instance, the check will flag a class implementation of a non-placement\noperator \nnew()\n when the class does not also define a non-placement operator\n\ndelete()\n function as well.\n\nThe check does not flag implicitly-defined operators, deleted or private\noperators, or placement operators.\n\nThis check corresponds to CERT C++ Coding Standard rule \nDCL54-CPP. Overload allocation and deallocation functions as a pair in the same scope\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/new-delete-overloads.html"
  },
  {
    "name": "misc-no-recursion",
    "description": "Finds strongly connected functions (by analyzing the call graph for\nSCCâs (Strongly Connected Components) that are loops),\ndiagnoses each function in the cycle,\nand displays one example of a possible call graph loop (recursion).\n\nReferences:\n\nCERT C++ Coding Standard rule \nDCL56-CPP. Avoid cycles during initialization of static objects\n.\n\n\nJPL Institutional Coding Standard for the C Programming Language\n(JPL DOCID D-60411) rule \n2.4 Do not use direct or indirect recursion\n.\n\n\nOpenCL Specification, Version 1.2 rule \n6.9 Restrictions: i. Recursion is not supported.\n.\n\nLimitations\nÂ¶\n\n\n\n\nThe check does not handle calls done through function pointers\n\n\nThe check does not handle C++ destructors",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/no-recursion.html"
  },
  {
    "name": "misc-non-copyable-objects",
    "description": "cert-fio38-c\n redirects here as an alias for this check.\n\nFlags dereferences and non-pointer declarations of objects that are\nnot meant to be passed by value, such as C FILE objects or POSIX\n\npthread_mutex_t\n objects.\n\nReferences\nÂ¶\n\n\nThis check corresponds to CERT C++ Coding Standard rule \nFIO38-C. Do not copy a FILE object\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/non-copyable-objects.html"
  },
  {
    "name": "misc-non-private-member-variables-in-classes",
    "description": "cppcoreguidelines-non-private-member-variables-in-classes\n redirects here\nas an alias for this check.\n\nFinds classes that contain non-static data members in addition to user-declared\nnon-static member functions and diagnose all data members declared with a\nnon-\npublic\n access specifier. The data members should be declared as\n\nprivate\n and accessed through member functions instead of exposed to derived\nclasses or class consumers.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreClassesWithAllMemberVariablesBeingPublic\nÂ¶\n\n\nWhen \ntrue\n, allows to completely ignore classes if \nall\n the member\nvariables in that class declared with a \npublic\n access specifier.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnorePublicMemberVariables\nÂ¶\n\n\nWhen \ntrue\n, allows to ignore (not diagnose) \nall\n the member variables\ndeclared with a \npublic\n access specifier. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/non-private-member-variables-in-classes.html"
  },
  {
    "name": "misc-override-with-different-visibility",
    "description": "Finds virtual function overrides with different visibility than the function\nin the base class. This includes for example if a virtual function declared as\n\nprivate\n is overridden and declared as \npublic\n in a subclass. The\ndetected change is the modification of visibility resulting from keywords\n\npublic\n, \nprotected\n, \nprivate\n at overridden virtual functions. The\ncheck applies to any normal virtual function and optionally to destructors or\noperators. Use of the \nusing\n keyword is not considered as visibility\nchange by this check.\n\nclass\n \nA\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nvoid\n \nf_pub\n();\n\n\nprivate\n:\n\n\n  \nvirtual\n \nvoid\n \nf_priv\n();\n\n\n};\n\n\n\nclass\n \nB\n:\n \npublic\n \nA\n \n{\n\n\npublic\n:\n\n\n  \nvoid\n \nf_priv\n();\n \n// warning: changed visibility from private to public\n\n\nprivate\n:\n\n\n  \nvoid\n \nf_pub\n();\n \n// warning: changed visibility from public to private\n\n\n};\n\n\n\nclass\n \nC\n:\n \nprivate\n \nA\n \n{\n\n\n  \n// no warning: f_pub becomes private in this case but this is from the\n\n\n  \n// private inheritance\n\n\n};\n\n\n\nclass\n \nD\n:\n \nprivate\n \nA\n \n{\n\n\npublic\n:\n\n\n  \nvoid\n \nf_pub\n();\n \n// warning: changed visibility from private to public\n\n\n                \n// 'f_pub' would have private access but is forced to be\n\n\n                \n// public\n\n\n};\n\nIf the visibility is changed in this way, it can indicate bad design or\nprogramming error.\n\nIf a virtual function is private in a subclass but public in the base class, it\ncan still be accessed from a pointer to the subclass if the pointer is converted\nto the base type. Probably private inheritance can be used instead.\n\nA protected virtual function that is made public in a subclass may have valid\nuse cases but similar (not exactly same) effect can be achieved with the\n\nusing\n keyword.\n\nOptions\nÂ¶\n\n\n\n\n\n\nDisallowedVisibilityChange\nÂ¶\n\n\nControls what kind of change to the visibility will be detected by the check.\nPossible values are \nany\n, \nwidening\n, \nnarrowing\n. For example the\n\nwidening\n option will produce warning only if the visibility is changed\nfrom more restrictive (\nprivate\n) to less restrictive (\npublic\n).\nDefault value is \nany\n.\n\n\n\n\n\n\n\n\nCheckDestructors\nÂ¶\n\n\nIf \ntrue\n, the check does apply to destructors too. Otherwise destructors\nare ignored by the check.\nDefault value is \nfalse\n.\n\n\n\n\n\n\n\n\nCheckOperators\nÂ¶\n\n\nIf \ntrue\n, the check does apply to overloaded C++ operators (as virtual\nmember functions) too. This includes other special member functions (like\nconversions) too. This option is probably useful only in rare cases because\noperators and conversions are not often virtual functions.\nDefault value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoredFunctions\nÂ¶\n\n\nThis option can be used to ignore the check at specific functions.\nTo configure this option, a semicolon-separated list of function names\nshould be provided. The list can contain regular expressions, in this way it\nis possible to select all functions of a specific class (like \nMyClass::.*\n)\nor a specific function of any class (like \nmy_function\n or\n\n::.*::my_function\n). The function names are matched at the base class.\nDefault value is empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/override-with-different-visibility.html"
  },
  {
    "name": "misc-predictable-rand",
    "description": "Warns for the usage of \nstd::rand()\n. Pseudorandom number generators use\nmathematical algorithms to produce a sequence of numbers with good\nstatistical properties, but the numbers produced are not genuinely random.\nThe \nstd::rand()\n function takes a seed (number), runs a mathematical\noperation on it and returns the result. By manipulating the seed the result\ncan be predictable.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C Coding Standard rules\n\nMSC30-C. Do not use the rand() function for generating pseudorandom numbers\n.\n\nMSC50-CPP. Do not use std::rand() for generating pseudorandom numbers\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/predictable-rand.html"
  },
  {
    "name": "misc-redundant-expression",
    "description": "Detect redundant expressions which are typically errors due to copy-paste.\n\nDepending on the operator expressions may be\n\nredundant,\n\n\nalways \ntrue\n,\n\n\nalways \nfalse\n,\n\n\nalways a constant (zero or one).\n\nExamples:\n\n((\nx\n+\n1\n)\n \n|\n \n(\nx\n+\n1\n))\n                   \n// (x+1) is redundant\n\n\n(\np\n->\nx\n \n==\n \np\n->\nx\n)\n                    \n// always true\n\n\n(\np\n->\nx\n \n<\n \np\n->\nx\n)\n                     \n// always false\n\n\n(\nspeed\n \n-\n \nspeed\n \n+\n \n1\n \n==\n \n12\n)\n         \n// speed - speed is always zero\n\n\nint\n \nb\n \n=\n \na\n \n|\n \n4\n \n|\n \na\n                 \n// identical expr on both sides\n\n\n((\nx\n=\n1\n)\n \n|\n \n(\nx\n=\n1\n))\n                   \n// expression is identical\n\n\n(\nDEFINE_1\n \n|\n \nDEFINE_1\n)\n             \n// same macro on the both sides\n\n\n((\nDEF_1\n \n+\n \nDEF_2\n)\n \n|\n \n(\nDEF_1\n+\nDEF_2\n))\n \n// expressions differ in spaces only\n\nFloats are handled except in the case that NaNs are checked like so:\n\nint\n \nTestFloat\n(\nfloat\n \nF\n)\n \n{\n\n\n  \nif\n \n(\nF\n \n==\n \nF\n)\n               \n// Identical float values used\n\n\n    \nreturn\n \n1\n;\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nint\n \nTestFloat\n(\nfloat\n \nF\n)\n \n{\n\n\n  \n// Testing NaN.\n\n\n  \nif\n \n(\nF\n \n!=\n \nF\n \n&&\n \nF\n \n==\n \nF\n)\n     \n// does not warn\n\n\n    \nreturn\n \n1\n;\n\n\n  \nreturn\n \n0\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/redundant-expression.html"
  },
  {
    "name": "misc-static-assert",
    "description": "cert-dcl03-c\n redirects here as an alias for this check.\n\nReplaces \nassert()\n with \nstatic_assert()\n if the condition is evaluable\nat compile time.\n\nThe condition of \nstatic_assert()\n is evaluated at compile time which is\nsafer and more efficient.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/static-assert.html"
  },
  {
    "name": "misc-throw-by-value-catch-by-reference",
    "description": "cert-err09-cpp\n and \ncert-err61-cpp\n redirect here as aliases of this check.\n\nFinds violations of the rule âThrow by value, catch by referenceâ presented for\nexample in âC++ Coding Standardsâ by H. Sutter and A. Alexandrescu, as well as\nthe CERT C++ Coding Standard rule \nERR61-CPP. Catch exceptions by lvalue\nreference\n.\n\nExceptions:\n\n\nThrowing string literals will not be flagged despite being a pointer. They\nare not susceptible to slicing and the usage of string literals is\nidiomatic.\n\n\nCatching character pointers (\nchar\n, \nwchar_t\n, unicode character\ntypes) will not be flagged to allow catching string literals.\n\n\nMoved named values will not be flagged as not throwing an anonymous\ntemporary. In this case we can be sure that the user knows that the object\ncanât be accessed outside catch blocks handling the error.\n\n\nThrowing function parameters will not be flagged as not throwing an\nanonymous temporary. This allows helper functions for throwing.\n\n\nRe-throwing caught exception variables will not be flagged as not throwing\nan anonymous temporary. Although this can usually be done by just writing\n\nthrow;\n it happens often enough in real code.\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckThrowTemporaries\nÂ¶\n\n\nTriggers detection of violations of the CERT recommendation ERR09-CPP. Throw\nanonymous temporaries.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnLargeObject\nÂ¶\n\n\nAlso warns for any large, trivial object caught by value. Catching a large\nobject by value is not dangerous but affects the performance negatively. The\nmaximum size of an object allowed to be caught without warning can be set\nusing the \nMaxSize\n option.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nMaxSize\nÂ¶\n\n\nDetermines the maximum size of an object allowed to be caught without\nwarning. Only applicable if \nWarnOnLargeObject\n is set to \ntrue\n. If\nthe option is set by the user to \nstd::numeric_limits<uint64_t>::max()\n then\nit reverts to the default value.\nDefault is the size of \nsize_t\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/throw-by-value-catch-by-reference.html"
  },
  {
    "name": "misc-unconventional-assign-operator",
    "description": "Finds declarations of assign operators with the wrong return and/or argument\ntypes and definitions with good return type but wrong \nreturn\n statements.\n\nThe return type must be \nClass&\n.\n\n\nThe assignment may be from the class type by value, const lvalue\nreference, non-const rvalue reference, or from a completely different\ntype (e.g. \nint\n).\n\n\nPrivate and deleted operators are ignored.\n\n\nThe operator must always return \n*this\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unconventional-assign-operator.html"
  },
  {
    "name": "misc-uniqueptr-reset-release",
    "description": "Find and replace \nunique_ptr::reset(release())\n with \nstd::move()\n.\n\nExample:\n\nstd\n::\nunique_ptr\n<\nFoo\n>\n \nx\n,\n \ny\n;\n\n\nx\n.\nreset\n(\ny\n.\nrelease\n());\n \n->\n \nx\n \n=\n \nstd\n::\nmove\n(\ny\n);\n\nIf \ny\n is already rvalue, \nstd::move()\n is not added. \nx\n and \ny\n can\nalso be \nstd::unique_ptr<Foo>*\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/uniqueptr-reset-release.html"
  },
  {
    "name": "misc-unused-alias-decls",
    "description": "Finds unused namespace alias declarations.\n\nnamespace\n \nmy_namespace\n \n{\n\n\nclass\n \nC\n \n{};\n\n\n}\n\n\nnamespace\n \nunused_alias\n \n=\n \n::\nmy_namespace\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unused-alias-decls.html"
  },
  {
    "name": "misc-unused-parameters",
    "description": "Finds unused function parameters. Unused parameters may signify a bug in the\ncode (e.g. when a different parameter is used instead). The suggested fixes\neither comment parameter name out or remove the parameter completely, if all\ncallers of the function are in the same translation unit and can be updated.\n\nThe check is similar to the \n-Wunused-parameter\n compiler diagnostic and\ncan be used to prepare a codebase to enabling of that diagnostic. By default\nthe check is more permissive (see \nStrictMode\n).\n\nvoid\n \na\n(\nint\n \ni\n)\n \n{\n \n/*some code that doesn't use `i`*/\n \n}\n\n\n\n// becomes\n\n\n\nvoid\n \na\n(\nint\n  \n/*i*/\n)\n \n{\n \n/*some code that doesn't use `i`*/\n \n}\n\nstatic\n \nvoid\n \nstaticFunctionA\n(\nint\n \ni\n);\n\n\nstatic\n \nvoid\n \nstaticFunctionA\n(\nint\n \ni\n)\n \n{\n \n/*some code that doesn't use `i`*/\n \n}\n\n\n\n// becomes\n\n\n\nstatic\n \nvoid\n \nstaticFunctionA\n()\n\n\nstatic\n \nvoid\n \nstaticFunctionA\n()\n \n{\n \n/*some code that doesn't use `i`*/\n \n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen \nfalse\n (default value), the check will ignore trivially unused parameters,\ni.e. when the corresponding function has an empty body (and in case of\nconstructors - no constructor initializers). When the function body is empty,\nan unused parameter is unlikely to be unnoticed by a human reader, and\nthereâs basically no place for a bug to hide.\n\n\n\n\n\n\n\n\nIgnoreVirtual\nÂ¶\n\n\nDetermines whether virtual method parameters should be inspected.\nSet to \ntrue\n to ignore them. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unused-parameters.html"
  },
  {
    "name": "misc-unused-using-decls",
    "description": "Finds unused \nusing\n declarations.\n\nUnused \nusing\n declarations in header files will not be diagnosed\nsince these using declarations are part of the headerâs public API.\nAllowed header file extensions can be configured via the global\noption \nHeaderFileExtensions\n.\n\nExample:\n\n// main.cpp\n\n\nnamespace\n \nn\n \n{\n \nclass\n \nC\n;\n \n}\n\n\nusing\n \nn\n::\nC\n;\n  \n// Never actually used.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unused-using-decls.html"
  },
  {
    "name": "misc-use-anonymous-namespace",
    "description": "Finds instances of \nstatic\n functions or variables declared at global scope\nthat could instead be moved into an anonymous namespace.\n\nAnonymous namespaces are the âsuperior alternativeâ according to the C++\nStandard. \nstatic\n was proposed for deprecation, but later un-deprecated to\nkeep C compatibility [1]. \nstatic\n is an overloaded term with different\nmeanings in different contexts, so it can create confusion.\n\nThe following uses of \nstatic\n will \nnot\n be diagnosed:\n\nFunctions or variables in header files, since anonymous namespaces in headers\nis considered an antipattern. Allowed header file extensions can be\nconfigured via the global option \nHeaderFileExtensions\n.\n\n\nconst\n or \nconstexpr\n variables, since they already have implicit\ninternal linkage in C++.\n\nExamples:\n\n// Bad\n\n\nstatic\n \nvoid\n \nfoo\n();\n\n\nstatic\n \nint\n \nx\n;\n\n\n\n// Good\n\n\nnamespace\n \n{\n\n\n  \nvoid\n \nfoo\n();\n\n\n  \nint\n \nx\n;\n\n\n}\n \n// namespace\n\n[1] \nUndeprecating static",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/use-anonymous-namespace.html"
  },
  {
    "name": "misc-use-internal-linkage",
    "description": "Detects variables, functions, and classes that can be marked as static or\n(in C++) moved into an anonymous namespace to enforce internal linkage.\n\nAny entity thatâs only used within a single file should be given internal\nlinkage. Doing so gives the compiler more information, allowing it to better\nremove dead code and perform more aggressive optimizations.\n\nExample:\n\nint\n \nv1\n;\n \n// can be marked as static\n\n\n\nvoid\n \nfn1\n()\n \n{}\n \n// can be marked as static\n\n\n\n// already declared as extern\n\n\nextern\n \nint\n \nv2\n;\n\n\n\nvoid\n \nfn3\n();\n \n// without function body in all declaration, maybe external linkage\n\n\nvoid\n \nfn3\n();\n\n\n\n// === C++-specific ===\n\n\n\nstruct\n \nS1\n \n{};\n \n// can be moved into anonymous namespace\n\n\n\nnamespace\n \n{\n\n\n  \n// already in anonymous namespace\n\n\n  \nint\n \nv2\n;\n\n\n  \nvoid\n \nfn2\n();\n\n\n  \nstruct\n \nS2\n \n{};\n\n\n}\n\n\n\n// export declarations\n\n\nexport\n \nvoid\n \nfn4\n()\n \n{}\n\n\nexport\n \nnamespace\n \nt\n \n{\n \nvoid\n \nfn5\n()\n \n{}\n \n}\n\n\nexport\n \nint\n \nv2\n;\n\n\nexport\n \nclass\n \nC\n \n{};\n\nOptions\nÂ¶\n\n\n\n\n\n\nFixMode\nÂ¶\n\n\nSelects what kind of a fix the check should provide. The default is \nUseStatic\n.\n\n\n\n\nNone\n\nDonât fix automatically.\n\n\nUseStatic\n\nAdd \nstatic\n for internal linkage variable and function.\n\n\n\n\n\n\n\n\n\n\nAnalyzeFunctions\nÂ¶\n\n\nWhether to suggest giving functions internal linkage. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nAnalyzeVariables\nÂ¶\n\n\nWhether to suggest giving variables internal linkage. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nAnalyzeTypes\nÂ¶\n\n\n(C++ only) Whether to suggest giving user-defined types (structs,\nclasses, unions, and enums) internal linkage. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/use-internal-linkage.html"
  },
  {
    "name": "modernize-avoid-bind",
    "description": "The check finds uses of \nstd::bind\n and \nboost::bind\n and replaces them\nwith lambdas. Lambdas will use value-capture unless reference capture is\nexplicitly requested with \nstd::ref\n or \nboost::ref\n.\n\nIt supports arbitrary callables including member functions, function objects,\nand free functions, and all variations thereof. Anything that you can pass\nto the first argument of \nbind\n should be diagnosable. Currently, the only\nknown case where a fix-it is unsupported is when the same placeholder is\nspecified multiple times in the parameter list.\n\nGiven:\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\nThen:\n\nvoid\n \nf\n()\n \n{\n\n\n  \nint\n \nx\n \n=\n \n2\n;\n\n\n  \nauto\n \nclj\n \n=\n \nstd\n::\nbind\n(\nadd\n,\n \nx\n,\n \n_1\n);\n\n\n}\n\nis replaced by:\n\nvoid\n \nf\n()\n \n{\n\n\n  \nint\n \nx\n \n=\n \n2\n;\n\n\n  \nauto\n \nclj\n \n=\n \n[\n=\n](\nauto\n \n&&\n \narg1\n)\n \n{\n \nreturn\n \nadd\n(\nx\n,\n \narg1\n);\n \n};\n\n\n}\n\nstd::bind\n can be hard to read and can result in larger object files and\nbinaries due to type information that will not be produced by equivalent\nlambdas.\n\nOptions\nÂ¶\n\n\n\n\n\n\nPermissiveParameterList\nÂ¶\n\n\nIf the option is set to \ntrue\n, the check will append \nauto&&...\n to the end\nof every placeholder parameter list. Without this, it is possible for a fix-it\nto perform an incorrect transformation in the case where the result of the \nbind\n\nis used in the context of a type erased functor such as \nstd::function\n which\nallows mismatched arguments. Default is is \nfalse\n.\n\n\n\n\nFor example:\n\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nfunction\n<\nint\n(\nint\n,\nint\n)\n>\n \nignore_args\n \n=\n \nstd\n::\nbind\n(\nadd\n,\n \n2\n,\n \n2\n);\n\n\n  \nreturn\n \nignore_args\n(\n3\n,\n \n3\n);\n\n\n}\n\n\n\n\n\n\nis valid code, and returns \n4\n. The actual values passed to \nignore_args\n are\nsimply ignored. Without \nPermissiveParameterList\n, this would be transformed into\n\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nfunction\n<\nint\n(\nint\n,\nint\n)\n>\n \nignore_args\n \n=\n \n[]\n \n{\n \nreturn\n \nadd\n(\n2\n,\n \n2\n);\n \n}\n\n\n  \nreturn\n \nignore_args\n(\n3\n,\n \n3\n);\n\n\n}\n\n\n\n\n\n\nwhich will \nnot\n compile, since the lambda does not contain an \noperator()\n\nthat accepts 2 arguments. With permissive parameter list, it instead generates\n\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nfunction\n<\nint\n(\nint\n,\nint\n)\n>\n \nignore_args\n \n=\n \n[](\nauto\n&&\n...)\n \n{\n \nreturn\n \nadd\n(\n2\n,\n \n2\n);\n \n}\n\n\n  \nreturn\n \nignore_args\n(\n3\n,\n \n3\n);\n\n\n}\n\n\n\n\n\n\nwhich is correct.\n\n\nThis check requires using C++14 or higher to run.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/avoid-bind.html"
  },
  {
    "name": "modernize-avoid-c-arrays",
    "description": "cppcoreguidelines-avoid-c-arrays\n redirects here as an alias for this check.\n\nhicpp-avoid-c-arrays\n redirects here as an alias for this check.\n\nFinds C-style array types and recommend to use \nstd::array<>\n /\n\nstd::vector<>\n. All types of C arrays are diagnosed.\n\nFor parameters of incomplete C-style array type, it would be better to\nuse \nstd::span\n / \ngsl::span\n as replacement.\n\nHowever, fix-it are potentially dangerous in header files and are therefore not\nemitted right now.\n\nint\n \na\n[]\n \n=\n \n{\n1\n,\n \n2\n};\n \n// warning: do not declare C-style arrays, use 'std::array' instead\n\n\n\nint\n \nb\n[\n1\n];\n \n// warning: do not declare C-style arrays, use 'std::array' instead\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nint\n \nc\n[\nb\n[\n0\n]];\n \n// warning: do not declare C VLA arrays, use 'std::vector' instead\n\n\n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \nint\n \nSize\n>\n\n\nclass\n \narray\n \n{\n\n\n  \nT\n \nd\n[\nSize\n];\n \n// warning: do not declare C-style arrays, use 'std::array' instead\n\n\n\n  \nint\n \ne\n[\n1\n];\n \n// warning: do not declare C-style arrays, use 'std::array' instead\n\n\n};\n\n\n\narray\n<\nint\n[\n4\n],\n \n2\n>\n \nd\n;\n \n// warning: do not declare C-style arrays, use 'std::array' instead\n\n\n\nusing\n \nk\n \n=\n \nint\n[\n4\n];\n \n// warning: do not declare C-style arrays, use 'std::array' instead\n\nHowever, the \nextern\n \n\"C\"\n code is ignored, since it is common to share\nsuch headers between C code, and C++ code.\n\n// Some header\n\n\nextern\n \n\"C\"\n \n{\n\n\n\nint\n \nf\n[]\n \n=\n \n{\n1\n,\n \n2\n};\n \n// not diagnosed\n\n\n\nint\n \nj\n[\n1\n];\n \n// not diagnosed\n\n\n\ninline\n \nvoid\n \nbar\n()\n \n{\n\n\n  \n{\n\n\n    \nint\n \nj\n[\nj\n[\n0\n]];\n \n// not diagnosed\n\n\n  \n}\n\n\n}\n\n\n\n}\n\nSimilarly, the \nmain()\n function is ignored. Its second and third parameters\ncan be either \nchar*\n \nargv[]\n or \nchar**\n \nargv\n, but cannot be\n\nstd::array<>\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowStringArrays\nÂ¶\n\n\nWhen set to \ntrue\n (default is \nfalse\n), variables of character array type\nwith deduced length, initialized directly from string literals, will be ignored.\nThis option doesnât affect cases where length canât be deduced, resembling\npointers, as seen in class members and parameters. Example:\n\n\nconst\n \nchar\n \nname\n[]\n \n=\n \n\"Some name\"\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/avoid-c-arrays.html"
  },
  {
    "name": "modernize-avoid-c-style-cast",
    "description": "Finds usages of C-style casts.\n\nC-style casts can perform a variety of different conversions (\nconst_cast\n,\n\nstatic_cast\n, \nreinterpret_cast\n, or a combination). This makes them\ndangerous as the intent is not clear, and they can silently perform unsafe\nconversions between incompatible types.\n\nThis check is similar to \n-Wold-style-cast\n, but it suggests automated fixes\nin some cases. The reported locations should not be different from the ones\ngenerated by \n-Wold-style-cast\n.\n\nExamples\nÂ¶\n\n\nclass\n \nA\n \n{\n\n\n  \npublic\n:\n\n\n  \nstd\n::\nstring\n \nv\n;\n\n\n};\n\n\n\nA\n \na\n;\n\n\ndouble\n \n*\nnum\n \n=\n \n(\ndouble\n*\n)(\n&\na\n);\n           \n// Compiles! Hides danger\n\n\n// num = static_cast<double*>(&a);     // Won't compile (good!)\n\n\nnum\n \n=\n \nreinterpret_cast\n<\ndouble\n*>\n(\n&\na\n);\n   \n// Compiles, danger is explicit\n\nReferences\nÂ¶\n\n\nCorresponding cpplint.py check name: \nreadability/casting\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/avoid-c-style-cast.html"
  },
  {
    "name": "modernize-avoid-setjmp-longjmp",
    "description": "Flags all call expressions involving \nsetjmp()\n and\n\nlongjmp()\n in C++ code.\n\nException handling with \nthrow\n and \ncatch\n should be used instead.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nERR52-CPP. Do not use setjmp() or longjmp()\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/avoid-setjmp-longjmp.html"
  },
  {
    "name": "modernize-avoid-variadic-functions",
    "description": "Find all function definitions (but not declarations) of C-style variadic\nfunctions.\n\nInstead of C-style variadic functions, C++ function parameter pack should be\nused.\n\nReferences\nÂ¶\n\n\nThis check corresponds to the CERT C++ Coding Standard rule\n\nDCL50-CPP. Do not define a C-style variadic function\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/avoid-variadic-functions.html"
  },
  {
    "name": "modernize-concat-nested-namespaces",
    "description": "Checks for use of nested namespaces such as\n\nnamespace\n \na\n \n{\n \nnamespace\n \nb\n \n{\n \n...\n \n}\n \n}\n\nand suggests changing to the more concise syntax introduced\nin C++17: \nnamespace\n \na::b\n \n{\n \n...\n \n}\n.\nInline namespaces are not modified.\n\nFor example:\n\nnamespace\n \nn1\n \n{\n\n\nnamespace\n \nn2\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\n}\n\n\n\nnamespace\n \nn3\n \n{\n\n\nnamespace\n \nn4\n \n{\n\n\nnamespace\n \nn5\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\n}\n\n\nnamespace\n \nn6\n \n{\n\n\nnamespace\n \nn7\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\n}\n\n\n}\n\n\n\n// in c++20\n\n\nnamespace\n \nn8\n \n{\n\n\ninline\n \nnamespace\n \nn9\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\n}\n\nWill be modified to:\n\nnamespace\n \nn1\n::\nn2\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\n\nnamespace\n \nn3\n \n{\n\n\nnamespace\n \nn4\n::\nn5\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\nnamespace\n \nn6\n::\nn7\n \n{\n\n\nvoid\n \nt\n();\n\n\n}\n\n\n}\n\n\n\n// in c++20\n\n\nnamespace\n \nn8\n::\ninline\n \nn9\n \n{\n\n\nvoid\n \nt\n();\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/concat-nested-namespaces.html"
  },
  {
    "name": "modernize-deprecated-headers",
    "description": "Some headers from C library were deprecated in C++ and are no longer welcome in\nC++ codebases. Some have no effect in C++. For more details refer to the C++14\nStandard [depr.c.headers] section.\n\nThis check replaces C standard library headers with their C++ alternatives and\nremoves redundant ones.\n\n// C++ source file...\n\n\n#include\n \n<assert.h>\n\n\n#include\n \n<stdbool.h>\n\n\n\n// becomes\n\n\n\n#include\n \n<cassert>\n\n\n// No 'stdbool.h' here.\n\nImportant note: the Standard doesnât guarantee that the C++ headers declare all\nthe same functions in the global namespace. The check in its current form can\nbreak the code that uses library symbols from the global namespace.\n\n<assert.h>\n\n\n<complex.h>\n\n\n<ctype.h>\n\n\n<errno.h>\n\n\n<fenv.h>\n     // deprecated since C++11\n\n\n<float.h>\n\n\n<inttypes.h>\n\n\n<limits.h>\n\n\n<locale.h>\n\n\n<math.h>\n\n\n<setjmp.h>\n\n\n<signal.h>\n\n\n<stdarg.h>\n\n\n<stddef.h>\n\n\n<stdint.h>\n\n\n<stdio.h>\n\n\n<stdlib.h>\n\n\n<string.h>\n\n\n<tgmath.h>\n   // deprecated since C++11\n\n\n<time.h>\n\n\n<uchar.h>\n    // deprecated since C++11\n\n\n<wchar.h>\n\n\n<wctype.h>\n\nIf the specified standard is older than C++11 the check will only replace\nheaders deprecated before C++11, otherwise â every header that appeared in\nthe previous list.\n\nThese headers donât have effect in C++:\n\n<iso646.h>\n\n\n<stdalign.h>\n\n\n<stdbool.h>\n\nThe checker ignores \ninclude\n directives within \nextern âCâ { â¦ }\n blocks,\nsince a library might want to expose some API for C and C++ libraries.\n\n// C++ source file...\n\n\nextern\n \n\"C\"\n \n{\n\n\n#include\n \n<assert.h>\n  // Left intact.\n\n\n#include\n \n<stdbool.h>\n // Left intact.\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckHeaderFile\nÂ¶\n\n\nclang-tidy\n cannot know if the header file included by the currently\nanalyzed C++ source file is not included by any other C source files.\nHence, to omit false-positives and wrong fixit-hints, we ignore emitting\nreports into header files. One can set this option to \ntrue\n if they know\nthat the header files in the project are only used by C++ source files.\nDefault is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/deprecated-headers.html"
  },
  {
    "name": "modernize-deprecated-ios-base-aliases",
    "description": "Detects usage of the deprecated member types of \nstd::ios_base\n and replaces\nthose that have a non-deprecated equivalent.\n\nDeprecated member type\n\n\nReplacement\n\n\n\n\n\n\n\n\nstd::ios_base::io_state\n\n\nstd::ios_base::iostate\n\n\n\n\nstd::ios_base::open_mode\n\n\nstd::ios_base::openmode\n\n\n\n\nstd::ios_base::seek_dir\n\n\nstd::ios_base::seekdir\n\n\n\n\nstd::ios_base::streamoff\n\n\n\n\n\n\nstd::ios_base::streampos",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/deprecated-ios-base-aliases.html"
  },
  {
    "name": "modernize-loop-convert",
    "description": "This check converts \nfor(...;\n \n...;\n \n...)\n loops to use the new range-based\nloops in C++11.\n\nThree kinds of loops can be converted:\n\nLoops over statically allocated arrays.\n\n\nLoops over containers, using iterators.\n\n\nLoops over array-like containers, using \noperator[]\n and \nat()\n.\n\nMinConfidence option\nÂ¶\n\n\n\n\nrisky\nÂ¶\n\n\nIn loops where the container expression is more complex than just a\nreference to a declared expression (a variable, function, enum, etc.),\nand some part of it appears elsewhere in the loop, we lower our confidence\nin the transformation due to the increased risk of changing semantics.\nTransformations for these loops are marked as \nrisky\n, and thus will only\nbe converted if the minimum required confidence level is set to \nrisky\n.\n\n\nint\n \narr\n[\n10\n][\n20\n];\n\n\nint\n \nl\n \n=\n \n5\n;\n\n\n\nfor\n \n(\nint\n \nj\n \n=\n \n0\n;\n \nj\n \n<\n \n20\n;\n \n++\nj\n)\n\n\n  \nint\n \nk\n \n=\n \narr\n[\nl\n][\nj\n]\n \n+\n \nl\n;\n \n// using l outside arr[l] is considered risky\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nobj\n.\ngetVector\n().\nsize\n();\n \n++\ni\n)\n\n\n  \nobj\n.\nfoo\n(\n10\n);\n \n// using 'obj' is considered risky\n\n\n\n\n\n\nSee\n\nRange-based loops evaluate end() only once\n\nfor an example of an incorrect transformation when the minimum required confidence\nlevel is set to \nrisky\n.\n\n\n\n\n\n\nreasonable (Default)\nÂ¶\n\n\nIf a loop calls \n.end()\n or \n.size()\n after each iteration, the\ntransformation for that loop is marked as \nreasonable\n, and thus will\nbe converted if the required confidence level is set to \nreasonable\n\n(default) or lower.\n\n\n// using size() is considered reasonable\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \ncontainer\n.\nsize\n();\n \n++\ni\n)\n\n\n  \ncout\n \n<<\n \ncontainer\n[\ni\n];\n\n\n\n\n\n\n\n\n\n\nsafe\nÂ¶\n\n\nAny other loops that do not match the above criteria to be marked as\n\nrisky\n or \nreasonable\n are marked \nsafe\n, and thus will be converted\nif the required confidence level is set to \nsafe\n or lower.\n\n\nint\n \narr\n[]\n \n=\n \n{\n1\n,\n2\n,\n3\n};\n\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n3\n;\n \n++\ni\n)\n\n\n  \ncout\n \n<<\n \narr\n[\ni\n];\n\nExample\nÂ¶\n\n\nOriginal:\n\n\nconst\n \nint\n \nN\n \n=\n \n5\n;\n\n\nint\n \narr\n[]\n \n=\n \n{\n1\n,\n2\n,\n3\n,\n4\n,\n5\n};\n\n\nvector\n<\nint\n>\n \nv\n;\n\n\nv\n.\npush_back\n(\n1\n);\n\n\nv\n.\npush_back\n(\n2\n);\n\n\nv\n.\npush_back\n(\n3\n);\n\n\n\n// safe conversion\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nN\n;\n \n++\ni\n)\n\n\n  \ncout\n \n<<\n \narr\n[\ni\n];\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nvector\n<\nint\n>::\niterator\n \nit\n \n=\n \nv\n.\nbegin\n();\n \nit\n \n!=\n \nv\n.\nend\n();\n \n++\nit\n)\n\n\n  \ncout\n \n<<\n \n*\nit\n;\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nvector\n<\nint\n>::\niterator\n \nit\n \n=\n \nbegin\n(\nv\n);\n \nit\n \n!=\n \nend\n(\nv\n);\n \n++\nit\n)\n\n\n  \ncout\n \n<<\n \n*\nit\n;\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nvector\n<\nint\n>::\niterator\n \nit\n \n=\n \nstd\n::\nbegin\n(\nv\n);\n \nit\n \n!=\n \nstd\n::\nend\n(\nv\n);\n \n++\nit\n)\n\n\n  \ncout\n \n<<\n \n*\nit\n;\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nv\n.\nsize\n();\n \n++\ni\n)\n\n\n  \ncout\n \n<<\n \nv\n[\ni\n];\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nsize\n(\nv\n);\n \n++\ni\n)\n\n\n  \ncout\n \n<<\n \nv\n[\ni\n];\n\n\n\n\n\n\nAfter applying the check with minimum confidence level set to\n\nreasonable\n (default):\n\n\nconst\n \nint\n \nN\n \n=\n \n5\n;\n\n\nint\n \narr\n[]\n \n=\n \n{\n1\n,\n2\n,\n3\n,\n4\n,\n5\n};\n\n\nvector\n<\nint\n>\n \nv\n;\n\n\nv\n.\npush_back\n(\n1\n);\n\n\nv\n.\npush_back\n(\n2\n);\n\n\nv\n.\npush_back\n(\n3\n);\n\n\n\n// safe conversion\n\n\nfor\n \n(\nauto\n \n&\n \nelem\n \n:\n \narr\n)\n\n\n  \ncout\n \n<<\n \nelem\n;\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nauto\n \n&\n \nelem\n \n:\n \nv\n)\n\n\n  \ncout\n \n<<\n \nelem\n;\n\n\n\n// reasonable conversion\n\n\nfor\n \n(\nauto\n \n&\n \nelem\n \n:\n \nv\n)\n\n\n  \ncout\n \n<<\n \nelem\n;\n\nReverse Iterator Support\nÂ¶\n\n\nThe converter is also capable of transforming iterator loops which use\n\nrbegin\n and \nrend\n for looping backwards over a container. Out of the box\nthis will automatically happen in C++20 mode using the \nranges\n library,\nhowever the check can be configured to work without C++20 by specifying a\nfunction to reverse a range and optionally the header file where that function\nlives.\n\nOptions\nÂ¶\n\n\n\n\n\n\nUseCxx20ReverseRanges\nÂ¶\n\n\nWhen set to true convert loops when in C++20 or later mode using\n\nstd::views::reverse\n.\nDefault value is \ntrue\n.\n\n\n\n\n\n\n\n\nMakeReverseRangeFunction\nÂ¶\n\n\nSpecify the function used to reverse an iterator pair, the function should\naccept a class with \nrbegin\n and \nrend\n methods and return a\nclass with \nbegin\n and \nend\n methods that call the \nrbegin\n and\n\nrend\n methods respectively. Common examples are \nstd::views::reverse\n\nand \nllvm::reverse\n.\nDefault value is an empty string.\n\n\n\n\n\n\n\n\nMakeReverseRangeHeader\nÂ¶\n\n\nSpecifies the header file where \nMakeReverseRangeFunction\n is\ndeclared. For the previous examples this option would be set to\n\nrange/v3/view/reverse.hpp\n and \nllvm/ADT/STLExtras.h\n respectively.\nIf this is an empty string and \nMakeReverseRangeFunction\n is set,\nthe check will proceed on the assumption that the function is already\navailable in the translation unit.\nThis can be wrapped in angle brackets to signify to add the include as a\nsystem include.\nDefault value is an empty string.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\nLimitations\nÂ¶\n\n\nThere are certain situations where the tool may erroneously perform\ntransformations that remove information and change semantics. Users of the tool\nshould be aware of the behavior and limitations of the check outlined by\nthe cases below.\n\n\n\n\nComments inside loop headers\nÂ¶\n\n\nComments inside the original loop header are ignored and deleted when\ntransformed.\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nN\n;\n \n/* This will be deleted */\n \n++\ni\n)\n \n{\n \n}\n\n\n\n\n\n\n\n\n\n\nRange-based loops evaluate end() only once\nÂ¶\n\n\nThe C++11 range-based for loop calls \n.end()\n only once during the\ninitialization of the loop. If in the original loop \n.end()\n is called after\neach iteration the semantics of the transformed loop may differ.\n\n\n// The following is semantically equivalent to the C++11 range-based for loop,\n\n\n// therefore the semantics of the header will not change.\n\n\nfor\n \n(\niterator\n \nit\n \n=\n \ncontainer\n.\nbegin\n(),\n \ne\n \n=\n \ncontainer\n.\nend\n();\n \nit\n \n!=\n \ne\n;\n \n++\nit\n)\n \n{\n \n}\n\n\n\n// Instead of calling .end() after each iteration, this loop will be\n\n\n// transformed to call .end() only once during the initialization of the loop,\n\n\n// which may affect semantics.\n\n\nfor\n \n(\niterator\n \nit\n \n=\n \ncontainer\n.\nbegin\n();\n \nit\n \n!=\n \ncontainer\n.\nend\n();\n \n++\nit\n)\n \n{\n \n}\n\n\n\n\n\n\nAs explained above, calling member functions of the container in the body\nof the loop is considered \nrisky\n. If the called member function modifies the\ncontainer the semantics of the converted loop will differ due to \n.end()\n\nbeing called only once.\n\n\nbool\n \nflag\n \n=\n \nfalse\n;\n\n\nfor\n \n(\nvector\n<\nT\n>::\niterator\n \nit\n \n=\n \nvec\n.\nbegin\n();\n \nit\n \n!=\n \nvec\n.\nend\n();\n \n++\nit\n)\n \n{\n\n\n  \n// Add a copy of the first element to the end of the vector.\n\n\n  \nif\n \n(\n!\nflag\n)\n \n{\n\n\n    \n// This line makes this transformation 'risky'.\n\n\n    \nvec\n.\npush_back\n(\n*\nit\n);\n\n\n    \nflag\n \n=\n \ntrue\n;\n\n\n  \n}\n\n\n  \ncout\n \n<<\n \n*\nit\n;\n\n\n}\n\n\n\n\n\n\nThe original code above prints out the contents of the container including the\nnewly added element while the converted loop, shown below, will only print the\noriginal contents and not the newly added element.\n\n\nbool\n \nflag\n \n=\n \nfalse\n;\n\n\nfor\n \n(\nauto\n \n&\n \nelem\n \n:\n \nvec\n)\n \n{\n\n\n  \n// Add a copy of the first element to the end of the vector.\n\n\n  \nif\n \n(\n!\nflag\n)\n \n{\n\n\n    \n// This line makes this transformation 'risky'\n\n\n    \nvec\n.\npush_back\n(\nelem\n);\n\n\n    \nflag\n \n=\n \ntrue\n;\n\n\n  \n}\n\n\n  \ncout\n \n<<\n \nelem\n;\n\n\n}\n\n\n\n\n\n\nSemantics will also be affected if \n.end()\n has side effects. For example, in\nthe case where calls to \n.end()\n are logged the semantics will change in the\ntransformed loop if \n.end()\n was originally called after each iteration.\n\n\niterator\n \nend\n()\n \n{\n\n\n  \nnum_of_end_calls\n++\n;\n\n\n  \nreturn\n \ncontainer\n.\nend\n();\n\n\n}\n\n\n\n\n\n\n\n\n\n\nOverloaded operator->() with side effects\nÂ¶\n\n\nSimilarly, if \noperator->()\n was overloaded to have side effects, such as\nlogging, the semantics will change. If the iteratorâs \noperator->()\n was used\nin the original loop it will be replaced with \n<container\n \nelement>.<member>\n\ninstead due to the implicit dereference as part of the range-based for loop.\nTherefore any side effect of the overloaded \noperator->()\n will no longer be\nperformed.\n\n\nfor\n \n(\niterator\n \nit\n \n=\n \nc\n.\nbegin\n();\n \nit\n \n!=\n \nc\n.\nend\n();\n \n++\nit\n)\n \n{\n\n\n  \nit\n->\nfunc\n();\n \n// Using operator->()\n\n\n}\n\n\n// Will be transformed to:\n\n\nfor\n \n(\nauto\n \n&\n \nelem\n \n:\n \nc\n)\n \n{\n\n\n  \nelem\n.\nfunc\n();\n \n// No longer using operator->()\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPointers and references to containers\nÂ¶\n\n\nWhile most of the checkâs risk analysis is dedicated to determining whether\nthe iterator or container was modified within the loop, it is possible to\ncircumvent the analysis by accessing and modifying the container through a\npointer or reference.\n\n\nIf the container were directly used instead of using the pointer or reference\nthe following transformation would have only been applied at the \nrisky\n\nlevel since calling a member function of the container is considered \nrisky\n.\nThe check cannot identify expressions associated with the container that are\ndifferent than the one used in the loop header, therefore the transformation\nbelow ends up being performed at the \nsafe\n level.\n\n\nvector\n<\nint\n>\n \nvec\n;\n\n\n\nvector\n<\nint\n>\n \n*\nptr\n \n=\n \n&\nvec\n;\n\n\nvector\n<\nint\n>\n \n&\nref\n \n=\n \nvec\n;\n\n\n\nfor\n \n(\nvector\n<\nint\n>::\niterator\n \nit\n \n=\n \nvec\n.\nbegin\n(),\n \ne\n \n=\n \nvec\n.\nend\n();\n \nit\n \n!=\n \ne\n;\n \n++\nit\n)\n \n{\n\n\n  \nif\n \n(\n!\nflag\n)\n \n{\n\n\n    \n// Accessing and modifying the container is considered risky, but the risk\n\n\n    \n// level is not raised here.\n\n\n    \nptr\n->\npush_back\n(\n*\nit\n);\n\n\n    \nref\n.\npush_back\n(\n*\nit\n);\n\n\n    \nflag\n \n=\n \ntrue\n;\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nOpenMP\nÂ¶\n\n\nAs range-based for loops are only available since OpenMP 5, this check should\nnot be used on code with a compatibility requirement of OpenMP prior to\nversion 5. It is \nintentional\n that this check does not make any attempts to\nexclude incorrect diagnostics on OpenMP for loops prior to OpenMP 5.\n\n\nTo prevent this check to be applied (and to break) OpenMP for loops\nbut still be applied to non-OpenMP for loops the usage of \nNOLINT\n\n(see \nSuppressing Undesired Diagnostics\n) on the specific for loops is recommended.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/loop-convert.html"
  },
  {
    "name": "modernize-macro-to-enum",
    "description": "Replaces groups of adjacent macros with an unscoped anonymous enum.\nUsing an unscoped anonymous enum ensures that everywhere the macro\ntoken was used previously, the enumerator name may be safely used.\n\nThis check can be used to enforce the C++ core guideline \nEnum.1:\nPrefer enumerations over macros\n,\nwithin the constraints outlined below.\n\nPotential macros for replacement must meet the following constraints:\n\nMacros must expand only to integral literal tokens or expressions\nof literal tokens.  The expression may contain any of the unary\noperators \n-\n, \n+\n, \n~\n or \n!\n, any of the binary operators\n\n,\n, \n-\n, \n+\n, \n*\n, \n/\n, \n%\n, \n&\n, \n|\n, \n^\n, \n<\n,\n\n>\n, \n<=\n, \n>=\n, \n==\n, \n!=\n, \n||\n, \n&&\n, \n<<\n, \n>>\n\nor \n<=>\n, the ternary operator \n?:\n and its\n\nGNU extension\n.\nParenthesized expressions are also recognized.  This recognizes\nmost valid expressions.  In particular, expressions with the\n\nsizeof\n operator are not recognized.\n\n\nMacros must be defined on sequential source file lines, or with\nonly comment lines in between macro definitions.\n\n\nMacros must all be defined in the same source file.\n\n\nMacros must not be defined within a conditional compilation block.\n(Conditional include guards are exempt from this constraint.)\n\n\nMacros must not be defined adjacent to other preprocessor directives.\n\n\nMacros must not be used in any conditional preprocessing directive.\n\n\nMacros must not be used as arguments to other macros.\n\n\nMacros must not be undefined.\n\n\nMacros must be defined at the top-level, not inside any declaration or\ndefinition.\n\nEach cluster of macros meeting the above constraints is presumed to\nbe a set of values suitable for replacement by an anonymous enum.\nFrom there, a developer can give the anonymous enum a name and\ncontinue refactoring to a scoped enum if desired.  Comments on the\nsame line as a macro definition or between subsequent macro definitions\nare preserved in the output.  No formatting is assumed in the provided\nreplacements, although clang-tidy can optionally format all fixes.\n\nWarning\n\n\nInitializing expressions are assumed to be valid initializers for\nan enum.  C requires that enum values fit into an \nint\n, but\nthis may not be the case for some accepted constant expressions.\nFor instance \n1\n \n<<\n \n40\n will not fit into an \nint\n when the size of\nan \nint\n is 32 bits.\n\nExamples:\n\n#define RED   0xFF0000\n\n\n#define GREEN 0x00FF00\n\n\n#define BLUE  0x0000FF\n\n\n\n#define TM_NONE (-1) \n// No method selected.\n\n\n#define TM_ONE 1    \n// Use tailored method one.\n\n\n#define TM_TWO 2    \n// Use tailored method two.  Method two\n\n\n                    \n// is preferable to method one.\n\n\n#define TM_THREE 3  \n// Use tailored method three.\n\nbecomes\n\nenum\n \n{\n\n\nRED\n \n=\n \n0xFF0000\n,\n\n\nGREEN\n \n=\n \n0x00FF00\n,\n\n\nBLUE\n \n=\n \n0x0000FF\n\n\n};\n\n\n\nenum\n \n{\n\n\nTM_NONE\n \n=\n \n(\n-1\n),\n \n// No method selected.\n\n\nTM_ONE\n \n=\n \n1\n,\n    \n// Use tailored method one.\n\n\nTM_TWO\n \n=\n \n2\n,\n    \n// Use tailored method two.  Method two\n\n\n                    \n// is preferable to method one.\n\n\nTM_THREE\n \n=\n \n3\n  \n// Use tailored method three.\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/macro-to-enum.html"
  },
  {
    "name": "modernize-make-shared",
    "description": "This check finds the creation of \nstd::shared_ptr\n objects by explicitly\ncalling the constructor and a \nnew\n expression, and replaces it with a call\nto \nstd::make_shared\n.\n\nauto\n \nmy_ptr\n \n=\n \nstd\n::\nshared_ptr\n<\nMyPair\n>\n(\nnew\n \nMyPair\n(\n1\n,\n \n2\n));\n\n\n\n// becomes\n\n\n\nauto\n \nmy_ptr\n \n=\n \nstd\n::\nmake_shared\n<\nMyPair\n>\n(\n1\n,\n \n2\n);\n\nThis check also finds calls to \nstd::shared_ptr::reset()\n with a \nnew\n\nexpression, and replaces it with a call to \nstd::make_shared\n.\n\nmy_ptr\n.\nreset\n(\nnew\n \nMyPair\n(\n1\n,\n \n2\n));\n\n\n\n// becomes\n\n\n\nmy_ptr\n \n=\n \nstd\n::\nmake_shared\n<\nMyPair\n>\n(\n1\n,\n \n2\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nMakeSmartPtrFunction\nÂ¶\n\n\nA string specifying the name of make-shared-ptr function. Default is\n\nstd::make_shared\n.\n\n\n\n\n\n\n\n\nMakeSmartPtrFunctionHeader\nÂ¶\n\n\nA string specifying the corresponding header of make-shared-ptr function.\nDefault is \n<memory>\n.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreDefaultInitialization\nÂ¶\n\n\nIf set to \nfalse\n, the check does not suggest edits that will transform\ndefault initialization into value initialization, as this can cause\nperformance regressions. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/make-shared.html"
  },
  {
    "name": "modernize-make-unique",
    "description": "This check finds the creation of \nstd::unique_ptr\n objects by explicitly\ncalling the constructor and a \nnew\n expression, and replaces it with a call\nto \nstd::make_unique\n, introduced in C++14.\n\nauto\n \nmy_ptr\n \n=\n \nstd\n::\nunique_ptr\n<\nMyPair\n>\n(\nnew\n \nMyPair\n(\n1\n,\n \n2\n));\n\n\n\n// becomes\n\n\n\nauto\n \nmy_ptr\n \n=\n \nstd\n::\nmake_unique\n<\nMyPair\n>\n(\n1\n,\n \n2\n);\n\nThis check also finds calls to \nstd::unique_ptr::reset()\n with a \nnew\n\nexpression, and replaces it with a call to \nstd::make_unique\n.\n\nmy_ptr\n.\nreset\n(\nnew\n \nMyPair\n(\n1\n,\n \n2\n));\n\n\n\n// becomes\n\n\n\nmy_ptr\n \n=\n \nstd\n::\nmake_unique\n<\nMyPair\n>\n(\n1\n,\n \n2\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nMakeSmartPtrFunction\nÂ¶\n\n\nA string specifying the name of make-unique-ptr function. Default is\n\nstd::make_unique\n.\n\n\n\n\n\n\n\n\nMakeSmartPtrFunctionHeader\nÂ¶\n\n\nA string specifying the corresponding header of make-unique-ptr function.\nDefault is \n<memory>\n.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreDefaultInitialization\nÂ¶\n\n\nIf set to \nfalse\n, the check does not suggest edits that will transform\ndefault initialization into value initialization, as this can cause\nperformance regressions. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/make-unique.html"
  },
  {
    "name": "modernize-min-max-use-initializer-list",
    "description": "Replaces nested \nstd::min\n and \nstd::max\n calls with an initializer list\nwhere applicable.\n\nFor instance, consider the following code:\n\nint\n \na\n \n=\n \nstd\n::\nmax\n(\nstd\n::\nmax\n(\ni\n,\n \nj\n),\n \nk\n);\n\nThe check will transform the above code to:\n\nint\n \na\n \n=\n \nstd\n::\nmax\n({\ni\n,\n \nj\n,\n \nk\n});",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/min-max-use-initializer-list.html"
  },
  {
    "name": "modernize-pass-by-value",
    "description": "With move semantics added to the language and the standard library updated with\nmove constructors added for many types it is now interesting to take an\nargument directly by value, instead of by const-reference, and then copy. This\ncheck allows the compiler to take care of choosing the best way to construct\nthe copy.\n\nThe transformation is usually beneficial when the calling code passes an\n\nrvalue\n and assumes the move construction is a cheap operation. This short\nexample illustrates how the construction of the value happens:\n\nvoid\n \nfoo\n(\nstd\n::\nstring\n \ns\n);\n\n\nstd\n::\nstring\n \nget_str\n();\n\n\n\nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n \n&\nstr\n)\n \n{\n\n\n  \nfoo\n(\nstr\n);\n       \n// lvalue  -> copy construction\n\n\n  \nfoo\n(\nget_str\n());\n \n// prvalue -> move construction\n\n\n}\n\nNote\n\n\nCurrently, only constructors are transformed to make use of pass-by-value.\nContributions that handle other situations are welcome!\n\nPass-by-value in constructors\nÂ¶\n\n\nReplaces the uses of const-references constructor parameters that are copied\ninto class fields. The parameter is then moved with \nstd::move()\n.\n\n\nSince \nstd::move()\n is a library function declared in \n<utility>\n it may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\n\n \n#include\n \n<string>\n\n\n\n \nclass\n \nFoo\n \n{\n\n\n \npublic\n:\n\n\n-\n  \nFoo\n(\nconst\n \nstd\n::\nstring\n \n&\nCopied\n,\n \nconst\n \nstd\n::\nstring\n \n&\nReadOnly\n)\n\n\n-\n    \n:\n \nCopied\n(\nCopied\n),\n \nReadOnly\n(\nReadOnly\n)\n\n\n+\n  \nFoo\n(\nstd\n::\nstring\n \nCopied\n,\n \nconst\n \nstd\n::\nstring\n \n&\nReadOnly\n)\n\n\n+\n    \n:\n \nCopied\n(\nstd\n::\nmove\n(\nCopied\n)),\n \nReadOnly\n(\nReadOnly\n)\n\n\n   \n{}\n\n\n\n \nprivate\n:\n\n\n   \nstd\n::\nstring\n \nCopied\n;\n\n\n   \nconst\n \nstd\n::\nstring\n \n&\nReadOnly\n;\n\n\n \n};\n\n\n\n \nstd\n::\nstring\n \nget_cwd\n();\n\n\n\n \nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n \n&\nPath\n)\n \n{\n\n\n   \n// The parameter corresponding to 'get_cwd()' is move-constructed. By\n\n\n   \n// using pass-by-value in the Foo constructor we managed to avoid a\n\n\n   \n// copy-construction.\n\n\n   \nFoo\n \nfoo\n(\nget_cwd\n(),\n \nPath\n);\n\n\n \n}\n\n\n\n\n\n\nIf the parameter is used more than once no transformation is performed since\nmoved objects have an undefined state. It means the following code will be left\nuntouched:\n\n\n#include\n \n<string>\n\n\n\nvoid\n \npass\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n);\n\n\n\nstruct\n \nFoo\n \n{\n\n\n  \nFoo\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n)\n \n:\n \nStr\n(\nS\n)\n \n{\n\n\n    \npass\n(\nS\n);\n\n\n  \n}\n\n\n\n  \nstd\n::\nstring\n \nStr\n;\n\n\n};\n\nLimitations\nÂ¶\n\n\nA situation where the generated code can be wrong is when the object referenced\nis modified before the assignment in the init-list through a âhiddenâ reference.\n\n\nExample:\n\n\n \nstd\n::\nstring\n \ns\n(\n\"foo\"\n);\n\n\n\n \nstruct\n \nBase\n \n{\n\n\n   \nBase\n()\n \n{\n\n\n     \ns\n \n=\n \n\"bar\"\n;\n\n\n   \n}\n\n\n \n};\n\n\n\n \nstruct\n \nDerived\n \n:\n \nBase\n \n{\n\n\n-\n  \nDerived\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n)\n \n:\n \nField\n(\nS\n)\n\n\n+\n  \nDerived\n(\nstd\n::\nstring\n \nS\n)\n \n:\n \nField\n(\nstd\n::\nmove\n(\nS\n))\n\n\n   \n{\n \n}\n\n\n\n   \nstd\n::\nstring\n \nField\n;\n\n\n \n};\n\n\n\n \nvoid\n \nf\n()\n \n{\n\n\n-\n  \nDerived\n \nd\n(\ns\n);\n \n// d.Field holds \"bar\"\n\n\n+\n  \nDerived\n \nd\n(\ns\n);\n \n// d.Field holds \"foo\"\n\n\n \n}\n\n\n\n\n\n\n\n\nNote about delayed template parsing\nÂ¶\n\n\nWhen delayed template parsing is enabled, constructors part of templated\ncontexts; templated constructors, constructors in class templates, constructors\nof inner classes of template classes, etc., are not transformed. Delayed\ntemplate parsing is enabled by default on Windows as a Microsoft extension:\n\nClang Compiler Userâs Manual - Microsoft extensions\n.\n\n\nDelayed template parsing can be enabled using the \n-fdelayed-template-parsing\n\nflag and disabled using \n-fno-delayed-template-parsing\n.\n\n\nExample:\n\n\n  \ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nC\n \n{\n\n\n    \nstd\n::\nstring\n \nS\n;\n\n\n\n  \npublic\n:\n\n\n=\n  \n// using -fdelayed-template-parsing (default on Windows)\n\n\n=\n  \nC\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n)\n \n:\n \nS\n(\nS\n)\n \n{}\n\n\n\n+\n  \n// using -fno-delayed-template-parsing (default on non-Windows systems)\n\n\n+\n  \nC\n(\nstd\n::\nstring\n \nS\n)\n \n:\n \nS\n(\nstd\n::\nmove\n(\nS\n))\n \n{}\n\n\n  \n};\n\n\n\n\n\n\n\n\nSee also\n\n\nFor more information about the pass-by-value idiom, read: \nWant Speed? Pass by Value\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nValuesOnly\nÂ¶\n\n\nWhen \ntrue\n, the check only warns about copied parameters that are already\npassed by value. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/pass-by-value.html"
  },
  {
    "name": "modernize-raw-string-literal",
    "description": "This check selectively replaces string literals containing escaped characters\nwith raw string literals.\n\nExample:\n\nconst\n \nchar\n \n*\nconst\n \nQuotes\n{\n\"embedded \n\\\"\nquotes\n\\\"\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nParagraph\n{\n\"Line one.\n\\n\nLine two.\n\\n\nLine three.\n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nSingleLine\n{\n\"Single line.\n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nTrailingSpace\n{\n\"Look here -> \n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nTab\n{\n\"One\n\\t\nTwo\n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nBell\n{\n\"Hello!\n\\a\n  And welcome!\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nPath\n{\n\"C:\n\\\\\nProgram Files\n\\\\\nVendor\n\\\\\nApplication.exe\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nRegEx\n{\n\"\n\\\\\nw\n\\\\\n([a-z]\n\\\\\n)\"\n};\n\nbecomes\n\nconst\n \nchar\n \n*\nconst\n \nQuotes\n{\nR\n\"\n(\nembedded \"quotes\"\n)\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nParagraph\n{\n\"Line one.\n\\n\nLine two.\n\\n\nLine three.\n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nSingleLine\n{\n\"Single line.\n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nTrailingSpace\n{\n\"Look here -> \n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nTab\n{\n\"One\n\\t\nTwo\n\\n\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nBell\n{\n\"Hello!\n\\a\n  And welcome!\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nPath\n{\nR\n\"\n(\nC:\\Program Files\\Vendor\\Application.exe\n)\n\"\n};\n\n\nconst\n \nchar\n \n*\nconst\n \nRegEx\n{\nR\n\"\n(\n\\w\\([a-z]\\)\n)\n\"\n};\n\nThe presence of any of the following escapes can cause the string to be\nconverted to a raw string literal: \n\\\\\n, \n\\'\n, \n\\\"\n, \n\\?\n,\nand octal or hexadecimal escapes for printable ASCII characters.\n\nA string literal containing only escaped newlines is a common way of\nwriting lines of text output. Introducing physical newlines with raw\nstring literals in this case is likely to impede readability. These\nstring literals are left unchanged.\n\nAn escaped horizontal tab, form feed, or vertical tab prevents the string\nliteral from being converted. The presence of a horizontal tab, form feed or\nvertical tab in source code is not visually obvious.\n\nOptions\nÂ¶\n\n\n\n\n\n\nDelimiterStem\nÂ¶\n\n\nCustom delimiter to escape characters in raw string literals. It is used in\nthe following construction: \nR\"stem_delimiter(contents)stem_delimiter\"\n.\nThe default value is \nlit\n.\n\n\n\n\n\n\n\n\nReplaceShorterLiterals\nÂ¶\n\n\nControls replacing shorter non-raw string literals with longer raw string\nliterals. Setting this option to \ntrue\n enables the replacement.\nThe default value is \nfalse\n (shorter literals are not replaced).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/raw-string-literal.html"
  },
  {
    "name": "modernize-redundant-void-arg",
    "description": "Find and remove redundant \nvoid\n argument lists.\n\nExamples:\n\n\n\n\nInitial code\n\n\nCode with applied fixes\n\n\n\n\n\n\n\n\nint\n \nf(void);\n\n\nint\n \nf();\n\n\n\n\nint\n \n(*f(void))(void);\n\n\nint\n \n(*f())();\n\n\n\n\ntypedef\n \nint\n \n(*f_t(void))(void);\n\n\ntypedef\n \nint\n \n(*f_t())();\n\n\n\n\nvoid\n \n(C::*p)(void);\n\n\nvoid\n \n(C::*p)();\n\n\n\n\nC::C(void)\n \n{}\n\n\nC::C()\n \n{}\n\n\n\n\nC::~C(void)\n \n{}\n\n\nC::~C()\n \n{}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/redundant-void-arg.html"
  },
  {
    "name": "modernize-replace-auto-ptr",
    "description": "This check replaces the uses of the deprecated class \nstd::auto_ptr\n by\n\nstd::unique_ptr\n (introduced in C++11). The transfer of ownership, done\nby the copy-constructor and the assignment operator, is changed to match\n\nstd::unique_ptr\n usage by using explicit calls to \nstd::move()\n.\n\nMigration example:\n\n-\nvoid\n \ntake_ownership_fn\n(\nstd\n::\nauto_ptr\n<\nint\n>\n \nint_ptr\n);\n\n\n+\nvoid\n \ntake_ownership_fn\n(\nstd\n::\nunique_ptr\n<\nint\n>\n \nint_ptr\n);\n\n\n\n \nvoid\n \nf\n(\nint\n \nx\n)\n \n{\n\n\n-\n  \nstd\n::\nauto_ptr\n<\nint\n>\n \na\n(\nnew\n \nint\n(\nx\n));\n\n\n-\n  \nstd\n::\nauto_ptr\n<\nint\n>\n \nb\n;\n\n\n+\n  \nstd\n::\nunique_ptr\n<\nint\n>\n \na\n(\nnew\n \nint\n(\nx\n));\n\n\n+\n  \nstd\n::\nunique_ptr\n<\nint\n>\n \nb\n;\n\n\n\n-\n  \nb\n \n=\n \na\n;\n\n\n-\n  \ntake_ownership_fn\n(\nb\n);\n\n\n+\n  \nb\n \n=\n \nstd\n::\nmove\n(\na\n);\n\n\n+\n  \ntake_ownership_fn\n(\nstd\n::\nmove\n(\nb\n));\n\n\n \n}\n\nSince \nstd::move()\n is a library function declared in \n<utility>\n it may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\nLimitations\nÂ¶\n\n\n\n\nIf headers modification is not activated or if a header is not allowed to be\nchanged this check will produce broken code (compilation error), where the\nheadersâ code will stay unchanged while the code using them will be changed.\n\n\nClient code that declares a reference to an \nstd::auto_ptr\n coming from\ncode that canât be migrated (such as a header coming from a 3\nrd\n\nparty library) will produce a compilation error after migration. This is\nbecause the type of the reference will be changed to \nstd::unique_ptr\n but\nthe type returned by the library wonât change, binding a reference to\n\nstd::unique_ptr\n from an \nstd::auto_ptr\n. This pattern doesnât make much\nsense and usually \nstd::auto_ptr\n are stored by value (otherwise what is\nthe point in using them instead of a reference or a pointer?).\n\n\n\n\n \n// <3rd-party header...>\n\n\n \nstd\n::\nauto_ptr\n<\nint\n>\n \nget_value\n();\n\n\n \nconst\n \nstd\n::\nauto_ptr\n<\nint\n>\n \n&\n \nget_ref\n();\n\n\n\n \n// <calling code (with migration)...>\n\n\n-\nstd\n::\nauto_ptr\n<\nint\n>\n \na\n(\nget_value\n());\n\n\n+\nstd\n::\nunique_ptr\n<\nint\n>\n \na\n(\nget_value\n());\n \n// ok, unique_ptr constructed from auto_ptr\n\n\n\n-\nconst\n \nstd\n::\nauto_ptr\n<\nint\n>\n \n&\n \np\n \n=\n \nget_ptr\n();\n\n\n+\nconst\n \nstd\n::\nunique_ptr\n<\nint\n>\n \n&\n \np\n \n=\n \nget_ptr\n();\n \n// won't compile\n\n\n\n\n\n\n\n\nNon-instantiated templates arenât modified.\n\n\n\n\ntemplate\n \n<\ntypename\n \nX\n>\n\n\nvoid\n \nf\n()\n \n{\n\n\n    \nstd\n::\nauto_ptr\n<\nX\n>\n \np\n;\n\n\n}\n\n\n\n// only 'f<int>()' (or similar) will trigger the replacement.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/replace-auto-ptr.html"
  },
  {
    "name": "modernize-replace-disallow-copy-and-assign-macro",
    "description": "Finds macro expansions of \nDISALLOW_COPY_AND_ASSIGN(Type)\n and replaces them\nwith a deleted copy constructor and a deleted assignment operator.\n\nBefore the \ndelete\n keyword was introduced in C++11 it was common practice to\ndeclare a copy constructor and an assignment operator as private members. This\neffectively makes them unusable to the public API of a class.\n\nWith the advent of the \ndelete\n keyword in C++11 we can abandon the\n\nprivate\n access of the copy constructor and the assignment operator and\ndelete the methods entirely.\n\nWhen running this check on a code like this:\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nDISALLOW_COPY_AND_ASSIGN\n(\nFoo\n);\n\n\n};\n\nIt will be transformed to this:\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nFoo\n(\nconst\n \nFoo\n \n&\n)\n \n=\n \ndelete\n;\n\n\n  \nconst\n \nFoo\n \n&\noperator\n=\n(\nconst\n \nFoo\n \n&\n)\n \n=\n \ndelete\n;\n\n\n};\n\nLimitations\nÂ¶\n\n\n\n\nNotice that the migration example above leaves the \nprivate\n access\nspecification untouched. You might want to run the check\n\nmodernize-use-equals-delete\n\nto get warnings for deleted functions in private sections.\n\nOptions\nÂ¶\n\n\n\n\n\n\nMacroName\nÂ¶\n\n\nA string specifying the macro name whose expansion will be replaced.\nDefault is \nDISALLOW_COPY_AND_ASSIGN\n.\n\n\n\n\nSee: \nhttps://en.cppreference.com/w/cpp/language/function#Deleted_functions",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/replace-disallow-copy-and-assign-macro.html"
  },
  {
    "name": "modernize-replace-random-shuffle",
    "description": "This check will find occurrences of \nstd::random_shuffle\n and replace it with\n\nstd::shuffle\n. In C++17 \nstd::random_shuffle\n will no longer be available\nand thus we need to replace it.\n\nBelow are two examples of what kind of occurrences will be found and two\nexamples of what it will be replaced with.\n\nstd\n::\nvector\n<\nint\n>\n \nv\n;\n\n\n\n// First example\n\n\nstd\n::\nrandom_shuffle\n(\nvec\n.\nbegin\n(),\n \nvec\n.\nend\n());\n\n\n\n// Second example\n\n\nstd\n::\nrandom_shuffle\n(\nvec\n.\nbegin\n(),\n \nvec\n.\nend\n(),\n \nrandomFunc\n);\n\nBoth of these examples will be replaced with:\n\nstd\n::\nshuffle\n(\nvec\n.\nbegin\n(),\n \nvec\n.\nend\n(),\n \nstd\n::\nmt19937\n(\nstd\n::\nrandom_device\n()()));\n\nThe second example will also receive a warning that \nrandomFunc\n is no longer\nsupported in the same way as before so if the user wants the same\nfunctionality, the user will need to change the implementation of the\n\nrandomFunc\n.\n\nOne thing to be aware of here is that \nstd::random_device\n is quite expensive\nto initialize. So if you are using the code in a performance critical place,\nyou probably want to initialize it elsewhere.\n\nAnother thing is that the seeding quality of the suggested fix is quite poor:\n\nstd::mt19937\n has an internal state of 624 32-bit integers, but is only\nseeded with a single integer. So if you require\nhigher quality randomness, you should consider seeding better, for example:\n\nstd\n::\nshuffle\n(\nv\n.\nbegin\n(),\n \nv\n.\nend\n(),\n \n[]()\n \n{\n\n\n  \nstd\n::\nmt19937\n::\nresult_type\n \nseeds\n[\nstd\n::\nmt19937\n::\nstate_size\n];\n\n\n  \nstd\n::\nrandom_device\n \ndevice\n;\n\n\n  \nstd\n::\nuniform_int_distribution\n<\ntypename\n \nstd\n::\nmt19937\n::\nresult_type\n>\n \ndist\n;\n\n\n  \nstd\n::\ngenerate\n(\nstd\n::\nbegin\n(\nseeds\n),\n \nstd\n::\nend\n(\nseeds\n),\n \n[\n&\n]\n \n{\n \nreturn\n \ndist\n(\ndevice\n);\n \n});\n\n\n  \nstd\n::\nseed_seq\n \nseq\n(\nstd\n::\nbegin\n(\nseeds\n),\n \nstd\n::\nend\n(\nseeds\n));\n\n\n  \nreturn\n \nstd\n::\nmt19937\n(\nseq\n);\n\n\n}());",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/replace-random-shuffle.html"
  },
  {
    "name": "modernize-return-braced-init-list",
    "description": "Replaces explicit calls to the constructor in a return with a braced\ninitializer list. This way the return type is not needlessly duplicated in the\nfunction definition and the return statement.\n\nFoo\n \nbar\n()\n \n{\n\n\n  \nBaz\n \nbaz\n;\n\n\n  \nreturn\n \nFoo\n(\nbaz\n);\n\n\n}\n\n\n\n// transforms to:\n\n\n\nFoo\n \nbar\n()\n \n{\n\n\n  \nBaz\n \nbaz\n;\n\n\n  \nreturn\n \n{\nbaz\n};\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/return-braced-init-list.html"
  },
  {
    "name": "modernize-shrink-to-fit",
    "description": "Replace copy and swap tricks on shrinkable containers with the\n\nshrink_to_fit()\n method call.\n\nThe \nshrink_to_fit()\n method is more readable and more effective than\nthe copy and swap trick to reduce the capacity of a shrinkable container.\nNote that, the \nshrink_to_fit()\n method is only available in C++11 and up.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/shrink-to-fit.html"
  },
  {
    "name": "modernize-type-traits",
    "description": "Converts standard library type traits of the form \ntraits<...>::type\n and\n\ntraits<...>::value\n into \ntraits_t<...>\n and\n\ntraits_v<...>\n respectively.\n\nFor example:\n\nstd\n::\nis_integral\n<\nT\n>::\nvalue\n\n\nstd\n::\nis_same\n<\nint\n,\n \nfloat\n>::\nvalue\n\n\ntypename\n \nstd\n::\nadd_const\n<\nT\n>::\ntype\n\n\nstd\n::\nmake_signed\n<\nunsigned\n>::\ntype\n\nWould be converted into:\n\nstd\n::\nis_integral_v\n<\nT\n>\n\n\nstd\n::\nis_same_v\n<\nint\n,\n \nfloat\n>\n\n\nstd\n::\nadd_const_t\n<\nT\n>\n\n\nstd\n::\nmake_signed_t\n<\nunsigned\n>\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf \ntrue\n donât diagnose traits defined in macros.\n\n\nNote: Fixes will never be emitted for code inside of macros.\n\n\n#define IS_SIGNED(T) std::is_signed<T>::value\n\n\n\n\n\n\nDefaults to \nfalse\n.\n\nLimitations\nÂ¶\n\n\nDoes not currently diagnose uses of type traits with nested name\nspecifiers (e.g. \nstd::chrono::is_clock\n,\n\nstd::chrono::treat_as_floating_point\n).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/type-traits.html"
  },
  {
    "name": "modernize-unary-static-assert",
    "description": "The check diagnoses any \nstatic_assert\n declaration with an\nempty string literal and provides a fix-it note to replace the\ndeclaration with a single-argument \nstatic_assert\n declaration.\n\nThe check is only applicable for C++17 and later code.\n\nThe following code:\n\nvoid\n \nf_textless\n(\nint\n \na\n)\n \n{\n\n\n  \nstatic_assert\n(\nsizeof\n(\na\n)\n \n<=\n \n10\n,\n \n\"\"\n);\n\n\n}\n\nis replaced by:\n\nvoid\n \nf_textless\n(\nint\n \na\n)\n \n{\n\n\n  \nstatic_assert\n(\nsizeof\n(\na\n)\n \n<=\n \n10\n);\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/unary-static-assert.html"
  },
  {
    "name": "modernize-use-auto",
    "description": "This check is responsible for using the \nauto\n type specifier for variable\ndeclarations to \nimprove code readability and maintainability\n. For example:\n\nstd\n::\nvector\n<\nint\n>::\niterator\n \nI\n \n=\n \nmy_container\n.\nbegin\n();\n\n\n\n// transforms to:\n\n\n\nauto\n \nI\n \n=\n \nmy_container\n.\nbegin\n();\n\nThe \nauto\n type specifier will only be introduced in situations where the\nvariable type matches the type of the initializer expression. In other words\n\nauto\n should deduce the same type that was originally spelled in the source.\nHowever, not every situation should be transformed:\n\nint\n \nval\n \n=\n \n42\n;\n\n\nInfoStruct\n \n&\nI\n \n=\n \nSomeObject\n.\ngetInfo\n();\n\n\n\n// Should not become:\n\n\n\nauto\n \nval\n \n=\n \n42\n;\n\n\nauto\n \n&\nI\n \n=\n \nSomeObject\n.\ngetInfo\n();\n\nIn this example using \nauto\n for builtins doesnât improve readability. In\nother situations it makes the code less self-documenting impairing readability\nand maintainability. As a result, \nauto\n is used only introduced in specific\nsituations described below.\n\nIterators\nÂ¶\n\n\nIterator type specifiers tend to be long and used frequently, especially in\nloop constructs. Since the functions generating iterators have a common format,\nthe type specifier can be replaced without obscuring the meaning of code while\nimproving readability and maintainability.\n\n\nfor\n \n(\nstd\n::\nvector\n<\nint\n>::\niterator\n \nI\n \n=\n \nmy_container\n.\nbegin\n(),\n\n\n                                \nE\n \n=\n \nmy_container\n.\nend\n();\n\n\n     \nI\n \n!=\n \nE\n;\n \n++\nI\n)\n \n{\n\n\n}\n\n\n\n// becomes\n\n\n\nfor\n \n(\nauto\n \nI\n \n=\n \nmy_container\n.\nbegin\n(),\n \nE\n \n=\n \nmy_container\n.\nend\n();\n \nI\n \n!=\n \nE\n;\n \n++\nI\n)\n \n{\n\n\n}\n\n\n\n\n\n\nThe check will only replace iterator type-specifiers when all of the following\nconditions are satisfied:\n\n\n\n\nThe iterator is for one of the standard containers in \nstd\n namespace:\n\n\n\n\narray\n\n\ndeque\n\n\nforward_list\n\n\nlist\n\n\nvector\n\n\nmap\n\n\nmultimap\n\n\nset\n\n\nmultiset\n\n\nunordered_map\n\n\nunordered_multimap\n\n\nunordered_set\n\n\nunordered_multiset\n\n\nqueue\n\n\npriority_queue\n\n\nstack\n\n\n\n\n\n\nThe iterator is one of the possible iterator types for standard containers:\n\n\n\n\niterator\n\n\nreverse_iterator\n\n\nconst_iterator\n\n\nconst_reverse_iterator\n\n\n\n\n\n\nIn addition to using iterator types directly, typedefs or other ways of\nreferring to those types are also allowed. However, implementation-specific\ntypes for which a type like \nstd::vector<int>::iterator\n is itself a\ntypedef will not be transformed. Consider the following examples:\n\n\n\n\n// The following direct uses of iterator types will be transformed.\n\n\nstd\n::\nvector\n<\nint\n>::\niterator\n \nI\n \n=\n \nMyVec\n.\nbegin\n();\n\n\n{\n\n\n  \nusing\n \nnamespace\n \nstd\n;\n\n\n  \nlist\n<\nint\n>::\niterator\n \nI\n \n=\n \nMyList\n.\nbegin\n();\n\n\n}\n\n\n\n// The type specifier for J would transform to auto since it's a typedef\n\n\n// to a standard iterator type.\n\n\ntypedef\n \nstd\n::\nmap\n<\nint\n,\n \nstd\n::\nstring\n>::\nconst_iterator\n \nmap_iterator\n;\n\n\nmap_iterator\n \nJ\n \n=\n \nMyMap\n.\nbegin\n();\n\n\n\n// The following implementation-specific iterator type for which\n\n\n// std::vector<int>::iterator could be a typedef would not be transformed.\n\n\n__gnu_cxx\n::\n__normal_iterator\n<\nint\n*\n,\n \nstd\n::\nvector\n>\n \nK\n \n=\n \nMyVec\n.\nbegin\n();\n\n\n\n\n\n\n\n\nThe initializer for the variable being declared is not a braced initializer\nlist. Otherwise, use of \nauto\n would cause the type of the variable to be\ndeduced as \nstd::initializer_list\n.\n\nNew expressions\nÂ¶\n\n\nFrequently, when a pointer is declared and initialized with \nnew\n, the\npointee type is written twice: in the declaration type and in the\n\nnew\n expression. In this case, the declaration type can be replaced with\n\nauto\n improving readability and maintainability.\n\n\nTypeName\n \n*\nmy_pointer\n \n=\n \nnew\n \nTypeName\n(\nmy_param\n);\n\n\n\n// becomes\n\n\n\nauto\n \n*\nmy_pointer\n \n=\n \nnew\n \nTypeName\n(\nmy_param\n);\n\n\n\n\n\n\nThe check will also replace the declaration type in multiple declarations, if\nthe following conditions are satisfied:\n\n\n\n\nAll declared variables have the same type (i.e. all of them are pointers to\nthe same type).\n\n\nAll declared variables are initialized with a \nnew\n expression.\n\n\nThe types of all the new expressions are the same than the pointee of the\ndeclaration type.\n\n\n\n\nTypeName\n \n*\nmy_first_pointer\n \n=\n \nnew\n \nTypeName\n,\n \n*\nmy_second_pointer\n \n=\n \nnew\n \nTypeName\n;\n\n\n\n// becomes\n\n\n\nauto\n \n*\nmy_first_pointer\n \n=\n \nnew\n \nTypeName\n,\n \n*\nmy_second_pointer\n \n=\n \nnew\n \nTypeName\n;\n\nCast expressions\nÂ¶\n\n\nFrequently, when a variable is declared and initialized with a cast, the\nvariable type is written twice: in the declaration type and in the\ncast expression. In this case, the declaration type can be replaced with\n\nauto\n improving readability and maintainability.\n\n\nTypeName\n \n*\nmy_pointer\n \n=\n \nstatic_cast\n<\nTypeName\n>\n(\nmy_param\n);\n\n\n\n// becomes\n\n\n\nauto\n \n*\nmy_pointer\n \n=\n \nstatic_cast\n<\nTypeName\n>\n(\nmy_param\n);\n\n\n\n\n\n\nThe check handles \nstatic_cast\n, \ndynamic_cast\n, \nconst_cast\n,\n\nreinterpret_cast\n, functional casts, C-style casts and function templates\nthat behave as casts, such as \nllvm::dyn_cast\n, \nboost::lexical_cast\n and\n\ngsl::narrow_cast\n. Calls to function templates are considered to behave as\ncasts if the first template argument is explicit and is a type, and the\nfunction returns that type, or a pointer or reference to it.\n\nLimitations\nÂ¶\n\n\n\n\nIf the initializer is an explicit conversion constructor, the check will not\nreplace the type specifier even though it would be safe to do so.\n\n\nUser-defined iterators are not handled at this time.\n\nOptions\nÂ¶\n\n\n\n\n\n\nMinTypeNameLength\nÂ¶\n\n\nIf the option is set to non-zero (default \n5\n), the check will ignore type\nnames having a length less than the option value. The option affects\nexpressions only, not iterators.\nSpaces between multi-lexeme type names (\nlong\n \nint\n) are considered as one.\nIf the \nRemoveStars\n option (see below) is set to \ntrue\n, then \n*s\n\nin the type are also counted as a part of the type name.\n\n\n\n\n// MinTypeNameLength = 0, RemoveStars=0\n\n\n\nint\n \na\n \n=\n \nstatic_cast\n<\nint\n>\n(\nfoo\n());\n            \n// ---> auto a = ...\n\n\n// length(bool *) = 4\n\n\nbool\n \n*\nb\n \n=\n \nnew\n \nbool\n;\n                         \n// ---> auto *b = ...\n\n\nunsigned\n \nc\n \n=\n \nstatic_cast\n<\nunsigned\n>\n(\nfoo\n());\n  \n// ---> auto c = ...\n\n\n\n// MinTypeNameLength = 5, RemoveStars=0\n\n\n\nint\n \na\n \n=\n \nstatic_cast\n<\nint\n>\n(\nfoo\n());\n                 \n// ---> int  a = ...\n\n\nbool\n \nb\n \n=\n \nstatic_cast\n<\nbool\n>\n(\nfoo\n());\n               \n// ---> bool b = ...\n\n\nbool\n \n*\npb\n \n=\n \nstatic_cast\n<\nbool\n*>\n(\nfoo\n());\n            \n// ---> bool *pb = ...\n\n\nunsigned\n \nc\n \n=\n \nstatic_cast\n<\nunsigned\n>\n(\nfoo\n());\n       \n// ---> auto c = ...\n\n\n// length(long <on-or-more-spaces> int) = 8\n\n\nlong\n \nint\n \nd\n \n=\n \nstatic_cast\n<\nlong\n \nint\n>\n(\nfoo\n());\n       \n// ---> auto d = ...\n\n\n\n// MinTypeNameLength = 5, RemoveStars=1\n\n\n\nint\n \na\n \n=\n \nstatic_cast\n<\nint\n>\n(\nfoo\n());\n                 \n// ---> int  a = ...\n\n\n// length(int * * ) = 5\n\n\nint\n \n**\npa\n \n=\n \nstatic_cast\n<\nint\n**>\n(\nfoo\n());\n            \n// ---> auto pa = ...\n\n\nbool\n \nb\n \n=\n \nstatic_cast\n<\nbool\n>\n(\nfoo\n());\n               \n// ---> bool b = ...\n\n\nbool\n \n*\npb\n \n=\n \nstatic_cast\n<\nbool\n*>\n(\nfoo\n());\n            \n// ---> auto pb = ...\n\n\nunsigned\n \nc\n \n=\n \nstatic_cast\n<\nunsigned\n>\n(\nfoo\n());\n       \n// ---> auto c = ...\n\n\nlong\n \nint\n \nd\n \n=\n \nstatic_cast\n<\nlong\n \nint\n>\n(\nfoo\n());\n       \n// ---> auto d = ...\n\n\n\n\n\n\n\n\n\n\nRemoveStars\nÂ¶\n\n\nIf the option is set to \ntrue\n (default is \nfalse\n), the check will remove\nstars from the non-typedef pointer types when replacing type names with\n\nauto\n. Otherwise, the check will leave stars. For example:\n\n\n\n\nTypeName\n \n*\nmy_first_pointer\n \n=\n \nnew\n \nTypeName\n,\n \n*\nmy_second_pointer\n \n=\n \nnew\n \nTypeName\n;\n\n\n\n// RemoveStars = 0\n\n\n\nauto\n \n*\nmy_first_pointer\n \n=\n \nnew\n \nTypeName\n,\n \n*\nmy_second_pointer\n \n=\n \nnew\n \nTypeName\n;\n\n\n\n// RemoveStars = 1\n\n\n\nauto\n \nmy_first_pointer\n \n=\n \nnew\n \nTypeName\n,\n \nmy_second_pointer\n \n=\n \nnew\n \nTypeName\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-auto.html"
  },
  {
    "name": "modernize-use-bool-literals",
    "description": "Finds integer literals which are cast to \nbool\n.\n\nbool\n \np\n \n=\n \n1\n;\n\n\nbool\n \nf\n \n=\n \nstatic_cast\n<\nbool\n>\n(\n1\n);\n\n\nstd\n::\nios_base\n::\nsync_with_stdio\n(\n0\n);\n\n\nbool\n \nx\n \n=\n \np\n \n?\n \n1\n \n:\n \n0\n;\n\n\n\n// transforms to\n\n\n\nbool\n \np\n \n=\n \ntrue\n;\n\n\nbool\n \nf\n \n=\n \ntrue\n;\n\n\nstd\n::\nios_base\n::\nsync_with_stdio\n(\nfalse\n);\n\n\nbool\n \nx\n \n=\n \np\n \n?\n \ntrue\n \n:\n \nfalse\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-bool-literals.html"
  },
  {
    "name": "modernize-use-constraints",
    "description": "Replace \nstd::enable_if\n with C++20 requires clauses.\n\nstd::enable_if\n is a SFINAE mechanism for selecting the desired function or\nclass template based on type traits or other requirements. \nenable_if\n\nchanges the meta-arity of the template, and has other\n\nadverse side effects\n\nin the code. C++20 introduces concepts and constraints as a cleaner language\nprovided solution to achieve the same outcome.\n\nThis check finds some common \nstd::enable_if\n patterns that can be replaced\nby C++20 requires clauses. The tool can replace some of these patterns\nautomatically, otherwise, the tool will emit a diagnostic without a\nreplacement. The tool can detect the following \nstd::enable_if\n patterns\n\nstd::enable_if\n in the return type of a function\n\n\nstd::enable_if\n as the trailing template parameter for function templates\n\nOther uses, for example, in class templates for function parameters, are not\ncurrently supported by this tool. Other variants such as \nboost::enable_if\n\nare not currently supported by this tool.\n\nBelow are some examples of code using \nstd::enable_if\n.\n\n// enable_if in function return type\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n,\n \nint\n>\n \nonly_if_t_has_the_trait\n()\n \n{\n \n...\n \n}\n\n\n\n// enable_if in the trailing template parameter\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n,\n \nint\n>\n \n=\n \n0\n>\n\n\nvoid\n \nanother_version\n()\n \n{\n \n...\n \n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\ntypename\n \nstd\n::\nenable_if\n<\nT\n::\nsome_value\n,\n \nObj\n>::\ntype\n \nexisting_constraint\n()\n \nrequires\n \n(\nT\n::\nanother_value\n)\n \n{\n\n\n  \nreturn\n \nObj\n{};\n\n\n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n,\n \nint\n>\n \n=\n \n0\n>\n\n\nstruct\n \nmy_class\n \n{};\n\nThe tool will replace the above code with,\n\n// warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nint\n \nonly_if_t_has_the_trait\n()\n \nrequires\n \nT\n::\nsome_trait\n \n{\n \n...\n \n}\n\n\n\n// warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nanother_version\n()\n \nrequires\n \nT\n::\nsome_trait\n \n{\n \n...\n \n}\n\n\n\n// The tool will emit a diagnostic for the following, but will\n\n\n// not attempt to replace the code.\n\n\n// warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\ntypename\n \nstd\n::\nenable_if\n<\nT\n::\nsome_value\n,\n \nObj\n>::\ntype\n \nexisting_constraint\n()\n \nrequires\n \n(\nT\n::\nanother_value\n)\n \n{\n\n\n  \nreturn\n \nObj\n{};\n\n\n}\n\n\n\n// The tool will not emit a diagnostic or attempt to replace the code.\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n,\n \nint\n>\n \n=\n \n0\n>\n\n\nstruct\n \nmy_class\n \n{};\n\nNote\n\n\nSystem headers are not analyzed by this check.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-constraints.html"
  },
  {
    "name": "modernize-use-default-member-init",
    "description": "This check converts constructorsâ member initializers into the new\ndefault member initializers in C++11. Other member initializers that match the\ndefault member initializer are removed. This can reduce repeated code or allow\nuse of â= defaultâ.\n\nstruct\n \nA\n \n{\n\n\n  \nA\n()\n \n:\n \ni\n(\n5\n),\n \nj\n(\n10.0\n)\n \n{}\n\n\n  \nA\n(\nint\n \ni\n)\n \n:\n \ni\n(\ni\n),\n \nj\n(\n10.0\n)\n \n{}\n\n\n  \nint\n \ni\n;\n\n\n  \ndouble\n \nj\n;\n\n\n};\n\n\n\n// becomes\n\n\n\nstruct\n \nA\n \n{\n\n\n  \nA\n()\n \n{}\n\n\n  \nA\n(\nint\n \ni\n)\n \n:\n \ni\n(\ni\n)\n \n{}\n\n\n  \nint\n \ni\n{\n5\n};\n\n\n  \ndouble\n \nj\n{\n10.0\n};\n\n\n};\n\nNote\n\n\nOnly converts member initializers for built-in types, enums, and pointers.\nThe \nreadability-redundant-member-init\n check will remove redundant member\ninitializers for classes.\n\nOptions\nÂ¶\n\n\n\n\n\n\nUseAssignment\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \nfalse\n), the check will initialize\nmembers with an assignment. For example:\n\n\n\n\nstruct\n \nA\n \n{\n\n\n  \nA\n()\n \n{}\n\n\n  \nA\n(\nint\n \ni\n)\n \n:\n \ni\n(\ni\n)\n \n{}\n\n\n  \nint\n \ni\n \n=\n \n5\n;\n\n\n  \ndouble\n \nj\n \n=\n \n10.0\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \ntrue\n), the check will not warn\nabout members declared inside macros.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-default-member-init.html"
  },
  {
    "name": "modernize-use-designated-initializers",
    "description": "Finds initializer lists for aggregate types which could be written as\ndesignated initializers instead.\n\nWith plain initializer lists, it is very easy to introduce bugs when adding new\nfields in the middle of a struct or class type. The same confusion might arise\nwhen changing the order of fields.\n\nC++20 supports the designated initializer syntax for aggregate types. By\napplying it, we can always be sure that aggregates are constructed correctly,\nbecause every variable being initialized is referenced by its name.\n\nExample:\n\nstruct\n \nS\n \n{\n \nint\n \ni\n,\n \nj\n;\n \n};\n\nis an aggregate type that should be initialized as\n\nS\n \ns\n{\n.\ni\n \n=\n \n1\n,\n \n.\nj\n \n=\n \n2\n};\n\ninstead of\n\nS\n \ns\n{\n1\n,\n \n2\n};\n\nwhich could easily become an issue when \ni\n and \nj\n are swapped in the\ndeclaration of \nS\n.\n\nEven when compiling in a language version older than C++20, depending on your\ncompiler, designated initializers are potentially supported. Therefore, the\ncheck is by default restricted to C99/C++20 and above. Check out the options\n\n-Wc99-designator\n to get support for mixed designators in initializer list\nin C and \n-Wc++20-designator\n for support of designated initializers in older\nC++ language modes.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nThe value \nfalse\n specifies that components of initializer lists expanded from\nmacros are not checked. The default value is \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreSingleElementAggregates\nÂ¶\n\n\nThe value \nfalse\n specifies that even initializers for aggregate types with\nonly a single element should be checked. The default value is \ntrue\n.\n\nstd::array\n initializations are always excluded, as the type is a\nstandard library abstraction and not intended to be initialized with\ndesignated initializers.\n\n\n\n\n\n\n\n\nRestrictToPODTypes\nÂ¶\n\n\nThe value \ntrue\n specifies that only Plain Old Data (POD) types shall be\nchecked. This makes the check applicable to even older C++ standards. The\ndefault value is \nfalse\n.\n\n\n\n\n\n\n\n\nStrictCStandardCompliance\nÂ¶\n\n\nWhen set to \nfalse\n, the check will not restrict itself to C99 and above.\nThe default value is \ntrue\n.\n\n\n\n\n\n\n\n\nStrictCppStandardCompliance\nÂ¶\n\n\nWhen set to \nfalse\n, the check will not restrict itself to C++20 and above.\nThe default value is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-designated-initializers.html"
  },
  {
    "name": "modernize-use-emplace",
    "description": "The check flags insertions to an STL-style container done by calling the\n\npush_back\n, \npush\n, or \npush_front\n methods with an\nexplicitly-constructed temporary of the container element type. In this case,\nthe corresponding \nemplace\n equivalent methods result in less verbose and\npotentially more efficient code.  Right now the check doesnât support\n\ninsert\n. It also doesnât support \ninsert\n functions for associative\ncontainers because replacing \ninsert\n with \nemplace\n may result in\n\nspeed regression\n, but it might get support with some addition flag in the future.\n\nThe \nContainersWithPushBack\n, \nContainersWithPush\n, and\n\nContainersWithPushFront\n options are used to specify the container\ntypes that support the \npush_back\n, \npush\n, and \npush_front\n operations\nrespectively. The default values for these options are as follows:\n\nContainersWithPushBack\n: \nstd::vector\n, \nstd::deque\n,\nand \nstd::list\n.\n\n\nContainersWithPush\n: \nstd::stack\n, \nstd::queue\n,\nand \nstd::priority_queue\n.\n\n\nContainersWithPushFront\n: \nstd::forward_list\n,\n\nstd::list\n, and \nstd::deque\n.\n\nThis check also reports when an \nemplace\n-like method is improperly used,\nfor example using \nemplace_back\n while also calling a constructor. This\ncreates a temporary that requires at best a move and at worst a copy. Almost\nall \nemplace\n-like functions in the STL are covered by this, with\n\ntry_emplace\n on \nstd::map\n and \nstd::unordered_map\n being the\nexception as it behaves slightly differently than all the others. More\ncontainers can be added with the \nEmplacyFunctions\n option, so long\nas the container defines a \nvalue_type\n type, and the \nemplace\n-like\nfunctions construct a \nvalue_type\n object.\n\nBefore:\n\nstd\n::\nvector\n<\nMyClass\n>\n \nv\n;\n\n\nv\n.\npush_back\n(\nMyClass\n(\n21\n,\n \n37\n));\n\n\nv\n.\nemplace_back\n(\nMyClass\n(\n21\n,\n \n37\n));\n\n\n\nstd\n::\nvector\n<\nstd\n::\npair\n<\nint\n,\n \nint\n>>\n \nw\n;\n\n\n\nw\n.\npush_back\n(\nstd\n::\npair\n<\nint\n,\n \nint\n>\n(\n21\n,\n \n37\n));\n\n\nw\n.\npush_back\n(\nstd\n::\nmake_pair\n(\n21L\n,\n \n37L\n));\n\n\nw\n.\nemplace_back\n(\nstd\n::\nmake_pair\n(\n21L\n,\n \n37L\n));\n\nAfter:\n\nstd\n::\nvector\n<\nMyClass\n>\n \nv\n;\n\n\nv\n.\nemplace_back\n(\n21\n,\n \n37\n);\n\n\nv\n.\nemplace_back\n(\n21\n,\n \n37\n);\n\n\n\nstd\n::\nvector\n<\nstd\n::\npair\n<\nint\n,\n \nint\n>>\n \nw\n;\n\n\nw\n.\nemplace_back\n(\n21\n,\n \n37\n);\n\n\nw\n.\nemplace_back\n(\n21L\n,\n \n37L\n);\n\n\nw\n.\nemplace_back\n(\n21L\n,\n \n37L\n);\n\nBy default, the check is able to remove unnecessary \nstd::make_pair\n and\n\nstd::make_tuple\n calls from \npush_back\n calls on containers of\n\nstd::pair\n and \nstd::tuple\n. Custom tuple-like types can be modified by\nthe \nTupleTypes\n option; custom make functions can be modified by the\n\nTupleMakeFunctions\n option.\n\nThe other situation is when we pass arguments that will be converted to a type\ninside a container.\n\nBefore:\n\nstd\n::\nvector\n<\nboost\n::\noptional\n<\nstd\n::\nstring\n>\n \n>\n \nv\n;\n\n\nv\n.\npush_back\n(\n\"abc\"\n);\n\nAfter:\n\nstd\n::\nvector\n<\nboost\n::\noptional\n<\nstd\n::\nstring\n>\n \n>\n \nv\n;\n\n\nv\n.\nemplace_back\n(\n\"abc\"\n);\n\nIn some cases the transformation would be valid, but the code wouldnât be\nexception safe. In this case the calls of \npush_back\n wonât be replaced.\n\nstd\n::\nvector\n<\nstd\n::\nunique_ptr\n<\nint\n>>\n \nv\n;\n\n\nv\n.\npush_back\n(\nstd\n::\nunique_ptr\n<\nint\n>\n(\nnew\n \nint\n(\n0\n)));\n\n\nauto\n \n*\nptr\n \n=\n \nnew\n \nint\n(\n1\n);\n\n\nv\n.\npush_back\n(\nstd\n::\nunique_ptr\n<\nint\n>\n(\nptr\n));\n\nThis is because replacing it with \nemplace_back\n could cause a leak of this\npointer if \nemplace_back\n would throw exception before emplacement (e.g. not\nenough memory to add a new element).\n\nFor more info read item 42 - âConsider emplacement instead of insertion.â of\nScott Meyers âEffective Modern C++â.\n\nThe default smart pointers that are considered are \nstd::unique_ptr\n,\n\nstd::shared_ptr\n, \nstd::auto_ptr\n. To specify other smart pointers or\nother classes use the \nSmartPointers\n option.\n\nCheck also doesnât fire if any argument of the constructor call would be:\n\na bit-field (bit-fields canât bind to rvalue/universal reference)\n\n\na \nnew\n expression (to avoid leak)\n\n\nif the argument would be converted via derived-to-base cast.\n\nThis check requires C++11 or higher to run.\n\nOptions\nÂ¶\n\n\n\n\n\n\nContainersWithPushBack\nÂ¶\n\n\nSemicolon-separated list of class names of custom containers that support\n\npush_back\n.\n\n\n\n\n\n\n\n\nContainersWithPush\nÂ¶\n\n\nSemicolon-separated list of class names of custom containers that support\n\npush\n.\n\n\n\n\n\n\n\n\nContainersWithPushFront\nÂ¶\n\n\nSemicolon-separated list of class names of custom containers that support\n\npush_front\n.\n\n\n\n\n\n\n\n\nIgnoreImplicitConstructors\nÂ¶\n\n\nWhen \ntrue\n, the check will ignore implicitly constructed arguments of\n\npush_back\n, e.g.\n\n\nstd\n::\nvector\n<\nstd\n::\nstring\n>\n \nv\n;\n\n\nv\n.\npush_back\n(\n\"a\"\n);\n \n// Ignored when IgnoreImplicitConstructors is `true`.\n\n\n\n\n\n\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nSmartPointers\nÂ¶\n\n\nSemicolon-separated list of class names of custom smart pointers.\n\n\n\n\n\n\n\n\nTupleTypes\nÂ¶\n\n\nSemicolon-separated list of \nstd::tuple\n-like class names.\n\n\n\n\n\n\n\n\nTupleMakeFunctions\nÂ¶\n\n\nSemicolon-separated list of \nstd::make_tuple\n-like function names. Those\nfunction calls will be removed from \npush_back\n calls and turned into\n\nemplace_back\n.\n\n\n\n\n\n\n\n\nEmplacyFunctions\nÂ¶\n\n\nSemicolon-separated list of containers without their template parameters\nand some \nemplace\n-like method of the container. Example:\n\nvector::emplace_back\n. Those methods will be checked for improper use and\nthe check will report when a temporary is unnecessarily created. All STL\ncontainers with such member functions are supported by default.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nstd\n::\nvector\n<\nMyTuple\n<\nint\n,\n \nbool\n,\n \nchar\n>>\n \nx\n;\n\n\nx\n.\npush_back\n(\nMakeMyTuple\n(\n1\n,\n \nfalse\n,\n \n'x'\n));\n\n\nx\n.\nemplace_back\n(\nMakeMyTuple\n(\n1\n,\n \nfalse\n,\n \n'x'\n));\n\n\n\n\n\n\ntransforms to:\n\n\nstd\n::\nvector\n<\nMyTuple\n<\nint\n,\n \nbool\n,\n \nchar\n>>\n \nx\n;\n\n\nx\n.\nemplace_back\n(\n1\n,\n \nfalse\n,\n \n'x'\n);\n\n\nx\n.\nemplace_back\n(\n1\n,\n \nfalse\n,\n \n'x'\n);\n\n\n\n\n\n\nwhen \nTupleTypes\n is set to \nMyTuple\n, \nTupleMakeFunctions\n\nis set to \nMakeMyTuple\n, and \nEmplacyFunctions\n is set to\n\nvector::emplace_back\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-emplace.html"
  },
  {
    "name": "modernize-use-equals-default",
    "description": "This check replaces default bodies of special member functions with \n=\n\n\ndefault;\n. The explicitly defaulted function declarations enable more\nopportunities in optimization, because the compiler might treat explicitly\ndefaulted functions as trivial.\n\nstruct\n \nA\n \n{\n\n\n  \nA\n()\n \n{}\n\n\n  \n~\nA\n();\n\n\n};\n\n\nA\n::~\nA\n()\n \n{}\n\n\n\n// becomes\n\n\n\nstruct\n \nA\n \n{\n\n\n  \nA\n()\n \n=\n \ndefault\n;\n\n\n  \n~\nA\n();\n\n\n};\n\n\nA\n::~\nA\n()\n \n=\n \ndefault\n;\n\nNote\n\n\nMove-constructor and move-assignment operator are not supported yet.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros and will\nignore special members with bodies contain macros or preprocessor directives.\nDefault is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-equals-default.html"
  },
  {
    "name": "modernize-use-equals-delete",
    "description": "Identifies unimplemented private special member functions, and recommends using\n\n=\n \ndelete\n for them. Additionally, it recommends relocating any deleted\nmember function from the \nprivate\n to the \npublic\n section.\n\nBefore the introduction of C++11, the primary method to effectively âeraseâ a\nparticular function involved declaring it as \nprivate\n without providing a\ndefinition. This approach would result in either a compiler error (when\nattempting to call a private function) or a linker error (due to an undefined\nreference).\n\nHowever, subsequent to the advent of C++11, a more conventional approach\nemerged for achieving this purpose. It involves flagging functions as\n\n=\n \ndelete\n and keeping them in the \npublic\n section of the class.\n\nTo prevent false positives, this check is only active within a translation\nunit where all other member functions have been implemented. The check will\ngenerate partial fixes by introducing \n=\n \ndelete\n, but the user is responsible\nfor manually relocating functions to the \npublic\n section.\n\n// Example: bad\n\n\nclass\n \nA\n \n{\n\n\n \nprivate\n:\n\n\n  \nA\n(\nconst\n \nA\n&\n);\n\n\n  \nA\n&\n \noperator\n=\n(\nconst\n \nA\n&\n);\n\n\n};\n\n\n\n// Example: good\n\n\nclass\n \nA\n \n{\n\n\n \npublic\n:\n\n\n  \nA\n(\nconst\n \nA\n&\n)\n \n=\n \ndelete\n;\n\n\n  \nA\n&\n \noperator\n=\n(\nconst\n \nA\n&\n)\n \n=\n \ndelete\n;\n\n\n};\n\nIgnoreMacros\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \ntrue\n), the check will not warn\nabout functions declared inside macros.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-equals-delete.html"
  },
  {
    "name": "modernize-use-integer-sign-comparison",
    "description": "Replace comparisons between signed and unsigned integers with their safe\nC++20 \nstd::cmp_*\n alternative, if available.\n\nThe check provides a replacement only for C++20 or later, otherwise\nit highlights the problem and expects the user to fix it manually.\n\nExamples of fixes created by the check:\n\nunsigned\n \nint\n \nfunc\n(\nint\n \na\n,\n \nunsigned\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \na\n \n==\n \nb\n;\n\n\n}\n\nbecomes\n\n#include\n \n<utility>\n\n\n\nunsigned\n \nint\n \nfunc\n(\nint\n \na\n,\n \nunsigned\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \nstd\n::\ncmp_equal\n(\na\n,\n \nb\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n.\nDefault is \nllvm\n.\n\n\n\n\n\n\n\n\nEnableQtSupport\nÂ¶\n\n\nMakes C++17 \nq20::cmp_*\n alternative available for Qt-based\napplications. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-integer-sign-comparison.html"
  },
  {
    "name": "modernize-use-nodiscard",
    "description": "Adds \n[[nodiscard]]\n attributes (introduced in C++17) to member functions in\norder to highlight at compile time which return values should not be ignored.\n\nMember functions need to satisfy the following conditions to be considered by\nthis check:\n\nno \n[[nodiscard]]\n, \n[[noreturn]]\n,\n\n__attribute__((warn_unused_result))\n,\n\n[[clang::warn_unused_result]]\n nor \n[[gcc::warn_unused_result]]\n\nattribute,\n\n\nnon-void return type,\n\n\nnon-template return types,\n\n\nconst member function,\n\n\nnon-variadic functions,\n\n\nno non-const reference parameters,\n\n\nno pointer parameters,\n\n\nno template parameters,\n\n\nno template function parameters,\n\n\nnot be a member of a class with mutable member variables,\n\n\nno Lambdas,\n\n\nno conversion functions.\n\nSuch functions have no means of altering any state or passing values other than\nvia the return type. Unless the member functions are altering state via some\nexternal call (e.g. I/O).\n\nExample\nÂ¶\n\n\nbool\n \nempty\n()\n \nconst\n;\n\n\nbool\n \nempty\n(\nint\n \ni\n)\n \nconst\n;\n\n\n\n\n\n\ntransforms to:\n\n\n[[\nnodiscard\n]]\n \nbool\n \nempty\n()\n \nconst\n;\n\n\n[[\nnodiscard\n]]\n \nbool\n \nempty\n(\nint\n \ni\n)\n \nconst\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nReplacementString\nÂ¶\n\n\nSpecifies a macro to use instead of \n[[nodiscard]]\n. This is useful when\nmaintaining source code that needs to compile with a pre-C++17 compiler.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nbool\n \nempty\n()\n \nconst\n;\n\n\nbool\n \nempty\n(\nint\n \ni\n)\n \nconst\n;\n\n\n\n\n\n\ntransforms to:\n\n\nNO_DISCARD\n \nbool\n \nempty\n()\n \nconst\n;\n\n\nNO_DISCARD\n \nbool\n \nempty\n(\nint\n \ni\n)\n \nconst\n;\n\n\n\n\n\n\nif the \nReplacementString\n option is set to \nNO_DISCARD\n.\n\n\n\n\nNote\n\n\nIf the \nReplacementString\n is not a C++ attribute, but instead a\nmacro, then that macro must be defined in scope or the fix-it will not be\napplied.\n\n\n\n\n\n\nNote\n\n\nFor alternative \n__attribute__\n syntax options to mark functions as\n\n[[nodiscard]]\n in non-c++17 source code.\nSee \nhttps://clang.llvm.org/docs/AttributeReference.html#nodiscard-warn-unused-result",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-nodiscard.html"
  },
  {
    "name": "modernize-use-noexcept",
    "description": "This check replaces deprecated dynamic exception specifications with\nthe appropriate noexcept specification (introduced in C++11). By\ndefault this check will replace \nthrow()\n with \nnoexcept\n,\nand \nthrow(<exception>[,...])\n or \nthrow(...)\n with\n\nnoexcept(false)\n.\n\nExample\nÂ¶\n\n\nvoid\n \nfoo\n()\n \nthrow\n();\n\n\nvoid\n \nbar\n()\n \nthrow\n(\nint\n)\n \n{}\n\n\n\n\n\n\ntransforms to:\n\n\nvoid\n \nfoo\n()\n \nnoexcept\n;\n\n\nvoid\n \nbar\n()\n \nnoexcept\n(\nfalse\n)\n \n{}\n\nOptions\nÂ¶\n\n\n\n\n\n\nReplacementString\nÂ¶\n\n\nUsers can use \nReplacementString\n to specify a macro to use\ninstead of \nnoexcept\n. This is useful when maintaining source code\nthat uses custom exception specification marking other than\n\nnoexcept\n. Fix-it hints will only be generated for non-throwing\nspecifications.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nvoid\n \nbar\n()\n \nthrow\n(\nint\n);\n\n\nvoid\n \nfoo\n()\n \nthrow\n();\n\n\n\n\n\n\ntransforms to:\n\n\nvoid\n \nbar\n()\n \nthrow\n(\nint\n);\n  \n// No fix-it generated.\n\n\nvoid\n \nfoo\n()\n \nNOEXCEPT\n;\n\n\n\n\n\n\nif the \nReplacementString\n option is set to \nNOEXCEPT\n.\n\n\n\n\n\n\nUseNoexceptFalse\nÂ¶\n\n\n\n\nEnabled by default, disabling will generate fix-it hints that remove\nthrowing dynamic exception specs, e.g., \nthrow(<something>)\n,\ncompletely without providing a replacement text, except for\ndestructors and delete operators that are \nnoexcept(true)\n by\ndefault.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nvoid\n \nfoo\n()\n \nthrow\n(\nint\n)\n \n{}\n\n\n\nstruct\n \nbar\n \n{\n\n\n  \nvoid\n \nfoobar\n()\n \nthrow\n(\nint\n);\n\n\n  \nvoid\n \noperator\n \ndelete\n(\nvoid\n \n*\nptr\n)\n \nthrow\n(\nint\n);\n\n\n  \nvoid\n \noperator\n \ndelete\n[](\nvoid\n \n*\nptr\n)\n \nthrow\n(\nint\n);\n\n\n  \n~\nbar\n()\n \nthrow\n(\nint\n);\n\n\n}\n\n\n\n\n\n\ntransforms to:\n\n\nvoid\n \nfoo\n()\n \n{}\n\n\n\nstruct\n \nbar\n \n{\n\n\n  \nvoid\n \nfoobar\n();\n\n\n  \nvoid\n \noperator\n \ndelete\n(\nvoid\n \n*\nptr\n)\n \nnoexcept\n(\nfalse\n);\n\n\n  \nvoid\n \noperator\n \ndelete\n[](\nvoid\n \n*\nptr\n)\n \nnoexcept\n(\nfalse\n);\n\n\n  \n~\nbar\n()\n \nnoexcept\n(\nfalse\n);\n\n\n}\n\n\n\n\n\n\nif the \nUseNoexceptFalse\n option is set to \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-noexcept.html"
  },
  {
    "name": "modernize-use-nullptr",
    "description": "The check converts the usage of null pointer constants (e.g. \nNULL\n, \n0\n)\nto use the new C++11 and C23 \nnullptr\n keyword.\n\nExample\nÂ¶\n\n\nvoid\n \nassignment\n()\n \n{\n\n\n  \nchar\n \n*\na\n \n=\n \nNULL\n;\n\n\n  \nchar\n \n*\nb\n \n=\n \n0\n;\n\n\n  \nchar\n \nc\n \n=\n \n0\n;\n\n\n}\n\n\n\nint\n \n*\nret_ptr\n()\n \n{\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\ntransforms to:\n\n\nvoid\n \nassignment\n()\n \n{\n\n\n  \nchar\n \n*\na\n \n=\n \nnullptr\n;\n\n\n  \nchar\n \n*\nb\n \n=\n \nnullptr\n;\n\n\n  \nchar\n \nc\n \n=\n \n0\n;\n\n\n}\n\n\n\nint\n \n*\nret_ptr\n()\n \n{\n\n\n  \nreturn\n \nnullptr\n;\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredTypes\nÂ¶\n\n\nSemicolon-separated list of regular expressions to match pointer types for\nwhich implicit casts will be ignored. Default value:\n\nstd::_CmpUnspecifiedParam::;^std::__cmp_cat::__unspec\n.\n\n\n\n\n\n\n\n\nNullMacros\nÂ¶\n\n\nComma-separated list of macro names that will be transformed along with\n\nNULL\n. By default this check will only replace the \nNULL\n macro and will\nskip any similar user-defined macros.\n\n\n\n\n\n\nExample\nÂ¶\n\n\n#define MY_NULL (void*)0\n\n\nvoid\n \nassignment\n()\n \n{\n\n\n  \nvoid\n \n*\np\n \n=\n \nMY_NULL\n;\n\n\n}\n\n\n\n\n\n\ntransforms to:\n\n\n#define MY_NULL NULL\n\n\nvoid\n \nassignment\n()\n \n{\n\n\n  \nint\n \n*\np\n \n=\n \nnullptr\n;\n\n\n}\n\n\n\n\n\n\nif the \nNullMacros\n option is set to \nMY_NULL\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-nullptr.html"
  },
  {
    "name": "modernize-use-override",
    "description": "Adds \noverride\n (introduced in C++11) to overridden virtual functions and\nremoves \nvirtual\n from those functions as it is not required.\n\nvirtual\n on non base class implementations was used to help indicate to the\nuser that a function was virtual. C++ compilers did not use the presence of\nthis to signify an overridden function.\n\nIn C++11 \noverride\n and \nfinal\n keywords were introduced to allow\noverridden functions to be marked appropriately. Their presence allows\ncompilers to verify that an overridden function correctly overrides a base\nclass implementation.\n\nThis can be useful as compilers can generate a compile time error when:\n\nThe base class implementation function signature changes.\n\n\nThe user has not created the override with the correct signature.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreDestructors\nÂ¶\n\n\nIf set to \ntrue\n, this check will not diagnose destructors. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreTemplateInstantiations\nÂ¶\n\n\nIf set to \ntrue\n, instructs this check to ignore virtual function overrides\nthat are part of template instantiations. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nAllowOverrideAndFinal\nÂ¶\n\n\nIf set to \ntrue\n, this check will not diagnose \noverride\n as redundant\nwith \nfinal\n. This is useful when code will be compiled by a compiler with\nwarning/error checking flags requiring \noverride\n explicitly on overridden\nmembers, such as \ngcc\n \n-Wsuggest-override\n/\ngcc\n \n-Werror=suggest-override\n.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nOverrideSpelling\nÂ¶\n\n\nSpecifies a macro to use instead of \noverride\n. This is useful when\nmaintaining source code that also needs to compile with a pre-C++11\ncompiler.\n\n\n\n\n\n\n\n\nFinalSpelling\nÂ¶\n\n\nSpecifies a macro to use instead of \nfinal\n. This is useful when\nmaintaining source code that also needs to compile with a pre-C++11\ncompiler.\n\n\n\n\n\n\nNote\n\n\nFor more information on the use of \noverride\n see \nhttps://en.cppreference.com/w/cpp/language/override",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-override.html"
  },
  {
    "name": "modernize-use-ranges",
    "description": "Detects calls to standard library iterator algorithms that could be replaced\nwith a ranges version instead.\n\nExample\nÂ¶\n\n\nauto\n \nIter1\n \n=\n \nstd\n::\nfind\n(\nItems\n.\nbegin\n(),\n \nItems\n.\nend\n(),\n \n0\n);\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nequal\n(\nItems1\n.\ncbegin\n(),\n \nItems1\n.\ncend\n(),\n\n\n                          \nstd\n::\nbegin\n(\nItems2\n),\n \nstd\n::\nend\n(\nItems2\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nIter1\n \n=\n \nstd\n::\nranges\n::\nfind\n(\nItems\n,\n \n0\n);\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nranges\n::\nequal\n(\nItems1\n,\n \nItems2\n);\n\nSupported algorithms\nÂ¶\n\n\nCalls to the following std library algorithms are checked:\n\n\nstd::adjacent_find\n,\n\nstd::all_of\n,\n\nstd::any_of\n,\n\nstd::binary_search\n,\n\nstd::copy_backward\n,\n\nstd::copy_if\n,\n\nstd::copy\n,\n\nstd::destroy\n,\n\nstd::equal_range\n,\n\nstd::equal\n,\n\nstd::fill\n,\n\nstd::find_end\n,\n\nstd::find_if_not\n,\n\nstd::find_if\n,\n\nstd::find\n,\n\nstd::for_each\n,\n\nstd::generate\n,\n\nstd::includes\n,\n\nstd::inplace_merge\n,\n\nstd::iota\n,\n\nstd::is_heap_until\n,\n\nstd::is_heap\n,\n\nstd::is_partitioned\n,\n\nstd::is_permutation\n,\n\nstd::is_sorted_until\n,\n\nstd::is_sorted\n,\n\nstd::lexicographical_compare\n,\n\nstd::lower_bound\n,\n\nstd::make_heap\n,\n\nstd::max_element\n,\n\nstd::merge\n,\n\nstd::min_element\n,\n\nstd::minmax_element\n,\n\nstd::mismatch\n,\n\nstd::move_backward\n,\n\nstd::move\n,\n\nstd::next_permutation\n,\n\nstd::none_of\n,\n\nstd::partial_sort_copy\n,\n\nstd::partition_copy\n,\n\nstd::partition_point\n,\n\nstd::partition\n,\n\nstd::pop_heap\n,\n\nstd::prev_permutation\n,\n\nstd::push_heap\n,\n\nstd::remove_copy_if\n,\n\nstd::remove_copy\n,\n\nstd::remove\n, \nstd::remove_if\n,\n\nstd::replace_if\n,\n\nstd::replace\n,\n\nstd::reverse_copy\n,\n\nstd::reverse\n,\n\nstd::rotate\n,\n\nstd::rotate_copy\n,\n\nstd::sample\n,\n\nstd::search\n,\n\nstd::set_difference\n,\n\nstd::set_intersection\n,\n\nstd::set_symmetric_difference\n,\n\nstd::set_union\n,\n\nstd::shift_left\n,\n\nstd::shift_right\n,\n\nstd::sort_heap\n,\n\nstd::sort\n,\n\nstd::stable_partition\n,\n\nstd::stable_sort\n,\n\nstd::transform\n,\n\nstd::uninitialized_copy\n,\n\nstd::uninitialized_default_construct\n,\n\nstd::uninitialized_fill\n,\n\nstd::uninitialized_move\n,\n\nstd::uninitialized_value_construct\n,\n\nstd::unique_copy\n,\n\nstd::unique\n,\n\nstd::upper_bound\n.\n\n\nNote: some range algorithms for \nvector<bool>\n require C++23 because it uses\nproxy iterators.\n\nReverse Iteration\nÂ¶\n\n\nIf calls are made using reverse iterators on containers, The code will be\nfixed using the \nstd::views::reverse\n adaptor.\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nequal\n(\nItems1\n.\nrbegin\n(),\n \nItems1\n.\nrend\n(),\n\n\n                          \nstd\n::\ncrbegin\n(\nItems2\n),\n \nstd\n::\ncrend\n(\nItems2\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nranges\n::\nequal\n(\nstd\n::\nviews\n::\nreverse\n(\nItems1\n),\n\n\n                                  \nstd\n::\nviews\n::\nreverse\n(\nItems2\n));\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nUseReversePipe\nÂ¶\n\n\nWhen \ntrue\n (default \nfalse\n), fixes which involve reverse ranges will use the\npipe adaptor syntax instead of the function syntax.\n\n\nstd\n::\nfind\n(\nItems\n.\nrbegin\n(),\n \nItems\n.\nrend\n(),\n \n0\n);\n\n\n\n\n\n\nTransforms to:\n\n\nstd\n::\nranges\n::\nfind\n(\nItems\n \n|\n \nstd\n::\nviews\n::\nreverse\n,\n \n0\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-ranges.html"
  },
  {
    "name": "modernize-use-scoped-lock",
    "description": "Finds uses of \nstd::lock_guard\n and suggests replacing them with C++17âs\nalternative \nstd::scoped_lock\n.\n\nFix-its are provided for single declarations of \nstd::lock_guard\n and warning\nis emitted for multiple declarations of \nstd::lock_guard\n that can be\nreplaced with a single declaration of \nstd::scoped_lock\n.\n\nExamples\nÂ¶\n\n\nSingle \nstd::lock_guard\n declaration:\n\n\nstd\n::\nmutex\n \nM\n;\n\n\nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\n \nL\n(\nM\n);\n\n\n\n\n\n\nTransforms to:\n\n\nstd\n::\nmutex\n \nM\n;\n\n\nstd\n::\nscoped_lock\n \nL\n(\nM\n);\n\n\n\n\n\n\nSingle \nstd::lock_guard\n declaration with \nstd::adopt_lock\n:\n\n\nstd\n::\nmutex\n \nM\n;\n\n\nstd\n::\nlock\n(\nM\n);\n\n\nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\n \nL\n(\nM\n,\n \nstd\n::\nadopt_lock\n);\n\n\n\n\n\n\nTransforms to:\n\n\nstd\n::\nmutex\n \nM\n;\n\n\nstd\n::\nlock\n(\nM\n);\n\n\nstd\n::\nscoped_lock\n \nL\n(\nstd\n::\nadopt_lock\n,\n \nM\n);\n\n\n\n\n\n\nMultiple \nstd::lock_guard\n declarations only emit warnings:\n\n\nstd\n::\nmutex\n \nM1\n,\n \nM2\n;\n\n\nstd\n::\nlock\n(\nM1\n,\n \nM2\n);\n\n\nstd\n::\nlock_guard\n \nLock1\n(\nM1\n,\n \nstd\n::\nadopt_lock\n);\n \n// warning: use single 'std::scoped_lock' instead of multiple 'std::lock_guard'\n\n\nstd\n::\nlock_guard\n \nLock2\n(\nM2\n,\n \nstd\n::\nadopt_lock\n);\n \n// note: additional 'std::lock_guard' declared here\n\nLimitations\nÂ¶\n\n\nThe check will not emit warnings if \nstd::lock_guard\n is used implicitly via\n\ntemplate\n parameter:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \ntypename\n \nLock\n>\n\n\nvoid\n \nTemplatedLock\n()\n \n{\n\n\n  \nstd\n::\nmutex\n \nM\n;\n\n\n  \nLock\n<\nstd\n::\nmutex\n>\n \nL\n(\nM\n);\n \n// no warning\n\n\n}\n\n\n\nvoid\n \ninstantiate\n()\n \n{\n\n\n  \nTemplatedLock\n<\nstd\n::\nlock_guard\n>\n();\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnSingleLocks\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on single \nstd::lock_guard\n declarations.\nSet this option to \nfalse\n if you want to get warnings only on multiple\n\nstd::lock_guard\n declarations that can be replaced with a single\n\nstd::scoped_lock\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnUsingAndTypedef\nÂ¶\n\n\nWhen \ntrue\n, the check will emit warnings if \nstd::lock_guard\n is used\nin \nusing\n or \ntypedef\n context. Default is \ntrue\n.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nusing\n \nLock\n \n=\n \nstd\n::\nlock_guard\n<\nT\n>\n;\n \n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'\n\n\n\nusing\n \nLockMutex\n \n=\n \nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\n;\n \n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'\n\n\n\ntypedef\n \nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\n \nLockDef\n;\n \n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'\n\n\n\nusing\n \nstd\n::\nlock_guard\n;\n \n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-scoped-lock.html"
  },
  {
    "name": "modernize-use-starts-ends-with",
    "description": "Checks for common roundabout ways to express \nstarts_with\n and \nends_with\n\nand suggests replacing with the simpler method when it is available. Notably,\nthis will work with \nstd::string\n and \nstd::string_view\n.\n\nCovered scenarios:\n\nExpression\n\n\nReplacement\n\n\n\n\nu.find(v)\n \n==\n \n0\n\n\nu.starts_with(v)\n\n\n\n\nu.find(v,\n \n0)\n \n==\n \n0\n\n\nu.starts_with(v)\n\n\n\n\nu.find(v,\n \n0,\n \nv.size())\n \n==\n \n0\n\n\nu.starts_with(v)\n\n\n\n\nu.rfind(v,\n \n0)\n \n!=\n \n0\n\n\n!u.starts_with(v)\n\n\n\n\nu.rfind(v,\n \n0,\n \nv.size())\n \n!=\n \n0\n\n\n!u.starts_with(v)\n\n\n\n\nu.compare(0,\n \nv.size(),\n \nv)\n \n==\n \n0\n\n\nu.starts_with(v)\n\n\n\n\nu.substr(0,\n \nv.size())\n \n==\n \nv\n\n\nu.starts_with(v)\n\n\n\n\nv\n \n!=\n \nu.substr(0,\n \nv.size())\n\n\n!u.starts_with(v)\n\n\n\n\nu.compare(u.size()\n \n-\n \nv.size(),\n \nv.size(),\n \nv)\n \n==\n \n0\n\n\nu.ends_with(v)\n\n\n\n\nu.rfind(v)\n \n==\n \nu.size()\n \n-\n \nv.size()\n\n\nu.ends_with(v)",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-starts-ends-with.html"
  },
  {
    "name": "modernize-use-std-format",
    "description": "Converts calls to \nabsl::StrFormat\n, or other functions via\nconfiguration options, to C++20âs \nstd::format\n, or another function\nvia a configuration option, modifying the format string appropriately and\nremoving now-unnecessary calls to \nstd::string::c_str()\n and\n\nstd::string::data()\n.\n\nFor example, it turns lines like\n\nreturn\n \nabsl\n::\nStrFormat\n(\n\"The %s is %3d\"\n,\n \ndescription\n.\nc_str\n(),\n \nvalue\n);\n\ninto:\n\nreturn\n \nstd\n::\nformat\n(\n\"The {} is {:3}\"\n,\n \ndescription\n,\n \nvalue\n);\n\nThe check uses the same format-string-conversion algorithm as\n\nmodernize-use-std-print\n and its\nshortcomings and behaviour in combination with macros are described in the\ndocumentation for that check.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\n\n\nWhen \ntrue\n, the check will add casts when converting from variadic\nfunctions and printing signed or unsigned integer types (including\nfixed-width integer types from \n<cstdint>\n, \nptrdiff_t\n, \nsize_t\n\nand \nssize_t\n) as the opposite signedness to ensure that the output\nwould matches that of a simple wrapper for \nstd::sprintf\n that\naccepted a C-style variable argument list. For example, with\n\nStrictMode\n enabled,\n\n\n\n\nextern\n \nstd\n::\nstring\n \nstrprintf\n(\nconst\n \nchar\n \n*\nformat\n,\n \n...);\n\n\nint\n \ni\n \n=\n \n-42\n;\n\n\nunsigned\n \nint\n \nu\n \n=\n \n0xffffffff\n;\n\n\nreturn\n \nstrprintf\n(\n\"%u %d\n\\n\n\"\n,\n \ni\n,\n \nu\n);\n\n\n\n\n\n\nwould be converted to\n\n\nreturn\n \nstd\n::\nformat\n(\n\"{} {}\n\\n\n\"\n,\n \nstatic_cast\n<\nunsigned\n \nint\n>\n(\ni\n),\n \nstatic_cast\n<\nint\n>\n(\nu\n));\n\n\n\n\n\n\nto ensure that the output will continue to be the unsigned representation\nof -42 and the signed representation of 0xffffffff (often 4294967254\nand -1 respectively). When \nfalse\n (which is the default), these casts\nwill not be added which may cause a change in the output. Note that this\noption makes no difference for the default value of\n\nStrFormatLikeFunctions\n since \nabsl::StrFormat\n takes a function\nparameter pack and is not a variadic function.\n\n\n\n\n\n\n\n\nStrFormatLikeFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement that\nthe first parameter contains the printf-style format string and the\narguments to be formatted follow immediately afterwards. Qualified member\nfunction names are supported, but the replacement function name must be\nunqualified. The default value is \nabsl::StrFormat\n.\n\n\n\n\n\n\n\n\nReplacementFormatFunction\nÂ¶\n\n\nThe function that will be used to replace the function set by the\n\nStrFormatLikeFunctions\n option rather than the default\n\nstd::format\n. It is expected that the function provides an interface\nthat is compatible with \nstd::format\n. A suitable candidate would be\n\nfmt::format\n.\n\n\n\n\n\n\n\n\nFormatHeader\nÂ¶\n\n\nThe header that must be included for the declaration of\n\nReplacementFormatFunction\n so that a \n#include\n directive can be added if\nrequired. If \nReplacementFormatFunction\n is \nstd::format\n then this option will\ndefault to \n<format>\n, otherwise this option will default to nothing\nand no \n#include\n directive will be added.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-format.html"
  },
  {
    "name": "modernize-use-std-numbers",
    "description": "Finds constants and function calls to math functions that can be replaced\nwith C++20âs mathematical constants from the \nnumbers\n header and offers\nfix-it hints.\nDoes not match the use of variables with that value, and instead,\noffers a replacement for the definition of those variables.\nFunction calls that match the pattern of how the constant is calculated are\nmatched and replaced with the \nstd::numbers\n constant.\nThe use of macros gets replaced with the corresponding \nstd::numbers\n\nconstant, instead of changing the macro definition.\n\nThe following list of constants from the \nnumbers\n header are supported:\n\ne\n\n\nlog2e\n\n\nlog10e\n\n\npi\n\n\ninv_pi\n\n\ninv_sqrtpi\n\n\nln2\n\n\nln10\n\n\nsqrt2\n\n\nsqrt3\n\n\ninv_sqrt3\n\n\negamma\n\n\nphi\n\nThe list currently includes all constants as of C++20.\n\nThe replacements use the type of the matched constant and can remove explicit\ncasts, i.e., switching between \nstd::numbers::e\n,\n\nstd::numbers::e_v<float>\n and \nstd::numbers::e_v<long\n \ndouble>\n where\nappropriate.\n\ndouble\n \nsqrt\n(\ndouble\n);\n\n\ndouble\n \nlog2\n(\ndouble\n);\n\n\nvoid\n \nsink\n(\nauto\n&&\n)\n \n{}\n\n\nvoid\n \nfloatSink\n(\nfloat\n);\n\n\n\n#define MY_PI 3.1415926\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n\n    \nconst\n \ndouble\n \nPi\n \n=\n \n3.141592653589\n;\n           \n// const double Pi = std::numbers::pi\n\n\n    \nconst\n \nauto\n \nUse\n \n=\n \nPi\n \n/\n \n2\n;\n                    \n// no match for Pi\n\n\n    \nstatic\n \nconstexpr\n \ndouble\n \nEuler\n \n=\n \n2.7182818\n;\n  \n// static constexpr double Euler = std::numbers::e;\n\n\n\n    \nlog2\n(\nexp\n(\n1\n));\n                               \n// std::numbers::log2e;\n\n\n    \nlog2\n(\nEuler\n);\n                                \n// std::numbers::log2e;\n\n\n    \n1\n \n/\n \nsqrt\n(\nMY_PI\n);\n                            \n// std::numbers::inv_sqrtpi;\n\n\n    \nsink\n(\nMY_PI\n);\n                                \n// sink(std::numbers::pi);\n\n\n    \nfloatSink\n(\nMY_PI\n);\n                           \n// floatSink(std::numbers::pi);\n\n\n    \nfloatSink\n(\nstatic_cast\n<\nfloat\n>\n(\nMY_PI\n));\n       \n// floatSink(std::numbers::pi_v<float>);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nDiffThreshold\nÂ¶\n\n\nA floating point value that sets the detection threshold for when literals\nmatch a constant. A literal matches a constant if\n\nabs(literal\n \n-\n \nconstant)\n \n<\n \nDiffThreshold\n evaluates to \ntrue\n. Default\nis \n0.001\n.\n\n\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-numbers.html"
  },
  {
    "name": "modernize-use-std-print",
    "description": "Converts calls to \nprintf\n, \nfprintf\n, \nabsl::PrintF\n and\n\nabsl::FPrintf\n to equivalent calls to C++23âs \nstd::print\n or\n\nstd::println\n as appropriate, modifying the format string appropriately.\nThe replaced and replacement functions can be customised by configuration\noptions. Each argument that is the result of a call to\n\nstd::string::c_str()\n and \nstd::string::data()\n will have that\nnow-unnecessary call removed in a similar manner to the\n\nreadability-redundant-string-cstr\n check.\n\nIn other words, it turns lines like:\n\nfprintf\n(\nstderr\n,\n \n\"The %s is %3d\n\\n\n\"\n,\n \ndescription\n.\nc_str\n(),\n \nvalue\n);\n\ninto:\n\nstd\n::\nprintln\n(\nstderr\n,\n \n\"The {} is {:3}\"\n,\n \ndescription\n,\n \nvalue\n);\n\nIf the \nReplacementPrintFunction\n or \nReplacementPrintlnFunction\n options\nare left at or set to their default values then this check is only enabled\nwith \n-std=c++23\n or later.\n\nMacros starting with \nPRI\n and \n__PRI\n from \n<inttypes.h>\n are\nexpanded, escaping is handled and adjacent strings are concatenated to form\na single \nStringLiteral\n before the format string is converted. Use of\nany other macros in the format string will cause a warning message to be\nemitted and no conversion will be performed. The converted format string\nwill always be a single string literal.\n\nThe check doesnât do a bad job, but itâs not perfect. In particular:\n\nIt assumes that the format string is correct for the arguments. If you\nget any warnings when compiling with \n-Wformat\n then misbehaviour is\npossible.\n\n\nAt the point that the check runs, the AST contains a single\n\nStringLiteral\n for the format string where escapes have been expanded.\nThe check tries to reconstruct escape sequences, they may not be the same\nas they were written (e.g. \n\"\\x41\\x0a\"\n will become \n\"A\\n\"\n and\n\n\"ab\"\n \n\"cd\"\n will become \n\"abcd\"\n.)\n\n\nIt supports field widths, precision, positional arguments, leading zeros,\nleading \n+\n, alignment and alternative forms.\n\n\nUse of any unsupported flags or specifiers will cause the entire\nstatement to be left alone and a warning to be emitted. Particular\nunsupported features are:\n\n\n\n\nThe \n%'\n flag for thousands separators.\n\n\nThe glibc extension \n%m\n.\n\n\n\n\n\n\nprintf\n and similar functions return the number of characters printed.\n\nstd::print\n does not. This means that any invocations that use the\nreturn value will not be converted. Unfortunately this currently includes\nexplicitly-casting to \nvoid\n. Deficiencies in this check mean that any\ninvocations inside \nGCC\n compound statements cannot be converted even\nif the resulting value is not used.\n\nIf conversion would be incomplete or unsafe then the entire invocation will\nbe left unchanged.\n\nIf the call is deemed suitable for conversion then:\n\nprintf\n, \nfprintf\n, \nabsl::PrintF\n, \nabsl::FPrintF\n and any\nfunctions specified by the \nPrintfLikeFunctions\n option or\n\nFprintfLikeFunctions\n are replaced with the function specified by the\n\nReplacementPrintlnFunction\n option if the format string ends with \n\\n\n\nor \nReplacementPrintFunction\n otherwise.\n\n\nthe format string is rewritten to use the \nstd::formatter\n language. If\na \n\\n\n is found at the end of the format string not preceded by \nr\n\nthen it is removed and \nReplacementPrintlnFunction\n is used rather than\n\nReplacementPrintFunction\n.\n\n\nany arguments that corresponded to \n%p\n specifiers that\n\nstd::formatter\n wouldnât accept are wrapped in a \nstatic_cast\n\nto \nconst\n \nvoid\n \n*\n.\n\n\nany arguments that corresponded to \n%s\n specifiers where the argument\nis of \nsigned\n \nchar\n or \nunsigned\n \nchar\n type are wrapped in a\n\nreinterpret_cast<const\n \nchar\n \n*>\n.\n\n\nany arguments where the format string and the parameter differ in\nsignedness will be wrapped in an appropriate \nstatic_cast\n if \nStrictMode\n\nis enabled.\n\n\nany arguments that end in a call to \nstd::string::c_str()\n or\n\nstd::string::data()\n will have that call removed.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\n\n\nWhen \ntrue\n, the check will add casts when converting from variadic\nfunctions like \nprintf\n and printing signed or unsigned integer types\n(including fixed-width integer types from \n<cstdint>\n, \nptrdiff_t\n,\n\nsize_t\n and \nssize_t\n) as the opposite signedness to ensure that\nthe output matches that of \nprintf\n. This does not apply when\nconverting from non-variadic functions such as \nabsl::PrintF\n and\n\nfmt::printf\n. For example, with \nStrictMode\n enabled:\n\n\n\n\nint\n \ni\n \n=\n \n-42\n;\n\n\nunsigned\n \nint\n \nu\n \n=\n \n0xffffffff\n;\n\n\nprintf\n(\n\"%u %d\n\\n\n\"\n,\n \ni\n,\n \nu\n);\n\n\n\n\n\n\nwould be converted to:\n\n\nstd\n::\nprint\n(\n\"{} {}\n\\n\n\"\n,\n \nstatic_cast\n<\nunsigned\n \nint\n>\n(\ni\n),\n \nstatic_cast\n<\nint\n>\n(\nu\n));\n\n\n\n\n\n\nto ensure that the output will continue to be the unsigned representation\nof \n-42\n and the signed representation of \n0xffffffff\n (often\n\n4294967254\n and \n-1\n respectively.) When \nfalse\n (which is the default),\nthese casts will not be added which may cause a change in the output.\n\n\n\n\n\n\n\n\nPrintfLikeFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement\nthat the first parameter contains the printf-style format string and the\narguments to be formatted follow immediately afterwards. Qualified member\nfunction names are supported, but the replacement function name must be\nunqualified. If neither this option nor \nFprintfLikeFunctions\n are set then\nthe default value is \nprintf; absl::PrintF\n, otherwise it is the empty\nstring.\n\n\n\n\n\n\n\n\nFprintfLikeFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement\nthat the first parameter is retained, the second parameter contains the\nprintf-style format string and the arguments to be formatted follow\nimmediately afterwards. Qualified member function names are supported,\nbut the replacement function name must be unqualified. If neither this\noption nor \nPrintfLikeFunctions\n are set then the default value is\n\nfprintf;absl::FPrintF\n, otherwise it is the empty string.\n\n\n\n\n\n\n\n\nReplacementPrintFunction\nÂ¶\n\n\nThe function that will be used to replace \nprintf\n, \nfprintf\n etc.\nduring conversion rather than the default \nstd::print\n when the\noriginalformat string does not end with \n\\n\n. It is expected that the\nfunction provides an interface that is compatible with \nstd::print\n. A\nsuitable candidate would be \nfmt::print\n.\n\n\n\n\n\n\n\n\nReplacementPrintlnFunction\nÂ¶\n\n\nThe function that will be used to replace \nprintf\n, \nfprintf\n etc.\nduring conversion rather than the default \nstd::println\n when the\noriginal format string ends with \n\\n\n. It is expected that the\nfunction provides an interface that is compatible with \nstd::println\n.\nA suitable candidate would be \nfmt::println\n.\n\n\n\n\n\n\n\n\nPrintHeader\nÂ¶\n\n\nThe header that must be included for the declaration of\n\nReplacementPrintFunction\n so that a \n#include\n directive can be\nadded if required. If \nReplacementPrintFunction\n is \nstd::print\n\nthen this option will default to \n<print>\n, otherwise this option will\ndefault to nothing and no \n#include\n directive will be added.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-print.html"
  },
  {
    "name": "modernize-use-string-view",
    "description": "Looks for functions returning \nstd::[w|u8|u16|u32]string\n and suggests to\nchange it to \nstd::[...]string_view\n for performance reasons if possible.\n\nEach time a new \nstd::string\n is created from a literal, a copy of that\nliteral is allocated either in \nstd::string\nâs internal buffer\n(for short literals) or on the heap.\n\nFor the cases where \nstd::string\n is returned from a function,\nsuch allocations can sometimes be eliminated by using \nstd::string_view\n\nas a return type.\n\nThis check looks for such functions returning \nstd::string\n constructed from\nthe literals and suggests replacing their return type to \nstd::string_view\n.\n\nIt handles \nstd::string\n, \nstd::wstring\n, \nstd::u8string\n,\n\nstd::u16string\n and \nstd::u32string\n along with their aliases and selects\nthe proper kind of \nstd::string_view\n to return.\n\nConsider the following example:\n\nstd\n::\nstring\n \nfoo\n(\nint\n \ni\n)\n \n{\n\n\n  \nswitch\n(\ni\n)\n \n{\n\n\n    \ncase\n \n1\n:\n\n\n      \nreturn\n \n\"case 1\"\n;\n\n\n    \n...\n\n\n    \ndefault\n:\n\n\n      \nreturn\n \n\"default\"\n;\n\n\n  \n}\n\n\n}\n\nIn the code above a new \nstd::string\n object is created on each function\ninvocation, making a copy of a string literal and possibly allocating a memory\non the heap.\n\nThe check gets this code transformed into:\n\nstd\n::\nstring_view\n \nfoo\n(\nint\n \ni\n)\n \n{\n\n\n  \nswitch\n(\ni\n)\n \n{\n\n\n    \ncase\n \n1\n:\n\n\n      \nreturn\n \n\"case 1\"\n;\n\n\n    \n...\n\n\n    \ndefault\n:\n\n\n      \nreturn\n \n\"default\"\n;\n\n\n  \n}\n\n\n}\n\nNew version re-uses statically allocated literals without additional overhead.\n\nSuppressing diagnostic\nÂ¶\n\n\nTo prevent an undesired diagnostic wrap the string literal with an explicit\n\nstd::string(...)\n constructor:\n\n\nstd\n::\nstring\n \nfoo\n()\n \n{\n\n\n  \nreturn\n \n\"default\"\n;\n \n//warning and fix are generated\n\n\n}\n\n\n\nstd\n::\nstring\n \nbar\n()\n \n{\n\n\n  \nreturn\n \nstd\n::\nstring\n(\n\"default\"\n);\n \n//warning and fix are NOT generated\n\n\n}\n\nLimitations\nÂ¶\n\n\n\n\nNo warning and/or fix are generated as for now for these code patterns:\n\n\n\n\nreturn\n \nstd::string(\"literal\");\n\n\nreturn\n \nstd::string{\"literal\"};\n\n\nreturn\n \n\"simpleLiteral\"s;\n\n\nauto\n \nfoo()\n \n{\n \nreturn\n \n\"autoReturn\";\n \n}\n\n\nauto\n \nTrailing()\n \n->\n \nstd::string\n \n{\n \nreturn\n \n\"Trailing\";\n \n}\n warns, doesnât fix\n\n\nreturnings from lambda\n\n\ncomplicated macro and templated code\n\n\n\n\n\n\n\n\nIn some cases the fixed code will not compile due to lack of conversion from\n\nstd::string_view\n to \nstd::string\n. It can be fixed (preferably) by\nconverting receiver \nstd::string\n to \nstd::string_view\n if possible or\nsimply make an explicit conversion.\n\n\nstring\n \nfoo\n()\n \n{\n        \n// <--- will be replaced with string_view\n\n\n  \nreturn\n \n\"foo\"\n;\n\n\n}\n\n\n\nvoid\n \nbar\n()\n \n{\n\n\n  \nstring\n \nerr\n \n=\n \nfoo\n();\n \n// <----- error: no viable conversion from\n\n\n                      \n// 'std::string_view' (aka 'basic_string_view<char>')\n\n\n                      \n// to 'std::string' (aka 'basic_string<char>')\n\n\n\n  \nstring\n \nfix\n(\nfoo\n());\n  \n// <----- no errors\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredFunctions\nÂ¶\n\n\nA semicolon-separated list of the names of functions or methods to be\nignored. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n matches\nevery type with suffix \nRef\n, \nref\n, \nReference\n and \nreference\n.\n\n\nIf a name in the list contains the sequence \n::\n it is matched against the\nqualified type name (i.e. \nnamespace::Type\n), otherwise it is matched\nagainst only the type name (i.e. \nType\n).\n\n\nThe default is \ntoString$;ToString$;to_string$\n.\n\n\n\n\n\n\n\n\nReplacementStringViewClass\nÂ¶\n\n\nA semicolon-separated list of \nstring=string_view\n pairs for replacing\n\nstring\n to \nstring_view\n counterparts.\n\n\n\n\n\n\nKey\n\n\nValue (example)\n\n\nDefault value\n\n\n\n\n\n\n\n\nstring\n\n\nllvm::StringRef\n\n\nstd::string_view\n\n\n\n\nwstring\n\n\nboost::wstring_view\n\n\nstd::wstring_view\n\n\n\n\nu8string\n\n\nabsl::u8string_view\n\n\nstd::u8string_view\n\n\n\n\nu16string\n\n\nQStringView\n\n\nstd::u16string_view\n\n\n\n\nu32string\n\n\nstd::u32zstring_view\n\n\nstd::u32string_view",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-string-view.html"
  },
  {
    "name": "modernize-use-structured-binding",
    "description": "Finds places where structured bindings could be used to decompose pairs and\nsuggests replacing them.\n\nThis check finds three code patterns and recommends using structured bindings\nfor clearer, more idiomatic C++17 code.\n\n1. Decompose a pair variable by assigning its members to separate variables\nright after its definition:\n\nauto\n \np\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\n\nint\n \nx\n \n=\n \np\n.\nfirst\n;\n\n\nint\n \ny\n \n=\n \np\n.\nsecond\n;\n\n\n\ninto\n:\n\n\n\nauto\n \n[\nx\n,\n \ny\n]\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\nUse \nstd::tie\n to decompose a pair into two predefined variables:\n\nint\n \na\n;\n\n\nint\n \nb\n;\n\n\nstd\n::\ntie\n(\na\n,\n \nb\n)\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\n\n\ninto\n:\n\n\n\nauto\n \n[\na\n,\n \nb\n]\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\n3. Manually decompose a pair by assigning to its members to local variables\nin a range-based for loop:\n\nfor\n \n(\nauto\n \np\n \n:\n \nvecOfPairs\n)\n \n{\n\n\n  \nint\n \nx\n \n=\n \np\n.\nfirst\n;\n\n\n  \nint\n \ny\n \n=\n \np\n.\nsecond\n;\n\n\n  \n// ...\n\n\n}\n\n\n\ninto\n:\n\n\n\nfor\n \n(\nauto\n \n[\nx\n,\n \ny\n]\n \n:\n \nvecOfPairs\n)\n \n{\n\n\n  \n// use x and y\n\n\n}\n\nLimitations\nÂ¶\n\n\nThe check currently ignores variables defined with attributes or qualifiers\nexcept \nconst\n and \n&\n since itâs not very common:\n\n\nstatic\n \nauto\n \npair\n \n=\n \ngetPair\n();\n\n\nstatic\n \nint\n \nb\n \n=\n \npair\n.\nfirst\n;\n\n\nstatic\n \nint\n \nc\n \n=\n \npair\n.\nsecond\n;\n\n\n\n\n\n\nThe check doesnât handle some situations which could possibly be transferred\nto structured bindings, for example:\n\n\nconst\n \nauto\n&\n \nresults\n \n=\n \nmapping\n.\ntry_emplace\n(\n\"hello!\"\n);\n\n\nconst\n \niterator\n&\n \nit\n \n=\n \nresults\n.\nfirst\n;\n\n\nbool\n \nsucceed\n \n=\n \nresults\n.\nsecond\n;\n\n\n// succeed is not changed in the following code\n\n\n\n\n\n\nand:\n\n\nconst\n \nauto\n \nresults\n \n=\n \nmapping\n.\ntry_emplace\n(\n\"hello!\"\n);\n\n\nif\n \n(\nresults\n.\nsecond\n)\n \n{\n\n\n    \nhandle_inserted\n(\nresults\n.\nfirst\n);\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-structured-binding.html"
  },
  {
    "name": "modernize-use-trailing-return-type",
    "description": "Rewrites function and lambda signatures to use a trailing return type\n(introduced in C++11). This transformation is purely stylistic.\nThe return type before the function name is replaced by \nauto\n\nand inserted after the function parameter list (and qualifiers).\n\nExample\nÂ¶\n\n\nint\n \nf1\n();\n\n\ninline\n \nint\n \nf2\n(\nint\n \narg\n)\n \nnoexcept\n;\n\n\nvirtual\n \nfloat\n \nf3\n()\n \nconst\n \n&&\n \n=\n \ndelete\n;\n\n\nauto\n \nlambda\n \n=\n \n[]()\n \n{};\n\n\n\n\n\n\ntransforms to:\n\n\nauto\n \nf1\n()\n \n->\n \nint\n;\n\n\ninline\n \nauto\n \nf2\n(\nint\n \narg\n)\n \n->\n \nint\n \nnoexcept\n;\n\n\nvirtual\n \nauto\n \nf3\n()\n \nconst\n \n&&\n \n->\n \nfloat\n \n=\n \ndelete\n;\n\n\nauto\n \nlambda\n \n=\n \n[]()\n \n->\n \nvoid\n \n{};\n\nLimitations\nÂ¶\n\n\nThe following categories of return types cannot be rewritten currently:\n\n\n\n\nfunction pointers\n\n\nmember function pointers\n\n\nmember pointers\n\n\n\n\nUnqualified names in the return type might erroneously refer to different\nentities after the rewrite.\nPreventing such errors requires a full lookup of all unqualified names\npresent in the return type in the scope of the trailing return type location.\nThis location includes e.g. function parameter names and members of the\nenclosing class (including all inherited classes).\nSuch a lookup is currently not implemented.\n\n\nGiven the following piece of code\n\n\nstruct\n \nS\n \n{\n \nlong\n \nlong\n \nvalue\n;\n \n};\n\n\nS\n \nf\n(\nunsigned\n \nS\n)\n \n{\n \nreturn\n \n{\nS\n \n*\n \n2\n};\n \n}\n\n\nclass\n \nCC\n \n{\n\n\n  \nint\n \nS\n;\n\n\n  \nstruct\n \nS\n \nm\n();\n\n\n};\n\n\nS\n \nCC::m\n()\n \n{\n \nreturn\n \n{\n0\n};\n \n}\n\n\n\n\n\n\na careless rewrite would produce the following output:\n\n\nstruct\n \nS\n \n{\n \nlong\n \nlong\n \nvalue\n;\n \n};\n\n\nauto\n \nf\n(\nunsigned\n \nS\n)\n \n->\n \nS\n \n{\n \nreturn\n \n{\nS\n \n*\n \n2\n};\n \n}\n \n// error\n\n\nclass\n \nCC\n \n{\n\n\n  \nint\n \nS\n;\n\n\n  \nauto\n \nm\n()\n \n->\n \nstruct\n \nS\n;\n\n\n};\n\n\nauto\n \nCC\n::\nm\n()\n \n->\n \nS\n \n{\n \nreturn\n \n{\n0\n};\n \n}\n \n// error\n\n\n\n\n\n\nThis code fails to compile because the S in the context of f refers to the\nequally named function parameter.\nSimilarly, the S in the context of m refers to the equally named class member.\nThe check can currently only detect and avoid a clash with a function parameter name.\n\nOptions\nÂ¶\n\n\n\n\n\n\nTransformFunctions\nÂ¶\n\n\nWhen set to \ntrue\n, function declarations will be transformed to use trailing\nreturn. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nTransformLambdas\nÂ¶\n\n\nControls how lambda expressions are transformed to use trailing\nreturn type. Possible values are:\n\n\n\n\nall\n - Transform all lambda expressions without an explicit return type\nto use trailing return type. If type can not be deduced, \nauto\n will be\nused since C++14 and generic message will be emitted otherwise.\n\n\nall_except_auto\n - Transform all lambda expressions except those whose return\ntype can not be deduced.\n\n\nnone\n - Do not transform any lambda expressions.\n\n\n\n\nDefault is \nall\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-trailing-return-type.html"
  },
  {
    "name": "modernize-use-transparent-functors",
    "description": "Prefer transparent functors to non-transparent ones. When using transparent\nfunctors, the type does not need to be repeated. The code is easier to read,\nmaintain and less prone to errors. It is not possible to introduce unwanted\nconversions.\n\n// Non-transparent functor\n\n\nstd\n::\nmap\n<\nint\n,\n \nstd\n::\nstring\n,\n \nstd\n::\ngreater\n<\nint\n>>\n \ns\n;\n\n\n\n// Transparent functor.\n\n\nstd\n::\nmap\n<\nint\n,\n \nstd\n::\nstring\n,\n \nstd\n::\ngreater\n<>>\n \ns\n;\n\n\n\n// Non-transparent functor\n\n\nusing\n \nMyFunctor\n \n=\n \nstd\n::\nless\n<\nMyType\n>\n;\n\nIt is not always a safe transformation though. The following case will be\nuntouched to preserve the semantics.\n\n// Non-transparent functor\n\n\nstd\n::\nmap\n<\nconst\n \nchar\n \n*\n,\n \nstd\n::\nstring\n,\n \nstd\n::\ngreater\n<\nstd\n::\nstring\n>>\n \ns\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nSafeMode\nÂ¶\n\n\nIf the option is set to \ntrue\n, the check will not diagnose cases where\nusing a transparent functor cannot be guaranteed to produce identical results\nas the original code. The default value for this option is \nfalse\n.\n\n\n\n\nThis check requires using C++14 or higher to run.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-transparent-functors.html"
  },
  {
    "name": "modernize-use-uncaught-exceptions",
    "description": "This check will warn on calls to \nstd::uncaught_exception\n and replace them\nwith calls to \nstd::uncaught_exceptions\n, since \nstd::uncaught_exception\n\nwas deprecated in C++17.\n\nBelow are a few examples of what kind of occurrences will be found and what\nthey will be replaced with.\n\n#define MACRO1 std::uncaught_exception\n\n\n#define MACRO2 std::uncaught_exception\n\n\n\nint\n \nuncaught_exception\n()\n \n{\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nint\n \nres\n;\n\n\n\n  \nres\n \n=\n \nuncaught_exception\n();\n\n\n  \n// No warning, since it is not the deprecated function from namespace std\n\n\n\n  \nres\n \n=\n \nMACRO2\n();\n\n\n  \n// Warning, but will not be replaced\n\n\n\n  \nres\n \n=\n \nstd\n::\nuncaught_exception\n();\n\n\n  \n// Warning and replaced\n\n\n\n  \nusing\n \nstd\n::\nuncaught_exception\n;\n\n\n  \n// Warning and replaced\n\n\n\n  \nres\n \n=\n \nuncaught_exception\n();\n\n\n  \n// Warning and replaced\n\n\n}\n\nAfter applying the fixes the code will look like the following:\n\n#define MACRO1 std::uncaught_exception\n\n\n#define MACRO2 std::uncaught_exception\n\n\n\nint\n \nuncaught_exception\n()\n \n{\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nint\n \nres\n;\n\n\n\n  \nres\n \n=\n \nuncaught_exception\n();\n\n\n\n  \nres\n \n=\n \nMACRO2\n();\n\n\n\n  \nres\n \n=\n \nstd\n::\nuncaught_exceptions\n();\n\n\n\n  \nusing\n \nstd\n::\nuncaught_exceptions\n;\n\n\n\n  \nres\n \n=\n \nuncaught_exceptions\n();\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-uncaught-exceptions.html"
  },
  {
    "name": "modernize-use-using",
    "description": "The check converts the usage of \ntypedef\n with \nusing\n keyword.\n\nBefore:\n\ntypedef\n \nint\n \nvariable\n;\n\n\n\nclass\n \nClass\n{};\n\n\ntypedef\n \nvoid\n \n(\nClass\n::*\n \nMyPtrType\n)()\n \nconst\n;\n\n\n\ntypedef\n \nstruct\n \n{\n \nint\n \na\n;\n \n}\n \nR_t\n,\n \n*\nR_p\n;\n\nAfter:\n\nusing\n \nvariable\n \n=\n \nint\n;\n\n\n\nclass\n \nClass\n{};\n\n\nusing\n \nMyPtrType\n \n=\n \nvoid\n \n(\nClass\n::*\n)()\n \nconst\n;\n\n\n\nusing\n \nR_t\n \n=\n \nstruct\n \n{\n \nint\n \na\n;\n \n};\n\n\nusing\n \nR_p\n \n=\n \nR_t\n*\n;\n\nThe checker ignores \ntypedef\n within \nextern âCâ { â¦ }\n blocks.\n\nextern\n \n\"C\"\n \n{\n\n\n  \ntypedef\n \nint\n \nInExternC\n;\n \n// Left intact.\n\n\n}\n\nThis check requires using C++11 or higher to run.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreExternC\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warning inside \nextern\n \n\"C\"\n\nscope. Default is \nfalse",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-using.html"
  },
  {
    "name": "mpi-buffer-deref",
    "description": "This check verifies if a buffer passed to an MPI (Message Passing Interface)\nfunction is sufficiently dereferenced. Buffers should be passed as a single\npointer or array. As MPI function signatures specify \nvoid\n \n*\n for their\nbuffer types, insufficiently dereferenced buffers can be passed, like for\nexample as double pointers or multidimensional arrays, without a compiler\nwarning emitted.\n\nExamples:\n\n// A double pointer is passed to the MPI function.\n\n\nchar\n \n*\nbuf\n;\n\n\nMPI_Send\n(\n&\nbuf\n,\n \n1\n,\n \nMPI_CHAR\n,\n \n0\n,\n \n0\n,\n \nMPI_COMM_WORLD\n);\n\n\n\n// A multidimensional array is passed to the MPI function.\n\n\nshort\n \nbuf\n[\n1\n][\n1\n];\n\n\nMPI_Send\n(\nbuf\n,\n \n1\n,\n \nMPI_SHORT\n,\n \n0\n,\n \n0\n,\n \nMPI_COMM_WORLD\n);\n\n\n\n// A pointer to an array is passed to the MPI function.\n\n\nshort\n \n*\nbuf\n[\n1\n];\n\n\nMPI_Send\n(\nbuf\n,\n \n1\n,\n \nMPI_SHORT\n,\n \n0\n,\n \n0\n,\n \nMPI_COMM_WORLD\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/mpi/buffer-deref.html"
  },
  {
    "name": "mpi-type-mismatch",
    "description": "This check verifies if buffer type and MPI (Message Passing Interface)\ndatatype pairs match for used MPI functions. All MPI datatypes defined\nby the MPI standard (3.1) are verified by this check. User defined typedefs,\ncustom MPI datatypes and null pointer constants are skipped, in the course\nof verification.\n\nExample:\n\n// In this case, the buffer type matches MPI datatype.\n\n\nchar\n \nbuf\n;\n\n\nMPI_Send\n(\n&\nbuf\n,\n \n1\n,\n \nMPI_CHAR\n,\n \n0\n,\n \n0\n,\n \nMPI_COMM_WORLD\n);\n\n\n\n// In the following case, the buffer type does not match MPI datatype.\n\n\nint\n \nbuf\n;\n\n\nMPI_Send\n(\n&\nbuf\n,\n \n1\n,\n \nMPI_CHAR\n,\n \n0\n,\n \n0\n,\n \nMPI_COMM_WORLD\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/mpi/type-mismatch.html"
  },
  {
    "name": "objc-assert-equals",
    "description": "Finds improper usages of \nXCTAssertEqual\n and \nXCTAssertNotEqual\n and replaces\nthem with \nXCTAssertEqualObjects\n or \nXCTAssertNotEqualObjects\n.\n\nThis makes tests less fragile, as many improperly rely on pointer equality for\nstrings that have equal values.  This assumption is not guaranteed by the\nlanguage.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/assert-equals.html"
  },
  {
    "name": "objc-avoid-nserror-init",
    "description": "Finds improper initialization of \nNSError\n objects.\n\nAccording to Apple developer document, we should always use factory method\n\nerrorWithDomain:code:userInfo:\n to create new NSError objects instead\nof \n[NSError\n \nalloc]\n \ninit]\n. Otherwise it will lead to a warning message\nduring runtime.\n\nThe corresponding information about \nNSError\n creation: \nhttps://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/CreateCustomizeNSError/CreateCustomizeNSError.html",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/avoid-nserror-init.html"
  },
  {
    "name": "objc-dealloc-in-category",
    "description": "Finds implementations of \n-dealloc\n in Objective-C categories. The category\nimplementation will override any \n-dealloc\n in the class implementation,\npotentially causing issues.\n\nClasses implement \n-dealloc\n to perform important actions to deallocate\nan object. If a category on the class implements \n-dealloc\n, it will\noverride the classâs implementation and unexpected deallocation behavior\nmay occur.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/dealloc-in-category.html"
  },
  {
    "name": "objc-forbidden-subclassing",
    "description": "Finds Objective-C classes which are subclasses of classes which are\nnot designed to be subclassed.\n\nBy default, includes a list of Objective-C classes which are publicly\ndocumented as not supporting subclassing.\n\nNote\n\n\nInstead of using this check, for code under your control, you should add\n\n__attribute__((objc_subclassing_restricted))\n before your \n@interface\n\ndeclarations to ensure the compiler prevents others from subclassing your\nObjective-C classes.\nSee \nhttps://clang.llvm.org/docs/AttributeReference.html#objc-subclassing-restricted\n\nOptions\nÂ¶\n\n\n\n\n\n\nForbiddenSuperClassNames\nÂ¶\n\n\nSemicolon-separated list of names of Objective-C classes which\ndo not support subclassing.\n\n\nDefaults to \nABNewPersonViewController;ABPeoplePickerNavigationController;ABPersonViewController;ABUnknownPersonViewController;NSHashTable;NSMapTable;NSPointerArray;NSPointerFunctions;NSTimer;UIActionSheet;UIAlertView;UIImagePickerController;UITextInputMode;UIWebView\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/forbidden-subclassing.html"
  },
  {
    "name": "objc-missing-hash",
    "description": "Finds Objective-C implementations that implement \n-isEqual:\n without also\nappropriately implementing \n-hash\n.\n\nApple documentation highlights that objects that are equal must have the same\nhash value:\n\nhttps://developer.apple.com/documentation/objectivec/1418956-nsobject/1418795-isequal?language=objc\n\nNote that the check only verifies the presence of \n-hash\n in scenarios where\nits omission could result in unexpected behavior. The verification of the\nimplementation of \n-hash\n is the responsibility of the developer, e.g.,\nthrough the addition of unit tests to verify the implementation.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/missing-hash.html"
  },
  {
    "name": "objc-nsdate-formatter",
    "description": "When \nNSDateFormatter\n is used to convert an \nNSDate\n type to a \nString\n\ntype, the user can specify a custom format string. Certain format specifiers\nare undesirable despite being legal.\nSee \nhttp://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\nfor all legal date patterns.\n\nThis checker reports as warnings the following string patterns in a date\nformat specifier:\n\nyyyy + ww : Calendar year specified with week of a week year\n(unless YYYY is also specified).\n\n\n\n\n\n\nExample 1:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nyyyy-ww\n;\n\n\nOutput string: \n2014-01\n (Wrong because itâs not the first week of 2014)\n\n\n\n\n\n\n\n\nExample 2:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \ndd-MM-yyyy (ww-YYYY)\n;\n\n\nOutput string: \n29-12-2014 (01-2015)\n (This is correct)\n\n\n\n\n\n\n\n\n\n\nF without ee/EE : Numeric day of week in a month without actual day.\n\n\n\n\n\n\nExample:\n Input Date: \n29 December 2014\n ; Format String: \nF-MM\n;\n\n\nOutput string: \n5-12\n (Wrong because it reads as \n5th ___ of Dec\n in\n\n\nEnglish)\n\n\n\n\n\n\n\n\n\n\nF without MM : Numeric day of week in a month without month.\n\n\n\n\n\n\nExample:\n Input Date: \n29 December 2014\n ; Format String: \nF-EE\n\n\nOutput string: \n5-Mon\n (Wrong because it reads as \n5th Mon of ___\n in\n\n\nEnglish)\n\n\n\n\n\n\n\n\n\n\nWW without MM : Week of the month without the month.\n\n\n\n\n\n\nExample:\n Input Date: \n29 December 2014\n ; Format String: \nWW-yyyy\n\n\nOutput string: \n05-2014\n (Wrong because it reads as \n5th Week of ___\n in\n\n\nEnglish)\n\n\n\n\n\n\n\n\n\n\nYYYY + QQ : Week year specified with quarter of normal year\n(unless yyyy is also specified).\n\n\n\n\n\n\nExample 1:\n Input Date: \n29 December 2014\n ; Format String: \nYYYY-QQ\n\n\nOutput string: \n2015-04\n (Wrong because itâs not the 4th quarter of\n\n\n2015)\n\n\n\n\n\n\n\n\nExample 2:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nww-YYYY (QQ-yyyy)\n\n\nOutput string: \n01-2015 (04-2014)\n (This is correct)\n\n\n\n\n\n\n\n\n\n\nYYYY + MM :  Week year specified with Month of a calendar year\n(unless yyyy is also specified).\n\n\n\n\n\n\nExample 1:\n Input Date: \n29 December 2014\n ; Format String: \nYYYY-MM\n\n\nOutput string: \n2015-12\n (Wrong because itâs not the 12th month of 2015)\n\n\n\n\n\n\n\n\nExample 2:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nww-YYYY (MM-yyyy)\n\n\nOutput string: \n01-2015 (12-2014)\n (This is correct)\n\n\n\n\n\n\n\n\n\n\nYYYY + DD : Week year with day of a calendar year\n(unless yyyy is also specified).\n\n\n\n\n\n\nExample 1:\n Input Date: \n29 December 2014\n ; Format String: \nYYYY-DD\n\n\nOutput string: \n2015-363\n (Wrong because itâs not the 363rd day of 2015)\n\n\n\n\n\n\n\n\nExample 2:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nww-YYYY (DD-yyyy)\n\n\nOutput string: \n01-2015 (363-2014)\n (This is correct)\n\n\n\n\n\n\n\n\n\n\nYYYY + WW : Week year with week of a calendar year\n(unless yyyy is also specified).\n\n\n\n\n\n\nExample 1:\n Input Date: \n29 December 2014\n ; Format String: \nYYYY-WW\n\n\nOutput string: \n2015-05\n (Wrong because itâs not the 5th week of 2015)\n\n\n\n\n\n\n\n\nExample 2:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nww-YYYY (WW-MM-yyyy)\n\n\nOutput string: \n01-2015 (05-12-2014)\n (This is correct)\n\n\n\n\n\n\n\n\n\n\nYYYY + F : Week year with day of week in a calendar month\n(unless yyyy is also specified).\n\n\n\n\n\n\nExample 1:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nYYYY-ww-F-EE\n\n\nOutput string: \n2015-01-5-Mon\n (Wrong because itâs not the 5th Monday of\n\n\nJanuary in 2015)\n\n\n\n\n\n\n\n\nExample 2:\n Input Date: \n29 December 2014\n ;\n\n\nFormat String: \nww-YYYY (F-EE-MM-yyyy)\n\n\nOutput string: \n01-2015 (5-Mon-12-2014)\n (This is correct)",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/nsdate-formatter.html"
  },
  {
    "name": "objc-nsinvocation-argument-lifetime",
    "description": "Finds calls to \nNSInvocation\n methods under ARC that donât have proper\nargument object lifetimes. When passing Objective-C objects as parameters\nto the \nNSInvocation\n methods \ngetArgument:atIndex:\n and\n\ngetReturnValue:\n, the values are copied by value into the argument pointer,\nwhich leads to incorrect releasing behavior if the object pointers are\nnot declared \n__unsafe_unretained\n.\n\nFor code:\n\nid\n \narg\n;\n\n\n[\ninvocation\n \ngetArgument\n:&\narg\n \natIndex\n:\n2\n];\n\n\n\n__strong\n \nid\n \nreturnValue\n;\n\n\n[\ninvocation\n \ngetReturnValue\n:&\nreturnValue\n];\n\nThe fix will be:\n\n__unsafe_unretained\n \nid\n \narg\n;\n\n\n[\ninvocation\n \ngetArgument\n:&\narg\n \natIndex\n:\n2\n];\n\n\n\n__unsafe_unretained\n \nid\n \nreturnValue\n;\n\n\n[\ninvocation\n \ngetReturnValue\n:&\nreturnValue\n];\n\nThe check will warn on being passed instance variable references that have\nlifetimes other than \n__unsafe_unretained\n, but does not propose a fix:\n\n// \"id _returnValue\" is declaration of instance variable of class.\n\n\n[\ninvocation\n \ngetReturnValue\n:&\nself\n->\n_returnValue\n];",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/nsinvocation-argument-lifetime.html"
  },
  {
    "name": "objc-property-declaration",
    "description": "Finds property declarations in Objective-C files that do not follow the pattern\nof property names in Appleâs programming guide. The property name should be\nin the format of Lower Camel Case.\n\nFor code:\n\n@property\n(\nnonatomic\n,\n \nassign\n)\n \nint\n \nLowerCamelCase\n;\n\nThe fix will be:\n\n@property\n(\nnonatomic\n,\n \nassign\n)\n \nint\n \nlowerCamelCase\n;\n\nThe check will only fix âCamelCaseâ to âcamelCaseâ. In some other cases we will\nonly provide warning messages since the property name could be complicated.\nUsers will need to come up with a proper name by their own.\n\nThis check also accepts special acronyms as prefixes or suffixes. Such prefixes\nor suffixes will suppress the Lower Camel Case check according to the guide:\n\nhttps://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-1002931-BBCFHEAB\n\nFor a full list of well-known acronyms:\n\nhttps://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE\n\nThe corresponding style rule: \nhttps://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-1001757\n\nThe check will also accept property declared in category with a prefix of\nlowercase letters followed by a â_â to avoid naming conflict. For example:\n\n@property\n(\nnonatomic\n,\n \nassign\n)\n \nint\n \nabc_lowerCamelCase\n;\n\nThe corresponding style rule: \nhttps://developer.apple.com/library/content/qa/qa1908/_index.html",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/property-declaration.html"
  },
  {
    "name": "objc-super-self",
    "description": "Finds invocations of \n-self\n on super instances in initializers of subclasses\nof \nNSObject\n and recommends calling a superclass initializer instead.\n\nInvoking \n-self\n on super instances in initializers is a common programmer\nerror when the programmerâs original intent is to call a superclass\ninitializer. Failing to call a superclass initializer breaks initializer\nchaining and can result in invalid object initialization.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/objc/super-self.html"
  },
  {
    "name": "openmp-exception-escape",
    "description": "Analyzes OpenMP Structured Blocks and checks that no exception escapes\nout of the Structured Block it was thrown in.\n\nAs per the OpenMP specification, a structured block is an executable statement,\npossibly compound, with a single entry at the top and a single exit at the\nbottom. Which means, \nthrow\n may not be used to âexitâ out of the\nstructured block. If an exception is not caught in the same structured block\nit was thrown in, the behavior is undefined.\n\nFIXME: this check does not model SEH, \nsetjmp\n/\nlongjmp\n.\n\nWARNING! This check may be expensive on large source files.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredExceptions\nÂ¶\n\n\nComma-separated list containing type names which are not counted as thrown\nexceptions in the check. Default value is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/openmp/exception-escape.html"
  },
  {
    "name": "openmp-use-default-none",
    "description": "Finds OpenMP directives that are allowed to contain a \ndefault\n clause,\nbut either donât specify it or the clause is specified but with the kind\nother than \nnone\n, and suggests to use the \ndefault(none)\n clause.\n\nUsing \ndefault(none)\n clause forces developers to explicitly specify data\nsharing attributes for the variables referenced in the construct,\nthus making it obvious which variables are referenced, and what is their\ndata sharing attribute, thus increasing readability and possibly making errors\neasier to spot.\n\nExample\nÂ¶\n\n\n// ``for`` directive cannot have ``default`` clause, no diagnostics.\n\n\nvoid\n \nn0\n(\nconst\n \nint\n \na\n)\n \n{\n\n\n#pragma omp for\n\n\n  \nfor\n \n(\nint\n \nb\n \n=\n \n0\n;\n \nb\n \n<\n \na\n;\n \nb\n++\n)\n\n\n    \n;\n\n\n}\n\n\n\n// ``parallel`` directive.\n\n\n\n// ``parallel`` directive can have ``default`` clause, but said clause is not\n\n\n// specified, diagnosed.\n\n\nvoid\n \np0_0\n()\n \n{\n\n\n#pragma omp parallel\n\n\n  \n;\n\n\n  \n// WARNING: OpenMP directive ``parallel`` does not specify ``default``\n\n\n  \n//          clause. Consider specifying ``default(none)`` clause.\n\n\n}\n\n\n\n// ``parallel`` directive can have ``default`` clause, and said clause is\n\n\n// specified, with ``none`` kind, all good.\n\n\nvoid\n \np0_1\n()\n \n{\n\n\n#pragma omp parallel default(none)\n\n\n  \n;\n\n\n}\n\n\n\n// ``parallel`` directive can have ``default`` clause, and said clause is\n\n\n// specified, but with ``shared`` kind, which is not ``none``, diagnose.\n\n\nvoid\n \np0_2\n()\n \n{\n\n\n#pragma omp parallel default(shared)\n\n\n  \n;\n\n\n  \n// WARNING: OpenMP directive ``parallel`` specifies ``default(shared)``\n\n\n  \n//          clause. Consider using ``default(none)`` clause instead.\n\n\n}\n\n\n\n// ``parallel`` directive can have ``default`` clause, and said clause is\n\n\n// specified, but with ``firstprivate`` kind, which is not ``none``, diagnose.\n\n\nvoid\n \np0_3\n()\n \n{\n\n\n#pragma omp parallel default(firstprivate)\n\n\n  \n;\n\n\n  \n// WARNING: OpenMP directive ``parallel`` specifies ``default(firstprivate)``\n\n\n  \n//          clause. Consider using ``default(none)`` clause instead.\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/openmp/use-default-none.html"
  },
  {
    "name": "performance-avoid-endl",
    "description": "Checks for uses of \nstd::endl\n on streams and suggests using the newline\ncharacter \n'\\n'\n instead.\n\nRationale:\nUsing \nstd::endl\n on streams can be less efficient than using the newline\ncharacter \n'\\n'\n because \nstd::endl\n performs two operations: it writes a\nnewline character to the output stream and then flushes the stream buffer.\nWriting a single newline character using \n'\\n'\n does not trigger a flush,\nwhich can improve performance. In addition, flushing the stream buffer can\ncause additional overhead when working with streams that are buffered.\n\nExample:\n\nConsider the following code:\n\n#include\n \n<iostream>\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \n\"Hello\"\n \n<<\n \nstd\n::\nendl\n;\n\n\n}\n\nWhich gets transformed into:\n\n#include\n \n<iostream>\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \n\"Hello\"\n \n<<\n \n'\\n'\n;\n\n\n}\n\nThis code writes a single newline character to the \nstd::cout\n stream without\nflushing the stream buffer.\n\nAdditionally, it is important to note that the standard C++ streams (like\n\nstd::cerr\n, \nstd::wcerr\n, \nstd::clog\n and \nstd::wclog\n)\nalways flush after a write operation, unless \nstd::ios_base::sync_with_stdio\n\nis set to \nfalse\n. regardless of whether \nstd::endl\n or \n'\\n'\n is used.\nTherefore, using \n'\\n'\n with these streams will not\nresult in any performance gain, but it is still recommended to use\n\n'\\n'\n for consistency and readability.\n\nIf you do need to flush the stream buffer, you can use \nstd::flush\n\nexplicitly like this:\n\n#include\n \n<iostream>\n\n\n\nint\n \nmain\n()\n \n{\n\n\n  \nstd\n::\ncout\n \n<<\n \n\"Hello\n\\n\n\"\n \n<<\n \nstd\n::\nflush\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/avoid-endl.html"
  },
  {
    "name": "performance-enum-size",
    "description": "Recommends the smallest possible underlying type for an \nenum\n or \nenum\n\nclass based on the range of its enumerators. Analyzes the values of the\nenumerators in an \nenum\n or \nenum\n class, including signed values, to\nrecommend the smallest possible underlying type that can represent all the\nvalues of the \nenum\n. The suggested underlying types are the integral types\n\nstd::uint8_t\n, \nstd::uint16_t\n, and \nstd::uint32_t\n for unsigned types,\nand \nstd::int8_t\n, \nstd::int16_t\n, and \nstd::int32_t\n for signed types.\nUsing the suggested underlying types can help reduce the memory footprint of\nthe program and improve performance in some cases.\n\nFor example:\n\n// BEFORE\n\n\nenum\n \nColor\n \n{\n\n\n    \nRED\n \n=\n \n-1\n,\n\n\n    \nGREEN\n \n=\n \n0\n,\n\n\n    \nBLUE\n \n=\n \n1\n\n\n};\n\n\n\nstd\n::\noptional\n<\nColor\n>\n \ncolor_opt\n;\n\nThe \nColor\n \nenum\n uses the default underlying type, which is \nint\n in this\ncase, and its enumerators have values of -1, 0, and 1. Additionally, the\n\nstd::optional<Color>\n object uses 8 bytes due to padding (platform\ndependent).\n\n// AFTER\n\n\nenum\n \nColor\n \n:\n \nstd\n::\nint8_t\n \n{\n\n\n    \nRED\n \n=\n \n-1\n,\n\n\n    \nGREEN\n \n=\n \n0\n,\n\n\n    \nBLUE\n \n=\n \n1\n\n\n}\n\n\n\nstd\n::\noptional\n<\nColor\n>\n \ncolor_opt\n;\n\nIn the revised version of the \nColor\n \nenum\n, the underlying type has been\nchanged to \nstd::int8_t\n. The enumerator \nRED\n has a value of -1, which can\nbe represented by a signed 8-bit integer.\n\nBy using a smaller underlying type, the memory footprint of the \nColor\n\n\nenum\n is reduced from 4 bytes to 1 byte. The revised version of the\n\nstd::optional<Color>\n object would only require 2 bytes (due to lack of\npadding), since it contains a single byte for the \nColor\n \nenum\n and a single\nbyte for the \nbool\n flag that indicates whether the optional value is set.\n\nReducing the memory footprint of an \nenum\n can have significant benefits in\nterms of memory usage and cache performance. However, itâs important to\nconsider the trade-offs and potential impact on code readability and\nmaintainability.\n\nEnums without enumerators (empty) are excluded from analysis.\n\nRequires C++11 or above.\nDoes not provide auto-fixes.\n\nOptions\nÂ¶\n\n\n\n\n\n\nEnumIgnoreList\nÂ¶\n\n\nOption is used to ignore certain enum types. It accepts a\nsemicolon-separated list of (fully qualified) enum type names or regular\nexpressions that match the enum type names. The default value is an empty\nstring, which means no enums will be ignored.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/enum-size.html"
  },
  {
    "name": "performance-faster-string-find",
    "description": "Optimize calls to \nstd::string::find()\n and friends when the needle passed is\na single character string literal. The character literal overload is more\nefficient.\n\nExamples:\n\nstr\n.\nfind\n(\n\"A\"\n);\n\n\n\n// becomes\n\n\n\nstr\n.\nfind\n(\n'A'\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringLikeClasses\nÂ¶\n\n\nSemicolon-separated list of names of string-like classes. By default only\n\n::std::basic_string\n and \n::std::basic_string_view\n are considered.\nThe check will only consider member functions named \nfind\n, \nrfind\n,\n\nfind_first_of\n, \nfind_first_not_of\n, \nfind_last_of\n, or\n\nfind_last_not_of\n within these classes.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/faster-string-find.html"
  },
  {
    "name": "performance-for-range-copy",
    "description": "Finds C++11 for ranges where the loop variable is copied in each iteration but\nit would suffice to obtain it by const reference.\n\nThe check is only applied to loop variables of types that are expensive to copy\nwhich means they are not trivially copyable or have a non-trivial copy\nconstructor or destructor.\n\nTo ensure that it is safe to replace the copy with a const reference the\nfollowing heuristic is employed:\n\nThe loop variable is const qualified.\n\n\nThe loop variable is not const, but only const methods or operators are\ninvoked on it, or it is used as const reference or value argument in\nconstructors or function calls.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnAllAutoCopies\nÂ¶\n\n\nWhen \ntrue\n, warns on any use of \nauto\n as the type of the range-based for\nloop variable. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types allowed to be copied in each\niteration. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n\nmatches every type with suffix \nRef\n, \nref\n, \nReference\n and\n\nreference\n. The default is empty. If a name in the list contains the\nsequence \n::\n, it is matched against the qualified type name\n(i.e. \nnamespace::Type\n), otherwise it is matched against only the\ntype name (i.e. \nType\n).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/for-range-copy.html"
  },
  {
    "name": "performance-implicit-conversion-in-loop",
    "description": "This warning appears in a range-based loop with a loop variable of const ref\ntype where the type of the variable does not match the one returned by the\niterator. This means that an implicit conversion happens, which can for example\nresult in expensive deep copies.\n\nExample:\n\nmap\n<\nint\n,\n \nvector\n<\nstring\n>>\n \nmy_map\n;\n\n\nfor\n \n(\nconst\n \npair\n<\nint\n,\n \nvector\n<\nstring\n>>&\n \np\n \n:\n \nmy_map\n)\n \n{}\n\n\n// The iterator type is in fact pair<const int, vector<string>>, which means\n\n\n// that the compiler added a conversion, resulting in a copy of the vectors.\n\nThe easiest solution is usually to use \nconst\n \nauto&\n instead of writing the\ntype manually.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/implicit-conversion-in-loop.html"
  },
  {
    "name": "performance-inefficient-algorithm",
    "description": "Warns on inefficient use of STL algorithms on associative containers.\n\nAssociative containers implement some of the algorithms as methods which\nshould be preferred to the algorithms in the algorithm header. The methods\ncan take advantage of the order of the elements.\n\nstd\n::\nset\n<\nint\n>\n \ns\n;\n\n\nauto\n \nit\n \n=\n \nstd\n::\nfind\n(\ns\n.\nbegin\n(),\n \ns\n.\nend\n(),\n \n43\n);\n\n\n\n// becomes\n\n\n\nauto\n \nit\n \n=\n \ns\n.\nfind\n(\n43\n);\n\nstd\n::\nset\n<\nint\n>\n \ns\n;\n\n\nauto\n \nc\n \n=\n \nstd\n::\ncount\n(\ns\n.\nbegin\n(),\n \ns\n.\nend\n(),\n \n43\n);\n\n\n\n// becomes\n\n\n\nauto\n \nc\n \n=\n \ns\n.\ncount\n(\n43\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/inefficient-algorithm.html"
  },
  {
    "name": "performance-inefficient-string-concatenation",
    "description": "This check warns about the performance overhead arising from concatenating\nstrings using the \noperator+\n, for instance:\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Bar\"\n);\n\n\na\n \n=\n \na\n \n+\n \nb\n;\n\nInstead of this structure you should use \noperator+=\n or \nstd::string\nâs\n(\nstd::basic_string\n) class member function \nappend()\n. For instance:\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n20000\n;\n \n++\ni\n)\n \n{\n\n\n    \na\n \n=\n \na\n \n+\n \n\"Bar\"\n \n+\n \nb\n;\n\n\n}\n\nCould be rewritten in a greatly more efficient way like:\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n20000\n;\n \n++\ni\n)\n \n{\n\n\n    \na\n.\nappend\n(\n\"Bar\"\n).\nappend\n(\nb\n);\n\n\n}\n\nAnd this can be rewritten too:\n\nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n&\n)\n \n{}\n\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nvoid\n \ng\n()\n \n{\n\n\n    \nf\n(\na\n \n+\n \n\"Bar\"\n \n+\n \nb\n);\n\n\n}\n\nIn a slightly more efficient way like:\n\nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n&\n)\n \n{}\n\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nvoid\n \ng\n()\n \n{\n\n\n    \nf\n(\nstd\n::\nstring\n(\na\n).\nappend\n(\n\"Bar\"\n).\nappend\n(\nb\n));\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen \nfalse\n, the check will only check the string usage in \nwhile\n, \nfor\n\nand \nfor-range\n statements. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/inefficient-string-concatenation.html"
  },
  {
    "name": "performance-inefficient-vector-operation",
    "description": "Finds possible inefficient \nstd::vector\n operations (e.g. \npush_back\n,\n\nemplace_back\n) that may cause unnecessary memory reallocations.\n\nIt can also find calls that add element to protobuf repeated field in a loop\nwithout calling Reserve() before the loop. Calling Reserve() first can avoid\nunnecessary memory reallocations.\n\nCurrently, the check only detects following kinds of loops with a single\nstatement body:\n\nCounter-based for loops start with 0:\n\nstd\n::\nvector\n<\nint\n>\n \nv\n;\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \n++\ni\n)\n \n{\n\n\n  \nv\n.\npush_back\n(\nn\n);\n\n\n  \n// This will trigger the warning since the push_back may cause multiple\n\n\n  \n// memory reallocations in v. This can be avoid by inserting a 'reserve(n)'\n\n\n  \n// statement before the for statement.\n\n\n}\n\n\n\nSomeProto\n \np\n;\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nn\n;\n \n++\ni\n)\n \n{\n\n\n  \np\n.\nadd_xxx\n(\nn\n);\n\n\n  \n// This will trigger the warning since the add_xxx may cause multiple memory\n\n\n  \n// reallocations. This can be avoid by inserting a\n\n\n  \n// 'p.mutable_xxx().Reserve(n)' statement before the for statement.\n\n\n}\n\nFor-range loops like \nfor\n \n(range-declaration\n \n:\n \nrange_expression)\n, the type\nof \nrange_expression\n can be \nstd::vector\n, \nstd::array\n,\n\nstd::deque\n, \nstd::set\n, \nstd::unordered_set\n, \nstd::map\n,\n\nstd::unordered_set\n:\n\nstd\n::\nvector\n<\nint\n>\n \ndata\n;\n\n\nstd\n::\nvector\n<\nint\n>\n \nv\n;\n\n\n\nfor\n \n(\nauto\n \nelement\n \n:\n \ndata\n)\n \n{\n\n\n  \nv\n.\npush_back\n(\nelement\n);\n\n\n  \n// This will trigger the warning since the 'push_back' may cause multiple\n\n\n  \n// memory reallocations in v. This can be avoid by inserting a\n\n\n  \n// 'reserve(data.size())' statement before the for statement.\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nVectorLikeClasses\nÂ¶\n\n\nSemicolon-separated list of names of vector-like classes. By default only\n\n::std::vector\n is considered.\n\n\n\n\n\n\n\n\nEnableProto\nÂ¶\n\n\nWhen \ntrue\n, the check will also warn on inefficient operations for proto\nrepeated fields. Otherwise, the check only warns on inefficient vector\noperations. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/inefficient-vector-operation.html"
  },
  {
    "name": "performance-move-const-arg",
    "description": "The check warns\n\nif \nstd::move()\n is called with a constant argument,\n\n\nif \nstd::move()\n is called with an argument of a trivially-copyable type,\n\n\nif the result of \nstd::move()\n is passed as a const reference argument.\n\nIn all three cases, the check will suggest a fix that removes the\n\nstd::move()\n.\n\nHere are examples of each of the three cases:\n\nconst\n \nstring\n \ns\n;\n\n\nreturn\n \nstd\n::\nmove\n(\ns\n);\n  \n// Warning: std::move of the const variable has no effect\n\n\n\nint\n \nx\n;\n\n\nreturn\n \nstd\n::\nmove\n(\nx\n);\n  \n// Warning: std::move of the variable of a trivially-copyable type has no effect\n\n\n\nvoid\n \nf\n(\nconst\n \nstring\n \n&\ns\n);\n\n\nstring\n \ns\n;\n\n\nf\n(\nstd\n::\nmove\n(\ns\n));\n  \n// Warning: passing result of std::move as a const reference argument; no move will actually happen\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckTriviallyCopyableMove\nÂ¶\n\n\nIf \ntrue\n, enables detection of trivially copyable types that do not\nhave a move constructor. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nCheckMoveToConstRef\nÂ¶\n\n\nIf \ntrue\n, enables detection of \nstd::move()\n passed as a const\nreference argument. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"
  },
  {
    "name": "performance-move-constructor-init",
    "description": "âcert-oop11-cppâ redirects here as an alias for this check.\n\nThe check flags user-defined move constructors that have a ctor-initializer\ninitializing a member or base class through a copy constructor instead of a\nmove constructor.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-constructor-init.html"
  },
  {
    "name": "performance-no-automatic-move",
    "description": "Finds local variables that cannot be automatically moved due to constness.\n\nUnder\n\ncertain conditions\n,\nlocal values are automatically moved out when returning from a function. A\ncommon mistake is to declare local \nlvalue\n variables \nconst\n, which\nprevents the move.\n\nExample \n[1]\n:\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\n \nCool\n()\n \n{\n\n\n  \nstd\n::\nvector\n<\nint\n>\n \nobj\n \n=\n \n...;\n\n\n  \nreturn\n \nobj\n;\n  \n// calls StatusOr::StatusOr(std::vector<int>&&)\n\n\n}\n\n\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\n \nNotCool\n()\n \n{\n\n\n  \nconst\n \nstd\n::\nvector\n<\nint\n>\n \nobj\n \n=\n \n...;\n\n\n  \nreturn\n \nobj\n;\n  \n// calls `StatusOr::StatusOr(const std::vector<int>&)`\n\n\n}\n\nThe former version (\nCool\n) should be preferred over the latter (\nNotCool\n)\nas it will avoid allocations and potentially large memory copies.\n\nSemantics\nÂ¶\n\n\nIn the example above, \nStatusOr::StatusOr(T&&)\n have the same semantics as\nlong as the copy and move constructors for \nT\n have the same semantics. Note\nthat there is no guarantee that \nS::S(T&&)\n and \nS::S(const\n \nT&)\n have the\nsame semantics for any single \nS\n, so weâre not providing automated fixes for\nthis check, and judgement should be exerted when making the suggested changes.\n\n-Wreturn-std-move\nÂ¶\n\n\nAnother case where the move cannot happen is the following:\n\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\n \nUncool\n()\n \n{\n\n\n  \nstd\n::\nvector\n<\nint\n>&&\n \nobj\n \n=\n \n...;\n\n\n  \nreturn\n \nobj\n;\n  \n// calls `StatusOr::StatusOr(const std::vector<int>&)`\n\n\n}\n\n\n\n\n\n\nIn that case the fix is more consensual: just \nreturn std::move(obj)\n.\nThis is handled by the \n-Wreturn-std-move\n warning.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-automatic-move.html"
  },
  {
    "name": "performance-no-int-to-ptr",
    "description": "Diagnoses every integer to pointer cast.\n\nWhile casting an (integral) pointer to an integer is obvious - you just get\nthe integral value of the pointer, casting an integer to an (integral) pointer\nis deceivingly different. While you will get a pointer with that integral\nvalue, if you got that integral value via a pointer-to-integer cast originally,\nthe new pointer will lack the provenance information from the original pointer.\n\nSo while (integral) pointer to integer casts are effectively no-ops,\nand are transparent to the optimizer, integer to (integral) pointer casts\nare \nNOT\n transparent, and may conceal information from optimizer.\n\nWhile that may be the intention, it is not always so. For example,\nletâs take a look at a routine to align the pointer up to the multiple of 16:\nThe obvious, naive implementation for that is:\n\nchar\n*\n \nsrc\n(\nchar\n*\n \nmaybe_underbiased_ptr\n)\n \n{\n\n\n  \nuintptr_t\n \nmaybe_underbiased_intptr\n \n=\n \n(\nuintptr_t\n)\nmaybe_underbiased_ptr\n;\n\n\n  \nuintptr_t\n \naligned_biased_intptr\n \n=\n \nmaybe_underbiased_intptr\n \n+\n \n15\n;\n\n\n  \nuintptr_t\n \naligned_intptr\n \n=\n \naligned_biased_intptr\n \n&\n \n(\n~\n15\n);\n\n\n  \nreturn\n \n(\nchar\n*\n)\naligned_intptr\n;\n \n// warning: avoid integer to pointer casts [performance-no-int-to-ptr]\n\n\n}\n\nThe check will rightfully diagnose that cast.\n\nBut when provenance concealment is not the goal of the code, but an accident,\nthis example can be rewritten as follows, without using integer to pointer cast:\n\nchar\n*\n\n\ntgt\n(\nchar\n*\n \nmaybe_underbiased_ptr\n)\n \n{\n\n\n    \nuintptr_t\n \nmaybe_underbiased_intptr\n \n=\n \n(\nuintptr_t\n)\nmaybe_underbiased_ptr\n;\n\n\n    \nuintptr_t\n \naligned_biased_intptr\n \n=\n \nmaybe_underbiased_intptr\n \n+\n \n15\n;\n\n\n    \nuintptr_t\n \naligned_intptr\n \n=\n \naligned_biased_intptr\n \n&\n \n(\n~\n15\n);\n\n\n    \nuintptr_t\n \nbias\n \n=\n \naligned_intptr\n \n-\n \nmaybe_underbiased_intptr\n;\n\n\n    \nreturn\n \nmaybe_underbiased_ptr\n \n+\n \nbias\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-int-to-ptr.html"
  },
  {
    "name": "performance-noexcept-destructor",
    "description": "The check flags user-defined destructors marked with \nnoexcept(expr)\n\nwhere \nexpr\n evaluates to \nfalse\n (but is not a \nfalse\n literal itself).\n\nWhen a destructor is marked as \nnoexcept\n, it assures the compiler that\nno exceptions will be thrown during the destruction of an object, which\nallows the compiler to perform certain optimizations such as omitting\nexception handling code.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-destructor.html"
  },
  {
    "name": "performance-noexcept-move-constructor",
    "description": "The check flags user-defined move constructors and assignment operators not\nmarked with \nnoexcept\n or marked with \nnoexcept(expr)\n where \nexpr\n\nevaluates to \nfalse\n (but is not a \nfalse\n literal itself).\n\nMove constructors of all the types used with STL containers, for example,\nshould be declared \nnoexcept\n. Otherwise STL may choose copy constructors\ninstead. The same is valid for move assignment operations.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"
  },
  {
    "name": "performance-noexcept-swap",
    "description": "The check flags user-defined swap and iter_swap functions not marked with\n\nnoexcept\n or marked with \nnoexcept(expr)\n where \nexpr\n evaluates to\n\nfalse\n (but is not a \nfalse\n literal itself).\n\nWhen a swap or iter_swap function is marked as \nnoexcept\n, it assures the\ncompiler that no exceptions will be thrown during the swapping of two objects,\nwhich allows the compiler to perform certain optimizations such as omitting\nexception handling code.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-swap.html"
  },
  {
    "name": "performance-string-view-conversions",
    "description": "Finds and removes redundant conversions from \nstd::[w|u8|u16|u32]string_view\n\nto \nstd::[...]string\n in call expressions expecting \nstd::[...]string_view\n.\n\nBefore:\n\nvoid\n \nfoo\n(\nint\n \np1\n,\n \nstd\n::\nstring_view\n \np2\n,\n \ndouble\n \np3\n);\n\n\nvoid\n \nbar\n(\nstd\n::\nstring_view\n \nsv\n)\n \n{\n\n\n    \nfoo\n(\n42\n,\n \nstd\n::\nstring\n(\nsv\n),\n \n3.14\n);\n \n// conversion to std::string is\n\n\n                                    \n// redundant as std::string_view\n\n\n                                    \n// is expected\n\n\n    \nfoo\n(\n42\n,\n \nstd\n::\nstring\n(\n\"foo\"\n),\n \n3.14\n);\n \n// conversion to std::string is\n\n\n                                       \n// redundant as std::string_view\n\n\n                                       \n// is expected\n\n\n}\n\nAfter:\n\nvoid\n \nfoo\n(\nint\n \np1\n,\n \nstd\n::\nstring_view\n \np2\n,\n \ndouble\n \np3\n);\n\n\nvoid\n \nbar\n(\nstd\n::\nstring_view\n \nsv\n)\n \n{\n\n\n    \nfoo\n(\n42\n,\n \nsv\n,\n \n3.14\n);\n\n\n    \nfoo\n(\n42\n,\n \n\"foo\"\n,\n \n3.14\n);\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/string-view-conversions.html"
  },
  {
    "name": "performance-trivially-destructible",
    "description": "Finds types that could be made trivially-destructible by removing out-of-line\ndefaulted destructor declarations.\n\nstruct\n \nA\n:\n \nTrivialType\n \n{\n\n\n  \n~\nA\n();\n \n// Makes A non-trivially-destructible.\n\n\n  \nTrivialType\n \ntrivial_fields\n;\n\n\n};\n\n\nA\n::~\nA\n()\n \n=\n \ndefault\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/trivially-destructible.html"
  },
  {
    "name": "performance-type-promotion-in-math-fn",
    "description": "Finds calls to C math library functions (from \nmath.h\n or, in C++, \ncmath\n)\nwith implicit \nfloat\n to \ndouble\n promotions.\n\nFor example, warns on \n::sin(0.f)\n, because this functionâs parameter is a\ndouble. You probably meant to call \nstd::sin(0.f)\n (in C++), or \nsinf(0.f)\n\n(in C).\n\nfloat\n \na\n;\n\n\nasin\n(\na\n);\n\n\n\n// becomes\n\n\n\nfloat\n \na\n;\n\n\nstd\n::\nasin\n(\na\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/type-promotion-in-math-fn.html"
  },
  {
    "name": "performance-unnecessary-copy-initialization",
    "description": "Finds local variable declarations that are initialized using the copy\nconstructor of a non-trivially-copyable type but it would suffice to obtain a\nconst reference.\n\nThe check is only applied if it is safe to replace the copy by a const\nreference. This is the case when the variable is const qualified or when it is\nonly used as a const, i.e. only const methods or operators are invoked on it,\nor it is used as const reference or value argument in constructors or function\ncalls.\n\nExample:\n\nconst\n \nstring\n&\n \nconstReference\n();\n\n\nvoid\n \nFunction\n()\n \n{\n\n\n  \n// The warning will suggest making this a const reference.\n\n\n  \nconst\n \nstring\n \nUnnecessaryCopy\n \n=\n \nconstReference\n();\n\n\n}\n\n\n\nstruct\n \nFoo\n \n{\n\n\n  \nconst\n \nstring\n&\n \nname\n()\n \nconst\n;\n\n\n};\n\n\nvoid\n \nFunction\n(\nconst\n \nFoo\n&\n \nfoo\n)\n \n{\n\n\n  \n// The warning will suggest making this a const reference.\n\n\n  \nstring\n \nUnnecessaryCopy1\n \n=\n \nfoo\n.\nname\n();\n\n\n  \nUnnecessaryCopy1\n.\nfind\n(\n\"bar\"\n);\n\n\n\n  \n// The warning will suggest making this a const reference.\n\n\n  \nstring\n \nUnnecessaryCopy2\n \n=\n \nUnnecessaryCopy1\n;\n\n\n  \nUnnecessaryCopy2\n.\nfind\n(\n\"bar\"\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types allowed to be initialized by\ncopying. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n matches\nevery type with suffix \nRef\n, \nref\n, \nReference\n and \nreference\n.\nThe default is empty. If a name in the list contains the sequence \n::\n, it\nis matched against the qualified type name (i.e. \nnamespace::Type\n),\notherwise it is matched against only the type name (i.e. \nType\n).\n\n\n\n\n\n\n\n\nExcludedContainerTypes\nÂ¶\n\n\nA semicolon-separated list of names of types whose methods are allowed to\nreturn the const reference the variable is copied from. When an expensive to\ncopy variable is copy initialized by the return value from a type on this\nlist the check does not trigger. This can be used to exclude types known to\nbe const incorrect or where the lifetime or immutability of returned\nreferences is not tied to mutations of the container. An example are view\ntypes that donât own the underlying data. Like for \nAllowedTypes\n above,\nregular expressions are accepted and the inclusion of \n::\n determines whether\nthe qualified typename is matched or not.\n\nLimitations\nÂ¶\n\n\nThis check does not perform lifetime analysis and may suggest replacing copies\nwith const references that could become dangling. Be cautious when the\nreferenced object might be invalidated by subsequent operations.\n\n\nvoid\n \nconsume\n(\nconst\n \nS\n&\n);\n\n\n\nvoid\n \nfunc\n(\nstd\n::\nvector\n<\nS\n>\n \n&\nVec\n)\n \n{\n\n\n  \nconst\n \nauto\n \nIt\n \n=\n \nVec\n.\nbegin\n();\n\n\n  \nconst\n \nS\n \nValue\n(\n*\nIt\n);\n \n// The warning will suggest making this a const reference.\n\n\n  \nVec\n.\nerase\n(\nIt\n);\n \n// Container modifications could invalidate references.\n\n\n  \nconsume\n(\nValue\n);\n \n// Safe with copy, dangling reference otherwise.\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/unnecessary-copy-initialization.html"
  },
  {
    "name": "performance-unnecessary-value-param",
    "description": "Flags value parameter declarations of expensive to copy types that are copied\nfor each invocation but it would suffice to pass them by const reference.\n\nThe check is only applied to parameters of types that are expensive to copy\nwhich means they are not trivially copyable or have a non-trivial copy\nconstructor or destructor.\n\nTo ensure that it is safe to replace the value parameter with a const reference\nthe following heuristic is employed:\n\nthe parameter is const qualified;\n\n\nthe parameter is not const, but only const methods or operators are invoked\non it, or it is used as const reference or value argument in constructors or\nfunction calls.\n\nExample:\n\nvoid\n \nf\n(\nconst\n \nstring\n \nValue\n)\n \n{\n\n\n  \n// The warning will suggest making Value a reference.\n\n\n}\n\n\n\nvoid\n \ng\n(\nExpensiveToCopy\n \nValue\n)\n \n{\n\n\n  \n// The warning will suggest making Value a const reference.\n\n\n  \nValue\n.\nConstMethd\n();\n\n\n  \nExpensiveToCopy\n \nCopy\n(\nValue\n);\n\n\n}\n\nIf the parameter is not const, only copied or assigned once and has a\nnon-trivial move-constructor or move-assignment operator respectively the check\nwill suggest to move it.\n\nExample:\n\nvoid\n \nsetValue\n(\nstring\n \nValue\n)\n \n{\n\n\n  \nField\n \n=\n \nValue\n;\n\n\n}\n\nWill become:\n\n#include\n \n<utility>\n\n\n\nvoid\n \nsetValue\n(\nstring\n \nValue\n)\n \n{\n\n\n  \nField\n \n=\n \nstd\n::\nmove\n(\nValue\n);\n\n\n}\n\nBecause the fix-it needs to change the signature of the function, it may break\nbuilds if the function is used in multiple translation units or some codes\ndepends on function signatures.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types allowed to be passed by value.\nRegular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n matches every\ntype with suffix \nRef\n, \nref\n, \nReference\n and \nreference\n. The\ndefault is empty. If a name in the list contains the sequence \n::\n, it is\nmatched against the qualified type name (i.e. \nnamespace::Type\n),\notherwise it is matched against only the type name (i.e. \nType\n).\n\n\n\n\n\n\n\n\nIgnoreCoroutines\nÂ¶\n\n\nA boolean specifying whether the check should suggest passing parameters by\nreference in coroutines. Passing parameters by reference in coroutines may\nnot be safe, please see \ncppcoreguidelines-avoid-reference-coroutine-parameters\n\nfor more information. Default is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/unnecessary-value-param.html"
  },
  {
    "name": "portability-avoid-pragma-once",
    "description": "Finds uses of \n#pragma\n \nonce\n and suggests replacing them with standard\ninclude guards (\n#ifndef\n/\n#define\n/\n#endif\n) for improved portability.\n\n#pragma\n \nonce\n is a non-standard extension, despite being widely supported\nby modern compilers. Relying on it can lead to portability issues in\nsome environments.\n\nSome older or specialized C/C++ compilers, particularly in embedded systems,\nmay not fully support \n#pragma\n \nonce\n.\n\nIt can also fail in certain file system configurations, like network drives\nor complex symbolic links, potentially leading to compilation issues.\n\nConsider the following header file:\n\n// my_header.h\n\n\n#pragma once \n// warning: avoid 'pragma once' directive; use include guards instead\n\nThe warning suggests using include guards:\n\n// my_header.h\n\n\n#ifndef PATH_TO_MY_HEADER_H \n// Good: use include guards.\n\n\n#define PATH_TO_MY_HEADER_H\n\n\n\n#endif \n// PATH_TO_MY_HEADER_H",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/portability/avoid-pragma-once.html"
  },
  {
    "name": "portability-restrict-system-includes",
    "description": "Checks to selectively allow or disallow a configurable list of system headers.\n\nFor example:\n\nIn order to \nonly\n allow \nzlib.h\n from the system you would set the options\nto \n-*,zlib.h\n.\n\n#include\n \n<curses.h>\n       // Bad: disallowed system header.\n\n\n#include\n \n<openssl/ssl.h>\n  // Bad: disallowed system header.\n\n\n#include\n \n<zlib.h>\n         // Good: allowed system header.\n\n\n#include\n \n\"src/myfile.h\"\n   // Good: non-system header always allowed.\n\nIn order to allow everything \nexcept\n \nzlib.h\n from the system you would set\nthe options to \n*,-zlib.h\n.\n\n#include\n \n<curses.h>\n       // Good: allowed system header.\n\n\n#include\n \n<openssl/ssl.h>\n  // Good: allowed system header.\n\n\n#include\n \n<zlib.h>\n         // Bad: disallowed system header.\n\n\n#include\n \n\"src/myfile.h\"\n   // Good: non-system header always allowed.\n\nSince the options support globbing you can use wildcarding to allow groups of\nheaders.\n\n-*,openssl/*.h\n will allow all openssl headers but disallow any others.\n\n#include\n \n<curses.h>\n       // Bad: disallowed system header.\n\n\n#include\n \n<openssl/ssl.h>\n  // Good: allowed system header.\n\n\n#include\n \n<openssl/rsa.h>\n  // Good: allowed system header.\n\n\n#include\n \n<zlib.h>\n         // Bad: disallowed system header.\n\n\n#include\n \n\"src/myfile.h\"\n   // Good: non-system header always allowed.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludes\nÂ¶\n\n\nA string containing a comma separated glob list of allowed include\nfilenames. Similar to the -checks glob list for running clang-tidy itself,\nthe two wildcard characters are \n*\n and \n-\n, to include and exclude globs,\nrespectively. The default is \n*\n, which allows all includes.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/portability/restrict-system-includes.html"
  },
  {
    "name": "portability-simd-intrinsics",
    "description": "Finds SIMD intrinsics calls and suggests \nstd::experimental::simd\n (\nP0214\n)\nalternatives.\n\nIf the option \nSuggest\n is set to \ntrue\n, for\n\n_mm_add_epi32\n(\na\n,\n \nb\n);\n \n// x86\n\n\nvec_add\n(\na\n,\n \nb\n);\n       \n// Power\n\nthe check suggests an alternative: \noperator+\n on \nstd::experimental::simd\n\nobjects.\n\nOtherwise, it just complains the intrinsics are non-portable (and there are\n\nP0214\n alternatives).\n\nMany architectures provide SIMD operations (e.g. x86 SSE/AVX, Power\nAltiVec/VSX, ARM NEON). It is common that SIMD code implementing the same\nalgorithm, is written in multiple target-dispatching pieces to optimize for\ndifferent architectures or micro-architectures.\n\nThe C++ standard proposal \nP0214\n and its extensions cover many common SIMD\noperations. By migrating from target-dependent intrinsics to \nP0214\n\noperations, the SIMD code can be simplified and pieces for different targets\ncan be unified.\n\nRefer to \nP0214\n for introduction and motivation for the data-parallel\nstandard library.\n\nOptions\nÂ¶\n\n\n\n\n\n\nSuggest\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \nfalse\n), the check will suggest\n\nP0214\n alternatives, otherwise it only points out the intrinsic function is\nnon-portable.\n\n\n\n\n\n\n\n\nStd\nÂ¶\n\n\nThe namespace used to suggest \nP0214\n alternatives. If not specified, \nstd::\n\nfor \n-std=c++20\n and \nstd::experimental::\n for \n-std=c++11\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/portability/simd-intrinsics.html"
  },
  {
    "name": "portability-std-allocator-const",
    "description": "Report use of \nstd::vector<const\n \nT>\n (and similar containers of const\nelements). These are not allowed in standard C++, and should usually be\n\nstd::vector<T>\n instead.â\n\nPer C++ \n[allocator.requirements.general]\n: âT is any cv-unqualified object\ntypeâ, \nstd::allocator<const\n \nT>\n is undefined. Many standard containers use\n\nstd::allocator\n by default and therefore their \nconst\n \nT\n instantiations\nare undefined.\n\nlibc++ defines \nstd::allocator<const\n \nT>\n as an extension which will be\nremoved in the future.\n\nlibstdc++ and MSVC do not support \nstd::allocator<const\n \nT>\n:\n\n// libstdc++ has a better diagnostic since https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48101\n\n\nstd\n::\ndeque\n<\nconst\n \nint\n>\n \ndeque\n;\n \n// error: static assertion failed: std::deque must have a non-const, non-volatile value_type\n\n\nstd\n::\nset\n<\nconst\n \nint\n>\n \nset\n;\n \n// error: static assertion failed: std::set must have a non-const, non-volatile value_type\n\n\nstd\n::\nvector\n<\nint\n*\n \nconst\n>\n \nvector\n;\n \n// error: static assertion failed: std::vector must have a non-const, non-volatile value_type\n\n\n\n// MSVC\n\n\n// error C2338: static_assert failed: 'The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.'\n\nCode bases only compiled with libc++ may accrue such undefined usage. This\ncheck finds such code and prevents backsliding while clean-up is ongoing.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/portability/std-allocator-const.html"
  },
  {
    "name": "portability-template-virtual-member-function",
    "description": "Finds cases when an uninstantiated virtual member function in a template class\ncauses cross-compiler incompatibility.\n\nUpon instantiating a template class, non-virtual member functions donât have\nto be instantiated unless they are used. Virtual member function instantiation\non the other hand is unspecified and depends on the implementation of the\ncompiler.\n\nIn the following snippets the virtual member function is not instantiated by\nGCC and Clang, but it is instantiated by MSVC, so while the snippet is accepted\nby the former compilers, it is rejected by the latter.\n\ntemplate\n<\ntypename\n \nT\n>\n\n\nstruct\n \nCrossPlatformError\n \n{\n\n\n    \nvirtual\n \n~\nCrossPlatformError\n()\n \n=\n \ndefault\n;\n\n\n\n    \nstatic\n \nvoid\n \nused\n()\n \n{}\n\n\n\n    \nvirtual\n \nvoid\n \nunused\n()\n \n{\n\n\n        \nT\n \nMSVCError\n \n=\n \nthis\n;\n\n\n    \n};\n\n\n};\n\n\n\nint\n \nmain\n()\n \n{\n\n\n    \nCrossPlatformError\n<\nint\n>::\nused\n();\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\nCross-platform projects that need to support MSVC on Windows might see compiler\nerrors because certain virtual member functions are instantiated, which are not\ninstantiated by other compilers on other platforms. This check highlights such\nvirtual member functions.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/portability/template-virtual-member-function.html"
  },
  {
    "name": "readability-ambiguous-smartptr-reset-call",
    "description": "Finds potentially erroneous calls to \nreset\n method on smart pointers when\nthe pointee type also has a \nreset\n method. Having a \nreset\n method in\nboth classes makes it easy to accidentally make the pointer null when\nintending to reset the underlying object.\n\nstruct\n \nResettable\n \n{\n\n\n  \nvoid\n \nreset\n()\n \n{\n \n/* Own reset logic */\n \n}\n\n\n};\n\n\n\nauto\n \nptr\n \n=\n \nstd\n::\nmake_unique\n<\nResettable\n>\n();\n\n\n\nptr\n->\nreset\n();\n  \n// Calls underlying reset method\n\n\nptr\n.\nreset\n();\n   \n// Makes the pointer null\n\nBoth calls are valid C++ code, but the second one might not be what the\ndeveloper intended, as it destroys the pointed-to object rather than resetting\nits state. Itâs easy to make such a typo because the difference between\n\n.\n and \n->\n is really small.\n\nThe recommended approach is to make the intent explicit by using either member\naccess or direct assignment:\n\nstd\n::\nunique_ptr\n<\nResettable\n>\n \nptr\n \n=\n \nstd\n::\nmake_unique\n<\nResettable\n>\n();\n\n\n\n(\n*\nptr\n).\nreset\n();\n  \n// Clearly calls underlying reset method\n\n\nptr\n \n=\n \nnullptr\n;\n   \n// Clearly makes the pointer null\n\nThe default smart pointers and classes that are considered are\n\nstd::unique_ptr\n, \nstd::shared_ptr\n, \nboost::shared_ptr\n. To specify\nother smart pointers or other classes use the \nSmartPointers\n option.\n\nNote\n\n\nThe check may emit invalid fix-its and misleading warning messages when\nspecifying custom smart pointers or other classes in the\n\nSmartPointers\n option. For example, \nboost::scoped_ptr\n does not\nhave an \noperator=\n which makes fix-its invalid.\n\nNote\n\n\nAutomatic fix-its are enabled only if \nclang-tidy\n is invoked with\nthe \nâfix-notes\n option.\n\nOptions\nÂ¶\n\n\n\n\n\n\nSmartPointers\nÂ¶\n\n\nSemicolon-separated list of fully qualified class names of custom smart\npointers. Default value is \n::std::unique_ptr;::std::shared_ptr;\n::boost::shared_ptr\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/ambiguous-smartptr-reset-call.html"
  },
  {
    "name": "readability-avoid-const-params-in-decls",
    "description": "Checks whether a function declaration has parameters that are top level\n\nconst\n.\n\nconst\n values in declarations do not affect the signature of a function, so\nthey should not be put there.\n\nExamples:\n\nvoid\n \nf\n(\nconst\n \nstring\n);\n   \n// Bad: const is top level.\n\n\nvoid\n \nf\n(\nconst\n \nstring\n&\n);\n  \n// Good: const is not top level.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/avoid-const-params-in-decls.html"
  },
  {
    "name": "readability-avoid-nested-conditional-operator",
    "description": "Identifies instances of nested conditional operators in the code.\n\nNested conditional operators, also known as ternary operators, can contribute\nto reduced code readability and comprehension. So they should be split as\nseveral statements and stored the intermediate results in temporary variable.\n\nExamples:\n\nint\n \nNestInConditional\n \n=\n \n(\ncondition1\n \n?\n \ntrue1\n \n:\n \nfalse1\n)\n \n?\n \ntrue2\n \n:\n \nfalse2\n;\n\n\nint\n \nNestInTrue\n \n=\n \ncondition1\n \n?\n \n(\ncondition2\n \n?\n \ntrue1\n \n:\n \nfalse1\n)\n \n:\n \nfalse2\n;\n\n\nint\n \nNestInFalse\n \n=\n \ncondition1\n \n?\n \ntrue1\n \n:\n \ncondition2\n \n?\n \ntrue2\n \n:\n \nfalse1\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/avoid-nested-conditional-operator.html"
  },
  {
    "name": "readability-avoid-return-with-void-value",
    "description": "Finds return statements with \nvoid\n values used within functions with\n\nvoid\n result types.\n\nA function with a \nvoid\n return type is intended to perform a task without\nproducing a return value. Return statements with expressions could lead\nto confusion and may miscommunicate the functionâs intended behavior.\n\nExample:\n\nvoid\n \ng\n();\n\n\nvoid\n \nf\n()\n \n{\n\n    \n//\n \n...\n\n    \nreturn\n \ng\n();\n\n\n}\n\nIn a long function body, the \nreturn\n statement suggests that the function\nreturns a value. However, \nreturn\n \ng();\n is a combination of two statements\nthat should be written as\n\ng\n();\n\n\nreturn\n;\n\nto make clear that \ng()\n is called and immediately afterwards the function\nreturns (nothing).\n\nIn C, the same issue is detected by the compiler if the \n-Wpedantic\n mode\nis enabled.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nThe value \nfalse\n specifies that return statements expanded\nfrom macros are not checked. The default value is \ntrue\n.\n\n\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nThe value \nfalse\n specifies that a direct return statement shall\nbe excluded from the analysis if it is the only statement not\ncontained in a block, like \nif\n \n(cond)\n \nreturn\n \ng();\n. The default\nvalue is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/avoid-return-with-void-value.html"
  },
  {
    "name": "readability-avoid-unconditional-preprocessor-if",
    "description": "Finds code blocks that are constantly enabled or disabled in preprocessor\ndirectives by analyzing \n#if\n conditions, such as \n#if\n \n0\n and \n#if\n \n1\n,\netc.\n\n#if 0\n\n\n    // some disabled code\n\n\n#endif\n\n\n\n#if 1\n\n\n   \n// some enabled code that can be disabled manually\n\n\n#endif\n\nUnconditional preprocessor directives, such as \n#if\n \n0\n for disabled code\nand \n#if\n \n1\n for enabled code, can lead to dead code and always enabled code,\nrespectively. Dead code can make understanding the codebase more difficult,\nhinder readability, and may be a sign of unfinished functionality or abandoned\nfeatures. This can cause maintenance issues, confusion for future developers,\nand potential compilation problems.\n\nAs a solution for both cases, consider using preprocessor macros or defines,\nlike \n#ifdef\n \nDEBUGGING_ENABLED\n, to control code enabling or disabling.\nThis approach provides better coordination and flexibility when working with\ndifferent parts of the codebase. Alternatively, you can comment out the entire\ncode using \n/*\n \n*/\n block comments and add a hint, such as \n@todo\n,\nto indicate future actions.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/avoid-unconditional-preprocessor-if.html"
  },
  {
    "name": "readability-braces-around-statements",
    "description": "google-readability-braces-around-statements\n redirects here as an alias for\nthis check.\n\nChecks that bodies of \nif\n statements and loops (\nfor\n, \ndo\n \nwhile\n, and\n\nwhile\n) are inside braces.\n\nBefore:\n\nif\n \n(\ncondition\n)\n\n\n  \nstatement\n;\n\nAfter:\n\nif\n \n(\ncondition\n)\n \n{\n\n\n  \nstatement\n;\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nShortStatementLines\nÂ¶\n\n\nDefines the minimal number of lines that the statement should have in order\nto trigger this check.\n\n\nThe number of lines is counted from the end of condition or initial keyword\n(\ndo\n/\nelse\n) until the last line of the inner statement. Default value\n\n0\n means that braces will be added to all statements (not having them\nalready).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/braces-around-statements.html"
  },
  {
    "name": "readability-const-return-type",
    "description": "Checks for functions with a \nconst\n-qualified return type and recommends\nremoval of the \nconst\n keyword. Such use of \nconst\n is usually superfluous,\nand can prevent valuable compiler optimizations. Does not (yet) fix trailing\nreturn types.\n\nExamples:\n\nconst\n \nint\n \nfoo\n();\n\n\nconst\n \nClazz\n \nfoo\n();\n\n\nClazz\n \n*\nconst\n \nfoo\n();\n\nNote that this applies strictly to top-level qualification, which excludes\npointers or references to const values. For example, these are fine:\n\nconst\n \nint\n*\n \nfoo\n();\n\n\nconst\n \nint\n&\n \nfoo\n();\n\n\nconst\n \nClazz\n*\n \nfoo\n();\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/const-return-type.html"
  },
  {
    "name": "readability-container-contains",
    "description": "Finds usages of \ncontainer.count()\n and\n\ncontainer.find()\n \n==\n \ncontainer.end()\n which should be replaced by a call to\nthe \ncontainer.contains()\n method.\n\nWhether an element is contained inside a container should be checked with\n\ncontains\n instead of \ncount\n/\nfind\n because \ncontains\n conveys the\nintent more clearly. Furthermore, for containers which permit multiple entries\nper key (\nmultimap\n, \nmultiset\n, â¦), \ncontains\n is more efficient than\n\ncount\n because \ncount\n has to do unnecessary additional work.\n\nExamples:\n\nInitial expression\n\n\nResult\n\n\n\n\nmyMap.find(x)\n \n==\n \nmyMap.end()\n\n\n!myMap.contains(x)\n\n\n\n\nmyMap.find(x)\n \n!=\n \nmyMap.end()\n\n\nmyMap.contains(x)\n\n\n\n\nmyStr.find(x)\n \n!=\n \nstd::string::npos\n\n\nmyStr.contains(x)\n\n\n\n\nif\n \n(myMap.count(x))\n\n\nif\n \n(myMap.contains(x))\n\n\n\n\nbool\n \nexists\n \n=\n \nmyMap.count(x)\n\n\nbool\n \nexists\n \n=\n \nmyMap.contains(x)\n\n\n\n\nbool\n \nexists\n \n=\n \nmyMap.count(x)\n \n>\n \n0\n\n\nbool\n \nexists\n \n=\n \nmyMap.contains(x)\n\n\n\n\nbool\n \nexists\n \n=\n \nmyMap.count(x)\n \n>=\n \n1\n\n\nbool\n \nexists\n \n=\n \nmyMap.contains(x)\n\n\n\n\nbool\n \nmissing\n \n=\n \nmyMap.count(x)\n \n==\n \n0\n\n\nbool\n \nmissing\n \n=\n \n!myMap.contains(x)\n\nThis check will apply to any class that has a \ncontains\n method, notably\nincluding \nstd::set\n, \nstd::unordered_set\n, \nstd::map\n, and\n\nstd::unordered_map\n as of C++20, and \nstd::string\n and\n\nstd::string_view\n as of C++23.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"
  },
  {
    "name": "readability-container-data-pointer",
    "description": "Finds cases where code could use \ndata()\n rather than the address of the\nelement at index 0 in a container. This pattern is commonly used to materialize\na pointer to the backing data of a container. \nstd::vector\n and\n\nstd::string\n provide a \ndata()\n accessor to retrieve the data pointer\nwhich should be preferred.\n\nThis also ensures that in the case that the container is empty, the data\npointer access does not perform an errant memory access.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredContainers\nÂ¶\n\n\nSemicolon-separated list of containers regexp for which this check wonât be\nenforced. Default is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-data-pointer.html"
  },
  {
    "name": "readability-container-size-empty",
    "description": "Checks whether a call to the \nsize()\n/\nlength()\n method can be replaced\nwith a call to \nempty()\n.\n\nThe emptiness of a container should be checked using the \nempty()\n method\ninstead of the \nsize()\n/\nlength()\n method. It shows clearer intent to use\n\nempty()\n. Furthermore some containers (for example, a \nstd::forward_list\n)\nmay implement the \nempty()\n method but not implement the \nsize()\n or\n\nlength()\n method. Using \nempty()\n whenever possible makes it easier to\nswitch to another container in the future.\n\nThe check issues warning if a container has \nempty()\n and \nsize()\n or\n\nlength()\n methods matching following signatures:\n\nsize_type\n \nsize\n()\n \nconst\n;\n\n\nsize_type\n \nlength\n()\n \nconst\n;\n\n\nbool\n \nempty\n()\n \nconst\n;\n\nsize_type\n can be any kind of integer type.\n\nOptions\nÂ¶\n\n\n\n\n\n\nExcludedComparisonTypes\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching class names for\nwhich the check will ignore comparisons of objects with default-constructed\nobjects of the same type. If a class is listed here, the check will not\nsuggest using \nempty()\n instead of such comparisons for objects of that\nclass. Default value is: \n::std::array\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-size-empty.html"
  },
  {
    "name": "readability-convert-member-functions-to-static",
    "description": "Finds non-static member functions that can be made \nstatic\n\nbecause the functions donât use \nthis\n.\n\nAfter applying modifications as suggested by the check, running the check again\nmight find more opportunities to mark member functions \nstatic\n.\n\nAfter making a member function \nstatic\n, you might want to run the check\n\nreadability-static-accessed-through-instance\n to replace calls like\n\nInstance.method()\n by \nClass::method()\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/convert-member-functions-to-static.html"
  },
  {
    "name": "readability-delete-null-pointer",
    "description": "Checks the \nif\n statements where a pointerâs existence is checked and\nthen deletes the pointer.\nThe check is unnecessary as deleting a null pointer has no effect.\n\nint\n \n*\np\n;\n\n\nif\n \n(\np\n)\n\n\n  \ndelete\n \np\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/delete-null-pointer.html"
  },
  {
    "name": "readability-duplicate-include",
    "description": "Looks for duplicate includes and removes them.  The check maintains a list of\nincluded files and looks for duplicates.  If a macro is defined or undefined\nthen the list of included files is cleared.\n\nExamples:\n\n#include\n \n<memory>\n\n\n#include\n \n<vector>\n\n\n#include\n \n<memory>\n\nbecomes\n\n#include\n \n<memory>\n\n\n#include\n \n<vector>\n\nBecause of the intervening macro definitions, this code remains unchanged:\n\n#undef NDEBUG\n\n\n#include\n \n\"assertion.h\"\n\n\n// ...code with assertions enabled\n\n\n\n#define NDEBUG\n\n\n#include\n \n\"assertion.h\"\n\n\n// ...code with assertions disabled\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredFilesList\nÂ¶\n\n\nA semicolon-separated list of regular expressions or filenames that are\nallowed to be included multiple times without diagnostics. Matching is\nperformed against the textual include name. Default is an empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/duplicate-include.html"
  },
  {
    "name": "readability-else-after-return",
    "description": "LLVM Coding Standards\n advises to\nreduce indentation where possible and where it makes understanding code easier.\nEarly exit is one of the suggested enforcements of that. Please do not use\n\nelse\n or \nelse\n \nif\n after something that interrupts control flow - like\n\nreturn\n, \nbreak\n, \ncontinue\n, \nthrow\n.\n\nThe following piece of code illustrates how the check works.\nThis piece of code:\n\nvoid\n \nfoo\n(\nint\n \nValue\n)\n \n{\n\n\n  \nint\n \nLocal\n \n=\n \n0\n;\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n42\n;\n \ni\n++\n)\n \n{\n\n\n    \nif\n \n(\nValue\n \n==\n \n1\n)\n \n{\n\n\n      \nreturn\n;\n\n\n    \n}\n \nelse\n \n{\n\n\n      \nLocal\n++\n;\n\n\n    \n}\n\n\n\n    \nif\n \n(\nValue\n \n==\n \n2\n)\n\n\n      \ncontinue\n;\n\n\n    \nelse\n\n\n      \nLocal\n++\n;\n\n\n\n    \nif\n \n(\nValue\n \n==\n \n3\n)\n \n{\n\n\n      \nthrow\n \n42\n;\n\n\n    \n}\n \nelse\n \n{\n\n\n      \nLocal\n++\n;\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\nWould be transformed into:\n\nvoid\n \nfoo\n(\nint\n \nValue\n)\n \n{\n\n\n  \nint\n \nLocal\n \n=\n \n0\n;\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n42\n;\n \ni\n++\n)\n \n{\n\n\n    \nif\n \n(\nValue\n \n==\n \n1\n)\n \n{\n\n\n      \nreturn\n;\n\n\n    \n}\n\n\n    \nLocal\n++\n;\n\n\n\n    \nif\n \n(\nValue\n \n==\n \n2\n)\n\n\n      \ncontinue\n;\n\n\n    \nLocal\n++\n;\n\n\n\n    \nif\n \n(\nValue\n \n==\n \n3\n)\n \n{\n\n\n      \nthrow\n \n42\n;\n\n\n    \n}\n\n\n    \nLocal\n++\n;\n\n\n  \n}\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnUnfixable\nÂ¶\n\n\nWhen \ntrue\n, emit a warning for cases where the check canât output a\nFix-It. These can occur with declarations inside the \nelse\n branch that\nwould have an extended lifetime if the \nelse\n branch was removed.\nDefault value is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnConditionVariables\nÂ¶\n\n\nWhen \ntrue\n, the check will attempt to refactor a variable defined inside\nthe condition of the \nif\n statement that is used in the \nelse\n branch\ndefining them just before the \nif\n statement. This can only be done if\nthe \nif\n statement is the last statement in its parentâs scope.\nDefault value is \ntrue\n.\n\nLLVM alias\nÂ¶\n\n\nThere is an alias of this check called llvm-else-after-return.\nIn that version the options \nWarnOnUnfixable\n and\n\nWarnOnConditionVariables\n are both set to \nfalse\n by default.\n\n\nThis check helps to enforce this \nLLVM Coding Standards recommendation\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/else-after-return.html"
  },
  {
    "name": "readability-enum-initial-value",
    "description": "Enforces consistent style for enumeratorsâ initialization, covering three\nstyles: none, first only, or all initialized explicitly.\n\nAn inconsistent style and strictness to defining the initializing value of\nenumerators may cause issues if the enumeration is extended with new\nenumerators that obtain their integer representation implicitly.\n\nThe following three cases are accepted:\n\nNo\n enumerators are explicit initialized.\n\n\nExactly \nthe first\n enumerator is explicit initialized.\n\n\nAll\n enumerators are explicit initialized.\n\nenum\n \nA\n \n{\n    \n// (1) Valid, none of enumerators are initialized.\n\n\n  \na0\n,\n\n\n  \na1\n,\n\n\n  \na2\n,\n\n\n};\n\n\n\nenum\n \nB\n \n{\n    \n// (2) Valid, the first enumerator is initialized.\n\n\n  \nb0\n \n=\n \n0\n,\n\n\n  \nb1\n,\n\n\n  \nb2\n,\n\n\n};\n\n\n\nenum\n \nC\n \n{\n    \n// (3) Valid, all of enumerators are initialized.\n\n\n  \nc0\n \n=\n \n0\n,\n\n\n  \nc1\n \n=\n \n1\n,\n\n\n  \nc2\n \n=\n \n2\n,\n\n\n};\n\n\n\nenum\n \nD\n \n{\n    \n// warning: initial values in enum 'D' are not consistent,\n\n\n            \n//          consider explicit initialization of all, none or only\n\n\n            \n//          the first enumerator\n\n\n  \nd0\n \n=\n \n0\n,\n\n\n  \nd1\n,\n       \n// note: uninitialized enumerator 'd1' defined here\n\n\n  \nd2\n \n=\n \n2\n,\n\n\n};\n\n\n\nenum\n \nE\n \n{\n    \n// warning: initial values in enum 'E' are not consistent,\n\n\n            \n//          consider explicit initialization of all, none or only\n\n\n            \n//          the first enumerator\n\n\n  \ne0\n \n=\n \n0\n,\n\n\n  \ne1\n,\n       \n// note: uninitialized enumerator 'e1' defined here\n\n\n  \ne2\n \n=\n \n2\n,\n\n\n  \ne3\n,\n       \n// note: uninitialized enumerator 'e3' defined here\n\n\n            \n// Dangerous, as the numeric values of e3 and e5 are both 3,\n\n\n            \n// and this is not explicitly visible in the code!\n\n\n  \ne4\n \n=\n \n2\n,\n\n\n  \ne5\n,\n       \n// note: uninitialized enumerator 'e5' defined here\n\n\n};\n\nThis check corresponds to the CERT C Coding Standard recommendation \nINT09-C. Ensure enumeration constants map to unique values\n.\n\ncert-int09-c\n redirects here as an alias of this check.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowExplicitZeroFirstInitialValue\nÂ¶\n\n\nIf set to \nfalse\n, the first enumerator must not be explicitly initialized to\na literal \n0\n.\nDefault is \ntrue\n.\n\n\nenum\n \nF\n \n{\n\n\n  \nf0\n \n=\n \n0\n,\n \n// Not allowed if AllowExplicitZeroFirstInitialValue is false.\n\n\n  \nf1\n,\n\n\n  \nf2\n,\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowExplicitSequentialInitialValues\nÂ¶\n\n\nIf set to \nfalse\n, explicit initialization to sequential values are not\nallowed.\nDefault is \ntrue\n.\n\n\nenum\n \nG\n \n{\n\n\n  \ng0\n \n=\n \n1\n,\n \n// Not allowed if AllowExplicitSequentialInitialValues is false.\n\n\n  \ng1\n \n=\n \n2\n,\n\n\n  \ng2\n \n=\n \n3\n,",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/enum-initial-value.html"
  },
  {
    "name": "readability-function-cognitive-complexity",
    "description": "Checks function Cognitive Complexity metric.\n\nThe metric is implemented as per the \nCOGNITIVE COMPLEXITY by SonarSource\n specification\nversion 1.2 (19 April 2017).\n\nOptions\nÂ¶\n\n\n\n\n\n\nThreshold\nÂ¶\n\n\nFlag functions with Cognitive Complexity exceeding this number.\nThe default is \n25\n.\n\n\n\n\n\n\n\n\nDescribeBasicIncrements\nÂ¶\n\n\nIf set to \ntrue\n, then for each function exceeding the complexity threshold\nthe check will issue additional diagnostics on every piece of code (loop,\n\nif\n statement, etc.) which contributes to that complexity. See also the\nexamples below. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will ignore code inside macros. Note, that also\nany macro arguments are ignored, even if they should count to the complexity.\nAs this might change in the future, this option isnât guaranteed to be\nforward-compatible. Default is \nfalse\n.\n\nBuilding blocks\nÂ¶\n\n\nThere are three basic building blocks of a Cognitive Complexity metric:\n\n\n\n\nIncrement\nÂ¶\n\n\nThe following structures increase the functionâs Cognitive Complexity metric\n(by \n1\n):\n\n\n\n\nConditional operators:\n\n\n\n\n\n\nif()\n\n\nelse\n \nif()\n\n\nelse\n\n\ncond\n \n?\n \ntrue\n \n:\n \nfalse\n\n\n\n\n\n\n\n\nswitch()\n\n\nLoops:\n\n\n\n\n\n\nfor()\n\n\nC++11 range-based \nfor()\n\n\nwhile()\n\n\ndo\n \nwhile()\n\n\n\n\n\n\n\n\ncatch\n \n()\n\n\ngoto\n \nLABEL\n, \ngoto\n \n*(&&LABEL))\n,\n\n\nsequences of binary logical operators:\n\n\n\n\n\n\nboolean1\n \n||\n \nboolean2\n\n\nboolean1\n \n&&\n \nboolean2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNesting level\nÂ¶\n\n\nWhile by itself the nesting level does not change the functionâs Cognitive\nComplexity metric, it is tracked, and is used by the next, third building\nblock. The following structures increase the nesting level (by \n1\n):\n\n\n\n\nConditional operators:\n\n\n\n\n\n\nif()\n\n\nelse\n \nif()\n\n\nelse\n\n\ncond\n \n?\n \ntrue\n \n:\n \nfalse\n\n\n\n\n\n\n\n\nswitch()\n\n\nLoops:\n\n\n\n\n\n\nfor()\n\n\nC++11 range-based \nfor()\n\n\nwhile()\n\n\ndo\n \nwhile()\n\n\n\n\n\n\n\n\ncatch\n \n()\n\n\nNested functions:\n\n\n\n\n\n\nC++11 Lambda\n\n\nNested \nclass\n\n\nNested \nstruct\n\n\n\n\n\n\n\n\nGNU statement expression\n\n\nApple Block Declaration\n\n\n\n\n\n\n\n\nNesting increment\nÂ¶\n\n\nThis is where the previous basic building block, \nNesting level\n, matters.\nThe following structures increase the functionâs Cognitive Complexity metric by\nthe current \nNesting level\n:\n\n\n\n\nConditional operators:\n\n\n\n\n\n\nif()\n\n\ncond\n \n?\n \ntrue\n \n:\n \nfalse\n\n\n\n\n\n\n\n\nswitch()\n\n\nLoops:\n\n\n\n\n\n\nfor()\n\n\nC++11 range-based \nfor()\n\n\nwhile()\n\n\ndo\n \nwhile()\n\n\n\n\n\n\n\n\ncatch\n \n()\n\nExamples\nÂ¶\n\n\nThe simplest case. This function has Cognitive Complexity of \n0\n.\n\n\nvoid\n \nfunction0\n()\n \n{}\n\n\n\n\n\n\nSlightly better example. This function has Cognitive Complexity of \n1\n.\n\n\nint\n \nfunction1\n(\nbool\n \nvar\n)\n \n{\n\n\n  \nif\n(\nvar\n)\n \n// +1, nesting level +1\n\n\n    \nreturn\n \n42\n;\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nFull example. This function has Cognitive Complexity of \n3\n.\n\n\nint\n \nfunction3\n(\nbool\n \nvar1\n,\n \nbool\n \nvar2\n)\n \n{\n\n\n  \nif\n(\nvar1\n)\n \n{\n \n// +1, nesting level +1\n\n\n    \nif\n(\nvar2\n)\n  \n// +2 (1 + current nesting level of 1), nesting level +1\n\n\n      \nreturn\n \n42\n;\n\n\n  \n}\n\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nIn the last example, the check will flag \nfunction3\n if the option Threshold is\nset to \n2\n or smaller. If the option DescribeBasicIncrements is set to \ntrue\n,\nit will additionally flag the two \nif\n statements with the amounts by which they\nincrease to the complexity of the function and the current nesting level.\n\nLimitations\nÂ¶\n\n\n\n\nThe metric is implemented with two notable exceptions:\n\n\npreprocessor conditionals\n (\n#ifdef\n, \n#if\n, \n#elif\n, \n#else\n,\n\n#endif\n) are not accounted for.\n\n\neach method in a recursion cycle\n is not accounted for. It canât be fully\nimplemented, because cross-translational-unit analysis would be needed,\nwhich is currently not possible in clang-tidy.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/function-cognitive-complexity.html"
  },
  {
    "name": "readability-function-size",
    "description": "google-readability-function-size\n redirects here as an alias for this check.\n\nChecks for large functions based on various metrics.\n\nOptions\nÂ¶\n\n\n\n\n\n\nLineThreshold\nÂ¶\n\n\nFlag functions exceeding this number of lines. The default is \nnone\n (ignore\nthe number of lines).\n\n\n\n\n\n\n\n\nStatementThreshold\nÂ¶\n\n\nFlag functions exceeding this number of statements. This may differ\nsignificantly from the number of lines for macro-heavy code. The default is\n\n800\n.\n\n\n\n\n\n\n\n\nBranchThreshold\nÂ¶\n\n\nFlag functions exceeding this number of control statements. The default is\n\nnone\n (ignore the number of branches).\n\n\n\n\n\n\n\n\nParameterThreshold\nÂ¶\n\n\nFlag functions that exceed a specified number of parameters. The default\nis \nnone\n (ignore the number of parameters).\n\n\n\n\n\n\n\n\nNestingThreshold\nÂ¶\n\n\nFlag compound statements which create next nesting level after\n\nNestingThreshold\n. This may differ significantly from the expected value\nfor macro-heavy code. The default is \nnone\n (ignore the nesting level).\n\n\n\n\n\n\n\n\nVariableThreshold\nÂ¶\n\n\nFlag functions exceeding this number of variables declared in the body.\nThe default is \nnone\n (ignore the number of variables).\nPlease note that function parameters and variables declared in lambdas,\nGNU Statement Expressions, and nested class inline functions are not counted.\n\n\n\n\n\n\n\n\nCountMemberInitAsStmt\nÂ¶\n\n\nWhen \ntrue\n, count class member initializers in constructors as statements.\nDefault is \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/function-size.html"
  },
  {
    "name": "readability-identifier-length",
    "description": "This check finds variables and function parameters whose length are too short.\nThe desired name length is configurable.\n\nSpecial cases are supported for loop counters and for exception variable names.\n\nOptions\nÂ¶\n\n\nThe following options are described below:\n\n\n\n\n\n\nMinimumVariableNameLength\n, \nIgnoredVariableNames\n\n\nMinimumParameterNameLength\n, \nIgnoredParameterNames\n\n\nMinimumLoopCounterNameLength\n, \nIgnoredLoopCounterNames\n\n\nMinimumExceptionNameLength\n,\n\nIgnoredExceptionVariableNames\n\n\n\n\n\n\n\n\n\n\nMinimumVariableNameLength\nÂ¶\n\n\nAll variables (other than loop counter, exception names and function\nparameters) are expected to have at least a length of\n\nMinimumVariableNameLength\n (default is \n3\n). Setting it to \n0\n or \n1\n\ndisables the check entirely.\n\n\nint\n \ni\n \n=\n \n42\n;\n    \n// warns that 'i' is too short\n\n\n\n\n\n\nThis check does not have any fix suggestions in the general case since\nvariable names have semantic value.\n\n\n\n\n\n\n\n\nIgnoredVariableNames\nÂ¶\n\n\nSpecifies a regular expression for variable names that are\nto be ignored. The default value is empty, thus no names are ignored.\n\n\n\n\n\n\n\n\nMinimumParameterNameLength\nÂ¶\n\n\nAll function parameter names are expected to have a length of at least\n\nMinimumParameterNameLength\n (default is \n3\n). Setting it to \n0\n or \n1\n\ndisables the check entirely.\n\n\nint\n \ndoubler\n(\nint\n \nx\n)\n   \n// warns that x is too short\n\n\n{\n\n\n   \nreturn\n \n2\n \n*\n \nx\n;\n\n\n}\n\n\n\n\n\n\nThis check does not have any fix suggestions in the general case since\nvariable names have semantic value.\n\n\n\n\n\n\n\n\nIgnoredParameterNames\nÂ¶\n\n\nSpecifies a regular expression for parameters that are to be ignored.\nThe default value is \n^[n]$\n for historical reasons.\n\n\n\n\n\n\n\n\nMinimumLoopCounterNameLength\nÂ¶\n\n\nLoop counter variables are expected to have a length of at least\n\nMinimumLoopCounterNameLength\n characters (default is \n2\n). Setting it to\n\n0\n or \n1\n disables the check entirely.\n\n\n// This warns that 'q' is too short.\n\n\nfor\n \n(\nint\n \nq\n \n=\n \n0\n;\n \nq\n \n<\n \nsize\n;\n \n++\n \nq\n)\n \n{\n\n\n   \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nIgnoredLoopCounterNames\nÂ¶\n\n\nSpecifies a regular expression for counter names that are to be ignored.\nThe default value is \n^[ijk_]$\n; the first three symbols for historical\nreasons and the last one since it is frequently used as a âdonât careâ\nvalue, specifically in tools such as Google Benchmark.\n\n\n// This does not warn by default, for historical reasons.\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nsize\n;\n \n++\n \ni\n)\n \n{\n\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nMinimumExceptionNameLength\nÂ¶\n\n\nException clause variables are expected to have a length of at least\n\nMinimumExceptionNameLength\n (default is \n2\n). Setting it to \n0\n or \n1\n\ndisables the check entirely.\n\n\ntry\n \n{\n\n\n    \n// ...\n\n\n}\n\n\n// This warns that 'e' is too short.\n\n\ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nx\n)\n \n{\n\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nIgnoredExceptionVariableNames\nÂ¶\n\n\nSpecifies a regular expression for exception variable names that are to\nbe ignored. The default value is \n^[e]$\n mainly for historical reasons.\n\n\ntry\n \n{\n\n\n    \n// ...\n\n\n}\n\n\n// This does not warn by default, for historical reasons.\n\n\ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \ne\n)\n \n{\n\n\n    \n// ...\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-length.html"
  },
  {
    "name": "readability-identifier-naming",
    "description": "Checks for identifiers naming style mismatch.\n\nThis check will try to enforce coding guidelines on the identifiers naming. It\nsupports one of the following casing types and tries to convert from one to\nanother if a mismatch is detected\n\nCasing types include:\n\nlower_case\n\n\nUPPER_CASE\n\n\ncamelBack\n\n\nCamelCase\n\n\ncamel_Snake_Back\n\n\nCamel_Snake_Case\n\n\naNy_CasE\n\n\nLeading_upper_snake_case\n\nIt also supports a fixed prefix and suffix that will be prepended or appended\nto the identifiers, regardless of the casing.\n\nMany configuration options are available, in order to be able to create\ndifferent rules for different kinds of identifiers. In general, the rules are\nfalling back to a more generic rule if the specific case is not configured.\n\nThe naming of virtual methods is reported where they occur in the base class,\nbut not where they are overridden, as it canât be fixed locally there.\nThis also applies for pseudo-override patterns like CRTP.\n\nLeading_upper_snake_case\n is a naming convention where the first word is\ncapitalized followed by lower case word(s) separated by underscore(s) â_â.\nExamples include: \nCap_snake_case\n, \nCobra_case\n, \nFoo_bar_baz\n,\nand \nMaster_copy_8gb\n.\n\nHungarian notation can be customized using different \nHungarianPrefix\n\nsettings. The options and their corresponding values are:\n\nOff\n - the default setting\n\n\nOn\n - example: \nint\n \niVariable\n\n\nLowerCase\n - example: \nint\n \ni_Variable\n\n\nCamelCase\n - example: \nint\n \nIVariable\n\nThe check only enforces style on kinds of identifiers which have been\nconfigured, so an empty config effectively disables it.\nThe \nDefaultCase\n option can be used to enforce style on all kinds of\nidentifiers, then optionally overriden for specific kinds which are desired\nwith a different case.\n\nFor example using values of:\n\nDefaultCase of \nlower_case\n\n\nMacroDefinitionCase of \nUPPER_CASE\n\n\nTemplateParameterCase of \nCamelCase\n\nIdentifies and transforms names as follows:\n\nBefore:\n\n#define macroDefinition\n\n\ntemplate\n \n<\ntypename\n \ntypenameParameter\n>\n\n\nint\n \nfunctionDeclaration\n(\ntypenameParameter\n \nparamVal\n,\n \nint\n \nparamCount\n);\n\nAfter:\n\n#define MACRO_DEFINITION\n\n\ntemplate\n \n<\ntypename\n \nTypenameParameter\n>\n\n\nint\n \nfunction_declarations\n(\nTypenameParameter\n \nparam_val\n,\n \nint\n \nparam_count\n);\n\nOptions summary\nÂ¶\n\n\nThe available options are summarized below:\n\n\nGeneral options\n\n\n\n\n\n\nAggressiveDependentMemberLookup\n\n\nCheckAnonFieldInParent\n\n\nGetConfigPerFile\n\n\nIgnoreMainLikeFunctions\n\n\n\n\n\n\nSpecific options\n\n\n\n\n\n\nDefaultCase\n, \nDefaultPrefix\n,\n\nDefaultSuffix\n, \nDefaultIgnoredRegexp\n,\n\nDefaultHungarianPrefix\n\n\nAbstractClassCase\n, \nAbstractClassPrefix\n,\n\nAbstractClassSuffix\n, \nAbstractClassIgnoredRegexp\n,\n\nAbstractClassHungarianPrefix\n\n\nClassCase\n, \nClassPrefix\n, \nClassSuffix\n,\n\nClassIgnoredRegexp\n, \nClassHungarianPrefix\n\n\nClassConstexprCase\n, \nClassConstexprPrefix\n,\n\nClassConstexprSuffix\n, \nClassConstexprIgnoredRegexp\n,\n\nClassConstexprHungarianPrefix\n\n\nClassConstantCase\n, \nClassConstantPrefix\n,\n\nClassConstantSuffix\n, \nClassConstantIgnoredRegexp\n,\n\nClassConstantHungarianPrefix\n\n\nClassMemberCase\n, \nClassMemberPrefix\n,\n\nClassMemberSuffix\n, \nClassMemberIgnoredRegexp\n,\n\nClassMemberHungarianPrefix\n\n\nClassMethodCase\n, \nClassMethodPrefix\n,\n\nClassMethodSuffix\n, \nClassMethodIgnoredRegexp\n\n\nConceptCase\n, \nConceptPrefix\n, \nConceptSuffix\n,\n\nConceptIgnoredRegexp\n\n\nConstantCase\n, \nConstantPrefix\n, \nConstantSuffix\n,\n\nConstantIgnoredRegexp\n, \nConstantHungarianPrefix\n\n\nConstantMemberCase\n, \nConstantMemberPrefix\n,\n\nConstantMemberSuffix\n, \nConstantMemberIgnoredRegexp\n,\n\nConstantMemberHungarianPrefix\n\n\nConstantParameterCase\n, \nConstantParameterPrefix\n,\n\nConstantParameterSuffix\n, \nConstantParameterIgnoredRegexp\n,\n\nConstantParameterHungarianPrefix\n\n\nConstantPointerParameterCase\n,\n\nConstantPointerParameterPrefix\n,\n\nConstantPointerParameterSuffix\n,\n\nConstantPointerParameterIgnoredRegexp\n,\n\nConstantPointerParameterHungarianPrefix\n\n\nConstexprFunctionCase\n, \nConstexprFunctionPrefix\n,\n\nConstexprFunctionSuffix\n, \nConstexprFunctionIgnoredRegexp\n\n\nConstexprMethodCase\n, \nConstexprMethodPrefix\n,\n\nConstexprMethodSuffix\n, \nConstexprMethodIgnoredRegexp\n\n\nConstexprVariableCase\n, \nConstexprVariablePrefix\n,\n\nConstexprVariableSuffix\n, \nConstexprVariableIgnoredRegexp\n,\n\nConstexprVariableHungarianPrefix\n\n\nEnumCase\n, \nEnumPrefix\n, \nEnumSuffix\n,\n\nEnumIgnoredRegexp\n\n\nEnumConstantCase\n, \nEnumConstantPrefix\n,\n\nEnumConstantSuffix\n, \nEnumConstantIgnoredRegexp\n,\n\nEnumConstantHungarianPrefix\n\n\nFunctionCase\n, \nFunctionPrefix\n, \nFunctionSuffix\n,\n\nFunctionIgnoredRegexp\n\n\nGlobalConstexprVariableCase\n,\n\nGlobalConstexprVariablePrefix\n,\n\nGlobalConstexprVariableSuffix\n,\n\nGlobalConstexprVariableIgnoredRegexp\n,\n\nGlobalConstexprVariableHungarianPrefix\n\n\nGlobalConstantCase\n, \nGlobalConstantPrefix\n,\n\nGlobalConstantSuffix\n, \nGlobalConstantIgnoredRegexp\n,\n\nGlobalConstantHungarianPrefix\n\n\nGlobalConstantPointerCase\n,\n\nGlobalConstantPointerPrefix\n,\n\nGlobalConstantPointerSuffix\n,\n\nGlobalConstantPointerIgnoredRegexp\n,\n\nGlobalConstantPointerHungarianPrefix\n\n\nGlobalFunctionCase\n, \nGlobalFunctionPrefix\n,\n\nGlobalFunctionSuffix\n, \nGlobalFunctionIgnoredRegexp\n\n\nGlobalPointerCase\n, \nGlobalPointerPrefix\n,\n\nGlobalPointerSuffix\n, \nGlobalPointerIgnoredRegexp\n,\n\nGlobalPointerHungarianPrefix\n\n\nGlobalVariableCase\n, \nGlobalVariablePrefix\n,\n\nGlobalVariableSuffix\n, \nGlobalVariableIgnoredRegexp\n,\n\nGlobalVariableHungarianPrefix\n\n\nInlineNamespaceCase\n, \nInlineNamespacePrefix\n,\n\nInlineNamespaceSuffix\n, \nInlineNamespaceIgnoredRegexp\n\n\nLocalConstexprVariableCase\n,\n\nLocalConstexprVariablePrefix\n,\n\nLocalConstexprVariableSuffix\n,\n\nLocalConstexprVariableIgnoredRegexp\n,\n\nLocalConstexprVariableHungarianPrefix\n\n\nLocalConstantCase\n, \nLocalConstantPrefix\n,\n\nLocalConstantSuffix\n, \nLocalConstantIgnoredRegexp\n,\n\nLocalConstantHungarianPrefix\n\n\nLocalConstantPointerCase\n,\n\nLocalConstantPointerPrefix\n,\n\nLocalConstantPointerSuffix\n,\n\nLocalConstantPointerIgnoredRegexp\n,\n\nLocalConstantPointerHungarianPrefix\n\n\nLocalPointerCase\n, \nLocalPointerPrefix\n,\n\nLocalPointerSuffix\n, \nLocalPointerIgnoredRegexp\n,\n\nLocalPointerHungarianPrefix\n\n\nLocalVariableCase\n, \nLocalVariablePrefix\n,\n\nLocalVariableSuffix\n, \nLocalVariableIgnoredRegexp\n,\n\nLocalVariableHungarianPrefix\n\n\nMacroDefinitionCase\n, \nMacroDefinitionPrefix\n,\n\nMacroDefinitionSuffix\n, \nMacroDefinitionIgnoredRegexp\n\n\nMemberCase\n, \nMemberPrefix\n, \nMemberSuffix\n,\n\nMemberIgnoredRegexp\n, \nMemberHungarianPrefix\n\n\nMethodCase\n, \nMethodPrefix\n, \nMethodSuffix\n,\n\nMethodIgnoredRegexp\n\n\nNamespaceCase\n, \nNamespacePrefix\n,\n\nNamespaceSuffix\n, \nNamespaceIgnoredRegexp\n\n\nParameterCase\n, \nParameterPrefix\n,\n\nParameterSuffix\n, \nParameterIgnoredRegexp\n,\n\nParameterHungarianPrefix\n\n\nParameterPackCase\n, \nParameterPackPrefix\n,\n\nParameterPackSuffix\n, \nParameterPackIgnoredRegexp\n\n\nPointerParameterCase\n, \nPointerParameterPrefix\n,\n\nPointerParameterSuffix\n, \nPointerParameterIgnoredRegexp\n,\n\nPointerParameterHungarianPrefix\n\n\nPrivateMemberCase\n, \nPrivateMemberPrefix\n,\n\nPrivateMemberSuffix\n, \nPrivateMemberIgnoredRegexp\n,\n\nPrivateMemberHungarianPrefix\n\n\nPrivateMethodCase\n, \nPrivateMethodPrefix\n,\n\nPrivateMethodSuffix\n, \nPrivateMethodIgnoredRegexp\n\n\nProtectedMemberCase\n, \nProtectedMemberPrefix\n,\n\nProtectedMemberSuffix\n, \nProtectedMemberIgnoredRegexp\n,\n\nProtectedMemberHungarianPrefix\n\n\nProtectedMethodCase\n, \nProtectedMethodPrefix\n,\n\nProtectedMethodSuffix\n, \nProtectedMethodIgnoredRegexp\n\n\nPublicMemberCase\n, \nPublicMemberPrefix\n,\n\nPublicMemberSuffix\n, \nPublicMemberIgnoredRegexp\n,\n\nPublicMemberHungarianPrefix\n\n\nPublicMethodCase\n, \nPublicMethodPrefix\n,\n\nPublicMethodSuffix\n, \nPublicMethodIgnoredRegexp\n\n\nScopedEnumConstantCase\n, \nScopedEnumConstantPrefix\n,\n\nScopedEnumConstantSuffix\n,\n\nScopedEnumConstantIgnoredRegexp\n\n\nStaticConstexprVariableCase\n,\n\nStaticConstexprVariablePrefix\n,\n\nStaticConstexprVariableSuffix\n,\n\nStaticConstexprVariableIgnoredRegexp\n,\n\nStaticConstexprVariableHungarianPrefix\n\n\nStaticConstantCase\n, \nStaticConstantPrefix\n,\n\nStaticConstantSuffix\n, \nStaticConstantIgnoredRegexp\n,\n\nStaticConstantHungarianPrefix\n\n\nStaticVariableCase\n, \nStaticVariablePrefix\n,\n\nStaticVariableSuffix\n, \nStaticVariableIgnoredRegexp\n,\n\nStaticVariableHungarianPrefix\n\n\nStructCase\n, \nStructPrefix\n, \nStructSuffix\n,\n\nStructIgnoredRegexp\n\n\nTemplateParameterCase\n, \nTemplateParameterPrefix\n,\n\nTemplateParameterSuffix\n, \nTemplateParameterIgnoredRegexp\n\n\nTemplateTemplateParameterCase\n,\n\nTemplateTemplateParameterPrefix\n,\n\nTemplateTemplateParameterSuffix\n,\n\nTemplateTemplateParameterIgnoredRegexp\n\n\nTypeAliasCase\n, \nTypeAliasPrefix\n,\n\nTypeAliasSuffix\n, \nTypeAliasIgnoredRegexp\n\n\nTypedefCase\n, \nTypedefPrefix\n, \nTypedefSuffix\n,\n\nTypedefIgnoredRegexp\n\n\nTypeTemplateParameterCase\n,\n\nTypeTemplateParameterPrefix\n,\n\nTypeTemplateParameterSuffix\n,\n\nTypeTemplateParameterIgnoredRegexp\n\n\nUnionCase\n, \nUnionPrefix\n, \nUnionSuffix\n,\n\nUnionIgnoredRegexp\n\n\nValueTemplateParameterCase\n,\n\nValueTemplateParameterPrefix\n,\n\nValueTemplateParameterSuffix\n,\n\nValueTemplateParameterIgnoredRegexp\n\n\nVariableCase\n, \nVariablePrefix\n, \nVariableSuffix\n,\n\nVariableIgnoredRegexp\n, \nVariableHungarianPrefix\n\n\nVirtualMethodCase\n, \nVirtualMethodPrefix\n,\n\nVirtualMethodSuffix\n, \nVirtualMethodIgnoredRegexp\n\nOptions description\nÂ¶\n\n\nA detailed description of each option is presented below:\n\n\n\n\n\n\nDefaultCase\nÂ¶\n\n\nWhen defined, the check will ensure all names by default conform to the\nselected casing.\n\n\n\n\n\n\n\n\nDefaultPrefix\nÂ¶\n\n\nWhen defined, the check will ensure all names by default will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nDefaultIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for all names by default\nmatching this regular expression.\n\n\n\n\n\n\n\n\nDefaultSuffix\nÂ¶\n\n\nWhen defined, the check will ensure all names by default will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nDefaultHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\n\n\n\n\nAbstractClassCase\nÂ¶\n\n\nWhen defined, the check will ensure abstract class names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nAbstractClassPrefix\nÂ¶\n\n\nWhen defined, the check will ensure abstract class names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nAbstractClassIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for abstract class names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nAbstractClassSuffix\nÂ¶\n\n\nWhen defined, the check will ensure abstract class names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nAbstractClassHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nAbstractClassCase of \nlower_case\n\n\nAbstractClassPrefix of \npre_\n\n\nAbstractClassSuffix of \n_post\n\n\nAbstractClassHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms abstract class names as follows:\n\n\nBefore:\n\n\nclass\n \nABSTRACT_CLASS\n \n{\n\n\npublic\n:\n\n\n  \nABSTRACT_CLASS\n();\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nclass\n \npre_abstract_class_post\n \n{\n\n\npublic\n:\n\n\n  \npre_abstract_class_post\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\nAggressiveDependentMemberLookup\nÂ¶\n\n\nWhen set to \ntrue\n the check will look in dependent base classes for dependent\nmember references that need changing. This can lead to errors with template\nspecializations so the default value is \nfalse\n.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nClassMemberCase of \nlower_case\n\n\n\n\n\n\nBefore:\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nBase\n \n{\n\n\n  \nT\n \nBadNamedMember\n;\n\n\n};\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nDerived\n \n:\n \nBase\n<\nT\n>\n \n{\n\n\n  \nvoid\n \nreset\n()\n \n{\n\n\n    \nthis\n->\nBadNamedMember\n \n=\n \n0\n;\n\n\n  \n}\n\n\n};\n\n\n\n\n\n\nAfter if AggressiveDependentMemberLookup is \nfalse\n:\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nBase\n \n{\n\n\n  \nT\n \nbad_named_member\n;\n\n\n};\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nDerived\n \n:\n \nBase\n<\nT\n>\n \n{\n\n\n  \nvoid\n \nreset\n()\n \n{\n\n\n    \nthis\n->\nBadNamedMember\n \n=\n \n0\n;\n\n\n  \n}\n\n\n};\n\n\n\n\n\n\nAfter if AggressiveDependentMemberLookup is \ntrue\n:\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nBase\n \n{\n\n\n  \nT\n \nbad_named_member\n;\n\n\n};\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nDerived\n \n:\n \nBase\n<\nT\n>\n \n{\n\n\n  \nvoid\n \nreset\n()\n \n{\n\n\n    \nthis\n->\nbad_named_member\n \n=\n \n0\n;\n\n\n  \n}\n\n\n};\n\n\n\n\n\n\n\n\n\n\nCheckAnonFieldInParent\nÂ¶\n\n\nWhen set to \ntrue\n, fields in anonymous records (i.e. anonymous\nunions and structs) will be treated as names in the enclosing scope\nrather than public members of the anonymous record for the purpose\nof name checking.\n\n\n\n\nFor example:\n\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nunion\n \n{\n\n\n    \nint\n \niv_\n;\n\n\n    \nfloat\n \nfv_\n;\n\n\n  \n};\n\n\n};\n\n\n\n\n\n\nIf \nCheckAnonFieldInParent\n is \nfalse\n, you may get warnings\nthat \niv_\n and \nfv_\n are not coherent to public member names, because\n\niv_\n and \nfv_\n are public members of the anonymous union. When\n\nCheckAnonFieldInParent\n is \ntrue\n, \niv_\n and \nfv_\n will be\ntreated as private data members of \nFoo\n for the purpose of name checking\nand thus no warnings will be emitted.\n\n\n\n\n\n\nClassCase\nÂ¶\n\n\nWhen defined, the check will ensure class names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nClassPrefix\nÂ¶\n\n\nWhen defined, the check will ensure class names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for class names matching\nthis regular expression.\n\n\n\n\n\n\n\n\nClassSuffix\nÂ¶\n\n\nWhen defined, the check will ensure class names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nClassCase of \nlower_case\n\n\nClassPrefix of \npre_\n\n\nClassSuffix of \n_post\n\n\nClassHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms class names as follows:\n\n\nBefore:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nFOO\n();\n\n\n  \n~\nFOO\n();\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nclass\n \npre_foo_post\n \n{\n\n\npublic\n:\n\n\n  \npre_foo_post\n();\n\n\n  \n~\npre_foo_post\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\nClassConstexprCase\nÂ¶\n\n\nWhen defined, the check will ensure class \nconstexpr\n names conform to\nthe selected casing.\n\n\n\n\n\n\n\n\nClassConstexprPrefix\nÂ¶\n\n\nWhen defined, the check will ensure class \nconstexpr\n names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassConstexprIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for class \nconstexpr\n names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nClassConstexprSuffix\nÂ¶\n\n\nWhen defined, the check will ensure class \nconstexpr\n names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassConstexprHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nClassConstexprCase of \nlower_case\n\n\nClassConstexprPrefix of \npre_\n\n\nClassConstexprSuffix of \n_post\n\n\nClassConstexprHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms class \nconstexpr\n variable names as follows:\n\n\nBefore:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nconstexpr\n \nint\n \nCLASS_CONSTEXPR\n;\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nconst\n \nint\n \npre_class_constexpr_post\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nClassConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure class constant names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nClassConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure class constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for class constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nClassConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure class constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nClassConstantCase of \nlower_case\n\n\nClassConstantPrefix of \npre_\n\n\nClassConstantSuffix of \n_post\n\n\nClassConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms class constant names as follows:\n\n\nBefore:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nconst\n \nint\n \nCLASS_CONSTANT\n;\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nconst\n \nint\n \npre_class_constant_post\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nClassMemberCase\nÂ¶\n\n\nWhen defined, the check will ensure class member names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nClassMemberPrefix\nÂ¶\n\n\nWhen defined, the check will ensure class member names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassMemberIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for class member names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nClassMemberSuffix\nÂ¶\n\n\nWhen defined, the check will ensure class member names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassMemberHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nClassMemberCase of \nlower_case\n\n\nClassMemberPrefix of \npre_\n\n\nClassMemberSuffix of \n_post\n\n\nClassMemberHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms class member names as follows:\n\n\nBefore:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nint\n \nCLASS_CONSTANT\n;\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nstatic\n \nint\n \npre_class_constant_post\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nClassMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure class method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nClassMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure class method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nClassMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for class method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nClassMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure class method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nClassMethodCase of \nlower_case\n\n\nClassMethodPrefix of \npre_\n\n\nClassMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms class method names as follows:\n\n\nBefore:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nint\n \nCLASS_MEMBER\n();\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFOO\n \n{\n\n\npublic\n:\n\n\n  \nint\n \npre_class_member_post\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\nConceptCase\nÂ¶\n\n\nWhen defined, the check will ensure concept names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConceptPrefix\nÂ¶\n\n\nWhen defined, the check will ensure concept names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConceptIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for concept names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConceptSuffix\nÂ¶\n\n\nWhen defined, the check will ensure concept names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConceptCase of \nCamelCase\n\n\nConceptPrefix of \nPre\n\n\nConceptSuffix of \nPost\n\n\n\n\n\n\nIdentifies and/or transforms concept names as follows:\n\n\nBefore:\n\n\ntemplate\n<\ntypename\n \nT\n>\n \nconcept\n \nmy_concept\n \n=\n \nrequires\n \n(\nT\n \nt\n)\n \n{\n \n{\nt\n++\n};\n \n};\n\n\n\n\n\n\nAfter:\n\n\ntemplate\n<\ntypename\n \nT\n>\n \nconcept\n \nPreMyConceptPost\n \n=\n \nrequires\n \n(\nT\n \nt\n)\n \n{\n \n{\nt\n++\n};\n \n};\n\n\n\n\n\n\n\n\n\n\nConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure constant names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstantCase of \nlower_case\n\n\nConstantPrefix of \npre_\n\n\nConstantSuffix of \n_post\n\n\nConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms constant names as follows:\n\n\nBefore:\n\n\nvoid\n \nfunction\n()\n \n{\n \nunsigned\n \nconst\n \nMyConst_array\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n \n}\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfunction\n()\n \n{\n \nunsigned\n \nconst\n \npre_myconst_array_post\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n \n}\n\n\n\n\n\n\n\n\n\n\nConstantMemberCase\nÂ¶\n\n\nWhen defined, the check will ensure constant member names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstantMemberPrefix\nÂ¶\n\n\nWhen defined, the check will ensure constant member names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantMemberIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constant member names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConstantMemberSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constant member names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantMemberHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstantMemberCase of \nlower_case\n\n\nConstantMemberPrefix of \npre_\n\n\nConstantMemberSuffix of \n_post\n\n\nConstantMemberHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms constant member names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nchar\n \nconst\n \nMY_ConstMember_string\n[\n4\n]\n \n=\n \n\"123\"\n;\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nchar\n \nconst\n \npre_my_constmember_string_post\n[\n4\n]\n \n=\n \n\"123\"\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\nConstantParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure constant parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstantParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure constant parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constant parameter names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConstantParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constant parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantParameterHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstantParameterCase of \nlower_case\n\n\nConstantParameterPrefix of \npre_\n\n\nConstantParameterSuffix of \n_post\n\n\nConstantParameterHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms constant parameter names as follows:\n\n\nBefore:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \nPARAMETER_1\n,\n \nint\n \nconst\n \nCONST_parameter\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \nPARAMETER_1\n,\n \nint\n \nconst\n \npre_const_parameter_post\n);\n\n\n\n\n\n\n\n\n\n\nConstantPointerParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure constant pointer parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstantPointerParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure constant pointer parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantPointerParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constant pointer parameter\nnames matching this regular expression.\n\n\n\n\n\n\n\n\nConstantPointerParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constant pointer parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstantPointerParameterHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstantPointerParameterCase of \nlower_case\n\n\nConstantPointerParameterPrefix of \npre_\n\n\nConstantPointerParameterSuffix of \n_post\n\n\nConstantPointerParameterHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms constant pointer parameter names as follows:\n\n\nBefore:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \nconst\n \n*\nCONST_parameter\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \nconst\n \n*\npre_const_parameter_post\n);\n\n\n\n\n\n\n\n\n\n\nConstexprFunctionCase\nÂ¶\n\n\nWhen defined, the check will ensure constexpr function names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstexprFunctionPrefix\nÂ¶\n\n\nWhen defined, the check will ensure constexpr function names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstexprFunctionIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constexpr function names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConstexprFunctionSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constexpr function names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstexprFunctionCase of \nlower_case\n\n\nConstexprFunctionPrefix of \npre_\n\n\nConstexprFunctionSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms constexpr function names as follows:\n\n\nBefore:\n\n\nconstexpr\n \nint\n \nCE_function\n()\n \n{\n \nreturn\n \n3\n;\n \n}\n\n\n\n\n\n\nAfter:\n\n\nconstexpr\n \nint\n \npre_ce_function_post\n()\n \n{\n \nreturn\n \n3\n;\n \n}\n\n\n\n\n\n\n\n\n\n\nConstexprMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure constexpr method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstexprMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure constexpr method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstexprMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constexpr method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConstexprMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constexpr method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstexprMethodCase of \nlower_case\n\n\nConstexprMethodPrefix of \npre_\n\n\nConstexprMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms constexpr method names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nconstexpr\n \nint\n \nCST_expr_Method\n()\n \n{\n \nreturn\n \n2\n;\n \n}\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nconstexpr\n \nint\n \npre_cst_expr_method_post\n()\n \n{\n \nreturn\n \n2\n;\n \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nConstexprVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure constexpr variable names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nConstexprVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure constexpr variable names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstexprVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for constexpr variable names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nConstexprVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure constexpr variable names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nConstexprVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nConstexprVariableCase of \nlower_case\n\n\nConstexprVariablePrefix of \npre_\n\n\nConstexprVariableSuffix of \n_post\n\n\nConstexprVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms constexpr variable names as follows:\n\n\nBefore:\n\n\nconstexpr\n \nint\n \nConstExpr_variable\n \n=\n \nMyConstant\n;\n\n\n\n\n\n\nAfter:\n\n\nconstexpr\n \nint\n \npre_constexpr_variable_post\n \n=\n \nMyConstant\n;\n\n\n\n\n\n\n\n\n\n\nEnumCase\nÂ¶\n\n\nWhen defined, the check will ensure enumeration names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nEnumPrefix\nÂ¶\n\n\nWhen defined, the check will ensure enumeration names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nEnumIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for enumeration names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nEnumSuffix\nÂ¶\n\n\nWhen defined, the check will ensure enumeration names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nEnumCase of \nlower_case\n\n\nEnumPrefix of \npre_\n\n\nEnumSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms enumeration names as follows:\n\n\nBefore:\n\n\nenum\n \nFOO\n \n{\n \nOne\n,\n \nTwo\n,\n \nThree\n \n};\n\n\n\n\n\n\nAfter:\n\n\nenum\n \npre_foo_post\n \n{\n \nOne\n,\n \nTwo\n,\n \nThree\n \n};\n\n\n\n\n\n\n\n\n\n\nEnumConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure enumeration constant names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nEnumConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure enumeration constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nEnumConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for enumeration constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nEnumConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure enumeration constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nEnumConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nEnumConstantCase of \nlower_case\n\n\nEnumConstantPrefix of \npre_\n\n\nEnumConstantSuffix of \n_post\n\n\nEnumConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms enumeration constant names as follows:\n\n\nBefore:\n\n\nenum\n \nFOO\n \n{\n \nOne\n,\n \nTwo\n,\n \nThree\n \n};\n\n\n\n\n\n\nAfter:\n\n\nenum\n \nFOO\n \n{\n \npre_One_post\n,\n \npre_Two_post\n,\n \npre_Three_post\n \n};\n\n\n\n\n\n\n\n\n\n\nFunctionCase\nÂ¶\n\n\nWhen defined, the check will ensure function names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nFunctionPrefix\nÂ¶\n\n\nWhen defined, the check will ensure function names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nFunctionIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for function names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nFunctionSuffix\nÂ¶\n\n\nWhen defined, the check will ensure function names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nFunctionCase of \nlower_case\n\n\nFunctionPrefix of \npre_\n\n\nFunctionSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms function names as follows:\n\n\nBefore:\n\n\nchar\n \nMY_Function_string\n();\n\n\n\n\n\n\nAfter:\n\n\nchar\n \npre_my_function_string_post\n();\n\n\n\n\n\n\n\n\n\n\nGetConfigPerFile\nÂ¶\n\n\nWhen \ntrue\n the check will look for the configuration for where an\nidentifier is declared. Useful for when included header files use a\ndifferent style.\nDefault value is \ntrue\n.\n\n\n\n\n\n\n\n\nGlobalConstexprVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure global \nconstexpr\n variable names\nconform to the selected casing.\n\n\n\n\n\n\n\n\nGlobalConstexprVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure global \nconstexpr\n variable names\nwill add the prefixed with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalConstexprVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for global \nconstexpr\n\nvariable names matching this regular expression.\n\n\n\n\n\n\n\n\nGlobalConstexprVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure global \nconstexpr\n variable names\nwill add the suffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalConstexprVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nGlobalConstexprVariableCase of \nlower_case\n\n\nGlobalConstexprVariablePrefix of \npre_\n\n\nGlobalConstexprVariableSuffix of \n_post\n\n\nGlobalConstexprVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms global \nconstexpr\n variable names as follows:\n\n\nBefore:\n\n\nconstexpr\n \nunsigned\n \nImportantValue\n \n=\n \n69\n;\n\n\n\n\n\n\nAfter:\n\n\nconstexpr\n \nunsigned\n \npre_important_value_post\n \n=\n \n69\n;\n\n\n\n\n\n\n\n\n\n\nGlobalConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure global constant names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nGlobalConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure global constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for global constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nGlobalConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure global constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nGlobalConstantCase of \nlower_case\n\n\nGlobalConstantPrefix of \npre_\n\n\nGlobalConstantSuffix of \n_post\n\n\nGlobalConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms global constant names as follows:\n\n\nBefore:\n\n\nunsigned\n \nconst\n \nMyConstGlobal_array\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\nAfter:\n\n\nunsigned\n \nconst\n \npre_myconstglobal_array_post\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\n\n\n\n\nGlobalConstantPointerCase\nÂ¶\n\n\nWhen defined, the check will ensure global constant pointer names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nGlobalConstantPointerPrefix\nÂ¶\n\n\nWhen defined, the check will ensure global constant pointer names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalConstantPointerIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for global constant pointer\nnames matching this regular expression.\n\n\n\n\n\n\n\n\nGlobalConstantPointerSuffix\nÂ¶\n\n\nWhen defined, the check will ensure global constant pointer names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalConstantPointerHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nGlobalConstantPointerCase of \nlower_case\n\n\nGlobalConstantPointerPrefix of \npre_\n\n\nGlobalConstantPointerSuffix of \n_post\n\n\nGlobalConstantPointerHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms global constant pointer names as follows:\n\n\nBefore:\n\n\nint\n \n*\nconst\n \nMyConstantGlobalPointer\n \n=\n \nnullptr\n;\n\n\n\n\n\n\nAfter:\n\n\nint\n \n*\nconst\n \npre_myconstantglobalpointer_post\n \n=\n \nnullptr\n;\n\n\n\n\n\n\n\n\n\n\nGlobalFunctionCase\nÂ¶\n\n\nWhen defined, the check will ensure global function names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nGlobalFunctionPrefix\nÂ¶\n\n\nWhen defined, the check will ensure global function names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalFunctionIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for global function names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nGlobalFunctionSuffix\nÂ¶\n\n\nWhen defined, the check will ensure global function names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nGlobalFunctionCase of \nlower_case\n\n\nGlobalFunctionPrefix of \npre_\n\n\nGlobalFunctionSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms global function names as follows:\n\n\nBefore:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \nPARAMETER_1\n,\n \nint\n \nconst\n \nCONST_parameter\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \npre_global_function_post\n(\nint\n \nPARAMETER_1\n,\n \nint\n \nconst\n \nCONST_parameter\n);\n\n\n\n\n\n\n\n\n\n\nGlobalPointerCase\nÂ¶\n\n\nWhen defined, the check will ensure global pointer names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nGlobalPointerPrefix\nÂ¶\n\n\nWhen defined, the check will ensure global pointer names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalPointerIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for global pointer names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nGlobalPointerSuffix\nÂ¶\n\n\nWhen defined, the check will ensure global pointer names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalPointerHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nGlobalPointerCase of \nlower_case\n\n\nGlobalPointerPrefix of \npre_\n\n\nGlobalPointerSuffix of \n_post\n\n\nGlobalPointerHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms global pointer names as follows:\n\n\nBefore:\n\n\nint\n \n*\nGLOBAL3\n;\n\n\n\n\n\n\nAfter:\n\n\nint\n \n*\npre_global3_post\n;\n\n\n\n\n\n\n\n\n\n\nGlobalVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure global variable names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nGlobalVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure global variable names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for global variable names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nGlobalVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure global variable names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nGlobalVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nGlobalVariableCase of \nlower_case\n\n\nGlobalVariablePrefix of \npre_\n\n\nGlobalVariableSuffix of \n_post\n\n\nGlobalVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms global variable names as follows:\n\n\nBefore:\n\n\nint\n \nGLOBAL3\n;\n\n\n\n\n\n\nAfter:\n\n\nint\n \npre_global3_post\n;\n\n\n\n\n\n\n\n\n\n\nIgnoreMainLikeFunctions\nÂ¶\n\n\nWhen set to \ntrue\n functions that have a similar signature to \nmain\n or\n\nwmain\n wonât enforce checks on the names of their parameters.\nDefault value is \nfalse\n.\n\n\n\n\n\n\n\n\nInlineNamespaceCase\nÂ¶\n\n\nWhen defined, the check will ensure inline namespaces names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nInlineNamespacePrefix\nÂ¶\n\n\nWhen defined, the check will ensure inline namespaces names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nInlineNamespaceIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for inline namespaces names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nInlineNamespaceSuffix\nÂ¶\n\n\nWhen defined, the check will ensure inline namespaces names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nInlineNamespaceCase of \nlower_case\n\n\nInlineNamespacePrefix of \npre_\n\n\nInlineNamespaceSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms inline namespaces names as follows:\n\n\nBefore:\n\n\nnamespace\n \nFOO_NS\n \n{\n\n\ninline\n \nnamespace\n \nInlineNamespace\n \n{\n\n\n...\n\n\n}\n\n\n}\n \n// namespace FOO_NS\n\n\n\n\n\n\nAfter:\n\n\nnamespace\n \nFOO_NS\n \n{\n\n\ninline\n \nnamespace\n \npre_inlinenamespace_post\n \n{\n\n\n...\n\n\n}\n\n\n}\n \n// namespace FOO_NS\n\n\n\n\n\n\n\n\n\n\nLocalConstexprVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure local \nconstexpr\n variable names\nconform to the selected casing.\n\n\n\n\n\n\n\n\nLocalConstexprVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure local \nconstexpr\n variable names will\nadd the prefixed with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalConstexprVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for local \nconstexpr\n variable\nnames matching this regular expression.\n\n\n\n\n\n\n\n\nLocalConstexprVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure local \nconstexpr\n variable names will\nadd the suffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalConstexprVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nLocalConstexprVariableCase of \nlower_case\n\n\nLocalConstexprVariablePrefix of \npre_\n\n\nLocalConstexprVariableSuffix of \n_post\n\n\nLocalConstexprVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms local \nconstexpr\n variable names as follows:\n\n\nBefore:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nconst\n \nlocal_Constexpr\n \n=\n \n420\n;\n \n}\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nconst\n \npre_local_constexpr_post\n \n=\n \n420\n;\n \n}\n\n\n\n\n\n\n\n\n\n\nLocalConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure local constant names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nLocalConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure local constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for local constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nLocalConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure local constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nLocalConstantCase of \nlower_case\n\n\nLocalConstantPrefix of \npre_\n\n\nLocalConstantSuffix of \n_post\n\n\nLocalConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms local constant names as follows:\n\n\nBefore:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nconst\n \nlocal_Constant\n \n=\n \n3\n;\n \n}\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nconst\n \npre_local_constant_post\n \n=\n \n3\n;\n \n}\n\n\n\n\n\n\n\n\n\n\nLocalConstantPointerCase\nÂ¶\n\n\nWhen defined, the check will ensure local constant pointer names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nLocalConstantPointerPrefix\nÂ¶\n\n\nWhen defined, the check will ensure local constant pointer names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalConstantPointerIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for local constant pointer names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nLocalConstantPointerSuffix\nÂ¶\n\n\nWhen defined, the check will ensure local constant pointer names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalConstantPointerHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nLocalConstantPointerCase of \nlower_case\n\n\nLocalConstantPointerPrefix of \npre_\n\n\nLocalConstantPointerSuffix of \n_post\n\n\nLocalConstantPointerHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms local constant pointer names as follows:\n\n\nBefore:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nconst\n \n*\nlocal_Constant\n \n=\n \n3\n;\n \n}\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nconst\n \n*\npre_local_constant_post\n \n=\n \n3\n;\n \n}\n\n\n\n\n\n\n\n\n\n\nLocalPointerCase\nÂ¶\n\n\nWhen defined, the check will ensure local pointer names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nLocalPointerPrefix\nÂ¶\n\n\nWhen defined, the check will ensure local pointer names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalPointerIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for local pointer names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nLocalPointerSuffix\nÂ¶\n\n\nWhen defined, the check will ensure local pointer names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalPointerHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nLocalPointerCase of \nlower_case\n\n\nLocalPointerPrefix of \npre_\n\n\nLocalPointerSuffix of \n_post\n\n\nLocalPointerHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms local pointer names as follows:\n\n\nBefore:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \n*\nlocal_Constant\n;\n \n}\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \n*\npre_local_constant_post\n;\n \n}\n\n\n\n\n\n\n\n\n\n\nLocalVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure local variable names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nLocalVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure local variable names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for local variable names\nmatching this regular expression.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nLocalVariableCase of \nCamelCase\n\n\nLocalVariableIgnoredRegexp of \n\\w{1,2}\n\n\n\n\n\n\nWill exclude variables with a length less than or equal to 2 from the\ncamel case check applied to other variables.\n\n\n\n\n\n\nLocalVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure local variable names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nLocalVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nLocalVariableCase of \nlower_case\n\n\nLocalVariablePrefix of \npre_\n\n\nLocalVariableSuffix of \n_post\n\n\nLocalVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms local variable names as follows:\n\n\nBefore:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \nlocal_Constant\n;\n \n}\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nfoo\n()\n \n{\n \nint\n \npre_local_constant_post\n;\n \n}\n\n\n\n\n\n\n\n\n\n\nMacroDefinitionCase\nÂ¶\n\n\nWhen defined, the check will ensure macro definitions conform to the\nselected casing.\n\n\n\n\n\n\n\n\nMacroDefinitionPrefix\nÂ¶\n\n\nWhen defined, the check will ensure macro definitions will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nMacroDefinitionIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for macro definitions\nmatching this regular expression.\n\n\n\n\n\n\n\n\nMacroDefinitionSuffix\nÂ¶\n\n\nWhen defined, the check will ensure macro definitions will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nMacroDefinitionCase of \nlower_case\n\n\nMacroDefinitionPrefix of \npre_\n\n\nMacroDefinitionSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms macro definitions as follows:\n\n\nBefore:\n\n\n#define MY_MacroDefinition\n\n\n\n\n\n\nAfter:\n\n\n#define pre_my_macro_definition_post\n\n\n\n\n\n\nNote: This will not warn on builtin macros or macros defined on the\ncommand line using the \n-D\n flag.\n\n\n\n\n\n\nMemberCase\nÂ¶\n\n\nWhen defined, the check will ensure member names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nMemberPrefix\nÂ¶\n\n\nWhen defined, the check will ensure member names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nMemberIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for member names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nMemberSuffix\nÂ¶\n\n\nWhen defined, the check will ensure member names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nMemberHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nMemberCase of \nlower_case\n\n\nMemberPrefix of \npre_\n\n\nMemberSuffix of \n_post\n\n\nMemberHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms member names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nchar\n \nMY_ConstMember_string\n[\n4\n];\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nchar\n \npre_my_constmember_string_post\n[\n4\n];\n\n\n}\n\n\n\n\n\n\n\n\n\n\nMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nMethodCase of \nlower_case\n\n\nMethodPrefix of \npre_\n\n\nMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms method names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nchar\n \nMY_Method_string\n();\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nchar\n \npre_my_method_string_post\n();\n\n\n}\n\n\n\n\n\n\n\n\n\n\nNamespaceCase\nÂ¶\n\n\nWhen defined, the check will ensure namespace names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nNamespacePrefix\nÂ¶\n\n\nWhen defined, the check will ensure namespace names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nNamespaceIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for namespace names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nNamespaceSuffix\nÂ¶\n\n\nWhen defined, the check will ensure namespace names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nNamespaceCase of \nlower_case\n\n\nNamespacePrefix of \npre_\n\n\nNamespaceSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms namespace names as follows:\n\n\nBefore:\n\n\nnamespace\n \nFOO_NS\n \n{\n\n\n...\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nnamespace\n \npre_foo_ns_post\n \n{\n\n\n...\n\n\n}\n\n\n\n\n\n\n\n\n\n\nParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for parameter names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nParameterHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nParameterCase of \nlower_case\n\n\nParameterPrefix of \npre_\n\n\nParameterSuffix of \n_post\n\n\nParameterHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms parameter names as follows:\n\n\nBefore:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \nPARAMETER_1\n,\n \nint\n \nconst\n \nCONST_parameter\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nGLOBAL_FUNCTION\n(\nint\n \npre_parameter_post\n,\n \nint\n \nconst\n \nCONST_parameter\n);\n\n\n\n\n\n\n\n\n\n\nParameterPackCase\nÂ¶\n\n\nWhen defined, the check will ensure parameter pack names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nParameterPackPrefix\nÂ¶\n\n\nWhen defined, the check will ensure parameter pack names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nParameterPackIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for parameter pack names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nParameterPackSuffix\nÂ¶\n\n\nWhen defined, the check will ensure parameter pack names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nParameterPackCase of \nlower_case\n\n\nParameterPackPrefix of \npre_\n\n\nParameterPackSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms parameter pack names as follows:\n\n\nBefore:\n\n\ntemplate\n \n<\ntypename\n...\n \nTYPE_parameters\n>\n \n{\n\n\n  \nvoid\n \nFUNCTION\n(\nint\n...\n \nTYPE_parameters\n);\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\ntemplate\n \n<\ntypename\n...\n \nTYPE_parameters\n>\n \n{\n\n\n  \nvoid\n \nFUNCTION\n(\nint\n...\n \npre_type_parameters_post\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPointerParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure pointer parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nPointerParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure pointer parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPointerParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for pointer parameter names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nPointerParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure pointer parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPointerParameterHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nPointerParameterCase of \nlower_case\n\n\nPointerParameterPrefix of \npre_\n\n\nPointerParameterSuffix of \n_post\n\n\nPointerParameterHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms pointer parameter names as follows:\n\n\nBefore:\n\n\nvoid\n \nFUNCTION\n(\nint\n \n*\nPARAMETER\n);\n\n\n\n\n\n\nAfter:\n\n\nvoid\n \nFUNCTION\n(\nint\n \n*\npre_parameter_post\n);\n\n\n\n\n\n\n\n\n\n\nPrivateMemberCase\nÂ¶\n\n\nWhen defined, the check will ensure private member names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nPrivateMemberPrefix\nÂ¶\n\n\nWhen defined, the check will ensure private member names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPrivateMemberIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for private member names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nPrivateMemberSuffix\nÂ¶\n\n\nWhen defined, the check will ensure private member names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPrivateMemberHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nPrivateMemberCase of \nlower_case\n\n\nPrivateMemberPrefix of \npre_\n\n\nPrivateMemberSuffix of \n_post\n\n\nPrivateMemberHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms private member names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nint\n \nMember_Variable\n;\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nint\n \npre_member_variable_post\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPrivateMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure private method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nPrivateMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure private method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPrivateMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for private method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nPrivateMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure private method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nPrivateMethodCase of \nlower_case\n\n\nPrivateMethodPrefix of \npre_\n\n\nPrivateMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms private method names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nint\n \nMember_Method\n();\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\nprivate\n:\n\n\n  \nint\n \npre_member_method_post\n();\n\n\n}\n\n\n\n\n\n\n\n\n\n\nProtectedMemberCase\nÂ¶\n\n\nWhen defined, the check will ensure protected member names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nProtectedMemberPrefix\nÂ¶\n\n\nWhen defined, the check will ensure protected member names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nProtectedMemberIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for protected member names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nProtectedMemberSuffix\nÂ¶\n\n\nWhen defined, the check will ensure protected member names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nProtectedMemberHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nProtectedMemberCase of \nlower_case\n\n\nProtectedMemberPrefix of \npre_\n\n\nProtectedMemberSuffix of \n_post\n\n\nProtectedMemberHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms protected member names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\nprotected\n:\n\n\n  \nint\n \nMember_Variable\n;\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\nprotected\n:\n\n\n  \nint\n \npre_member_variable_post\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\nProtectedMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure protected method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nProtectedMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure protected method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nProtectedMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for protected method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nProtectedMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure protected method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nProtectedMethodCase of \nlower_case\n\n\nProtectedMethodPrefix of \npre_\n\n\nProtectedMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms protect method names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\nprotected\n:\n\n\n  \nint\n \nMember_Method\n();\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\nprotected\n:\n\n\n  \nint\n \npre_member_method_post\n();\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPublicMemberCase\nÂ¶\n\n\nWhen defined, the check will ensure public member names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nPublicMemberPrefix\nÂ¶\n\n\nWhen defined, the check will ensure public member names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPublicMemberIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for public member names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nPublicMemberSuffix\nÂ¶\n\n\nWhen defined, the check will ensure public member names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPublicMemberHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nPublicMemberCase of \nlower_case\n\n\nPublicMemberPrefix of \npre_\n\n\nPublicMemberSuffix of \n_post\n\n\nPublicMemberHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms public member names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nint\n \nMember_Variable\n;\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nint\n \npre_member_variable_post\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\nPublicMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure public method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nPublicMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure public method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nPublicMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for public method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nPublicMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure public method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nPublicMethodCase of \nlower_case\n\n\nPublicMethodPrefix of \npre_\n\n\nPublicMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms public method names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nint\n \nMember_Method\n();\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nint\n \npre_member_method_post\n();\n\n\n}\n\n\n\n\n\n\n\n\n\n\nScopedEnumConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure scoped enum constant names conform to\nthe selected casing.\n\n\n\n\n\n\n\n\nScopedEnumConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure scoped enum constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nScopedEnumConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for scoped enum constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nScopedEnumConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure scoped enum constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nScopedEnumConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nScopedEnumConstantCase of \nlower_case\n\n\nScopedEnumConstantPrefix of \npre_\n\n\nScopedEnumConstantSuffix of \n_post\n\n\nScopedEnumConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms enumeration constant names as follows:\n\n\nBefore:\n\n\nenum\n \nclass\n \nFOO\n \n{\n \nOne\n,\n \nTwo\n,\n \nThree\n \n};\n\n\n\n\n\n\nAfter:\n\n\nenum\n \nclass\n \nFOO\n \n{\n \npre_One_post\n,\n \npre_Two_post\n,\n \npre_Three_post\n \n};\n\n\n\n\n\n\n\n\n\n\nStaticConstexprVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure static \nconstexpr\n variable names\nconform to the selected casing.\n\n\n\n\n\n\n\n\nStaticConstexprVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure static \nconstexpr\n variable names\nwill add the prefixed with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStaticConstexprVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for static \nconstexpr\n\nvariable names matching this regular expression.\n\n\n\n\n\n\n\n\nStaticConstexprVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure static \nconstexpr\n variable names\nwill add the suffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStaticConstexprVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nStaticConstexprVariableCase of \nlower_case\n\n\nStaticConstexprVariablePrefix of \npre_\n\n\nStaticConstexprVariableSuffix of \n_post\n\n\nStaticConstexprVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms static \nconstexpr\n variable names as follows:\n\n\nBefore:\n\n\nstatic\n \nunsigned\n \nconstexpr\n \nMyConstexprStatic_array\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\nAfter:\n\n\nstatic\n \nunsigned\n \nconstexpr\n \npre_my_constexpr_static_array_post\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\n\n\n\n\nStaticConstantCase\nÂ¶\n\n\nWhen defined, the check will ensure static constant names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nStaticConstantPrefix\nÂ¶\n\n\nWhen defined, the check will ensure static constant names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStaticConstantIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for static constant names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nStaticConstantSuffix\nÂ¶\n\n\nWhen defined, the check will ensure static constant names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStaticConstantHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nStaticConstantCase of \nlower_case\n\n\nStaticConstantPrefix of \npre_\n\n\nStaticConstantSuffix of \n_post\n\n\nStaticConstantHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms static constant names as follows:\n\n\nBefore:\n\n\nstatic\n \nunsigned\n \nconst\n \nMyConstStatic_array\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\nAfter:\n\n\nstatic\n \nunsigned\n \nconst\n \npre_myconststatic_array_post\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\n\n\n\n\nStaticVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure static variable names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nStaticVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure static variable names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStaticVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for static variable names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nStaticVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure static variable names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStaticVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nStaticVariableCase of \nlower_case\n\n\nStaticVariablePrefix of \npre_\n\n\nStaticVariableSuffix of \n_post\n\n\nStaticVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms static variable names as follows:\n\n\nBefore:\n\n\nstatic\n \nunsigned\n \nMyStatic_array\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\nAfter:\n\n\nstatic\n \nunsigned\n \npre_mystatic_array_post\n[]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n};\n\n\n\n\n\n\n\n\n\n\nStructCase\nÂ¶\n\n\nWhen defined, the check will ensure struct names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nStructPrefix\nÂ¶\n\n\nWhen defined, the check will ensure struct names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nStructIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for struct names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nStructSuffix\nÂ¶\n\n\nWhen defined, the check will ensure struct names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nStructCase of \nlower_case\n\n\nStructPrefix of \npre_\n\n\nStructSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms struct names as follows:\n\n\nBefore:\n\n\nstruct\n \nFOO\n \n{\n\n\n  \nFOO\n();\n\n\n  \n~\nFOO\n();\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nstruct\n \npre_foo_post\n \n{\n\n\n  \npre_foo_post\n();\n\n\n  \n~\npre_foo_post\n();\n\n\n};\n\n\n\n\n\n\n\n\n\n\nTemplateParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure template parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nTemplateParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure template parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nTemplateParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for template parameter names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nTemplateParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure template parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nTemplateParameterCase of \nlower_case\n\n\nTemplateParameterPrefix of \npre_\n\n\nTemplateParameterSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms template parameter names as follows:\n\n\nBefore:\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nFoo\n \n{};\n\n\n\n\n\n\nAfter:\n\n\ntemplate\n \n<\ntypename\n \npre_t_post\n>\n \nclass\n \nFoo\n \n{};\n\n\n\n\n\n\n\n\n\n\nTemplateTemplateParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure template template parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nTemplateTemplateParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure template template parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nTemplateTemplateParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for template template parameter\nnames matching this regular expression.\n\n\n\n\n\n\n\n\nTemplateTemplateParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure template template parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nTemplateTemplateParameterCase of \nlower_case\n\n\nTemplateTemplateParameterPrefix of \npre_\n\n\nTemplateTemplateParameterSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms template template parameter names as follows:\n\n\nBefore:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \nclass\n \nTPL_parameter\n,\n \nint\n \nCOUNT_params\n,\n\n\n          \ntypename\n...\n \nTYPE_parameters\n>\n\n\n\n\n\n\nAfter:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \nclass\n \npre_tpl_parameter_post\n,\n \nint\n \nCOUNT_params\n,\n\n\n          \ntypename\n...\n \nTYPE_parameters\n>\n\n\n\n\n\n\n\n\n\n\nTypeAliasCase\nÂ¶\n\n\nWhen defined, the check will ensure type alias names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nTypeAliasPrefix\nÂ¶\n\n\nWhen defined, the check will ensure type alias names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nTypeAliasIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for type alias names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nTypeAliasSuffix\nÂ¶\n\n\nWhen defined, the check will ensure type alias names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nTypeAliasCase of \nlower_case\n\n\nTypeAliasPrefix of \npre_\n\n\nTypeAliasSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms type alias names as follows:\n\n\nBefore:\n\n\nusing\n \nMY_STRUCT_TYPE\n \n=\n \nmy_structure\n;\n\n\n\n\n\n\nAfter:\n\n\nusing\n \npre_my_struct_type_post\n \n=\n \nmy_structure\n;\n\n\n\n\n\n\n\n\n\n\nTypedefCase\nÂ¶\n\n\nWhen defined, the check will ensure typedef names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nTypedefPrefix\nÂ¶\n\n\nWhen defined, the check will ensure typedef names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nTypedefIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for typedef names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nTypedefSuffix\nÂ¶\n\n\nWhen defined, the check will ensure typedef names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nTypedefCase of \nlower_case\n\n\nTypedefPrefix of \npre_\n\n\nTypedefSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms typedef names as follows:\n\n\nBefore:\n\n\ntypedef\n \nint\n \nMYINT\n;\n\n\n\n\n\n\nAfter:\n\n\ntypedef\n \nint\n \npre_myint_post\n;\n\n\n\n\n\n\n\n\n\n\nTypeTemplateParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure type template parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nTypeTemplateParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure type template parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nTypeTemplateParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for type template names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nTypeTemplateParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure type template parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nTypeTemplateParameterCase of \nlower_case\n\n\nTypeTemplateParameterPrefix of \npre_\n\n\nTypeTemplateParameterSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms type template parameter names as follows:\n\n\nBefore:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \nclass\n \nTPL_parameter\n,\n \nint\n \nCOUNT_params\n,\n\n\n          \ntypename\n...\n \nTYPE_parameters\n>\n\n\n\n\n\n\nAfter:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \nclass\n \nTPL_parameter\n,\n \nint\n \nCOUNT_params\n,\n\n\n          \ntypename\n...\n \npre_type_parameters_post\n>\n\n\n\n\n\n\n\n\n\n\nUnionCase\nÂ¶\n\n\nWhen defined, the check will ensure union names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nUnionPrefix\nÂ¶\n\n\nWhen defined, the check will ensure union names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nUnionIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for union names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nUnionSuffix\nÂ¶\n\n\nWhen defined, the check will ensure union names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nUnionCase of \nlower_case\n\n\nUnionPrefix of \npre_\n\n\nUnionSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms union names as follows:\n\n\nBefore:\n\n\nunion\n \nFOO\n \n{\n\n\n  \nint\n \na\n;\n\n\n  \nchar\n \nb\n;\n\n\n};\n\n\n\n\n\n\nAfter:\n\n\nunion\n \npre_foo_post\n \n{\n\n\n  \nint\n \na\n;\n\n\n  \nchar\n \nb\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nValueTemplateParameterCase\nÂ¶\n\n\nWhen defined, the check will ensure value template parameter names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nValueTemplateParameterPrefix\nÂ¶\n\n\nWhen defined, the check will ensure value template parameter names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nValueTemplateParameterIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for value template parameter\nnames matching this regular expression.\n\n\n\n\n\n\n\n\nValueTemplateParameterSuffix\nÂ¶\n\n\nWhen defined, the check will ensure value template parameter names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nValueTemplateParameterCase of \nlower_case\n\n\nValueTemplateParameterPrefix of \npre_\n\n\nValueTemplateParameterSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms value template parameter names as follows:\n\n\nBefore:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \nclass\n \nTPL_parameter\n,\n \nint\n \nCOUNT_params\n,\n\n\n          \ntypename\n...\n \nTYPE_parameters\n>\n\n\n\n\n\n\nAfter:\n\n\ntemplate\n \n<\ntemplate\n \n<\ntypename\n>\n \nclass\n \nTPL_parameter\n,\n \nint\n \npre_count_params_post\n,\n\n\n          \ntypename\n...\n \nTYPE_parameters\n>\n\n\n\n\n\n\n\n\n\n\nVariableCase\nÂ¶\n\n\nWhen defined, the check will ensure variable names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nVariablePrefix\nÂ¶\n\n\nWhen defined, the check will ensure variable names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nVariableIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for variable names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nVariableSuffix\nÂ¶\n\n\nWhen defined, the check will ensure variable names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nVariableHungarianPrefix\nÂ¶\n\n\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nVariableCase of \nlower_case\n\n\nVariablePrefix of \npre_\n\n\nVariableSuffix of \n_post\n\n\nVariableHungarianPrefix of \nOn\n\n\n\n\n\n\nIdentifies and/or transforms variable names as follows:\n\n\nBefore:\n\n\nunsigned\n \nMyVariable\n;\n\n\n\n\n\n\nAfter:\n\n\nunsigned\n \npre_myvariable_post\n;\n\n\n\n\n\n\n\n\n\n\nVirtualMethodCase\nÂ¶\n\n\nWhen defined, the check will ensure virtual method names conform to the\nselected casing.\n\n\n\n\n\n\n\n\nVirtualMethodPrefix\nÂ¶\n\n\nWhen defined, the check will ensure virtual method names will add the\nprefix with the given value (regardless of casing).\n\n\n\n\n\n\n\n\nVirtualMethodIgnoredRegexp\nÂ¶\n\n\nIdentifier naming checks wonât be enforced for virtual method names\nmatching this regular expression.\n\n\n\n\n\n\n\n\nVirtualMethodSuffix\nÂ¶\n\n\nWhen defined, the check will ensure virtual method names will add the\nsuffix with the given value (regardless of casing).\n\n\n\n\nFor example using values of:\n\n\n\n\n\n\nVirtualMethodCase of \nlower_case\n\n\nVirtualMethodPrefix of \npre_\n\n\nVirtualMethodSuffix of \n_post\n\n\n\n\n\n\nIdentifies and/or transforms virtual method names as follows:\n\n\nBefore:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nint\n \nMemberFunction\n();\n\n\n}\n\n\n\n\n\n\nAfter:\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nvirtual\n \nint\n \npre_member_function_post\n();\n\n\n}\n\nThe default mapping table of Hungarian Notation\nÂ¶\n\n\nIn Hungarian notation, a variable name starts with a group of lower-case\nletters which are mnemonics for the type or purpose of that variable, followed\nby whatever name the programmer has chosen; this last part is sometimes\ndistinguished as the given name. The first character of the given name can be\ncapitalized to separate it from the type indicators (see also CamelCase).\nOtherwise the case of this character denotes scope.\n\n\nThe following table is the default mapping table of Hungarian Notation\nwhich maps Decl to its prefix string. You can also have your own style\nin config file.\n\n\n\n\n\n\nPrimitive Type\n\n\n\n\n\n\n\n\nMicrosoft Type\n\n\n\n\n\n\nType\n\n\nPrefix\n\n\nType\n\n\nPrefix\n\n\nType\n\n\nPrefix\n\n\n\n\n\n\n\n\nint8_t\n\n\ni8\n\n\nsigned int\n\n\nsi\n\n\nBOOL\n\n\nb\n\n\n\n\nint16_t\n\n\ni16\n\n\nsigned short\n\n\nss\n\n\nBOOLEAN\n\n\nb\n\n\n\n\nint32_t\n\n\ni32\n\n\nsigned short int\n\n\nssi\n\n\nBYTE\n\n\nby\n\n\n\n\nint64_t\n\n\ni64\n\n\nsigned long long int\n\n\nslli\n\n\nCHAR\n\n\nc\n\n\n\n\nuint8_t\n\n\nu8\n\n\nsigned long long\n\n\nsll\n\n\nUCHAR\n\n\nuc\n\n\n\n\nuint16_t\n\n\nu16\n\n\nsigned long int\n\n\nsli\n\n\nSHORT\n\n\ns\n\n\n\n\nuint32_t\n\n\nu32\n\n\nsigned long\n\n\nsl\n\n\nUSHORT\n\n\nus\n\n\n\n\nuint64_t\n\n\nu64\n\n\nsigned\n\n\ns\n\n\nWORD\n\n\nw\n\n\n\n\nchar8_t\n\n\nc8\n\n\nunsigned long long int\n\n\nulli\n\n\nDWORD\n\n\ndw\n\n\n\n\nchar16_t\n\n\nc16\n\n\nunsigned long long\n\n\null\n\n\nDWORD32\n\n\ndw32\n\n\n\n\nchar32_t\n\n\nc32\n\n\nunsigned long int\n\n\nuli\n\n\nDWORD64\n\n\ndw64\n\n\n\n\nfloat\n\n\nf\n\n\nunsigned long\n\n\nul\n\n\nLONG\n\n\nl\n\n\n\n\ndouble\n\n\nd\n\n\nunsigned short int\n\n\nusi\n\n\nULONG\n\n\nul\n\n\n\n\nchar\n\n\nc\n\n\nunsigned short\n\n\nus\n\n\nULONG32\n\n\nul32\n\n\n\n\nbool\n\n\nb\n\n\nunsigned int\n\n\nui\n\n\nULONG64\n\n\nul64\n\n\n\n\n_Bool\n\n\nb\n\n\nunsigned char\n\n\nuc\n\n\nULONGLONG\n\n\null\n\n\n\n\nint\n\n\ni\n\n\nunsigned\n\n\nu\n\n\nHANDLE\n\n\nh\n\n\n\n\nsize_t\n\n\nn\n\n\nlong long int\n\n\nlli\n\n\nINT\n\n\ni\n\n\n\n\nshort\n\n\ns\n\n\nlong double\n\n\nld\n\n\nINT8\n\n\ni8\n\n\n\n\nsigned\n\n\ni\n\n\nlong long\n\n\nll\n\n\nINT16\n\n\ni16\n\n\n\n\nunsigned\n\n\nu\n\n\nlong int\n\n\nli\n\n\nINT32\n\n\ni32\n\n\n\n\nlong\n\n\nl\n\n\nlong\n\n\nl\n\n\nINT64\n\n\ni64\n\n\n\n\nlong long\n\n\nll\n\n\nptrdiff_t\n\n\np\n\n\nUINT\n\n\nui\n\n\n\n\nunsigned long\n\n\nul\n\n\nvoid\n\n\nnone\n\n\nUINT8\n\n\nu8\n\n\n\n\nlong double\n\n\nld\n\n\n\n\n\n\nUINT16\n\n\nu16\n\n\n\n\nptrdiff_t\n\n\np\n\n\n\n\n\n\nUINT32\n\n\nu32\n\n\n\n\nwchar_t\n\n\nwc\n\n\n\n\n\n\nUINT64\n\n\nu64\n\n\n\n\nshort int\n\n\nsi\n\n\n\n\n\n\nPVOID\n\n\np\n\n\n\n\nshort\n\n\ns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere are more trivial options for Hungarian Notation:\n\n\n\n\nHungarianNotation.General.*\nOptions are not belonging to any specific Decl.\n\n\n\n\nHungarianNotation.CString.*\nOptions for NULL-terminated string.\n\n\n\n\nHungarianNotation.DerivedType.*\nOptions for derived types.\n\n\n\n\nHungarianNotation.PrimitiveType.*\nOptions for primitive types.\n\n\n\n\nHungarianNotation.UserDefinedType.*\nOptions for user-defined types.\n\nOptions for Hungarian Notation\nÂ¶\n\n\n\n\nHungarianNotation.General.TreatStructAsClass\n\n\nHungarianNotation.DerivedType.Array\n\n\nHungarianNotation.DerivedType.Pointer\n\n\nHungarianNotation.DerivedType.FunctionPointer\n\n\nHungarianNotation.CString.CharPointer\n\n\nHungarianNotation.CString.CharArray\n\n\nHungarianNotation.CString.WideCharPointer\n\n\nHungarianNotation.CString.WideCharArray\n\n\nHungarianNotation.PrimitiveType.*\n\n\nHungarianNotation.UserDefinedType.*\n\n\n\n\n\n\n\n\nHungarianNotation.General.TreatStructAsClass\nÂ¶\n\n\nWhen defined, the check will treat naming of struct as a class.\nThe default value is \nfalse\n.\n\n\n\n\n\n\n\n\nHungarianNotation.DerivedType.Array\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \na\n.\n\n\n\n\n\n\n\n\nHungarianNotation.DerivedType.Pointer\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \np\n.\n\n\n\n\n\n\n\n\nHungarianNotation.DerivedType.FunctionPointer\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \nfn\n.\n\n\n\n\nBefore:\n\n\n// Array\n\n\nint\n \nDataArray\n[\n2\n]\n \n=\n \n{\n0\n};\n\n\n\n// Pointer\n\n\nvoid\n \n*\nDataBuffer\n \n=\n \nNULL\n;\n\n\n\n// FunctionPointer\n\n\ntypedef\n \nvoid\n \n(\n*\nFUNC_PTR\n)();\n\n\nFUNC_PTR\n \nFuncPtr\n \n=\n \nNULL\n;\n\n\n\n\n\n\nAfter:\n\n\n// Array\n\n\nint\n \naDataArray\n[\n2\n]\n \n=\n \n{\n0\n};\n\n\n\n// Pointer\n\n\nvoid\n \n*\npDataBuffer\n \n=\n \nNULL\n;\n\n\n\n// FunctionPointer\n\n\ntypedef\n \nvoid\n \n(\n*\nFUNC_PTR\n)();\n\n\nFUNC_PTR\n \nfnFuncPtr\n \n=\n \nNULL\n;\n\n\n\n\n\n\n\n\n\n\nHungarianNotation.CString.CharPointer\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \nsz\n.\n\n\n\n\n\n\n\n\nHungarianNotation.CString.CharArray\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \nsz\n.\n\n\n\n\n\n\n\n\nHungarianNotation.CString.WideCharPointer\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \nwsz\n.\n\n\n\n\n\n\n\n\nHungarianNotation.CString.WideCharArray\nÂ¶\n\n\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is \nwsz\n.\n\n\n\n\nBefore:\n\n\n// CharPointer\n\n\nconst\n \nchar\n \n*\nNamePtr\n \n=\n \n\"Name\"\n;\n\n\n\n// CharArray\n\n\nconst\n \nchar\n \nNameArray\n[]\n \n=\n \n\"Name\"\n;\n\n\n\n// WideCharPointer\n\n\nconst\n \nwchar_t\n \n*\nWideNamePtr\n \n=\n \nL\n\"Name\"\n;\n\n\n\n// WideCharArray\n\n\nconst\n \nwchar_t\n \nWideNameArray\n[]\n \n=\n \nL\n\"Name\"\n;\n\n\n\n\n\n\nAfter:\n\n\n// CharPointer\n\n\nconst\n \nchar\n \n*\nszNamePtr\n \n=\n \n\"Name\"\n;\n\n\n\n// CharArray\n\n\nconst\n \nchar\n \nszNameArray\n[]\n \n=\n \n\"Name\"\n;\n\n\n\n// WideCharPointer\n\n\nconst\n \nwchar_t\n \n*\nwszWideNamePtr\n \n=\n \nL\n\"Name\"\n;\n\n\n\n// WideCharArray\n\n\nconst\n \nwchar_t\n \nwszWideNameArray\n[]\n \n=\n \nL\n\"Name\"\n;\n\n\n\n\n\n\n\n\n\n\nHungarianNotation.PrimitiveType.*\nÂ¶\n\n\nWhen defined, the check will ensure variable name of involved primitive\ntypes will add the prefix with the given string. The default prefixes are\ndefined in the default mapping table.\n\n\n\n\n\n\n\n\nHungarianNotation.UserDefinedType.*\nÂ¶\n\n\nWhen defined, the check will ensure variable name of involved primitive\ntypes will add the prefix with the given string. The default prefixes are\ndefined in the default mapping table.\n\n\n\n\nBefore:\n\n\nint8_t\n   \nValueI8\n      \n=\n \n0\n;\n\n\nint16_t\n  \nValueI16\n     \n=\n \n0\n;\n\n\nint32_t\n  \nValueI32\n     \n=\n \n0\n;\n\n\nint64_t\n  \nValueI64\n     \n=\n \n0\n;\n\n\nuint8_t\n  \nValueU8\n      \n=\n \n0\n;\n\n\nuint16_t\n \nValueU16\n     \n=\n \n0\n;\n\n\nuint32_t\n \nValueU32\n     \n=\n \n0\n;\n\n\nuint64_t\n \nValueU64\n     \n=\n \n0\n;\n\n\nfloat\n    \nValueFloat\n   \n=\n \n0.0\n;\n\n\ndouble\n   \nValueDouble\n  \n=\n \n0.0\n;\n\n\nULONG\n    \nValueUlong\n   \n=\n \n0\n;\n\n\nDWORD\n    \nValueDword\n   \n=\n \n0\n;\n\n\n\n\n\n\nAfter:\n\n\nint8_t\n   \ni8ValueI8\n    \n=\n \n0\n;\n\n\nint16_t\n  \ni16ValueI16\n  \n=\n \n0\n;\n\n\nint32_t\n  \ni32ValueI32\n  \n=\n \n0\n;\n\n\nint64_t\n  \ni64ValueI64\n  \n=\n \n0\n;\n\n\nuint8_t\n  \nu8ValueU8\n    \n=\n \n0\n;\n\n\nuint16_t\n \nu16ValueU16\n  \n=\n \n0\n;\n\n\nuint32_t\n \nu32ValueU32\n  \n=\n \n0\n;\n\n\nuint64_t\n \nu64ValueU64\n  \n=\n \n0\n;\n\n\nfloat\n    \nfValueFloat\n  \n=\n \n0.0\n;\n\n\ndouble\n   \ndValueDouble\n \n=\n \n0.0\n;\n\n\nULONG\n    \nulValueUlong\n \n=\n \n0\n;\n\n\nDWORD\n    \ndwValueDword\n \n=\n \n0\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/identifier-naming.html"
  },
  {
    "name": "readability-implicit-bool-conversion",
    "description": "This check can be used to find implicit conversions between built-in types and\nbooleans. Depending on use case, it may simply help with readability of the\ncode, or in some cases, point to potential bugs which remain unnoticed due to\nimplicit conversions.\n\nThe following is a real-world example of bug which was hiding behind implicit\n\nbool\n conversion:\n\nclass\n \nFoo\n \n{\n\n\n  \nint\n \nm_foo\n;\n\n\n\npublic\n:\n\n\n  \nvoid\n \nsetFoo\n(\nbool\n \nfoo\n)\n \n{\n \nm_foo\n \n=\n \nfoo\n;\n \n}\n \n// warning: implicit conversion bool -> int\n\n\n  \nint\n \ngetFoo\n()\n \n{\n \nreturn\n \nm_foo\n;\n \n}\n\n\n};\n\n\n\nvoid\n \nuse\n(\nFoo\n&\n \nfoo\n)\n \n{\n\n\n  \nbool\n \nvalue\n \n=\n \nfoo\n.\ngetFoo\n();\n \n// warning: implicit conversion int -> bool\n\n\n}\n\nThis code is the result of unsuccessful refactoring, where type of \nm_foo\n\nchanged from \nbool\n to \nint\n. The programmer forgot to change all\noccurrences of \nbool\n, and the remaining code is no longer correct, yet it\nstill compiles without any visible warnings.\n\nIn addition to issuing warnings, fix-it hints are provided to help solve the\nreported issues. This can be used for improving readability of code, for\nexample:\n\nvoid\n \nconversionsToBool\n()\n \n{\n\n\n  \nfloat\n \nfloating\n;\n\n\n  \nbool\n \nboolean\n \n=\n \nfloating\n;\n\n\n  \n// ^ propose replacement: bool boolean = floating != 0.0f;\n\n\n\n  \nint\n \ninteger\n;\n\n\n  \nif\n \n(\ninteger\n)\n \n{}\n\n\n  \n// ^ propose replacement: if (integer != 0) {}\n\n\n\n  \nint\n*\n \npointer\n;\n\n\n  \nif\n \n(\n!\npointer\n)\n \n{}\n\n\n  \n// ^ propose replacement: if (pointer == nullptr) {}\n\n\n\n  \nwhile\n \n(\n1\n)\n \n{}\n\n\n  \n// ^ propose replacement: while (true) {}\n\n\n}\n\n\n\nvoid\n \nfunctionTakingInt\n(\nint\n \nparam\n);\n\n\n\nvoid\n \nconversionsFromBool\n()\n \n{\n\n\n  \nbool\n \nboolean\n;\n\n\n  \nfunctionTakingInt\n(\nboolean\n);\n\n\n  \n// ^ propose replacement: functionTakingInt(static_cast<int>(boolean));\n\n\n\n  \nfunctionTakingInt\n(\ntrue\n);\n\n\n  \n// ^ propose replacement: functionTakingInt(1);\n\n\n}\n\nIn general, the following conversion types are checked:\n\ninteger expression/literal to boolean (conversion from a single bit bitfield\nto boolean is explicitly allowed, since thereâs no ambiguity / information\nloss in this case),\n\n\nfloating expression/literal to boolean,\n\n\npointer/pointer to member/\nnullptr\n/\nNULL\n to boolean,\n\n\nboolean expression/literal to integer (conversion from boolean to a single\nbit bitfield is explicitly allowed),\n\n\nboolean expression/literal to floating.\n\nThe rules for generating fix-it hints are:\n\nin case of conversions from other built-in type to bool, an explicit\ncomparison is proposed to make it clear what exactly is being compared:\n\n\n\n\nbool\n \nboolean\n \n=\n \nfloating;\n is changed to\n\nbool\n \nboolean\n \n=\n \nfloating\n \n==\n \n0.0f;\n,\n\n\nfor other types, appropriate literals are used (\n0\n, \n0u\n, \n0.0f\n,\n\n0.0\n, \nnullptr\n),\n\n\n\n\n\n\nin case of negated expressions conversion to bool, the proposed replacement\nwith comparison is simplified:\n\n\n\n\nif\n \n(!pointer)\n is changed to \nif\n \n(pointer\n \n==\n \nnullptr)\n,\n\n\n\n\n\n\nin case of conversions from bool to other built-in types, an explicit\n\nstatic_cast\n (or a C-style cast since C23) is proposed to make it clear\nthat a conversion is taking place:\n\n\n\n\nint\n \ninteger\n \n=\n \nboolean;\n is changed to\n\nint\n \ninteger\n \n=\n \nstatic_cast<int>(boolean);\n,\n\n\n\n\n\n\nif the conversion is performed on type literals, an equivalent literal is\nproposed, according to what type is actually expected, for example:\n\n\n\n\nfunctionTakingBool(0);\n is changed to \nfunctionTakingBool(false);\n,\n\n\nfunctionTakingInt(true);\n is changed to \nfunctionTakingInt(1);\n,\n\n\nfor other types, appropriate literals are used (\nfalse\n, \ntrue\n, \n0\n,\n\n1\n, \n0u\n, \n1u\n, \n0.0f\n, \n1.0f\n, \n0.0\n, \n1.0f\n).\n\nSome additional accommodations are made for pre-C++11 dialects:\n\nfalse\n literal conversion to pointer is detected,\n\n\ninstead of \nnullptr\n literal, \n0\n is proposed as replacement.\n\nSome additional accommodations are made for C:\n\nbool\n (or \n_Bool\n) operands in logical operators (\n&&\n, \n||\n) are\nignored.\n\nOccurrences of implicit conversions inside macros and template instantiations\nare deliberately ignored, as it is not clear how to deal with such cases.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowIntegerConditions\nÂ¶\n\n\nWhen \ntrue\n, the check will allow conditional integer conversions. Default\nis \nfalse\n.\n\n\n\n\n\n\n\n\nAllowPointerConditions\nÂ¶\n\n\nWhen \ntrue\n, the check will allow conditional pointer conversions. Default\nis \nfalse\n.\n\n\n\n\n\n\n\n\nUseUpperCaseLiteralSuffix\nÂ¶\n\n\nWhen \ntrue\n, the replacements will use an uppercase literal suffix in the\nprovided fixes. Default is \nfalse\n.\n\n\n\n\nExample\n\n\nuint32_t\n \nfoo\n;\n\n\nif\n \n(\nfoo\n)\n \n{}\n\n\n// ^ propose replacement default: if (foo != 0u) {}\n\n\n// ^ propose replacement with option `UseUpperCaseLiteralSuffix`: if (foo != 0U) {}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/implicit-bool-conversion.html"
  },
  {
    "name": "readability-inconsistent-declaration-parameter-name",
    "description": "Find function declarations which differ in parameter names.\n\nExample:\n\n// in foo.hpp:\n\n\nvoid\n \nfoo\n(\nint\n \na\n,\n \nint\n \nb\n,\n \nint\n \nc\n);\n\n\n\n// in foo.cpp:\n\n\nvoid\n \nfoo\n(\nint\n \nd\n,\n \nint\n \ne\n,\n \nint\n \nf\n);\n \n// warning\n\nThis check should help to enforce consistency in large projects, where it often\nhappens that a definition of function is refactored, changing the parameter\nnames, but its declaration in header file is not updated. With this check, we\ncan easily find and correct such inconsistencies, keeping declaration and\ndefinition always in sync.\n\nUnnamed parameters are allowed and are not taken into account when comparing\nfunction declarations, for example:\n\nvoid\n \nfoo\n(\nint\n \na\n);\n\n\nvoid\n \nfoo\n(\nint\n);\n \n// no warning\n\nOne name is also allowed to be a case-insensitive prefix/suffix of the other:\n\nvoid\n \nfoo\n(\nint\n \ncount\n);\n\n\nvoid\n \nfoo\n(\nint\n \ncount_input\n)\n \n{\n \n// no warning\n\n\n  \nint\n \ncount\n \n=\n \nadjustCount\n(\ncount_input\n);\n\n\n}\n\nTo help with refactoring, in some cases fix-it hints are generated to align\nparameter names to a single naming convention. This works with the assumption\nthat the function definition is the most up-to-date version, as it directly\nreferences parameter names in its body. Example:\n\nvoid\n \nfoo\n(\nint\n \na\n);\n \n// warning and fix-it hint (replace \"a\" to \"b\")\n\n\nint\n \nfoo\n(\nint\n \nb\n)\n \n{\n \nreturn\n \nb\n \n+\n \n2\n;\n \n}\n \n// definition with use of \"b\"\n\nIn the case of multiple redeclarations or function template specializations,\na warning is issued for every redeclaration or specialization inconsistent with\nthe definition or the first declaration seen in a translation unit.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \ntrue\n), the check will not warn\nabout names declared inside macros.\n\n\n\n\n\n\n\n\nStrict\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \nfalse\n), then names must match\nexactly (or be absent).",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/inconsistent-declaration-parameter-name.html"
  },
  {
    "name": "readability-inconsistent-ifelse-braces",
    "description": "Detects \nif\n/\nelse\n statements where one branch uses braces and the other\ndoes not.\n\nBefore:\n\nif\n \n(\ncondition\n)\n \n{\n\n\n  \nstatement\n;\n\n\n}\n \nelse\n\n\n  \nstatement\n;\n\n\n\nif\n \n(\ncondition\n)\n\n\n  \nstatement\n;\n\n\n\nif\n \n(\ncondition\n)\n\n\n  \nstatement\n;\n\n\nelse\n\n\n  \nstatement\n;\n\nAfter:\n\nif\n \n(\ncondition\n)\n \n{\n\n\n  \nstatement\n;\n\n\n}\n \nelse\n \n{\n\n\n  \nstatement\n;\n\n\n}\n\n\n\nif\n \n(\ncondition\n)\n\n\n  \nstatement\n;\n\n\n\nif\n \n(\ncondition\n)\n\n\n  \nstatement\n;\n\n\nelse\n\n\n  \nstatement\n;",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/inconsistent-ifelse-braces.html"
  },
  {
    "name": "readability-isolate-declaration",
    "description": "Detects local variable declarations declaring more than one variable and\ntries to refactor the code to one statement per declaration.\n\nThe automatic code-transformation will use the same indentation as the original\nfor every created statement and add a line break after each statement.\nIt keeps the order of the variable declarations consistent, too.\n\nvoid\n \nf\n()\n \n{\n\n\n  \nint\n \n*\n \npointer\n \n=\n \nnullptr\n,\n \nvalue\n \n=\n \n42\n,\n \n*\n \nconst\n \nconst_ptr\n \n=\n \n&\nvalue\n;\n\n\n  \n// This declaration will be diagnosed and transformed into:\n\n\n  \n// int * pointer = nullptr;\n\n\n  \n// int value = 42;\n\n\n  \n// int * const const_ptr = &value;\n\n\n}\n\nThe check excludes places where it is necessary or common to declare\nmultiple variables in one statement and there is no other way supported in the\nlanguage. Please note that structured bindings are not considered.\n\n// It is not possible to transform this declaration and doing the declaration\n\n\n// before the loop will increase the scope of the variable 'Begin' and 'End'\n\n\n// which is undesirable.\n\n\nfor\n \n(\nint\n \nBegin\n \n=\n \n0\n,\n \nEnd\n \n=\n \n100\n;\n \nBegin\n \n<\n \nEnd\n;\n \n++\nBegin\n);\n\n\nif\n \n(\nint\n \nBegin\n \n=\n \n42\n,\n \nResult\n \n=\n \nsome_function\n(\nBegin\n);\n \nBegin\n \n==\n \nResult\n);\n\n\n\n// It is not possible to transform this declaration because the result is\n\n\n// not functionality preserving as 'j' and 'k' would not be part of the\n\n\n// 'if' statement anymore.\n\n\nif\n \n(\nSomeCondition\n())\n\n\n  \nint\n \ni\n \n=\n \n42\n,\n \nj\n \n=\n \n43\n,\n \nk\n \n=\n \nfunction\n(\ni\n,\nj\n);\n\nLimitations\nÂ¶\n\n\nGlobal variables and member variables are excluded.\n\n\nThe check currently does not support the automatic transformation of\nmember-pointer-types.\n\n\nstruct\n \nS\n \n{\n\n\n  \nint\n \na\n;\n\n\n  \nconst\n \nint\n \nb\n;\n\n\n  \nvoid\n \nf\n()\n \n{}\n\n\n};\n\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \n// Only a diagnostic message is emitted\n\n\n  \nint\n \nS\n::*\np\n \n=\n \n&\nS\n::\na\n,\n \nS\n::*\nconst\n \nq\n \n=\n \n&\nS\n::\na\n;\n\n\n}\n\n\n\n\n\n\nFurthermore, the transformation is very cautious when it detects various kinds\nof macros or preprocessor directives in the range of the statement. In this\ncase the transformation will not happen to avoid unexpected side-effects due to\nmacros.\n\n\n#define NULL 0\n\n\n#define MY_NICE_TYPE int **\n\n\n#define VAR_NAME(name) name##__LINE__\n\n\n#define A_BUNCH_OF_VARIABLES int m1 = 42, m2 = 43, m3 = 44;\n\n\n\nvoid\n \nmacros\n()\n \n{\n\n\n  \nint\n \n*\np1\n \n=\n \nNULL\n,\n \n*\np2\n \n=\n \nNULL\n;\n\n\n  \n// Will be transformed to\n\n\n  \n// int *p1 = NULL;\n\n\n  \n// int *p2 = NULL;\n\n\n\n  \nMY_NICE_TYPE\n \np3\n,\n \nv1\n,\n \nv2\n;\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n\n  \nint\n \nVAR_NAME\n(\nv3\n),\n\n\n      \nVAR_NAME\n(\nv4\n),\n\n\n      \nVAR_NAME\n(\nv5\n);\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n\n  \nA_BUNCH_OF_VARIABLES\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n\n  \nint\n \nUnconditional\n,\n\n\n#if CONFIGURATION\n\n\n      \nIfConfigured\n \n=\n \n42\n,\n\n\n#else\n\n\n      \nIfConfigured\n \n=\n \n0\n;\n\n\n#endif\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/isolate-declaration.html"
  },
  {
    "name": "readability-magic-numbers",
    "description": "Detects magic numbers, integer or floating point literals that are embedded in\ncode and not introduced via constants or symbols.\n\nMany coding guidelines advise replacing the magic values with symbolic\nconstants to improve readability. Here are a few references:\n\nRule ES.45: Avoid âmagic constantsâ; use symbolic constants in C++ Core Guidelines\n\n\nRule 5.1.1 Use symbolic names instead of literal values in code in High Integrity C++\n\n\nItem 17 in âC++ Coding Standards: 101 Rules, Guidelines and Best\nPracticesâ by Herb Sutter and Andrei Alexandrescu\n\n\nChapter 17 in âClean Code - A handbook of agile software craftsmanship.â\nby Robert C. Martin\n\n\nRule 20701 in âTRAIN REAL TIME DATA PROTOCOL Coding Rulesâ by Armin-Hagen\nWeiss, Bombardier\n\n\nhttp://wiki.c2.com/?MagicNumber\n\nExamples of magic values:\n\ntemplate\n<\ntypename\n \nT\n,\n \nsize_t\n \nN\n>\n\n\nstruct\n \nCustomType\n \n{\n\n\n   \nT\n \narr\n[\nN\n];\n\n\n};\n\n\n\nstruct\n \nOtherType\n \n{\n\n\n   \nCustomType\n<\nint\n,\n \n30\n>\n \ncontainer\n;\n\n\n}\n\n\nCustomType\n<\nint\n,\n \n30\n>\n \nvalues\n;\n\n\n\ndouble\n \ncircleArea\n \n=\n \n3.1415926535\n \n*\n \nradius\n \n*\n \nradius\n;\n\n\n\ndouble\n \ntotalCharge\n \n=\n \n1.08\n \n*\n \nitemPrice\n;\n\n\n\nint\n \ngetAnswer\n()\n \n{\n\n\n   \nreturn\n \n-3\n;\n \n// FILENOTFOUND\n\n\n}\n\n\n\nfor\n \n(\nint\n \nmm\n \n=\n \n1\n;\n \nmm\n \n<=\n \n12\n;\n \n++\nmm\n)\n \n{\n\n\n   \nstd\n::\ncout\n \n<<\n \nmonth\n[\nmm\n]\n \n<<\n \n'\\n'\n;\n\n\n}\n\nExample with magic values refactored:\n\ntemplate\n<\ntypename\n \nT\n,\n \nsize_t\n \nN\n>\n\n\nstruct\n \nCustomType\n \n{\n\n\n   \nT\n \narr\n[\nN\n];\n\n\n};\n\n\n\nconst\n \nsize_t\n \nNUMBER_OF_ELEMENTS\n \n=\n \n30\n;\n\n\nusing\n \ncontainerType\n \n=\n \nCustomType\n<\nint\n,\n \nNUMBER_OF_ELEMENTS\n>\n;\n\n\n\nstruct\n \nOtherType\n \n{\n\n\n   \ncontainerType\n \ncontainer\n;\n\n\n}\n\n\ncontainerType\n \nvalues\n;\n\n\n\ndouble\n \ncircleArea\n \n=\n \nM_PI\n \n*\n \nradius\n \n*\n \nradius\n;\n\n\n\nconst\n \ndouble\n \nTAX_RATE\n \n=\n \n0.08\n;\n  \n// or make it variable and read from a file\n\n\n\ndouble\n \ntotalCharge\n \n=\n \n(\n1.0\n \n+\n \nTAX_RATE\n)\n \n*\n \nitemPrice\n;\n\n\n\nint\n \ngetAnswer\n()\n \n{\n\n\n   \nreturn\n \nE_FILE_NOT_FOUND\n;\n\n\n}\n\n\n\nfor\n \n(\nint\n \nmm\n \n=\n \n1\n;\n \nmm\n \n<=\n \nMONTHS_IN_A_YEAR\n;\n \n++\nmm\n)\n \n{\n\n\n   \nstd\n::\ncout\n \n<<\n \nmonth\n[\nmm\n]\n \n<<\n \n'\\n'\n;\n\n\n}\n\nFor integral literals by default only \n0\n and \n1\n (and \n-1\n) integer values\nare accepted without a warning. This can be overridden with the\n\nIgnoredIntegerValues\n option. Negative values are accepted if their\nabsolute value is present in the \nIgnoredIntegerValues\n list.\n\nAs a special case for integral values, all powers of two can be accepted\nwithout warning by enabling the \nIgnorePowersOf2IntegerValues\n option.\n\nFor floating point literals by default the \n0.0\n floating point value is\naccepted without a warning. The set of ignored floating point literals can\nbe configured using the \nIgnoredFloatingPointValues\n option.\nFor each value in that set, the given string value is converted to a\nfloating-point value representation used by the target architecture. If a\nfloating-point literal value compares equal to one of the converted values,\nthen that literal is not diagnosed by this check. Because floating-point\nequality is used to determine whether to diagnose or not, the user needs to\nbe aware of the details of floating-point representations for any values that\ncannot be precisely represented for their target architecture.\n\nFor each value in the \nIgnoredFloatingPointValues\n set, both the\nsingle-precision form and double-precision form are accepted (for example, if\n3.14 is in the set, neither 3.14f nor 3.14 will produce a warning).\n\nScientific notation is supported for both source code input and option.\nAlternatively, the check for the floating point numbers can be disabled for\nall floating point values by enabling the\n\nIgnoreAllFloatingPointValues\n option.\n\nSince values \n0\n and \n0.0\n are so common as the base counter of loops,\nor initialization values for sums, they are always accepted without warning,\neven if not present in the respective ignored values list.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredIntegerValues\nÂ¶\n\n\nSemicolon-separated list of magic positive integers that will be accepted\nwithout a warning. Default values are \n{1, 2, 3, 4}\n, and \n0\n is accepted\nunconditionally.\n\n\n\n\n\n\n\n\nIgnorePowersOf2IntegerValues\nÂ¶\n\n\nBoolean value indicating whether to accept all powers-of-two integer values\nwithout warning. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoredFloatingPointValues\nÂ¶\n\n\nSemicolon-separated list of magic positive floating point values that will\nbe accepted without a warning. Default values are \n{1.0, 100.0}\n and \n0.0\n\nis accepted unconditionally.\n\n\n\n\n\n\n\n\nIgnoreAllFloatingPointValues\nÂ¶\n\n\nBoolean value indicating whether to accept all floating point values without\nwarning. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreBitFieldsWidths\nÂ¶\n\n\nBoolean value indicating whether to accept magic numbers as bit field widths\nwithout warning. This is useful for example for register definitions which\nare generated from hardware specifications. Default value is \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreTypeAliases\nÂ¶\n\n\nBoolean value indicating whether to accept magic numbers in \ntypedef\n or\n\nusing\n declarations. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreUserDefinedLiterals\nÂ¶\n\n\nBoolean value indicating whether to accept magic numbers in user-defined\nliterals. Default value is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/magic-numbers.html"
  },
  {
    "name": "readability-make-member-function-const",
    "description": "Finds non-static member functions that can be made \nconst\n\nbecause the functions donât use \nthis\n in a non-const way.\n\nThis check tries to annotate methods according to\n\nlogical constness\n\n(not physical constness).\nTherefore, it will suggest to add a \nconst\n qualifier to a non-const\nmethod only if this method does something that is already possible though the\npublic interface on a \nconst\n pointer to the object:\n\nreading a public member variable\n\n\ncalling a public const-qualified member function\n\n\nreturning const-qualified \nthis\n\n\npassing const-qualified \nthis\n as a parameter.\n\nThis check will also suggest to add a \nconst\n qualifier to a non-const\nmethod if this method uses private data and functions in a limited number of\nways where logical constness and physical constness coincide:\n\nreading a member variable of builtin type\n\nSpecifically, this check will not suggest to add a \nconst\n to a non-const\nmethod if the method reads a private member variable of pointer type because\nthat allows to modify the pointee which might not preserve logical constness.\nFor the same reason, it does not allow to call private member functions\nor member functions on private member variables.\n\nIn addition, this check ignores functions that\n\nare declared \nvirtual\n\n\ncontain a \nconst_cast\n\n\nare templated or part of a class template\n\n\nhave an empty body\n\n\ndo not (implicitly) use \nthis\n at all\n(see \nreadability-convert-member-functions-to-static\n).\n\nThe following real-world examples will be preserved by the check:\n\nclass\n \nE1\n \n{\n\n\n  \nPimpl\n \n&\ngetPimpl\n()\n \nconst\n;\n\n\npublic\n:\n\n\n  \nint\n \n&\nget\n()\n \n{\n\n\n    \n// Calling a private member function disables this check.\n\n\n    \nreturn\n \ngetPimpl\n()\n->\ni\n;\n\n\n  \n}\n\n\n  \n...\n\n\n};\n\n\n\nclass\n \nE2\n \n{\n\n\npublic\n:\n\n\n  \nconst\n \nint\n \n*\nget\n()\n \nconst\n;\n\n\n  \n// const_cast disables this check.\n\n\n  \nS\n \n*\nget\n()\n \n{\n\n\n    \nreturn\n \nconst_cast\n<\nint\n*>\n(\nconst_cast\n<\nconst\n \nC\n*>\n(\nthis\n)\n->\nget\n());\n\n\n  \n}\n\n\n  \n...\n\n\n};\n\nAfter applying modifications as suggested by the check, running the check again\nmight find more opportunities to mark member functions \nconst\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/make-member-function-const.html"
  },
  {
    "name": "readability-math-missing-parentheses",
    "description": "Check for missing parentheses in mathematical expressions that involve\noperators of different priorities.\n\nParentheses in mathematical expressions clarify the order\nof operations, especially with different-priority operators. Lengthy or\nmultiline expressions can obscure this order, leading to coding errors.\nIDEs can aid clarity by highlighting parentheses. Explicitly using parentheses\nalso clarifies what the developer had in mind when writing the expression.\nEnsuring their presence reduces ambiguity and errors, promoting clearer and\nmore maintainable code.\n\nBefore:\n\nint\n \nx\n \n=\n \n1\n \n+\n \n2\n \n*\n \n3\n \n-\n \n4\n \n/\n \n5\n;\n\nAfter:\n\nint\n \nx\n \n=\n \n1\n \n+\n \n(\n2\n \n*\n \n3\n)\n \n-\n \n(\n4\n \n/\n \n5\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/math-missing-parentheses.html"
  },
  {
    "name": "readability-misleading-indentation",
    "description": "Correct indentation helps to understand code. Mismatch of the syntactical\nstructure and the indentation of the code may hide serious problems.\nMissing braces can also make it significantly harder to read the code,\ntherefore it is important to use braces.\n\nThe way to avoid dangling else is to always check that an \nelse\n belongs\nto the \nif\n that begins in the same column.\n\nYou can omit braces when your inner part of e.g. an \nif\n statement has only\none statement in it. Although in that case you should begin the next statement\nin the same column with the \nif\n.\n\nExamples:\n\n// Dangling else:\n\n\nif\n \n(\ncond1\n)\n\n\n  \nif\n \n(\ncond2\n)\n\n\n    \nfoo1\n();\n\n\nelse\n\n\n  \nfoo2\n();\n  \n// Wrong indentation: else belongs to if(cond2) statement.\n\n\n\n// Missing braces:\n\n\nif\n \n(\ncond1\n)\n\n\n  \nfoo1\n();\n\n\n  \nfoo2\n();\n  \n// Not guarded by if(cond1).\n\nLimitations\nÂ¶\n\n\nNote that this check only works as expected when the tabs or spaces are used\nconsistently and not mixed.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/misleading-indentation.html"
  },
  {
    "name": "readability-misplaced-array-index",
    "description": "This check warns for unusual array index syntax.\n\nThe following code has unusual array index syntax:\n\nvoid\n \nf\n(\nint\n \n*\nX\n,\n \nint\n \nY\n)\n \n{\n\n\n  \nY\n[\nX\n]\n \n=\n \n0\n;\n\n\n}\n\nbecomes\n\nvoid\n \nf\n(\nint\n \n*\nX\n,\n \nint\n \nY\n)\n \n{\n\n\n  \nX\n[\nY\n]\n \n=\n \n0\n;\n\n\n}\n\nThe check warns about such unusual syntax for readability reasons:\n\n\nThere are programmers that are not familiar with this unusual syntax.\n\n\nIt is possible that variables are mixed up.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/misplaced-array-index.html"
  },
  {
    "name": "readability-named-parameter",
    "description": "Find functions with unnamed arguments.\n\nThe check implements the following rule originating in the Google C++ Style\nGuide:\n\nhttps://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions\n\nAll parameters should have the same name in both the function declaration and\ndefinition. If a parameter is not utilized, its name can be commented out in a\nfunction definition.\n\nint\n \ndoingSomething\n(\nint\n \na\n,\n \nint\n \nb\n,\n \nint\n \nc\n);\n\n\n\nint\n \ndoingSomething\n(\nint\n \na\n,\n \nint\n \nb\n,\n \nint\n \n/*c*/\n)\n \n{\n\n\n    \n// Ok: the third param is not used\n\n\n    \nreturn\n \na\n \n+\n \nb\n;\n\n\n}\n\nCorresponding cpplint.py check name: \nreadability/function\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nInsertPlainNamesInForwardDecls\nÂ¶\n\n\nIf set to \ntrue\n, the check will insert parameter names without comments for\nforward declarations only. Otherwise, the check will insert parameter names\nas comments (e.g., \n/*param*/\n). Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/named-parameter.html"
  },
  {
    "name": "readability-non-const-parameter",
    "description": "The check finds function parameters of a pointer type that could be changed to\npoint to a constant type instead.\n\nWhen \nconst\n is used properly, many mistakes can be avoided. Advantages when\nusing \nconst\n properly:\n\nprevent unintentional modification of data;\n\n\nget additional warnings such as using uninitialized data;\n\n\nmake it easier for developers to see possible side effects.\n\nThis check is not strict about constness, it only warns when the constness will\nmake the function interface safer.\n\n// warning here; the declaration \"const char *p\" would make the function\n\n\n// interface safer.\n\n\nchar\n \nf1\n(\nchar\n \n*\np\n)\n \n{\n\n\n  \nreturn\n \n*\np\n;\n\n\n}\n\n\n\n// no warning; the declaration could be more const \"const int * const p\" but\n\n\n// that does not make the function interface safer.\n\n\nint\n \nf2\n(\nconst\n \nint\n \n*\np\n)\n \n{\n\n\n  \nreturn\n \n*\np\n;\n\n\n}\n\n\n\n// no warning; making x const does not make the function interface safer\n\n\nint\n \nf3\n(\nint\n \nx\n)\n \n{\n\n\n  \nreturn\n \nx\n;\n\n\n}\n\n\n\n// no warning; Technically, *p can be const (\"const struct S *p\"). But making\n\n\n// *p const could be misleading. People might think that it's safe to pass\n\n\n// const data to this function.\n\n\nstruct\n \nS\n \n{\n \nint\n \n*\na\n;\n \nint\n \n*\nb\n;\n \n};\n\n\nint\n \nf3\n(\nstruct\n \nS\n \n*\np\n)\n \n{\n\n\n  \n*\n(\np\n->\na\n)\n \n=\n \n0\n;\n\n\n}\n\n\n\n// no warning; p is referenced by an lvalue.\n\n\nvoid\n \nf4\n(\nint\n \n*\np\n)\n \n{\n\n\n  \nint\n \n&\nx\n \n=\n \n*\np\n;\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/non-const-parameter.html"
  },
  {
    "name": "readability-operators-representation",
    "description": "Enforces consistent token representation for invoked binary, unary and\noverloaded operators in C++ code. The check supports both traditional and\nalternative representations of operators, such as \n&&\n and \nand\n, \n||\n\nand \nor\n, and so on.\n\nIn the realm of C++ programming, developers have the option to choose between\ntwo distinct representations for operators: traditional token representation\nand alternative token representation. Traditional tokens utilize symbols,\nsuch as \n&&\n, \n||\n, and \n!\n, while alternative tokens employ more\ndescriptive words like \nand\n, \nor\n, and \nnot\n.\n\nIn the following mapping table, a comprehensive list of traditional and\nalternative tokens, along with their corresponding representations,\nis presented:\n\nToken Representation Mapping Table\nÂ¶\n\n\n\n\nTraditional\n\n\nAlternative\n\n\n\n\n\n\n\n\n&&\n\n\nand\n\n\n\n\n&=\n\n\nand_eq\n\n\n\n\n&\n\n\nbitand\n\n\n\n\n|\n\n\nbitor\n\n\n\n\n~\n\n\ncompl\n\n\n\n\n!\n\n\nnot\n\n\n\n\n!=\n\n\nnot_eq\n\n\n\n\n||\n\n\nor\n\n\n\n\n|=\n\n\nor_eq\n\n\n\n\n^\n\n\nxor\n\n\n\n\n^=\n\n\nxor_eq\n\nExample\nÂ¶\n\n\n// Traditional Token Representation:\n\n\n\nif\n \n(\n!\na\n||!\nb\n)\n\n\n{\n\n\n    \n// do something\n\n\n}\n\n\n\n// Alternative Token Representation:\n\n\n\nif\n \n(\nnot\n \na\n \nor\n \nnot\n \nb\n)\n\n\n{\n\n\n    \n// do something\n\n\n}\n\nOptions\nÂ¶\n\n\nDue to the distinct benefits and drawbacks of each representation, the default\nconfiguration doesnât enforce either. Explicit configuration is needed.\n\n\nTo configure check to enforce Traditional Token Representation for all\noperators set options to \n&&;&=;&;|;~;!;!=;||;|=;^;^=\n.\n\n\nTo configure check to enforce Alternative Token Representation for all\noperators set options to\n\nand;and_eq;bitand;bitor;compl;not;not_eq;or;or_eq;xor;xor_eq\n.\n\n\nDevelopers do not need to enforce all operators, and can mix the\nrepresentations as desired by specifying a semicolon-separated list of\nboth traditional and alternative tokens in the configuration,\nsuch as \nand;||;not\n.\n\n\n\n\n\n\nBinaryOperators\nÂ¶\n\n\nThis option allows you to specify a semicolon-separated list of binary\noperators for which you want to enforce specific token representation.\nThe default value is empty string.\n\n\n\n\n\n\n\n\nOverloadedOperators\nÂ¶\n\n\nThis option allows you to specify a semicolon-separated list of overloaded\noperators for which you want to enforce specific token representation.\nThe default value is empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/operators-representation.html"
  },
  {
    "name": "readability-qualified-auto",
    "description": "Adds pointer qualifications to \nauto\n-typed variables that are deduced to\npointers.\n\nLLVM Coding Standards\n\nadvises to make it obvious if a \nauto\n typed variable is a pointer. This\ncheck will transform \nauto\n to \nauto\n \n*\n when the type is deduced to be a\npointer.\n\nfor\n \n(\nauto\n \nData\n \n:\n \nMutatablePtrContainer\n)\n \n{\n\n\n  \nchange\n(\n*\nData\n);\n\n\n}\n\n\nfor\n \n(\nauto\n \nData\n \n:\n \nConstantPtrContainer\n)\n \n{\n\n\n  \nobserve\n(\n*\nData\n);\n\n\n}\n\nWould be transformed into:\n\nfor\n \n(\nauto\n \n*\nData\n \n:\n \nMutatablePtrContainer\n)\n \n{\n\n\n  \nchange\n(\n*\nData\n);\n\n\n}\n\n\nfor\n \n(\nconst\n \nauto\n \n*\nData\n \n:\n \nConstantPtrContainer\n)\n \n{\n\n\n  \nobserve\n(\n*\nData\n);\n\n\n}\n\nNote \nconst\n \nvolatile\n qualified types will retain their \nconst\n and\n\nvolatile\n qualifiers. Pointers to pointers will not be fully qualified.\n\nconst\n \nauto\n \nFoo\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz1\n);\n\n\nconst\n \nauto\n \nBar\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBaz2\n);\n\n\nvolatile\n \nauto\n \nFooBar\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz3\n);\n\n\nauto\n \nBarFoo\n \n=\n \ncast\n<\nint\n \n**>\n(\nBaz4\n);\n\nWould be transformed into:\n\nauto\n \n*\nconst\n \nFoo\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz1\n);\n\n\nconst\n \nauto\n \n*\nconst\n \nBar\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBaz2\n);\n\n\nauto\n \n*\nvolatile\n \nFooBar\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz3\n);\n\n\nauto\n \n*\nBarFoo\n \n=\n \ncast\n<\nint\n \n**>\n(\nBaz4\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nAddConstToQualified\nÂ¶\n\n\nWhen set to \ntrue\n the check will add const qualifiers variables defined as\n\nauto\n \n*\n or \nauto\n \n&\n when applicable.\nDefault value is \ntrue\n.\n\n\n\n\nauto\n \nFoo1\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar1\n);\n\n\nauto\n \n*\nFoo2\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar2\n);\n\n\nauto\n \n&\nFoo3\n \n=\n \ncast\n<\nconst\n \nint\n \n&>\n(\nBar3\n);\n\n\n\n\n\n\nIf AddConstToQualified is set to \nfalse\n, it will be transformed into:\n\n\nconst\n \nauto\n \n*\nFoo1\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar1\n);\n\n\nauto\n \n*\nFoo2\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar2\n);\n\n\nauto\n \n&\nFoo3\n \n=\n \ncast\n<\nconst\n \nint\n \n&>\n(\nBar3\n);\n\n\n\n\n\n\nOtherwise it will be transformed into:\n\n\nconst\n \nauto\n \n*\nFoo1\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar1\n);\n\n\nconst\n \nauto\n \n*\nFoo2\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar2\n);\n\n\nconst\n \nauto\n \n&\nFoo3\n \n=\n \ncast\n<\nconst\n \nint\n \n&>\n(\nBar3\n);\n\n\n\n\n\n\nNote in the LLVM alias, the default value is \nfalse\n.\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types to ignore when \nauto\n is\ndeduced to that type or a pointer to that type. Note that this distinguishes\ntype aliases from the original type, so specifying e.g. \nmy_int\n will not\nsuppress reports about \nint\n even if it is defined as a \ntypedef\n alias\nfor \nint\n. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n\nmatches every type with suffix \nRef\n, \nref\n, \nReference\n and\n\nreference\n. If a name in the list contains the sequence \n::\n it is matched\nagainst the qualified type name (i.e. \nnamespace::Type\n), otherwise it is\nmatched against only the type name (i.e. \nType\n). E.g. to suppress reports\nfor \nstd::array\n iterators use \nstd::array<.*>::(const_)?iterator\n string.\nThe default is an empty string.\n\n\n\n\n\n\n\n\nIgnoreAliasing\nÂ¶\n\n\nIf set to \ntrue\n the check will use the underlying type to determine the type\nthat \nauto\n is deduced to. If set to \nfalse\n the check will not look beyond\nthe first type alias.\nDefault value is \ntrue\n.\n\n\nusing\n \nIntPtr\n \n=\n \nint\n*\n;\n\n\nIntPtr\n \nfoo\n();\n\n\n\nauto\n \nbar\n \n=\n \nfoo\n();\n\n\n\n\n\n\nIf \nIgnoreAliasing\n is set to \ntrue\n, it will be transformed into:\n\n\nauto\n \n*\nbar\n \n=\n \nfoo\n();\n\n\n\n\n\n\nOtherwise no changes will occur.\n\nLimitations\nÂ¶\n\n\nWhen \nIgnoreAliasing\n is set to \nfalse\n, there are cases where\nClang has not preserved the type alias and the underlying type will be used so\nfalse positives may occur.\n\n\nFor example:\n\n\nusing\n \nIntPtr\n \n=\n \nint\n \n*\n;\n\n\n\nvoid\n \nloopPtr\n(\nconst\n \nstd\n::\nvector\n<\nIntPtr\n>\n \n&\nVectorIntPtr\n)\n \n{\n\n\n\n  \n// May fail for IgnoreAliasing==false as AST does not have the 'IntPtr'\n\n\n  \nfor\n \n(\nauto\n \nData\n \n:\n \nVectorIntPtr\n)\n \n{\n\n\n  \n}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/qualified-auto.html"
  },
  {
    "name": "readability-redundant-access-specifiers",
    "description": "Finds classes, structs, and unions containing redundant member (field and\nmethod) access specifiers.\n\nExample\nÂ¶\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nint\n \nx\n;\n\n\n  \nint\n \ny\n;\n\n\npublic\n:\n\n\n  \nint\n \nz\n;\n\n\nprotected\n:\n\n\n  \nint\n \na\n;\n\n\npublic\n:\n\n\n  \nint\n \nc\n;\n\n\n}\n\n\n\n\n\n\nIn the example above, the second \npublic\n declaration can be removed without\nany changes of behavior.\n\nOptions\nÂ¶\n\n\n\n\n\n\nCheckFirstDeclaration\nÂ¶\n\n\nIf set to \ntrue\n, the check will also diagnose if the first access\nspecifier declaration is redundant (e.g. \nprivate\n inside \nclass\n,\nor \npublic\n inside \nstruct\n or \nunion\n).\nDefault is \nfalse\n.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nstruct\n \nBar\n \n{\n\n\npublic\n:\n\n\n  \nint\n \nx\n;\n\n\n}\n\n\n\n\n\n\nIf \nCheckFirstDeclaration\n option is enabled, a warning about redundant\naccess specifier will be emitted, because \npublic\n is the default member access\nfor structs.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-access-specifiers.html"
  },
  {
    "name": "readability-redundant-casting",
    "description": "Detects explicit type casting operations that involve the same source and\ndestination types, and subsequently recommend their removal. Covers a range of\nexplicit casting operations, including \nstatic_cast\n, \nconst_cast\n, C-style\ncasts, and \nreinterpret_cast\n. Its primary objective is to enhance code\nreadability and maintainability by eliminating unnecessary type casting.\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\nint\n \nresult\n \n=\n \nstatic_cast\n<\nint\n>\n(\nvalue\n);\n\nIn this example, the \nstatic_cast<int>(value)\n is redundant, as it performs\na cast from an \nint\n to another \nint\n.\n\nCasting operations involving constructor conversions, user-defined conversions,\nfunctional casts, type-dependent casts, casts between distinct type aliases\nthat refer to the same underlying type, as well as bitfield-related casts and\ncasts directly from lvalue to rvalue, are all disregarded by the check.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreTypeAliases\nÂ¶\n\n\nWhen set to \nfalse\n, the check will consider type aliases, and when set to\n\ntrue\n, it will resolve all type aliases and operate on the underlying\ntypes. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-casting.html"
  },
  {
    "name": "readability-redundant-control-flow",
    "description": "This check looks for procedures (functions returning no value) with \nreturn\n\nstatements at the end of the function. Such \nreturn\n statements are\nredundant.\n\nLoop statements (\nfor\n, \nwhile\n, \ndo\n \nwhile\n) are checked for redundant\n\ncontinue\n statements at the end of the loop body.\n\nExamples:\n\nThe following function \nf\n contains a redundant \nreturn\n statement:\n\nextern\n \nvoid\n \ng\n();\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \ng\n();\n\n\n  \nreturn\n;\n\n\n}\n\nbecomes\n\nextern\n \nvoid\n \ng\n();\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \ng\n();\n\n\n}\n\nThe following function \nk\n contains a redundant \ncontinue\n statement:\n\nvoid\n \nk\n()\n \n{\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \n++\ni\n)\n \n{\n\n\n    \ncontinue\n;\n\n\n  \n}\n\n\n}\n\nbecomes\n\nvoid\n \nk\n()\n \n{\n\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \n++\ni\n)\n \n{\n\n\n  \n}\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-control-flow.html"
  },
  {
    "name": "readability-redundant-declaration",
    "description": "Finds redundant variable and function declarations.\n\nextern\n \nint\n \nX\n;\n\n\nextern\n \nint\n \nX\n;\n\nbecomes\n\nextern\n \nint\n \nX\n;\n\nSuch redundant declarations can be removed without changing program behavior.\nThey can for instance be unintentional left overs from previous refactorings\nwhen code has been moved around. Having redundant declarations could in worst\ncase mean that there are typos in the code that cause bugs.\n\nNormally the code can be automatically fixed, \nclang-tidy\n can remove\nthe second declaration. However there are 2 cases when you need to fix the code\nmanually:\n\nWhen the declarations are in different header files;\n\n\nWhen multiple variables are declared together.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will not give warnings inside macros. Default\nis \ntrue\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-declaration.html"
  },
  {
    "name": "readability-redundant-function-ptr-dereference",
    "description": "Finds redundant dereferences of a function pointer.\n\nBefore:\n\nint\n \nf\n(\nint\n,\nint\n);\n\n\nint\n \n(\n*\np\n)(\nint\n,\n \nint\n)\n \n=\n \n&\nf\n;\n\n\n\nint\n \ni\n \n=\n \n(\n**\np\n)(\n10\n,\n \n50\n);\n\nAfter:\n\nint\n \nf\n(\nint\n,\nint\n);\n\n\nint\n \n(\n*\np\n)(\nint\n,\n \nint\n)\n \n=\n \n&\nf\n;\n\n\n\nint\n \ni\n \n=\n \n(\n*\np\n)(\n10\n,\n \n50\n);",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-function-ptr-dereference.html"
  },
  {
    "name": "readability-redundant-inline-specifier",
    "description": "Detects redundant \ninline\n specifiers on function and variable declarations.\n\nExamples:\n\nconstexpr\n \ninline\n \nvoid\n \nf\n()\n \n{}\n\nIn the example above the keyword \ninline\n is redundant since constexpr\nfunctions are implicitly inlined\n\nclass\n \nMyClass\n \n{\n\n\n    \ninline\n \nvoid\n \nmyMethod\n()\n \n{}\n\n\n};\n\nIn the example above the keyword \ninline\n is redundant since member functions\ndefined entirely inside a class/struct/union definition are implicitly inlined.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nIf set to \ntrue\n, the check will also flag functions and variables that\nalready have internal linkage as redundant. Default is \nfalse\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-inline-specifier.html"
  },
  {
    "name": "readability-redundant-member-init",
    "description": "Finds member initializations that are unnecessary because the same default\nconstructor would be called if they were not present.\n\nExample\nÂ¶\n\n\n// Explicitly initializing the member s and v is unnecessary.\n\n\nclass\n \nFoo\n \n{\n\n\npublic\n:\n\n\n  \nFoo\n()\n \n:\n \ns\n()\n \n{}\n\n\n\nprivate\n:\n\n\n  \nstd\n::\nstring\n \ns\n;\n\n\n  \nstd\n::\nvector\n<\nint\n>\n \nv\n \n{};\n\n\n};\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreBaseInCopyConstructors\nÂ¶\n\n\nDefault is \nfalse\n.\n\n\nWhen \ntrue\n, the check will ignore unnecessary base class initializations\nwithin copy constructors, since some compilers issue warnings/errors when\nbase classes are not explicitly initialized in copy constructors. For example,\n\ngcc\n with \n-Wextra\n or \n-Werror=extra\n issues warning or error\n\nbase\n \nclass\n \n'Bar'\n \nshould\n \nbe\n \nexplicitly\n \ninitialized\n \nin\n \nthe\n \ncopy\n \nconstructor\n\nif \nBar()\n were removed in the following example:\n\n\n\n\n// Explicitly initializing member s and base class Bar is unnecessary.\n\n\nstruct\n \nFoo\n \n:\n \npublic\n \nBar\n \n{\n\n\n  \n// Remove s() below. If IgnoreBaseInCopyConstructors!=0, keep Bar().\n\n\n  \nFoo\n(\nconst\n \nFoo\n&\n \nfoo\n)\n \n:\n \nBar\n(),\n \ns\n()\n \n{}\n\n\n  \nstd\n::\nstring\n \ns\n;\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-member-init.html"
  },
  {
    "name": "readability-redundant-parentheses",
    "description": "Detect redundant parentheses.\n\nWhen modifying code, one often forgets to remove the corresponding parentheses.\nThis results in overly lengthy code. When the expression is complex, finding\nthe matching parentheses becomes particularly difficult.\n\nExample\nÂ¶\n\n\n(\n1\n);\n\n\n((\na\n \n+\n \n2\n))\n \n*\n \n3\n;\n\n\n(\na\n);\n\n\n(\n\"aaa\"\n);\n\n\n\n\n\n\nCurrently this check does not take into account the precedence of operations.\nEven if the expression within the parentheses has a higher priority than that\noutside the parentheses. In other words, removing the parentheses will not\naffect the semantics.\n\n\nint\n \na\n \n=\n \n(\n1\n \n*\n \n2\n)\n \n+\n \n3\n;\n \n// no warning\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowedDecls\nÂ¶\n\n\nSemicolon-separated list of regular expressions matching names of declarations\nto ignore when the parentheses are around. Declarations can include variables\nor functions. The default is an \nstd::max;std::min\n.\n\n\nSome STL library functions may have the same name as widely used function-like\nmacro. For example, \nstd::max\n and \nmax\n macro. A workaround to distinguish\nthem is adding parentheses around functions to prevent function-like macro.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-parentheses.html"
  },
  {
    "name": "readability-redundant-preprocessor",
    "description": "Finds potentially redundant preprocessor directives. At the moment the\nfollowing cases are detected:\n\n#ifdef\n .. \n#endif\n pairs which are nested inside an outer pair with the\nsame condition. For example:\n\n#ifdef FOO\n\n\n#ifdef FOO \n// inner ifdef is considered redundant\n\n\nvoid\n \nf\n();\n\n\n#endif\n\n\n#endif\n\nSame for \n#ifndef\n .. \n#endif\n pairs. For example:\n\n#ifndef FOO\n\n\n#ifndef FOO \n// inner ifndef is considered redundant\n\n\nvoid\n \nf\n();\n\n\n#endif\n\n\n#endif\n\n#ifndef\n inside an \n#ifdef\n with the same condition:\n\n#ifdef FOO\n\n\n#ifndef FOO \n// inner ifndef is considered redundant\n\n\nvoid\n \nf\n();\n\n\n#endif\n\n\n#endif\n\n#ifdef\n inside an \n#ifndef\n with the same condition:\n\n#ifndef FOO\n\n\n#ifdef FOO \n// inner ifdef is considered redundant\n\n\nvoid\n \nf\n();\n\n\n#endif\n\n\n#endif\n\n#if\n .. \n#endif\n pairs which are nested inside an outer pair with the same\ncondition. For example:\n\n#define FOO 4\n\n\n#if FOO == 4\n\n\n#if FOO == 4 \n// inner if is considered redundant\n\n\nvoid\n \nf\n();\n\n\n#endif\n\n\n#endif",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-preprocessor.html"
  },
  {
    "name": "readability-redundant-smartptr-get",
    "description": "Find and remove redundant calls to smart pointerâs \n.get()\n method.\n\nExamples:\n\nptr\n.\nget\n()\n->\nFoo\n()\n  \n==>\n  \nptr\n->\nFoo\n()\n\n\n*\nptr\n.\nget\n()\n  \n==>\n  \n*\nptr\n\n\n*\nptr\n->\nget\n()\n  \n==>\n  \n**\nptr\n\n\nif\n \n(\nptr\n.\nget\n()\n \n==\n \nnullptr\n)\n \n...\n \n=>\n \nif\n \n(\nptr\n \n==\n \nnullptr\n)\n \n...\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \ntrue\n), the check will not warn\nabout calls inside macros.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-smartptr-get.html"
  },
  {
    "name": "readability-redundant-string-cstr",
    "description": "Finds unnecessary calls to \nstd::string::c_str()\n and\n\nstd::string::data()\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringParameterFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of function/method/operator, with the requirement\nthat any parameter currently accepting a \nconst\n \nchar*\n input should also\nbe able to accept \nstd::string\n inputs, or proper overload candidates that\ncan do so should exist. This can be used to configure functions such as\n\nfmt::format\n, \nspdlog::logger::info\n, or wrappers around these and\nsimilar functions. The default value is the empty string.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-string-cstr.html"
  },
  {
    "name": "readability-redundant-string-init",
    "description": "Finds unnecessary string initializations.\n\nExamples\nÂ¶\n\n\n// Initializing string with empty string literal is unnecessary.\n\n\nstd\n::\nstring\n \na\n \n=\n \n\"\"\n;\n\n\nstd\n::\nstring\n \nb\n(\n\"\"\n);\n\n\n\n// becomes\n\n\n\nstd\n::\nstring\n \na\n;\n\n\nstd\n::\nstring\n \nb\n;\n\n\n\n// Initializing a string_view with an empty string literal produces an\n\n\n// instance that compares equal to string_view().\n\n\nstd\n::\nstring_view\n \na\n \n=\n \n\"\"\n;\n\n\nstd\n::\nstring_view\n \nb\n(\n\"\"\n);\n\n\n\n// becomes\n\n\nstd\n::\nstring_view\n \na\n;\n\n\nstd\n::\nstring_view\n \nb\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringNames\nÂ¶\n\n\nDefault is \n::std::basic_string;::std::basic_string_view\n.\n\n\nSemicolon-delimited list of class names to apply this check to.\nBy default \n::std::basic_string\n applies to \nstd::string\n and\n\nstd::wstring\n. Set to e.g. \n::std::basic_string;llvm::StringRef;QString\n\nto perform this check on custom classes.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-string-init.html"
  },
  {
    "name": "readability-redundant-typename",
    "description": "Finds redundant uses of the \ntypename\n keyword.\n\ntypename\n is redundant in two cases. First, before non-dependent names:\n\n/*typename*/\n \nstd\n::\nvector\n<\nint\n>::\nsize_type\n \nsize\n;\n\nAnd second, since C++20, before dependent names that appear in a context\nwhere only a type is allowed (the following example shows just a few of them):\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nusing\n \ntrait\n \n=\n \n/*typename*/\n \nT\n::\ntype\n;\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\n/*typename*/\n \nT\n::\nunderlying_type\n \nas_underlying\n(\nT\n \nn\n)\n \n{\n\n\n  \nreturn\n \nstatic_cast\n<\n/*typename*/\n \nT\n::\nunderlying_type\n>\n(\nn\n);\n\n\n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nS\n \n{\n\n\n  \n/*typename*/\n \nT\n::\ntype\n \nvariable\n;\n\n\n  \n/*typename*/\n \nT\n::\ntype\n \nfunction\n(\n/*typename*/\n \nT\n::\ntype\n);\n\n\n};",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-typename.html"
  },
  {
    "name": "readability-reference-to-constructed-temporary",
    "description": "Detects C++ code where a reference variable is used to extend the lifetime of\na temporary object that has just been constructed.\n\nThis construction is often the result of multiple code refactorings or a lack\nof developer knowledge, leading to confusion or subtle bugs. In most cases,\nwhat the developer really wanted to do is create a new variable rather than\nextending the lifetime of a temporary object.\n\nExamples of problematic code include:\n\nconst\n \nstd\n::\nstring\n&\n \nstr\n(\n\"hello\"\n);\n\n\n\nstruct\n \nPoint\n \n{\n \nint\n \nx\n;\n \nint\n \ny\n;\n \n};\n\n\nconst\n \nPoint\n&\n \np\n \n=\n \n{\n \n1\n,\n \n2\n \n};\n\nIn the first example, a \nconst\n \nstd::string&\n reference variable \nstr\n is\nassigned a temporary object created by the \nstd::string(\"hello\")\n\nconstructor. In the second example, a \nconst\n \nPoint&\n reference variable \np\n\nis assigned an object that is constructed from an initializer list\n\n{\n \n1,\n \n2\n \n}\n. Both of these examples extend the lifetime of the temporary\nobject to the lifetime of the reference variable, which can make it difficult\nto reason about and may lead to subtle bugs or misunderstanding.\n\nTo avoid these issues, it is recommended to change the reference variable to a\n(\nconst\n) value variable.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/reference-to-constructed-temporary.html"
  },
  {
    "name": "readability-simplify-boolean-expr",
    "description": "Looks for boolean expressions involving boolean constants and simplifies\nthem to use the appropriate boolean expression directly.  Simplifies\nboolean expressions by application of DeMorganâs Theorem.\n\nExamples:\n\nInitial expression\n\n\nResult\n\n\n\n\nif\n \n(b\n \n==\n \ntrue)\n\n\nif\n \n(b)\n\n\n\n\nif\n \n(b\n \n==\n \nfalse)\n\n\nif\n \n(!b)\n\n\n\n\nif\n \n(b\n \n&&\n \ntrue)\n\n\nif\n \n(b)\n\n\n\n\nif\n \n(b\n \n&&\n \nfalse)\n\n\nif\n \n(false)\n\n\n\n\nif\n \n(b\n \n||\n \ntrue)\n\n\nif\n \n(true)\n\n\n\n\nif\n \n(b\n \n||\n \nfalse)\n\n\nif\n \n(b)\n\n\n\n\ne\n \n?\n \ntrue\n \n:\n \nfalse\n\n\ne\n\n\n\n\ne\n \n?\n \nfalse\n \n:\n \ntrue\n\n\n!e\n\n\n\n\nif\n \n(true)\n \nt();\n \nelse\n \nf();\n\n\nt();\n\n\n\n\nif\n \n(false)\n \nt();\n \nelse\n \nf();\n\n\nf();\n\n\n\n\nif\n \n(e)\n \nreturn\n \ntrue;\n \nelse\n \nreturn\n \nfalse;\n\n\nreturn\n \ne;\n\n\n\n\nif\n \n(e)\n \nreturn\n \nfalse;\n \nelse\n \nreturn\n \ntrue;\n\n\nreturn\n \n!e;\n\n\n\n\nif\n \n(e)\n \nb\n \n=\n \ntrue;\n \nelse\n \nb\n \n=\n \nfalse;\n\n\nb\n \n=\n \ne;\n\n\n\n\nif\n \n(e)\n \nb\n \n=\n \nfalse;\n \nelse\n \nb\n \n=\n \ntrue;\n\n\nb\n \n=\n \n!e;\n\n\n\n\nif\n \n(e)\n \nreturn\n \ntrue;\n \nreturn\n \nfalse;\n\n\nreturn\n \ne;\n\n\n\n\nif\n \n(e)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n\n\nreturn\n \n!e;\n\n\n\n\n!(!a\n \n||\n \nb)\n\n\na\n \n&&\n \n!b\n\n\n\n\n!(a\n \n||\n \n!b)\n\n\n!a\n \n&&\n \nb\n\n\n\n\n!(!a\n \n||\n \n!b)\n\n\na\n \n&&\n \nb\n\n\n\n\n!(!a\n \n&&\n \nb)\n\n\na\n \n||\n \n!b\n\n\n\n\n!(a\n \n&&\n \n!b)\n\n\n!a\n \n||\n \nb\n\n\n\n\n!(!a\n \n&&\n \n!b)\n\n\na\n \n||\n \nb\n\nThe resulting expression \ne\n is modified as follows:\n\n\nUnnecessary parentheses around the expression are removed.\n\n\nNegated applications of \n!\n are eliminated.\n\n\nNegated applications of comparison operators are changed to use the\nopposite condition.\n\n\nImplicit conversions of pointers, including pointers to members, to\n\nbool\n are replaced with explicit comparisons to \nnullptr\n in C++11\nor \nNULL\n in C++98/03.\n\n\nImplicit casts to \nbool\n are replaced with explicit casts to \nbool\n.\n\n\nObject expressions with \nexplicit\n \noperator\n \nbool\n conversion operators\nare replaced with explicit casts to \nbool\n.\n\n\nImplicit conversions of integral types to \nbool\n are replaced with\nexplicit comparisons to \n0\n.\n\n\n\n\n\n\nExamples:\n\n\nThe ternary assignment \nbool\n \nb\n \n=\n \n(i\n \n<\n \n0)\n \n?\n \ntrue\n \n:\n \nfalse;\n has redundant\nparentheses and becomes \nbool\n \nb\n \n=\n \ni\n \n<\n \n0;\n.\n\n\nThe conditional return \nif\n \n(!b)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n has an\nimplied double negation and becomes \nreturn\n \nb;\n.\n\n\nThe conditional return \nif\n \n(i\n \n<\n \n0)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n becomes\n\nreturn\n \ni\n \n>=\n \n0;\n.\n\n\nThe conditional return \nif\n \n(i\n \n!=\n \n0)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n becomes\n\nreturn\n \ni\n \n==\n \n0;\n.\n\n\n\n\nThe conditional return \nif\n \n(p)\n \nreturn\n \ntrue;\n \nreturn\n \nfalse;\n has an\nimplicit conversion of a pointer to \nbool\n and becomes\n\nreturn\n \np\n \n!=\n \nnullptr;\n.\n\n\nThe ternary assignment \nbool\n \nb\n \n=\n \n(i\n \n&\n \n1)\n \n?\n \ntrue\n \n:\n \nfalse;\n has an\nimplicit conversion of \ni\n \n&\n \n1\n to \nbool\n and becomes\n\nbool\n \nb\n \n=\n \n(i\n \n&\n \n1)\n \n!=\n \n0;\n.\n\n\n\n\nThe conditional return \nif\n \n(i\n \n&\n \n1)\n \nreturn\n \ntrue;\n \nelse\n \nreturn\n \nfalse;\n has\nan implicit conversion of an integer quantity \ni\n \n&\n \n1\n to \nbool\n and\nbecomes \nreturn\n \n(i\n \n&\n \n1)\n \n!=\n \n0;\n\n\nGiven \nstruct\n \nX\n \n{\n \nexplicit\n \noperator\n \nbool();\n \n};\n, and an instance \nx\n\nof \nstruct\n \nX\n, the conditional return\n\nif\n \n(x)\n \nreturn\n \ntrue;\n \nreturn\n \nfalse;\n\nbecomes \nreturn\n \nstatic_cast<bool>(x);\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf \ntrue\n, ignore boolean expressions originating from expanded macros.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nChainedConditionalReturn\nÂ¶\n\n\nIf \ntrue\n, conditional boolean return statements at the end of an\n\nif/else\n \nif\n chain will be transformed. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nChainedConditionalAssignment\nÂ¶\n\n\nIf \ntrue\n, conditional boolean assignments at the end of an \nif/else\n\n\nif\n chain will be transformed. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nSimplifyDeMorgan\nÂ¶\n\n\nIf \ntrue\n, DeMorganâs Theorem will be applied to simplify negated\nconjunctions and disjunctions.  Default is \ntrue\n.\n\n\n\n\n\n\n\n\nSimplifyDeMorganRelaxed\nÂ¶\n\n\nIf \ntrue\n, \nSimplifyDeMorgan\n will also transform negated\nconjunctions and disjunctions where there is no negation on either operand.\nThis option has no effect if \nSimplifyDeMorgan\n is \nfalse\n.\nDefault is \nfalse\n.\n\n\nWhen Enabled:\n\n\nbool X = !(A && B)\nbool Y = !(A || B)\n\n\n\n\n\nWould be transformed to:\n\n\nbool X = !A || !B\nbool Y = !A && !B",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/simplify-boolean-expr.html"
  },
  {
    "name": "readability-simplify-subscript-expr",
    "description": "This check simplifies subscript expressions. Currently this covers calling\n\n.data()\n and immediately doing an array subscript operation to obtain a\nsingle element, in which case simply calling \noperator[]\n suffice.\n\nExamples:\n\nstd\n::\nstring\n \ns\n \n=\n \n...;\n\n\nchar\n \nc\n \n=\n \ns\n.\ndata\n()[\ni\n];\n  \n// char c = s[i];\n\nOptions\nÂ¶\n\n\n\n\n\n\nTypes\nÂ¶\n\n\nThe list of type(s) that triggers this check. Default is\n\n::std::basic_string;::std::basic_string_view;::std::vector;::std::array;::std::span",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/simplify-subscript-expr.html"
  },
  {
    "name": "readability-static-accessed-through-instance",
    "description": "Checks for member expressions that access static members through instances, and\nreplaces them with uses of the appropriate qualified-id.\n\nExample:\n\nThe following code:\n\nstruct\n \nC\n \n{\n\n\n  \nstatic\n \nvoid\n \nfoo\n();\n\n\n  \nstatic\n \nint\n \nx\n;\n\n\n  \nenum\n \n{\n \nE1\n \n};\n\n\n  \nenum\n \nE\n \n{\n \nE2\n \n};\n\n\n};\n\n\n\nC\n \n*\nc1\n \n=\n \nnew\n \nC\n();\n\n\nc1\n->\nfoo\n();\n\n\nc1\n->\nx\n;\n\n\nc1\n->\nE1\n;\n\n\nc1\n->\nE2\n;\n\nis changed to:\n\nC\n \n*\nc1\n \n=\n \nnew\n \nC\n();\n\n\nC\n::\nfoo\n();\n\n\nC\n::\nx\n;\n\n\nC\n::\nE1\n;\n\n\nC\n::\nE2\n;\n\nThe \nâfix\n commandline option provides default support for safe fixes, whereas\n\nâfix-notes\n enables fixes that may replace expressions with side effects,\npotentially altering the programâs behavior.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/static-accessed-through-instance.html"
  },
  {
    "name": "readability-static-definition-in-anonymous-namespace",
    "description": "Finds static function and variable definitions in anonymous namespace.\n\nIn this case, \nstatic\n is redundant, because anonymous namespace limits the\nvisibility of definitions to a single translation unit.\n\nnamespace\n \n{\n\n\n  \nstatic\n \nint\n \na\n \n=\n \n1\n;\n \n// Warning.\n\n\n  \nstatic\n \nconst\n \nint\n \nb\n \n=\n \n1\n;\n \n// Warning.\n\n\n  \nnamespace\n \ninner\n \n{\n\n\n    \nstatic\n \nint\n \nc\n \n=\n \n1\n;\n \n// Warning.\n\n\n  \n}\n\n\n}\n\nThe check will apply a fix by removing the redundant \nstatic\n qualifier.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/static-definition-in-anonymous-namespace.html"
  },
  {
    "name": "readability-string-compare",
    "description": "Finds string comparisons using the compare method.\n\nA common mistake is to use the stringâs \ncompare\n method instead of using the\nequality or inequality operators. The compare method is intended for sorting\nfunctions and thus returns a negative number, a positive number or\nzero depending on the lexicographical relationship between the strings\ncompared. If an equality or inequality check can suffice, that is recommended.\nThis is recommended to avoid the risk of incorrect interpretation of the return\nvalue and to simplify the code. The string equality and inequality operators\ncan also be faster than the \ncompare\n method due to early termination.\n\nExample\nÂ¶\n\n\n// The same rules apply to std::string_view.\n\n\nstd\n::\nstring\n \nstr1\n{\n\"a\"\n};\n\n\nstd\n::\nstring\n \nstr2\n{\n\"b\"\n};\n\n\n\n// use str1 != str2 instead.\n\n\nif\n \n(\nstr1\n.\ncompare\n(\nstr2\n))\n \n{\n\n\n}\n\n\n\n// use str1 == str2 instead.\n\n\nif\n \n(\n!\nstr1\n.\ncompare\n(\nstr2\n))\n \n{\n\n\n}\n\n\n\n// use str1 == str2 instead.\n\n\nif\n \n(\nstr1\n.\ncompare\n(\nstr2\n)\n \n==\n \n0\n)\n \n{\n\n\n}\n\n\n\n// use str1 != str2 instead.\n\n\nif\n \n(\nstr1\n.\ncompare\n(\nstr2\n)\n \n!=\n \n0\n)\n \n{\n\n\n}\n\n\n\n// use str1 == str2 instead.\n\n\nif\n \n(\n0\n \n==\n \nstr1\n.\ncompare\n(\nstr2\n))\n \n{\n\n\n}\n\n\n\n// use str1 != str2 instead.\n\n\nif\n \n(\n0\n \n!=\n \nstr1\n.\ncompare\n(\nstr2\n))\n \n{\n\n\n}\n\n\n\n// Use str1 == \"foo\" instead.\n\n\nif\n \n(\nstr1\n.\ncompare\n(\n\"foo\"\n)\n \n==\n \n0\n)\n \n{\n\n\n}\n\n\n\n\n\n\nThe above code examples show the list of if-statements that this check will\ngive a warning for. All of them use \ncompare\n to check equality or\ninequality of two strings instead of using the correct operators.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStringLikeClasses\nÂ¶\n\n\nA string containing semicolon-separated names of string-like classes.\nBy default contains only \n::std::basic_string\n\nand \n::std::basic_string_view\n. If a class from this list has\na \ncompare\n method similar to that of \nstd::string\n, it will be checked\nin the same way.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nstruct\n \nCustomString\n \n{\n\n\npublic\n:\n\n\n  \nint\n \ncompare\n \n(\nconst\n \nCustomString\n&\n \nother\n)\n \nconst\n;\n\n\n}\n\n\n\nCustomString\n \nstr1\n;\n\n\nCustomString\n \nstr2\n;\n\n\n\n// use str1 != str2 instead.\n\n\nif\n \n(\nstr1\n.\ncompare\n(\nstr2\n))\n \n{\n\n\n}\n\n\n\n\n\n\nIf \nStringLikeClasses\n contains \nCustomString\n, the check will suggest\nreplacing \ncompare\n with equality operator.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/string-compare.html"
  },
  {
    "name": "readability-suspicious-call-argument",
    "description": "Finds function calls where the arguments passed are provided out of order,\nbased on the difference between the argument name and the parameter names\nof the function.\n\nGiven a function call \nf(foo,\n \nbar);\n and a function signature\n\nvoid\n \nf(T\n \ntvar,\n \nU\n \nuvar)\n, the arguments \nfoo\n and \nbar\n are swapped if\n\nfoo\n (the argument name) is more similar to \nuvar\n (the other parameter)\nthan \ntvar\n (the parameter it is currently passed to) \nand\n \nbar\n is\nmore similar to \ntvar\n than \nuvar\n.\n\nWarnings might indicate either that the arguments are swapped, or that the\nnamesâ cross-similarity might hinder code comprehension.\n\nHeuristics\nÂ¶\n\n\nThe following heuristics are implemented in the check.\nIf \nany\n of the enabled heuristics deem the arguments to be provided out of\norder, a warning will be issued.\n\n\nThe heuristics themselves are implemented by considering pairs of strings, and\nare symmetric, so in the following there is no distinction on which string is\nthe argument name and which string is the parameter name.\n\n\n\n\nEquality\nÂ¶\n\n\nThe most trivial heuristic, which compares the two strings for case-insensitive\nequality.\n\n\n\n\n\n\nAbbreviation\nÂ¶\n\n\nCommon abbreviations can be specified which will deem the strings similar if\nthe abbreviated and the abbreviation stand together.\nFor example, if \nsrc\n is registered as an abbreviation for \nsource\n, then\nthe following code example will be warned about.\n\n\nvoid\n \nfoo\n(\nint\n \nsource\n,\n \nint\n \nx\n);\n\n\n\nfoo\n(\nb\n,\n \nsrc\n);\n\n\n\n\n\n\nThe abbreviations to recognise can be configured with the\n\nAbbreviations\n check option.\nThis heuristic is case-insensitive.\n\n\n\n\n\n\nPrefix\nÂ¶\n\n\nThe \nprefix\n heuristic reports if one of the strings is a sufficiently long\nprefix of the other string, e.g. \ntarget\n to \ntargetPtr\n.\nThe similarity percentage is the length ratio of the prefix to the longer\nstring, in the previous example, it would be \n6 / 9 = 66.66â¦\n%.\n\n\nThis heuristic can be configured with \nbounds\n.\nThe default bounds are: below \n25\n% dissimilar and above \n30\n% similar.\nThis heuristic is case-insensitive.\n\n\n\n\n\n\nSuffix\nÂ¶\n\n\nAnalogous to the \nPrefix\n heuristic.\nIn the case of \noldValue\n and \nvalue\n compared, the similarity percentage\nis \n8 / 5 = 62.5\n%.\n\n\nThis heuristic can be configured with \nbounds\n.\nThe default bounds are: below \n25\n% dissimilar and above \n30\n% similar.\nThis heuristic is case-insensitive.\n\n\n\n\n\n\nSubstring\nÂ¶\n\n\nThe substring heuristic combines the prefix and the suffix heuristic, and tries\nto find the \nlongest common substring\n in the two strings provided.\nThe similarity percentage is the ratio of the found longest common substring\nagainst the \nlonger\n of the two input strings.\nFor example, given \nval\n and \nrvalue\n, the similarity is \n3 / 6 = 50\n%.\nIf no characters are common in the two string, \n0\n%.\n\n\nThis heuristic can be configured with \nbounds\n.\nThe default bounds are: below \n40\n% dissimilar and above \n50\n% similar.\nThis heuristic is case-insensitive.\n\n\n\n\n\n\nLevenshtein distance (as \nLevenshtein\n)\nÂ¶\n\n\nThe \nLevenshtein distance\n\ndescribes how many single-character changes (additions, changes, or removals)\nmust be applied to transform one string into another.\n\n\nThe Levenshtein distance is translated into a similarity percentage by dividing\nit with the length of the \nlonger\n string, and taking its complement with\nregards to \n100\n%.\nFor example, given \nsomething\n and \nanything\n, the distance is \n4\n edits,\nand the similarity percentage is \n100\n% \n- 4 / 9 = 55.55â¦\n%.\n\n\nThis heuristic can be configured with \nbounds\n.\nThe default bounds are: below \n50\n% dissimilar and above \n66\n% similar.\nThis heuristic is case-sensitive.\n\n\n\n\n\n\nJaroâWinkler distance (as \nJaroWinkler\n)\nÂ¶\n\n\nThe \nJaroâWinkler distance\n\nis an edit distance like the Levenshtein distance.\nIt is calculated from the amount of common characters that are sufficiently\nclose to each other in position, and to-be-changed characters.\nThe original definition of Jaro has been extended by Winkler to weigh prefix\nsimilarities more.\nThe similarity percentage is expressed as an average of the common and\nnon-common characters against the length of both strings.\n\n\nThis heuristic can be configured with \nbounds\n.\nThe default bounds are: below \n75\n% dissimilar and above \n85\n% similar.\nThis heuristic is case-insensitive.\n\n\n\n\n\n\nSÃ¸rensenâDice coefficient (as \nDice\n)\nÂ¶\n\n\nThe \nSÃ¸rensenâDice coefficient\n\nwas originally defined to measure the similarity of two sets.\nFormally, the coefficient is calculated by dividing \n2 * #(intersection)\n with\n\n#(set1) + #(set2)\n, where \n#()\n is the cardinality function of sets.\nThis metric is applied to strings by creating bigrams (substring sequences of\nlength 2) of the two strings and using the set of bigrams for the two strings\nas the two sets.\n\n\nThis heuristic can be configured with \nbounds\n.\nThe default bounds are: below \n60\n% dissimilar and above \n70\n% similar.\nThis heuristic is case-insensitive.\n\nOptions\nÂ¶\n\n\n\n\n\n\nMinimumIdentifierNameLength\nÂ¶\n\n\nSets the minimum required length the argument and parameter names\nneed to have. Names shorter than this length will be ignored.\nDefaults to \n3\n.\n\n\n\n\n\n\n\n\nAbbreviations\nÂ¶\n\n\nFor the \nAbbreviation\n heuristic\n(\nsee here\n), this option configures the\nabbreviations in the \nâabbreviation=abbreviated_valueâ\n format.\nThe option is a string, with each value joined by \nâ;â\n.\n\n\nBy default, the following abbreviations are set:\n\n\n\n\n\n\naddr=address\n\n\narr=array\n\n\nattr=attribute\n\n\nbuf=buffer\n\n\ncl=client\n\n\ncnt=count\n\n\ncol=column\n\n\ncpy=copy\n\n\ndest=destination\n\n\ndist=distance\n\n\ndst=distance\n\n\nelem=element\n\n\nhght=height\n\n\ni=index\n\n\nidx=index\n\n\nlen=length\n\n\nln=line\n\n\nlst=list\n\n\nnr=number\n\n\nnum=number\n\n\npos=position\n\n\nptr=pointer\n\n\nref=reference\n\n\nsrc=source\n\n\nsrv=server\n\n\nstmt=statement\n\n\nstr=string\n\n\nval=value\n\n\nvar=variable\n\n\nvec=vector\n\n\nwdth=width\n\n\n\n\n\n\n\n\nThe configuration options for each implemented heuristic (see above) is\nconstructed dynamically.\nIn the following, \n<HeuristicName>\n refers to one of the keys from the\nheuristics implemented.\n\n\n\n\n\n\n<HeuristicName>\nÂ¶\n\n\nTrue\n or \nFalse\n, whether a particular heuristic, such as \nEquality\n or\n\nLevenshtein\n is enabled.\n\n\nDefaults to \nTrue\n for every heuristic.\n\n\n\n\n\n\n\n\n<HeuristicName>DissimilarBelow\n,\n \n<HeuristicName>SimilarAbove\nÂ¶\n\n\nA value between \n0\n and \n100\n, expressing a percentage.\nThe bounds set what percentage of similarity the heuristic must deduce\nfor the two identifiers to be considered similar or dissimilar by the\ncheck.\n\n\nGiven arguments \narg1\n and \narg2\n passed to \nparam1\n and \nparam2\n,\nrespectively, the bounds check is performed in the following way:\nIf the similarity of the currently passed argument order\n(\narg1\n to \nparam1\n) is \nbelow\n the \nDissimilarBelow\n threshold, and\nthe similarity of the suggested swapped order (\narg1\n to \nparam2\n) is\n\nabove\n the \nSimilarAbove\n threshold, the swap is reported.\n\n\nFor the defaults of each heuristic, \nsee above\n.\n\nName synthesis\nÂ¶\n\n\nWhen comparing the argument names and parameter names, the following logic is\nused to gather the names for comparison:\n\n\nParameter names are the identifiers as written in the source code.\n\n\nArgument names are:\n\n\n\n\n\n\nIf a variable is passed, the variableâs name.\n\n\nIf a subsequent function callâs return value is used as argument, the\ncalled functionâs name.\n\n\nOtherwise, empty string.\n\n\n\n\n\n\nEmpty argument or parameter names are ignored by the heuristics.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/suspicious-call-argument.html"
  },
  {
    "name": "readability-trailing-comma",
    "description": "Checks for presence or absence of trailing commas in enum definitions and\ninitializer lists.\n\nThe check supports separate policies for single-line and multi-line constructs,\nallowing different styles for each. By default, the check enforces trailing\ncommas in multi-line constructs and removes them from single-line constructs.\n\nTrailing commas in multi-line constructs offer several benefits:\n\nAdding or removing elements at the end only changes a single line, making\ndiffs smaller and easier to read.\n\n\nFormatters may change code to a more desired style.\n\n\nCode generators avoid the need for special handling of the last element.\n\n// Without trailing commas - adding \"Yellow\" requires modifying the \"Blue\" line\n\n\nenum\n \nColor\n \n{\n\n\n  \nRed\n,\n\n\n  \nGreen\n,\n\n\n  \nBlue\n\n\n};\n\n\n\n// With trailing commas - adding \"Yellow\" is a clean, single-line change\n\n\nenum\n \nColor\n \n{\n\n\n  \nRed\n,\n\n\n  \nGreen\n,\n\n\n  \nBlue\n,\n\n\n};\n\nLimitations\nÂ¶\n\n\nThe check currently doesnât analyze code inside macros.\n\nOptions\nÂ¶\n\n\n\n\n\n\nSingleLineCommaPolicy\nÂ¶\n\n\nControls whether to add, remove, or ignore trailing commas in single-line\nenum definitions and initializer lists.\nValid values are:\n\n\n\n\nAppend\n: Add trailing commas where missing.\n\n\nRemove\n: Remove trailing commas where present.\n\n\nIgnore\n: Do not check single-line constructs.\n\n\n\n\nDefault is \nRemove\n.\n\n\n\n\n\n\n\n\nMultiLineCommaPolicy\nÂ¶\n\n\nControls whether to add, remove, or ignore trailing commas in multi-line\nenum definitions and initializer lists.\nValid values are:\n\n\n\n\nAppend\n: Add trailing commas where missing.\n\n\nRemove\n: Remove trailing commas where present.\n\n\nIgnore\n: Do not check multi-line constructs.\n\n\n\n\nDefault is \nAppend\n.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/trailing-comma.html"
  },
  {
    "name": "readability-uniqueptr-delete-release",
    "description": "Replace \ndelete\n \n<unique_ptr>.release()\n with \n<unique_ptr>\n \n=\n \nnullptr\n.\nThe latter is shorter, simpler and does not require use of raw pointer APIs.\n\nstd\n::\nunique_ptr\n<\nint\n>\n \nP\n;\n\n\ndelete\n \nP\n.\nrelease\n();\n\n\n\n// becomes\n\n\n\nstd\n::\nunique_ptr\n<\nint\n>\n \nP\n;\n\n\nP\n \n=\n \nnullptr\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nPreferResetCall\nÂ¶\n\n\nIf \ntrue\n, refactor by calling the reset member function instead of\nassigning to \nnullptr\n. Default value is \nfalse\n.\n\n\nstd\n::\nunique_ptr\n<\nint\n>\n \nP\n;\n\n\ndelete\n \nP\n.\nrelease\n();\n\n\n\n// becomes\n\n\n\nstd\n::\nunique_ptr\n<\nint\n>\n \nP\n;\n\n\nP\n.\nreset\n();",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/uniqueptr-delete-release.html"
  },
  {
    "name": "readability-uppercase-literal-suffix",
    "description": "cert-dcl16-c\n redirects here as an alias for this check.\nBy default, only the suffixes that begin with \nl\n (\nl\n, \nll\n, \nlu\n,\n\nllu\n, but not \nu\n, \nul\n, \null\n) are diagnosed by that alias.\n\nhicpp-uppercase-literal-suffix\n redirects here as an alias for this check.\n\nDetects when the integral literal or floating point (decimal or hexadecimal)\nliteral has a non-uppercase suffix and provides a fix-it hint with the\nuppercase suffix.\n\nAll valid combinations of suffixes are supported.\n\nauto\n \nx\n \n=\n \n1\n;\n  \n// OK, no suffix.\n\n\n\nauto\n \nx\n \n=\n \n1u\n;\n \n// warning: integer literal suffix 'u' is not upper-case\n\n\n\nauto\n \nx\n \n=\n \n1U\n;\n \n// OK, suffix is uppercase.\n\n\n\n...\n\nOptions\nÂ¶\n\n\n\n\n\n\nNewSuffixes\nÂ¶\n\n\nOptionally, a list of the destination suffixes can be provided. When the\nsuffix is found, a case-insensitive lookup in that list is made, and if a\nreplacement is found that is different from the current suffix, then the\ndiagnostic is issued. This allows for fine-grained control of what suffixes to\nconsider and what their replacements should be.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nGiven a list \nL;uL\n:\n\n\n\n\nl\n -> \nL\n\n\nL\n will be kept as is.\n\n\nul\n -> \nuL\n\n\nUl\n -> \nuL\n\n\nUL\n -> \nuL\n\n\nuL\n will be kept as is.\n\n\null\n will be kept as is, since it is not in the list\n\n\nand so on.\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf this option is set to \ntrue\n (default is \ntrue\n), the check will not warn\nabout literal suffixes inside macros.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/uppercase-literal-suffix.html"
  },
  {
    "name": "readability-use-anyofallof",
    "description": "Finds range-based for loops that can be replaced by a call to\n\nstd::any_of\n or \nstd::all_of\n. In C++20 mode, suggests\n\nstd::ranges::any_of\n or \nstd::ranges::all_of\n.\n\nExample:\n\nbool\n \nall_even\n(\nstd\n::\nvector\n<\nint\n>\n \nV\n)\n \n{\n\n\n  \nfor\n \n(\nint\n \nI\n \n:\n \nV\n)\n \n{\n\n\n    \nif\n \n(\nI\n \n%\n \n2\n)\n\n\n      \nreturn\n \nfalse\n;\n\n\n  \n}\n\n\n  \nreturn\n \ntrue\n;\n\n\n  \n// Replace loop by\n\n\n  \n// return std::ranges::all_of(V, [](int I) { return I % 2 == 0; });\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/use-anyofallof.html"
  },
  {
    "name": "readability-use-concise-preprocessor-directives",
    "description": "Finds uses of \n#if\n that can be simplified to \n#ifdef\n or \n#ifndef\n and,\nsince C23 and C++23, uses of \n#elif\n that can be simplified to \n#elifdef\n\nor \n#elifndef\n:\n\n#if defined(MEOW)\n\n\n#if !defined(MEOW)\n\n\n\n// becomes\n\n\n\n#ifdef MEOW\n\n\n#ifndef MEOW\n\nSince C23 and C++23:\n\n#elif defined(MEOW)\n\n\n#elif !defined(MEOW)\n\n\n\n// becomes\n\n\n\n#elifdef MEOW\n\n\n#elifndef MEOW",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/use-concise-preprocessor-directives.html"
  },
  {
    "name": "readability-use-std-min-max",
    "description": "Replaces certain conditional statements with equivalent calls to\n\nstd::min\n or \nstd::max\n.\nNote: This may impact performance in critical code due to potential\nadditional stores compared to the original if statement.\n\nBefore:\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nint\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n;\n\n\n  \nif\n \n(\na\n \n<\n \nb\n)\n\n\n    \na\n \n=\n \nb\n;\n\n\n}\n\nAfter:\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nint\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n3\n;\n\n\n  \na\n \n=\n \nstd\n::\nmax\n(\na\n,\n \nb\n);\n\n\n}",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/use-std-min-max.html"
  },
  {
    "name": "zircon-temporary-objects",
    "description": "Note\n\n\nThe \nzircon-temporary-objects\n check has been deprecated and will be removed\nin 24th release of LLVM. Please use\n\nfuchsia-temporary-objects\n instead.",
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/zircon/temporary-objects.html"
  }
]