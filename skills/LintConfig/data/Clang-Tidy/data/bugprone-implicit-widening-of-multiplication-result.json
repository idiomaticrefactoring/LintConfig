{
  "name": "bugprone-implicit-widening-of-multiplication-result",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/implicit-widening-of-multiplication-result.html",
    "fixable": true
  },
  "content": {
    "introduction": "The check diagnoses instances where a result of a multiplication is implicitly\nwidened, and suggests (with fix-it) to either silence the code by making\nwidening explicit, or to perform the multiplication in a wider type,\nto avoid the widening afterwards.\n\nThis is mainly useful when operating on very large buffers.\nFor example, consider:\n\nvoid\n \nzeroinit\n(\nchar\n*\n \nbase\n,\n \nunsigned\n \nwidth\n,\n \nunsigned\n \nheight\n)\n \n{\n\n\n  \nfor\n(\nunsigned\n \nrow\n \n=\n \n0\n;\n \nrow\n \n!=\n \nheight\n;\n \n++\nrow\n)\n \n{\n\n\n    \nfor\n(\nunsigned\n \ncol\n \n=\n \n0\n;\n \ncol\n \n!=\n \nwidth\n;\n \n++\ncol\n)\n \n{\n\n\n      \nchar\n*\n \nptr\n \n=\n \nbase\n \n+\n \nrow\n \n*\n \nwidth\n \n+\n \ncol\n;\n\n\n      \n*\nptr\n \n=\n \n0\n;\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\nThis is fine in general, but if \nwidth\n \n*\n \nheight\n overflows,\nyou end up wrapping back to the beginning of \nbase\n\ninstead of processing the entire requested buffer.\n\nIndeed, this only matters for pretty large buffers (4GB+),\nbut that can happen very easily for example in image processing,\nwhere for that to happen you âonlyâ need a ~269MPix image.\n\nOptions\nÂ¶\n\n\n\n\n\n\nUseCXXStaticCastsInCppSources\nÂ¶\n\n\nWhen suggesting fix-its for C++ code, should C++-style \nstatic_cast<>()\nâs\nbe suggested, or C-style casts. Defaults to \ntrue\n.\n\n\n\n\n\n\n\n\nUseCXXHeadersInCppSources\nÂ¶\n\n\nWhen suggesting to include the appropriate header in C++ code,\nshould \n<cstddef>\n header be suggested, or \n<stddef.h>\n.\nDefaults to \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreConstantIntExpr\nÂ¶\n\n\nIf the multiplication operands are compile-time constants (like literals or\nare \nconstexpr\n) and fit within the source expression type, do not emit a\ndiagnostic or suggested fix.  Only considers expressions where the source\nexpression is a signed integer type.  Defaults to \nfalse\n.\n\n\n\n\nExamples:\n\n\nlong\n \nmul\n(\nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \na\n \n*\n \nb\n;\n \n// warning: performing an implicit widening conversion to type 'long' of a multiplication performed in type 'int'\n\n\n}\n\n\n\nchar\n*\n \nptr_add\n(\nchar\n \n*\nbase\n,\n \nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \nbase\n \n+\n \na\n \n*\n \nb\n;\n \n// warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n\n\n}\n\n\n\nchar\n \nptr_subscript\n(\nchar\n \n*\nbase\n,\n \nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n\n  \nreturn\n \nbase\n[\na\n \n*\n \nb\n];\n \n// warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n\n\n}",
    "configurations": []
  }
}