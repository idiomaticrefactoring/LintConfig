{
  "name": "cppcoreguidelines-rvalue-reference-param-not-moved",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/rvalue-reference-param-not-moved.html",
    "fixable": false
  },
  "content": {
    "introduction": "Warns when an rvalue reference function parameter is never moved within\nthe function body.\n\nRvalue reference parameters indicate a parameter that should be moved with\n\nstd::move\n from within the function body. Any such parameter that is\nnever moved is confusing and potentially indicative of a buggy program.\n\nExample:\n\nvoid\n \nlogic\n(\nstd\n::\nstring\n&&\n \nInput\n)\n \n{\n\n\n  \nstd\n::\nstring\n \nCopy\n(\nInput\n);\n \n// Oops - forgot to std::move\n\n\n}\n\nNote that parameters that are unused and marked as such will not be diagnosed.\n\nExample:\n\nvoid\n \nconditional_use\n([[\nmaybe_unused\n]]\n \nstd\n::\nstring\n&&\n \nInput\n)\n \n{\n\n\n  \n// No diagnostic here since Input is unused and marked as such\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowPartialMove\nÂ¶\n\n\n\n\nIf set to \ntrue\n, the check accepts \nstd::move\n calls containing any\nsubexpression containing the parameter. CppCoreGuideline F.18 officially\nmandates that the parameter itself must be moved. Default is \nfalse\n.\n\n\n\n\n// 'p' is flagged by this check if and only if AllowPartialMove is false\n\n\nvoid\n \nmove_members_of\n(\npair\n<\nObj\n,\n \nObj\n>&&\n \np\n)\n \n{\n\n\n  \npair\n<\nObj\n,\n \nObj\n>\n \nother\n;\n\n\n  \nother\n.\nfirst\n \n=\n \nstd\n::\nmove\n(\np\n.\nfirst\n);\n\n\n  \nother\n.\nsecond\n \n=\n \nstd\n::\nmove\n(\np\n.\nsecond\n);\n\n\n}\n\n\n\n// 'p' is never flagged by this check\n\n\nvoid\n \nmove_whole_pair\n(\npair\n<\nObj\n,\n \nObj\n>&&\n \np\n)\n \n{\n\n\n  \npair\n<\nObj\n,\n \nObj\n>\n \nother\n \n=\n \nstd\n::\nmove\n(\np\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nIgnoreUnnamedParams\nÂ¶\n\n\nIf set to \ntrue\n, the check ignores unnamed rvalue reference parameters.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreNonDeducedTemplateTypes\nÂ¶\n\n\n\n\nIf set to \ntrue\n, the check ignores non-deduced template type rvalue\nreference parameters. Default is \nfalse\n.\n\n\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nstruct\n \nSomeClass\n \n{\n\n\n  \n// Below, 'T' is not deduced and 'T&&' is an rvalue reference type.\n\n\n  \n// This will be flagged if and only if IgnoreNonDeducedTemplateTypes is\n\n\n  \n// false. One suggested fix would be to specialize the class for 'T' and\n\n\n  \n// 'T&' separately (e.g., see std::future), or allow only one of 'T' or\n\n\n  \n// 'T&' instantiations of SomeClass (e.g., see std::optional).\n\n\n  \nSomeClass\n(\nT\n&&\n \nt\n)\n \n{\n \n}\n\n\n};\n\n\n\n// Never flagged, since 'T' is a forwarding reference in a deduced context\n\n\ntemplate\n \n<\nclass\n \nT\n>\n\n\nvoid\n \nforwarding_ref\n(\nT\n&&\n \nt\n)\n \n{\n\n\n  \nT\n \nother\n \n=\n \nstd\n::\nforward\n<\nT\n>\n(\nt\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nMoveFunction\nÂ¶\n\n\nSpecify the function used for moving. Default is \n::std::move\n.\n\n\n\n\nThis check implements \nF.18\n\nfrom the C++ Core Guidelines.",
    "configurations": []
  }
}