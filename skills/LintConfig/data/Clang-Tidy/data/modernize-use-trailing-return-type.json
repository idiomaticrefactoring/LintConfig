{
  "name": "modernize-use-trailing-return-type",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-trailing-return-type.html",
    "fixable": true
  },
  "content": {
    "introduction": "Rewrites function and lambda signatures to use a trailing return type\n(introduced in C++11). This transformation is purely stylistic.\nThe return type before the function name is replaced by \nauto\n\nand inserted after the function parameter list (and qualifiers).\n\nExample\nÂ¶\n\n\nint\n \nf1\n();\n\n\ninline\n \nint\n \nf2\n(\nint\n \narg\n)\n \nnoexcept\n;\n\n\nvirtual\n \nfloat\n \nf3\n()\n \nconst\n \n&&\n \n=\n \ndelete\n;\n\n\nauto\n \nlambda\n \n=\n \n[]()\n \n{};\n\n\n\n\n\n\ntransforms to:\n\n\nauto\n \nf1\n()\n \n->\n \nint\n;\n\n\ninline\n \nauto\n \nf2\n(\nint\n \narg\n)\n \n->\n \nint\n \nnoexcept\n;\n\n\nvirtual\n \nauto\n \nf3\n()\n \nconst\n \n&&\n \n->\n \nfloat\n \n=\n \ndelete\n;\n\n\nauto\n \nlambda\n \n=\n \n[]()\n \n->\n \nvoid\n \n{};\n\nLimitations\nÂ¶\n\n\nThe following categories of return types cannot be rewritten currently:\n\n\n\n\nfunction pointers\n\n\nmember function pointers\n\n\nmember pointers\n\n\n\n\nUnqualified names in the return type might erroneously refer to different\nentities after the rewrite.\nPreventing such errors requires a full lookup of all unqualified names\npresent in the return type in the scope of the trailing return type location.\nThis location includes e.g. function parameter names and members of the\nenclosing class (including all inherited classes).\nSuch a lookup is currently not implemented.\n\n\nGiven the following piece of code\n\n\nstruct\n \nS\n \n{\n \nlong\n \nlong\n \nvalue\n;\n \n};\n\n\nS\n \nf\n(\nunsigned\n \nS\n)\n \n{\n \nreturn\n \n{\nS\n \n*\n \n2\n};\n \n}\n\n\nclass\n \nCC\n \n{\n\n\n  \nint\n \nS\n;\n\n\n  \nstruct\n \nS\n \nm\n();\n\n\n};\n\n\nS\n \nCC::m\n()\n \n{\n \nreturn\n \n{\n0\n};\n \n}\n\n\n\n\n\n\na careless rewrite would produce the following output:\n\n\nstruct\n \nS\n \n{\n \nlong\n \nlong\n \nvalue\n;\n \n};\n\n\nauto\n \nf\n(\nunsigned\n \nS\n)\n \n->\n \nS\n \n{\n \nreturn\n \n{\nS\n \n*\n \n2\n};\n \n}\n \n// error\n\n\nclass\n \nCC\n \n{\n\n\n  \nint\n \nS\n;\n\n\n  \nauto\n \nm\n()\n \n->\n \nstruct\n \nS\n;\n\n\n};\n\n\nauto\n \nCC\n::\nm\n()\n \n->\n \nS\n \n{\n \nreturn\n \n{\n0\n};\n \n}\n \n// error\n\n\n\n\n\n\nThis code fails to compile because the S in the context of f refers to the\nequally named function parameter.\nSimilarly, the S in the context of m refers to the equally named class member.\nThe check can currently only detect and avoid a clash with a function parameter name.\n\nOptions\nÂ¶\n\n\n\n\n\n\nTransformFunctions\nÂ¶\n\n\nWhen set to \ntrue\n, function declarations will be transformed to use trailing\nreturn. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nTransformLambdas\nÂ¶\n\n\nControls how lambda expressions are transformed to use trailing\nreturn type. Possible values are:\n\n\n\n\nall\n - Transform all lambda expressions without an explicit return type\nto use trailing return type. If type can not be deduced, \nauto\n will be\nused since C++14 and generic message will be emitted otherwise.\n\n\nall_except_auto\n - Transform all lambda expressions except those whose return\ntype can not be deduced.\n\n\nnone\n - Do not transform any lambda expressions.\n\n\n\n\nDefault is \nall\n.",
    "configurations": []
  }
}