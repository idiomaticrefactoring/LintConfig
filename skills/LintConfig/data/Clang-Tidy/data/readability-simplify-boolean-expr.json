{
  "name": "readability-simplify-boolean-expr",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/simplify-boolean-expr.html",
    "fixable": true
  },
  "content": {
    "introduction": "Looks for boolean expressions involving boolean constants and simplifies\nthem to use the appropriate boolean expression directly.  Simplifies\nboolean expressions by application of DeMorganâs Theorem.\n\nExamples:\n\nInitial expression\n\n\nResult\n\n\n\n\nif\n \n(b\n \n==\n \ntrue)\n\n\nif\n \n(b)\n\n\n\n\nif\n \n(b\n \n==\n \nfalse)\n\n\nif\n \n(!b)\n\n\n\n\nif\n \n(b\n \n&&\n \ntrue)\n\n\nif\n \n(b)\n\n\n\n\nif\n \n(b\n \n&&\n \nfalse)\n\n\nif\n \n(false)\n\n\n\n\nif\n \n(b\n \n||\n \ntrue)\n\n\nif\n \n(true)\n\n\n\n\nif\n \n(b\n \n||\n \nfalse)\n\n\nif\n \n(b)\n\n\n\n\ne\n \n?\n \ntrue\n \n:\n \nfalse\n\n\ne\n\n\n\n\ne\n \n?\n \nfalse\n \n:\n \ntrue\n\n\n!e\n\n\n\n\nif\n \n(true)\n \nt();\n \nelse\n \nf();\n\n\nt();\n\n\n\n\nif\n \n(false)\n \nt();\n \nelse\n \nf();\n\n\nf();\n\n\n\n\nif\n \n(e)\n \nreturn\n \ntrue;\n \nelse\n \nreturn\n \nfalse;\n\n\nreturn\n \ne;\n\n\n\n\nif\n \n(e)\n \nreturn\n \nfalse;\n \nelse\n \nreturn\n \ntrue;\n\n\nreturn\n \n!e;\n\n\n\n\nif\n \n(e)\n \nb\n \n=\n \ntrue;\n \nelse\n \nb\n \n=\n \nfalse;\n\n\nb\n \n=\n \ne;\n\n\n\n\nif\n \n(e)\n \nb\n \n=\n \nfalse;\n \nelse\n \nb\n \n=\n \ntrue;\n\n\nb\n \n=\n \n!e;\n\n\n\n\nif\n \n(e)\n \nreturn\n \ntrue;\n \nreturn\n \nfalse;\n\n\nreturn\n \ne;\n\n\n\n\nif\n \n(e)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n\n\nreturn\n \n!e;\n\n\n\n\n!(!a\n \n||\n \nb)\n\n\na\n \n&&\n \n!b\n\n\n\n\n!(a\n \n||\n \n!b)\n\n\n!a\n \n&&\n \nb\n\n\n\n\n!(!a\n \n||\n \n!b)\n\n\na\n \n&&\n \nb\n\n\n\n\n!(!a\n \n&&\n \nb)\n\n\na\n \n||\n \n!b\n\n\n\n\n!(a\n \n&&\n \n!b)\n\n\n!a\n \n||\n \nb\n\n\n\n\n!(!a\n \n&&\n \n!b)\n\n\na\n \n||\n \nb\n\nThe resulting expression \ne\n is modified as follows:\n\n\nUnnecessary parentheses around the expression are removed.\n\n\nNegated applications of \n!\n are eliminated.\n\n\nNegated applications of comparison operators are changed to use the\nopposite condition.\n\n\nImplicit conversions of pointers, including pointers to members, to\n\nbool\n are replaced with explicit comparisons to \nnullptr\n in C++11\nor \nNULL\n in C++98/03.\n\n\nImplicit casts to \nbool\n are replaced with explicit casts to \nbool\n.\n\n\nObject expressions with \nexplicit\n \noperator\n \nbool\n conversion operators\nare replaced with explicit casts to \nbool\n.\n\n\nImplicit conversions of integral types to \nbool\n are replaced with\nexplicit comparisons to \n0\n.\n\n\n\n\n\n\nExamples:\n\n\nThe ternary assignment \nbool\n \nb\n \n=\n \n(i\n \n<\n \n0)\n \n?\n \ntrue\n \n:\n \nfalse;\n has redundant\nparentheses and becomes \nbool\n \nb\n \n=\n \ni\n \n<\n \n0;\n.\n\n\nThe conditional return \nif\n \n(!b)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n has an\nimplied double negation and becomes \nreturn\n \nb;\n.\n\n\nThe conditional return \nif\n \n(i\n \n<\n \n0)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n becomes\n\nreturn\n \ni\n \n>=\n \n0;\n.\n\n\nThe conditional return \nif\n \n(i\n \n!=\n \n0)\n \nreturn\n \nfalse;\n \nreturn\n \ntrue;\n becomes\n\nreturn\n \ni\n \n==\n \n0;\n.\n\n\n\n\nThe conditional return \nif\n \n(p)\n \nreturn\n \ntrue;\n \nreturn\n \nfalse;\n has an\nimplicit conversion of a pointer to \nbool\n and becomes\n\nreturn\n \np\n \n!=\n \nnullptr;\n.\n\n\nThe ternary assignment \nbool\n \nb\n \n=\n \n(i\n \n&\n \n1)\n \n?\n \ntrue\n \n:\n \nfalse;\n has an\nimplicit conversion of \ni\n \n&\n \n1\n to \nbool\n and becomes\n\nbool\n \nb\n \n=\n \n(i\n \n&\n \n1)\n \n!=\n \n0;\n.\n\n\n\n\nThe conditional return \nif\n \n(i\n \n&\n \n1)\n \nreturn\n \ntrue;\n \nelse\n \nreturn\n \nfalse;\n has\nan implicit conversion of an integer quantity \ni\n \n&\n \n1\n to \nbool\n and\nbecomes \nreturn\n \n(i\n \n&\n \n1)\n \n!=\n \n0;\n\n\nGiven \nstruct\n \nX\n \n{\n \nexplicit\n \noperator\n \nbool();\n \n};\n, and an instance \nx\n\nof \nstruct\n \nX\n, the conditional return\n\nif\n \n(x)\n \nreturn\n \ntrue;\n \nreturn\n \nfalse;\n\nbecomes \nreturn\n \nstatic_cast<bool>(x);\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf \ntrue\n, ignore boolean expressions originating from expanded macros.\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nChainedConditionalReturn\nÂ¶\n\n\nIf \ntrue\n, conditional boolean return statements at the end of an\n\nif/else\n \nif\n chain will be transformed. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nChainedConditionalAssignment\nÂ¶\n\n\nIf \ntrue\n, conditional boolean assignments at the end of an \nif/else\n\n\nif\n chain will be transformed. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nSimplifyDeMorgan\nÂ¶\n\n\nIf \ntrue\n, DeMorganâs Theorem will be applied to simplify negated\nconjunctions and disjunctions.  Default is \ntrue\n.\n\n\n\n\n\n\n\n\nSimplifyDeMorganRelaxed\nÂ¶\n\n\nIf \ntrue\n, \nSimplifyDeMorgan\n will also transform negated\nconjunctions and disjunctions where there is no negation on either operand.\nThis option has no effect if \nSimplifyDeMorgan\n is \nfalse\n.\nDefault is \nfalse\n.\n\n\nWhen Enabled:\n\n\nbool X = !(A && B)\nbool Y = !(A || B)\n\n\n\n\n\nWould be transformed to:\n\n\nbool X = !A || !B\nbool Y = !A && !B",
    "configurations": []
  }
}