{
  "name": "performance-no-automatic-move",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-automatic-move.html",
    "fixable": false
  },
  "content": {
    "introduction": "Finds local variables that cannot be automatically moved due to constness.\n\nUnder\n\ncertain conditions\n,\nlocal values are automatically moved out when returning from a function. A\ncommon mistake is to declare local \nlvalue\n variables \nconst\n, which\nprevents the move.\n\nExample \n[1]\n:\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\n \nCool\n()\n \n{\n\n\n  \nstd\n::\nvector\n<\nint\n>\n \nobj\n \n=\n \n...;\n\n\n  \nreturn\n \nobj\n;\n  \n// calls StatusOr::StatusOr(std::vector<int>&&)\n\n\n}\n\n\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\n \nNotCool\n()\n \n{\n\n\n  \nconst\n \nstd\n::\nvector\n<\nint\n>\n \nobj\n \n=\n \n...;\n\n\n  \nreturn\n \nobj\n;\n  \n// calls `StatusOr::StatusOr(const std::vector<int>&)`\n\n\n}\n\nThe former version (\nCool\n) should be preferred over the latter (\nNotCool\n)\nas it will avoid allocations and potentially large memory copies.\n\nSemantics\nÂ¶\n\n\nIn the example above, \nStatusOr::StatusOr(T&&)\n have the same semantics as\nlong as the copy and move constructors for \nT\n have the same semantics. Note\nthat there is no guarantee that \nS::S(T&&)\n and \nS::S(const\n \nT&)\n have the\nsame semantics for any single \nS\n, so weâre not providing automated fixes for\nthis check, and judgement should be exerted when making the suggested changes.\n\n-Wreturn-std-move\nÂ¶\n\n\nAnother case where the move cannot happen is the following:\n\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\n \nUncool\n()\n \n{\n\n\n  \nstd\n::\nvector\n<\nint\n>&&\n \nobj\n \n=\n \n...;\n\n\n  \nreturn\n \nobj\n;\n  \n// calls `StatusOr::StatusOr(const std::vector<int>&)`\n\n\n}\n\n\n\n\n\n\nIn that case the fix is more consensual: just \nreturn std::move(obj)\n.\nThis is handled by the \n-Wreturn-std-move\n warning.",
    "configurations": []
  }
}