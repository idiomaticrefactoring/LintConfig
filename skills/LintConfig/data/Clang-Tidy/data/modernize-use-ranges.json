{
  "name": "modernize-use-ranges",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-ranges.html",
    "fixable": true
  },
  "content": {
    "introduction": "Detects calls to standard library iterator algorithms that could be replaced\nwith a ranges version instead.\n\nExample\nÂ¶\n\n\nauto\n \nIter1\n \n=\n \nstd\n::\nfind\n(\nItems\n.\nbegin\n(),\n \nItems\n.\nend\n(),\n \n0\n);\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nequal\n(\nItems1\n.\ncbegin\n(),\n \nItems1\n.\ncend\n(),\n\n\n                          \nstd\n::\nbegin\n(\nItems2\n),\n \nstd\n::\nend\n(\nItems2\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nIter1\n \n=\n \nstd\n::\nranges\n::\nfind\n(\nItems\n,\n \n0\n);\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nranges\n::\nequal\n(\nItems1\n,\n \nItems2\n);\n\nSupported algorithms\nÂ¶\n\n\nCalls to the following std library algorithms are checked:\n\n\nstd::adjacent_find\n,\n\nstd::all_of\n,\n\nstd::any_of\n,\n\nstd::binary_search\n,\n\nstd::copy_backward\n,\n\nstd::copy_if\n,\n\nstd::copy\n,\n\nstd::destroy\n,\n\nstd::equal_range\n,\n\nstd::equal\n,\n\nstd::fill\n,\n\nstd::find_end\n,\n\nstd::find_if_not\n,\n\nstd::find_if\n,\n\nstd::find\n,\n\nstd::for_each\n,\n\nstd::generate\n,\n\nstd::includes\n,\n\nstd::inplace_merge\n,\n\nstd::iota\n,\n\nstd::is_heap_until\n,\n\nstd::is_heap\n,\n\nstd::is_partitioned\n,\n\nstd::is_permutation\n,\n\nstd::is_sorted_until\n,\n\nstd::is_sorted\n,\n\nstd::lexicographical_compare\n,\n\nstd::lower_bound\n,\n\nstd::make_heap\n,\n\nstd::max_element\n,\n\nstd::merge\n,\n\nstd::min_element\n,\n\nstd::minmax_element\n,\n\nstd::mismatch\n,\n\nstd::move_backward\n,\n\nstd::move\n,\n\nstd::next_permutation\n,\n\nstd::none_of\n,\n\nstd::partial_sort_copy\n,\n\nstd::partition_copy\n,\n\nstd::partition_point\n,\n\nstd::partition\n,\n\nstd::pop_heap\n,\n\nstd::prev_permutation\n,\n\nstd::push_heap\n,\n\nstd::remove_copy_if\n,\n\nstd::remove_copy\n,\n\nstd::remove\n, \nstd::remove_if\n,\n\nstd::replace_if\n,\n\nstd::replace\n,\n\nstd::reverse_copy\n,\n\nstd::reverse\n,\n\nstd::rotate\n,\n\nstd::rotate_copy\n,\n\nstd::sample\n,\n\nstd::search\n,\n\nstd::set_difference\n,\n\nstd::set_intersection\n,\n\nstd::set_symmetric_difference\n,\n\nstd::set_union\n,\n\nstd::shift_left\n,\n\nstd::shift_right\n,\n\nstd::sort_heap\n,\n\nstd::sort\n,\n\nstd::stable_partition\n,\n\nstd::stable_sort\n,\n\nstd::transform\n,\n\nstd::uninitialized_copy\n,\n\nstd::uninitialized_default_construct\n,\n\nstd::uninitialized_fill\n,\n\nstd::uninitialized_move\n,\n\nstd::uninitialized_value_construct\n,\n\nstd::unique_copy\n,\n\nstd::unique\n,\n\nstd::upper_bound\n.\n\n\nNote: some range algorithms for \nvector<bool>\n require C++23 because it uses\nproxy iterators.\n\nReverse Iteration\nÂ¶\n\n\nIf calls are made using reverse iterators on containers, The code will be\nfixed using the \nstd::views::reverse\n adaptor.\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nequal\n(\nItems1\n.\nrbegin\n(),\n \nItems1\n.\nrend\n(),\n\n\n                          \nstd\n::\ncrbegin\n(\nItems2\n),\n \nstd\n::\ncrend\n(\nItems2\n));\n\n\n\n\n\n\nTransforms to:\n\n\nauto\n \nAreSame\n \n=\n \nstd\n::\nranges\n::\nequal\n(\nstd\n::\nviews\n::\nreverse\n(\nItems1\n),\n\n\n                                  \nstd\n::\nviews\n::\nreverse\n(\nItems2\n));\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nUseReversePipe\nÂ¶\n\n\nWhen \ntrue\n (default \nfalse\n), fixes which involve reverse ranges will use the\npipe adaptor syntax instead of the function syntax.\n\n\nstd\n::\nfind\n(\nItems\n.\nrbegin\n(),\n \nItems\n.\nrend\n(),\n \n0\n);\n\n\n\n\n\n\nTransforms to:\n\n\nstd\n::\nranges\n::\nfind\n(\nItems\n \n|\n \nstd\n::\nviews\n::\nreverse\n,\n \n0\n);",
    "configurations": []
  }
}