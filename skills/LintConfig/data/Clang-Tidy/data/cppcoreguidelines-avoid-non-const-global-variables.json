{
  "name": "cppcoreguidelines-avoid-non-const-global-variables",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-non-const-global-variables.html",
    "fixable": false
  },
  "content": {
    "introduction": "Finds non-const global variables as described in \nI.2\n\nof C++ Core Guidelines.\nAs \nR.6\n\nof C++ Core Guidelines is a duplicate of rule \nI.2\n\nit also covers that rule.\n\nchar\n \na\n;\n  \n// Warns!\n\n\nconst\n \nchar\n \nb\n \n=\n  \n0\n;\n\n\n\nnamespace\n \nsome_namespace\n\n\n{\n\n\n    \nchar\n \nc\n;\n  \n// Warns!\n\n\n    \nconst\n \nchar\n \nd\n \n=\n \n0\n;\n\n\n}\n\n\n\nchar\n \n*\n \nc_ptr1\n \n=\n \n&\nsome_namespace\n::\nc\n;\n  \n// Warns!\n\n\nchar\n \n*\nconst\n \nc_const_ptr\n \n=\n \n&\nsome_namespace\n::\nc\n;\n  \n// Warns!\n\n\nchar\n \n&\n \nc_reference\n \n=\n \nsome_namespace\n::\nc\n;\n  \n// Warns!\n\n\n\nclass\n \nFoo\n  \n// No Warnings inside Foo, only namespace scope is covered\n\n\n{\n\n\npublic\n:\n\n\n    \nchar\n \ne\n \n=\n \n0\n;\n\n\n    \nconst\n \nchar\n \nf\n \n=\n \n0\n;\n\n\nprotected\n:\n\n\n    \nchar\n \ng\n \n=\n \n0\n;\n\n\nprivate\n:\n\n\n    \nchar\n \nh\n \n=\n \n0\n;\n\n\n};\n\nThe variables \na\n, \nc\n, \nc_ptr1\n, \nc_const_ptr\n and \nc_reference\n\nwill all generate warnings since they are either a non-const globally accessible\nvariable, a pointer or a reference providing global access to non-const data\nor both.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowInternalLinkage\nÂ¶\n\n\nWhen set to \ntrue\n, static non-const variables and variables in anonymous\nnamespaces will not generate a warning. The default value is \nfalse\n.\n\n\n\n\n\n\n\n\nAllowThreadLocal\nÂ¶\n\n\nWhen set to \ntrue\n, non-const global variables with thread-local storage\nduration will not generate a warning. The default value is \nfalse\n.",
    "configurations": []
  }
}