{
  "name": "readability-redundant-typename",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/redundant-typename.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds redundant uses of the \ntypename\n keyword.\n\ntypename\n is redundant in two cases. First, before non-dependent names:\n\n/*typename*/\n \nstd\n::\nvector\n<\nint\n>::\nsize_type\n \nsize\n;\n\nAnd second, since C++20, before dependent names that appear in a context\nwhere only a type is allowed (the following example shows just a few of them):\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nusing\n \ntrait\n \n=\n \n/*typename*/\n \nT\n::\ntype\n;\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\n/*typename*/\n \nT\n::\nunderlying_type\n \nas_underlying\n(\nT\n \nn\n)\n \n{\n\n\n  \nreturn\n \nstatic_cast\n<\n/*typename*/\n \nT\n::\nunderlying_type\n>\n(\nn\n);\n\n\n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nS\n \n{\n\n\n  \n/*typename*/\n \nT\n::\ntype\n \nvariable\n;\n\n\n  \n/*typename*/\n \nT\n::\ntype\n \nfunction\n(\n/*typename*/\n \nT\n::\ntype\n);\n\n\n};",
    "configurations": []
  }
}