{
  "name": "bugprone-shared-ptr-array-mismatch",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/shared-ptr-array-mismatch.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds initializations of C++ shared pointers to non-array type that are\ninitialized with an array.\n\nIf a shared pointer \nstd::shared_ptr<T>\n is initialized with a new-expression\n\nnew\n \nT[]\n the memory is not deallocated correctly. The pointer uses plain\n\ndelete\n in this case to deallocate the target memory. Instead a \ndelete[]\n\ncall is needed. A \nstd::shared_ptr<T[]>\n calls the correct delete operator.\n\nThe check offers replacement of \nshared_ptr<T>\n to \nshared_ptr<T[]>\n if it\nis used at a single variable declaration (one variable in one statement).\n\nExample:\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx\n(\nnew\n \nFoo\n[\n10\n]);\n \n// -> std::shared_ptr<Foo[]> x(new Foo[10]);\n\n\n//                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx1\n(\nnew\n \nFoo\n),\n \nx2\n(\nnew\n \nFoo\n[\n10\n]);\n \n// no replacement\n\n\n//                                   ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n\n\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx3\n(\nnew\n \nFoo\n[\n10\n],\n \n[](\nconst\n \nFoo\n \n*\nptr\n)\n \n{\n \ndelete\n[]\n \nptr\n;\n \n});\n \n// no warning\n\n\n\nstruct\n \nS\n \n{\n\n\n  \nstd\n::\nshared_ptr\n<\nFoo\n>\n \nx\n(\nnew\n \nFoo\n[\n10\n]);\n \n// no replacement in this case\n\n\n  \n//                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n\n\n};\n\nThis check partially covers the CERT C++ Coding Standard rule\n\nMEM51-CPP. Properly deallocate dynamically allocated resources\n\nHowever, only the \nstd::shared_ptr\n case is detected by this check.",
    "configurations": []
  }
}