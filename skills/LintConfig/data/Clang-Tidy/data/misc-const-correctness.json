{
  "name": "misc-const-correctness",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/const-correctness.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds local variables and function parameters which could be declared as\n\nconst\n but are not.\n\nDeclaring variables as \nconst\n is required or recommended by many coding\nguidelines, such as:\n\nES.25\n\nfrom the C++ Core Guidelines.\n\nPlease note that this checkâs analysis is type-based only. Variables that are\nnot modified but used to create a non-const handle that might escape the scope\nare not diagnosed as potential \nconst\n.\n\n// Declare a variable, which is not ``const`` ...\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n// but use it as read-only. This means that `i` can be declared ``const``.\n\n\nint\n \nresult\n \n=\n \ni\n \n*\n \ni\n;\n       \n// Before transformation\n\n\nint\n \nconst\n \nresult\n \n=\n \ni\n \n*\n \ni\n;\n \n// After transformation\n\nThe check can analyze values, pointers and references and pointees:\n\n// Normal values like built-ins or objects.\n\n\nint\n \npotential_const_int\n \n=\n \n42\n;\n       \n// Before transformation\n\n\nint\n \nconst\n \npotential_const_int\n \n=\n \n42\n;\n \n// After transformation\n\n\nint\n \ncopy_of_value\n \n=\n \npotential_const_int\n;\n\n\n\nMyClass\n \ncould_be_const\n;\n       \n// Before transformation\n\n\nMyClass\n \nconst\n \ncould_be_const\n;\n \n// After transformation\n\n\ncould_be_const\n.\nconst_qualified_method\n();\n\n\n\n// References can be declared const as well.\n\n\nint\n \n&\nreference_value\n \n=\n \npotential_const_int\n;\n       \n// Before transformation\n\n\nint\n \nconst\n&\n \nreference_value\n \n=\n \npotential_const_int\n;\n \n// After transformation\n\n\nint\n \nanother_copy\n \n=\n \nreference_value\n;\n\n\n\n// The similar semantics of pointers are analyzed.\n\n\nint\n \n*\npointer_variable\n \n=\n \n&\npotential_const_int\n;\n \n// Before transformation\n\n\nint\n \nconst\n*\nconst\n \npointer_variable\n \n=\n \n&\npotential_const_int\n;\n \n// After transformation, both pointer itself and pointee are supported.\n\n\nint\n \nlast_copy\n \n=\n \n*\npointer_variable\n;\n\nThe automatic code transformation is only applied to variables that are\ndeclared in single declarations. You may want to prepare your code base with\n\nreadability-isolate-declaration\n first.\n\nNote that there is the check\n\ncppcoreguidelines-avoid-non-const-global-variables\n\nto enforce \nconst\n correctness on all globals.\n\nLimitations\nÂ¶\n\n\nThe check does not run on \nC\n code.\n\n\nThe check will not analyze templated variables, template functions or variables\nthat are instantiation dependent. Different instantiations can result\nin different \nconst\n correctness properties and in general it is not\npossible to find all instantiations of a template. The template might\nbe used differently in an independent translation unit.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAnalyzeValues\nÂ¶\n\n\nEnable or disable the analysis of ordinary value variables, like\n\nint\n \ni\n \n=\n \n42;\n. Default is \ntrue\n.\n\n\n// Warning\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n// No warning\n\n\nint\n \nconst\n \ni\n \n=\n \n42\n;\n\n\n\n// Warning\n\n\nint\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n// No warning\n\n\nint\n \nconst\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzeReferences\nÂ¶\n\n\nEnable or disable the analysis of reference variables, like\n\nint\n \n&ref\n \n=\n \ni;\n. Default is \ntrue\n.\n\n\nint\n \ni\n \n=\n \n42\n;\n\n\n// Warning\n\n\nint\n&\n \nref\n \n=\n \ni\n;\n\n\n// No warning\n\n\nint\n \nconst\n&\n \nref\n \n=\n \ni\n;\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzePointers\nÂ¶\n\n\nEnable or disable the analysis of pointers variables, like\n\nint\n \n*ptr\n \n=\n \n&i;\n. For specific checks, see\n\nWarnPointersAsValues\n and \nWarnPointersAsPointers\n.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nAnalyzeParameters\nÂ¶\n\n\nEnable or disable the analysis of function parameters, like\n\nvoid\n \nfoo(int*\n \nptr)\n. Only reference and pointer parameters are analyzed.\nCurrently, member functions (including constructors) and lambdas are excluded\nfrom the analysis. Default is \ntrue\n.\n\n\n// Warning\n\n\nvoid\n \nfunction\n(\nint\n&\n \nparam\n)\n \n{}\n\n\n// No warning\n\n\nvoid\n \nfunction\n(\nconst\n \nint\n&\n \nparam\n)\n \n{}\n\n\n\n\n\n\n\n\n\n\n\n\nWarnPointersAsValues\nÂ¶\n\n\nThis option enables the suggestion for \nconst\n of the pointer itself.\nPointer values have two possibilities to be \nconst\n, the pointer\nand the value pointing to. Default is \nfalse\n.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Warning\n\n\nconst\n \nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// No warning\n\n\nconst\n \nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n\n\n\n\n\n\n\n\n\nWarnPointersAsPointers\nÂ¶\n\n\nThis option enables the suggestion for \nconst\n of the value pointing to.\nDefault is \ntrue\n.\n\n\nRequires \nAnalyzePointers\n to be \ntrue\n.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// No warning\n\n\nconst\n \nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// Warning\n\n\nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformValues\nÂ¶\n\n\nProvides fixit-hints for value types that automatically add \nconst\n if\nits a single declaration. Default is \ntrue\n.\n\n\n// Before\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n// After\n\n\nint\n \nconst\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Before\n\n\nint\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n// After\n\n\nint\n \nconst\n \na\n[]\n \n=\n \n{\n42\n,\n \n42\n,\n \n42\n};\n\n\n\n// Result is modified later in its life-time. No diagnostic and fixit hint will be emitted.\n\n\nint\n \nresult\n \n=\n \nvalue\n \n*\n \n3\n;\n\n\nresult\n \n-=\n \n10\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformReferences\nÂ¶\n\n\nProvides fixit-hints for reference types that automatically add \nconst\n if\nits a single declaration. Default is \ntrue\n.\n\n\n// This variable could still be a constant. But because there is a non-const reference to\n\n\n// it, it can not be transformed (yet).\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n// The reference 'ref_value' is not modified and can be made 'const int &ref_value = value;'\n\n\n// Before\n\n\nint\n \n&\nref_value\n \n=\n \nvalue\n;\n\n\n// After\n\n\nint\n \nconst\n \n&\nref_value\n \n=\n \nvalue\n;\n\n\n\n// Result is modified later in its life-time. No diagnostic and fixit hint will be emitted.\n\n\nint\n \nresult\n \n=\n \nref_value\n \n*\n \n3\n;\n\n\nresult\n \n-=\n \n10\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformPointersAsValues\nÂ¶\n\n\nProvides fixit-hints for pointers if their pointee is not changed. This does\nnot analyze if the value-pointed-to is unchanged! Default is \nfalse\n.\n\n\nRequires âWarnPointersAsValuesâ to be âtrueâ.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Before\n\n\nconst\n \nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// After\n\n\nconst\n \nint\n \n*\nconst\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n// Before\n\n\nconst\n \nint\n \n*\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n// After\n\n\nconst\n \nint\n \n*\nconst\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n\n// Before\n\n\nint\n \n*\nptr_value\n \n=\n \n&\nvalue\n;\n\n\n// After\n\n\nint\n \n*\nconst\n \nptr_value\n \n=\n \n&\nvalue\n;\n\n\n\nint\n \nresult\n \n=\n \n100\n \n*\n \n(\n*\nptr_value\n);\n \n// Does not modify the pointer itself.\n\n\n// This modification of the pointee is still allowed and not diagnosed.\n\n\n*\nptr_value\n \n=\n \n0\n;\n\n\n\n// The following pointer may not become a 'int *const'.\n\n\nint\n \n*\nchanging_pointee\n \n=\n \n&\nvalue\n;\n\n\nchanging_pointee\n \n=\n \n&\nresult\n;\n\n\n\n\n\n\n\n\n\n\n\n\nTransformPointersAsPointers\nÂ¶\n\n\nProvides fix-it hints for pointers if the value it pointing to is not changed.\nDefault is \nfalse\n.\n\n\nRequires \nWarnPointersAsPointers\n to be \ntrue\n.\n\n\nint\n \nvalue\n \n=\n \n42\n;\n\n\n\n// Before\n\n\nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n// After\n\n\nconst\n \nint\n \n*\n \npointer_variable\n \n=\n \n&\nvalue\n;\n\n\n\n// Before\n\n\nint\n \n*\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n// After\n\n\nconst\n \nint\n \n*\n \na\n[]\n \n=\n \n{\n&\nvalue\n,\n \n&\nvalue\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types that will be excluded from\nconst-correctness checking. Regular expressions are accepted, e.g.\n\n[Rr]ef(erence)?$\n matches every type with suffix \nRef\n, \nref\n,\n\nReference\n and \nreference\n. If a name in the list contains the sequence\n\n::\n, it is matched against the qualified type name\n(i.e. \nnamespace::Type\n), otherwise it is matched against only the type\nname (i.e. \nType\n). Default is empty string.",
    "configurations": []
  }
}