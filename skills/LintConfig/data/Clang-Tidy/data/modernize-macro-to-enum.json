{
  "name": "modernize-macro-to-enum",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/macro-to-enum.html",
    "fixable": true
  },
  "content": {
    "introduction": "Replaces groups of adjacent macros with an unscoped anonymous enum.\nUsing an unscoped anonymous enum ensures that everywhere the macro\ntoken was used previously, the enumerator name may be safely used.\n\nThis check can be used to enforce the C++ core guideline \nEnum.1:\nPrefer enumerations over macros\n,\nwithin the constraints outlined below.\n\nPotential macros for replacement must meet the following constraints:\n\nMacros must expand only to integral literal tokens or expressions\nof literal tokens.  The expression may contain any of the unary\noperators \n-\n, \n+\n, \n~\n or \n!\n, any of the binary operators\n\n,\n, \n-\n, \n+\n, \n*\n, \n/\n, \n%\n, \n&\n, \n|\n, \n^\n, \n<\n,\n\n>\n, \n<=\n, \n>=\n, \n==\n, \n!=\n, \n||\n, \n&&\n, \n<<\n, \n>>\n\nor \n<=>\n, the ternary operator \n?:\n and its\n\nGNU extension\n.\nParenthesized expressions are also recognized.  This recognizes\nmost valid expressions.  In particular, expressions with the\n\nsizeof\n operator are not recognized.\n\n\nMacros must be defined on sequential source file lines, or with\nonly comment lines in between macro definitions.\n\n\nMacros must all be defined in the same source file.\n\n\nMacros must not be defined within a conditional compilation block.\n(Conditional include guards are exempt from this constraint.)\n\n\nMacros must not be defined adjacent to other preprocessor directives.\n\n\nMacros must not be used in any conditional preprocessing directive.\n\n\nMacros must not be used as arguments to other macros.\n\n\nMacros must not be undefined.\n\n\nMacros must be defined at the top-level, not inside any declaration or\ndefinition.\n\nEach cluster of macros meeting the above constraints is presumed to\nbe a set of values suitable for replacement by an anonymous enum.\nFrom there, a developer can give the anonymous enum a name and\ncontinue refactoring to a scoped enum if desired.  Comments on the\nsame line as a macro definition or between subsequent macro definitions\nare preserved in the output.  No formatting is assumed in the provided\nreplacements, although clang-tidy can optionally format all fixes.\n\nWarning\n\n\nInitializing expressions are assumed to be valid initializers for\nan enum.  C requires that enum values fit into an \nint\n, but\nthis may not be the case for some accepted constant expressions.\nFor instance \n1\n \n<<\n \n40\n will not fit into an \nint\n when the size of\nan \nint\n is 32 bits.\n\nExamples:\n\n#define RED   0xFF0000\n\n\n#define GREEN 0x00FF00\n\n\n#define BLUE  0x0000FF\n\n\n\n#define TM_NONE (-1) \n// No method selected.\n\n\n#define TM_ONE 1    \n// Use tailored method one.\n\n\n#define TM_TWO 2    \n// Use tailored method two.  Method two\n\n\n                    \n// is preferable to method one.\n\n\n#define TM_THREE 3  \n// Use tailored method three.\n\nbecomes\n\nenum\n \n{\n\n\nRED\n \n=\n \n0xFF0000\n,\n\n\nGREEN\n \n=\n \n0x00FF00\n,\n\n\nBLUE\n \n=\n \n0x0000FF\n\n\n};\n\n\n\nenum\n \n{\n\n\nTM_NONE\n \n=\n \n(\n-1\n),\n \n// No method selected.\n\n\nTM_ONE\n \n=\n \n1\n,\n    \n// Use tailored method one.\n\n\nTM_TWO\n \n=\n \n2\n,\n    \n// Use tailored method two.  Method two\n\n\n                    \n// is preferable to method one.\n\n\nTM_THREE\n \n=\n \n3\n  \n// Use tailored method three.\n\n\n};",
    "configurations": []
  }
}