{
  "name": "readability-implicit-bool-conversion",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/implicit-bool-conversion.html",
    "fixable": true
  },
  "content": {
    "introduction": "This check can be used to find implicit conversions between built-in types and\nbooleans. Depending on use case, it may simply help with readability of the\ncode, or in some cases, point to potential bugs which remain unnoticed due to\nimplicit conversions.\n\nThe following is a real-world example of bug which was hiding behind implicit\n\nbool\n conversion:\n\nclass\n \nFoo\n \n{\n\n\n  \nint\n \nm_foo\n;\n\n\n\npublic\n:\n\n\n  \nvoid\n \nsetFoo\n(\nbool\n \nfoo\n)\n \n{\n \nm_foo\n \n=\n \nfoo\n;\n \n}\n \n// warning: implicit conversion bool -> int\n\n\n  \nint\n \ngetFoo\n()\n \n{\n \nreturn\n \nm_foo\n;\n \n}\n\n\n};\n\n\n\nvoid\n \nuse\n(\nFoo\n&\n \nfoo\n)\n \n{\n\n\n  \nbool\n \nvalue\n \n=\n \nfoo\n.\ngetFoo\n();\n \n// warning: implicit conversion int -> bool\n\n\n}\n\nThis code is the result of unsuccessful refactoring, where type of \nm_foo\n\nchanged from \nbool\n to \nint\n. The programmer forgot to change all\noccurrences of \nbool\n, and the remaining code is no longer correct, yet it\nstill compiles without any visible warnings.\n\nIn addition to issuing warnings, fix-it hints are provided to help solve the\nreported issues. This can be used for improving readability of code, for\nexample:\n\nvoid\n \nconversionsToBool\n()\n \n{\n\n\n  \nfloat\n \nfloating\n;\n\n\n  \nbool\n \nboolean\n \n=\n \nfloating\n;\n\n\n  \n// ^ propose replacement: bool boolean = floating != 0.0f;\n\n\n\n  \nint\n \ninteger\n;\n\n\n  \nif\n \n(\ninteger\n)\n \n{}\n\n\n  \n// ^ propose replacement: if (integer != 0) {}\n\n\n\n  \nint\n*\n \npointer\n;\n\n\n  \nif\n \n(\n!\npointer\n)\n \n{}\n\n\n  \n// ^ propose replacement: if (pointer == nullptr) {}\n\n\n\n  \nwhile\n \n(\n1\n)\n \n{}\n\n\n  \n// ^ propose replacement: while (true) {}\n\n\n}\n\n\n\nvoid\n \nfunctionTakingInt\n(\nint\n \nparam\n);\n\n\n\nvoid\n \nconversionsFromBool\n()\n \n{\n\n\n  \nbool\n \nboolean\n;\n\n\n  \nfunctionTakingInt\n(\nboolean\n);\n\n\n  \n// ^ propose replacement: functionTakingInt(static_cast<int>(boolean));\n\n\n\n  \nfunctionTakingInt\n(\ntrue\n);\n\n\n  \n// ^ propose replacement: functionTakingInt(1);\n\n\n}\n\nIn general, the following conversion types are checked:\n\ninteger expression/literal to boolean (conversion from a single bit bitfield\nto boolean is explicitly allowed, since thereâs no ambiguity / information\nloss in this case),\n\n\nfloating expression/literal to boolean,\n\n\npointer/pointer to member/\nnullptr\n/\nNULL\n to boolean,\n\n\nboolean expression/literal to integer (conversion from boolean to a single\nbit bitfield is explicitly allowed),\n\n\nboolean expression/literal to floating.\n\nThe rules for generating fix-it hints are:\n\nin case of conversions from other built-in type to bool, an explicit\ncomparison is proposed to make it clear what exactly is being compared:\n\n\n\n\nbool\n \nboolean\n \n=\n \nfloating;\n is changed to\n\nbool\n \nboolean\n \n=\n \nfloating\n \n==\n \n0.0f;\n,\n\n\nfor other types, appropriate literals are used (\n0\n, \n0u\n, \n0.0f\n,\n\n0.0\n, \nnullptr\n),\n\n\n\n\n\n\nin case of negated expressions conversion to bool, the proposed replacement\nwith comparison is simplified:\n\n\n\n\nif\n \n(!pointer)\n is changed to \nif\n \n(pointer\n \n==\n \nnullptr)\n,\n\n\n\n\n\n\nin case of conversions from bool to other built-in types, an explicit\n\nstatic_cast\n (or a C-style cast since C23) is proposed to make it clear\nthat a conversion is taking place:\n\n\n\n\nint\n \ninteger\n \n=\n \nboolean;\n is changed to\n\nint\n \ninteger\n \n=\n \nstatic_cast<int>(boolean);\n,\n\n\n\n\n\n\nif the conversion is performed on type literals, an equivalent literal is\nproposed, according to what type is actually expected, for example:\n\n\n\n\nfunctionTakingBool(0);\n is changed to \nfunctionTakingBool(false);\n,\n\n\nfunctionTakingInt(true);\n is changed to \nfunctionTakingInt(1);\n,\n\n\nfor other types, appropriate literals are used (\nfalse\n, \ntrue\n, \n0\n,\n\n1\n, \n0u\n, \n1u\n, \n0.0f\n, \n1.0f\n, \n0.0\n, \n1.0f\n).\n\nSome additional accommodations are made for pre-C++11 dialects:\n\nfalse\n literal conversion to pointer is detected,\n\n\ninstead of \nnullptr\n literal, \n0\n is proposed as replacement.\n\nSome additional accommodations are made for C:\n\nbool\n (or \n_Bool\n) operands in logical operators (\n&&\n, \n||\n) are\nignored.\n\nOccurrences of implicit conversions inside macros and template instantiations\nare deliberately ignored, as it is not clear how to deal with such cases.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowIntegerConditions\nÂ¶\n\n\nWhen \ntrue\n, the check will allow conditional integer conversions. Default\nis \nfalse\n.\n\n\n\n\n\n\n\n\nAllowPointerConditions\nÂ¶\n\n\nWhen \ntrue\n, the check will allow conditional pointer conversions. Default\nis \nfalse\n.\n\n\n\n\n\n\n\n\nUseUpperCaseLiteralSuffix\nÂ¶\n\n\nWhen \ntrue\n, the replacements will use an uppercase literal suffix in the\nprovided fixes. Default is \nfalse\n.\n\n\n\n\nExample\n\n\nuint32_t\n \nfoo\n;\n\n\nif\n \n(\nfoo\n)\n \n{}\n\n\n// ^ propose replacement default: if (foo != 0u) {}\n\n\n// ^ propose replacement with option `UseUpperCaseLiteralSuffix`: if (foo != 0U) {}",
    "configurations": []
  }
}