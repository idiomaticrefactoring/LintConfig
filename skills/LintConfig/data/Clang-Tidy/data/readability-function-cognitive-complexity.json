{
  "name": "readability-function-cognitive-complexity",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/function-cognitive-complexity.html",
    "fixable": false
  },
  "content": {
    "introduction": "Checks function Cognitive Complexity metric.\n\nThe metric is implemented as per the \nCOGNITIVE COMPLEXITY by SonarSource\n specification\nversion 1.2 (19 April 2017).\n\nOptions\nÂ¶\n\n\n\n\n\n\nThreshold\nÂ¶\n\n\nFlag functions with Cognitive Complexity exceeding this number.\nThe default is \n25\n.\n\n\n\n\n\n\n\n\nDescribeBasicIncrements\nÂ¶\n\n\nIf set to \ntrue\n, then for each function exceeding the complexity threshold\nthe check will issue additional diagnostics on every piece of code (loop,\n\nif\n statement, etc.) which contributes to that complexity. See also the\nexamples below. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf set to \ntrue\n, the check will ignore code inside macros. Note, that also\nany macro arguments are ignored, even if they should count to the complexity.\nAs this might change in the future, this option isnât guaranteed to be\nforward-compatible. Default is \nfalse\n.\n\nBuilding blocks\nÂ¶\n\n\nThere are three basic building blocks of a Cognitive Complexity metric:\n\n\n\n\nIncrement\nÂ¶\n\n\nThe following structures increase the functionâs Cognitive Complexity metric\n(by \n1\n):\n\n\n\n\nConditional operators:\n\n\n\n\n\n\nif()\n\n\nelse\n \nif()\n\n\nelse\n\n\ncond\n \n?\n \ntrue\n \n:\n \nfalse\n\n\n\n\n\n\n\n\nswitch()\n\n\nLoops:\n\n\n\n\n\n\nfor()\n\n\nC++11 range-based \nfor()\n\n\nwhile()\n\n\ndo\n \nwhile()\n\n\n\n\n\n\n\n\ncatch\n \n()\n\n\ngoto\n \nLABEL\n, \ngoto\n \n*(&&LABEL))\n,\n\n\nsequences of binary logical operators:\n\n\n\n\n\n\nboolean1\n \n||\n \nboolean2\n\n\nboolean1\n \n&&\n \nboolean2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNesting level\nÂ¶\n\n\nWhile by itself the nesting level does not change the functionâs Cognitive\nComplexity metric, it is tracked, and is used by the next, third building\nblock. The following structures increase the nesting level (by \n1\n):\n\n\n\n\nConditional operators:\n\n\n\n\n\n\nif()\n\n\nelse\n \nif()\n\n\nelse\n\n\ncond\n \n?\n \ntrue\n \n:\n \nfalse\n\n\n\n\n\n\n\n\nswitch()\n\n\nLoops:\n\n\n\n\n\n\nfor()\n\n\nC++11 range-based \nfor()\n\n\nwhile()\n\n\ndo\n \nwhile()\n\n\n\n\n\n\n\n\ncatch\n \n()\n\n\nNested functions:\n\n\n\n\n\n\nC++11 Lambda\n\n\nNested \nclass\n\n\nNested \nstruct\n\n\n\n\n\n\n\n\nGNU statement expression\n\n\nApple Block Declaration\n\n\n\n\n\n\n\n\nNesting increment\nÂ¶\n\n\nThis is where the previous basic building block, \nNesting level\n, matters.\nThe following structures increase the functionâs Cognitive Complexity metric by\nthe current \nNesting level\n:\n\n\n\n\nConditional operators:\n\n\n\n\n\n\nif()\n\n\ncond\n \n?\n \ntrue\n \n:\n \nfalse\n\n\n\n\n\n\n\n\nswitch()\n\n\nLoops:\n\n\n\n\n\n\nfor()\n\n\nC++11 range-based \nfor()\n\n\nwhile()\n\n\ndo\n \nwhile()\n\n\n\n\n\n\n\n\ncatch\n \n()\n\nExamples\nÂ¶\n\n\nThe simplest case. This function has Cognitive Complexity of \n0\n.\n\n\nvoid\n \nfunction0\n()\n \n{}\n\n\n\n\n\n\nSlightly better example. This function has Cognitive Complexity of \n1\n.\n\n\nint\n \nfunction1\n(\nbool\n \nvar\n)\n \n{\n\n\n  \nif\n(\nvar\n)\n \n// +1, nesting level +1\n\n\n    \nreturn\n \n42\n;\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nFull example. This function has Cognitive Complexity of \n3\n.\n\n\nint\n \nfunction3\n(\nbool\n \nvar1\n,\n \nbool\n \nvar2\n)\n \n{\n\n\n  \nif\n(\nvar1\n)\n \n{\n \n// +1, nesting level +1\n\n\n    \nif\n(\nvar2\n)\n  \n// +2 (1 + current nesting level of 1), nesting level +1\n\n\n      \nreturn\n \n42\n;\n\n\n  \n}\n\n\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nIn the last example, the check will flag \nfunction3\n if the option Threshold is\nset to \n2\n or smaller. If the option DescribeBasicIncrements is set to \ntrue\n,\nit will additionally flag the two \nif\n statements with the amounts by which they\nincrease to the complexity of the function and the current nesting level.\n\nLimitations\nÂ¶\n\n\n\n\nThe metric is implemented with two notable exceptions:\n\n\npreprocessor conditionals\n (\n#ifdef\n, \n#if\n, \n#elif\n, \n#else\n,\n\n#endif\n) are not accounted for.\n\n\neach method in a recursion cycle\n is not accounted for. It canât be fully\nimplemented, because cross-translational-unit analysis would be needed,\nwhich is currently not possible in clang-tidy.",
    "configurations": []
  }
}