{
  "name": "readability-reference-to-constructed-temporary",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/reference-to-constructed-temporary.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects C++ code where a reference variable is used to extend the lifetime of\na temporary object that has just been constructed.\n\nThis construction is often the result of multiple code refactorings or a lack\nof developer knowledge, leading to confusion or subtle bugs. In most cases,\nwhat the developer really wanted to do is create a new variable rather than\nextending the lifetime of a temporary object.\n\nExamples of problematic code include:\n\nconst\n \nstd\n::\nstring\n&\n \nstr\n(\n\"hello\"\n);\n\n\n\nstruct\n \nPoint\n \n{\n \nint\n \nx\n;\n \nint\n \ny\n;\n \n};\n\n\nconst\n \nPoint\n&\n \np\n \n=\n \n{\n \n1\n,\n \n2\n \n};\n\nIn the first example, a \nconst\n \nstd::string&\n reference variable \nstr\n is\nassigned a temporary object created by the \nstd::string(\"hello\")\n\nconstructor. In the second example, a \nconst\n \nPoint&\n reference variable \np\n\nis assigned an object that is constructed from an initializer list\n\n{\n \n1,\n \n2\n \n}\n. Both of these examples extend the lifetime of the temporary\nobject to the lifetime of the reference variable, which can make it difficult\nto reason about and may lead to subtle bugs or misunderstanding.\n\nTo avoid these issues, it is recommended to change the reference variable to a\n(\nconst\n) value variable.",
    "configurations": []
  }
}