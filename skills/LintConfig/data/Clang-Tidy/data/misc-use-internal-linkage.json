{
  "name": "misc-use-internal-linkage",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/use-internal-linkage.html",
    "fixable": true
  },
  "content": {
    "introduction": "Detects variables, functions, and classes that can be marked as static or\n(in C++) moved into an anonymous namespace to enforce internal linkage.\n\nAny entity thatâs only used within a single file should be given internal\nlinkage. Doing so gives the compiler more information, allowing it to better\nremove dead code and perform more aggressive optimizations.\n\nExample:\n\nint\n \nv1\n;\n \n// can be marked as static\n\n\n\nvoid\n \nfn1\n()\n \n{}\n \n// can be marked as static\n\n\n\n// already declared as extern\n\n\nextern\n \nint\n \nv2\n;\n\n\n\nvoid\n \nfn3\n();\n \n// without function body in all declaration, maybe external linkage\n\n\nvoid\n \nfn3\n();\n\n\n\n// === C++-specific ===\n\n\n\nstruct\n \nS1\n \n{};\n \n// can be moved into anonymous namespace\n\n\n\nnamespace\n \n{\n\n\n  \n// already in anonymous namespace\n\n\n  \nint\n \nv2\n;\n\n\n  \nvoid\n \nfn2\n();\n\n\n  \nstruct\n \nS2\n \n{};\n\n\n}\n\n\n\n// export declarations\n\n\nexport\n \nvoid\n \nfn4\n()\n \n{}\n\n\nexport\n \nnamespace\n \nt\n \n{\n \nvoid\n \nfn5\n()\n \n{}\n \n}\n\n\nexport\n \nint\n \nv2\n;\n\n\nexport\n \nclass\n \nC\n \n{};\n\nOptions\nÂ¶\n\n\n\n\n\n\nFixMode\nÂ¶\n\n\nSelects what kind of a fix the check should provide. The default is \nUseStatic\n.\n\n\n\n\nNone\n\nDonât fix automatically.\n\n\nUseStatic\n\nAdd \nstatic\n for internal linkage variable and function.\n\n\n\n\n\n\n\n\n\n\nAnalyzeFunctions\nÂ¶\n\n\nWhether to suggest giving functions internal linkage. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nAnalyzeVariables\nÂ¶\n\n\nWhether to suggest giving variables internal linkage. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nAnalyzeTypes\nÂ¶\n\n\n(C++ only) Whether to suggest giving user-defined types (structs,\nclasses, unions, and enums) internal linkage. Default is \ntrue\n.",
    "configurations": []
  }
}