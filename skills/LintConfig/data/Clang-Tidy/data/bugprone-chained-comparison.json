{
  "name": "bugprone-chained-comparison",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/chained-comparison.html",
    "fixable": false
  },
  "content": {
    "introduction": "Check detects chained comparison operators that can lead to unintended\nbehavior or logical errors.\n\nChained comparisons are expressions that use multiple comparison operators\nto compare three or more values. For example, the expression \na\n \n<\n \nb\n \n<\n \nc\n\ncompares the values of \na\n, \nb\n, and \nc\n. However, this expression does\nnot evaluate as \n(a\n \n<\n \nb)\n \n&&\n \n(b\n \n<\n \nc)\n, which is probably what the developer\nintended. Instead, it evaluates as \n(a\n \n<\n \nb)\n \n<\n \nc\n, which may produce\nunintended results, especially when the types of \na\n, \nb\n, and \nc\n are\ndifferent.\n\nTo avoid such errors, the check will issue a warning when a chained\ncomparison operator is detected, suggesting to use parentheses to specify\nthe order of evaluation or to use a logical operator to separate comparison\nexpressions.\n\nConsider the following examples:\n\nint\n \na\n \n=\n \n2\n,\n \nb\n \n=\n \n6\n,\n \nc\n \n=\n \n4\n;\n\n\nif\n \n(\na\n \n<\n \nb\n \n<\n \nc\n)\n \n{\n\n\n    \n// This block will be executed\n\n\n}\n\nIn this example, the developer intended to check if \na\n is less than \nb\n\nand \nb\n is less than \nc\n. However, the expression \na\n \n<\n \nb\n \n<\n \nc\n is\nequivalent to \n(a\n \n<\n \nb)\n \n<\n \nc\n. Since \na\n \n<\n \nb\n is \ntrue\n, the expression\n\n(a\n \n<\n \nb)\n \n<\n \nc\n is evaluated as \n1\n \n<\n \nc\n, which is equivalent to \ntrue\n \n<\n \nc\n\nand is invalid in this case as \nb\n \n<\n \nc\n is \nfalse\n.\n\nEven that above issue could be detected as comparison of \nint\n to \nbool\n,\nthere is more dangerous example:\n\nbool\n \na\n \n=\n \nfalse\n,\n \nb\n \n=\n \nfalse\n,\n \nc\n \n=\n \ntrue\n;\n\n\nif\n \n(\na\n \n==\n \nb\n \n==\n \nc\n)\n \n{\n\n\n    \n// This block will be executed\n\n\n}\n\nIn this example, the developer intended to check if \na\n, \nb\n, and \nc\n are\nall equal. However, the expression \na\n \n==\n \nb\n \n==\n \nc\n is evaluated as\n\n(a\n \n==\n \nb)\n \n==\n \nc\n. Since \na\n \n==\n \nb\n is true, the expression \n(a\n \n==\n \nb)\n \n==\n \nc\n\nis evaluated as \ntrue\n \n==\n \nc\n, which is equivalent to \ntrue\n \n==\n \ntrue\n.\nThis comparison yields \ntrue\n, even though \na\n and \nb\n are \nfalse\n, and\nare not equal to \nc\n.\n\nTo avoid this issue, the developer can use a logical operator to separate the\ncomparison expressions, like this:\n\nif\n \n(\na\n \n==\n \nb\n \n&&\n \nb\n \n==\n \nc\n)\n \n{\n\n\n    \n// This block will not be executed\n\n\n}\n\nAlternatively, use of parentheses in the comparison expressions can make the\ndeveloperâs intention more explicit and help avoid misunderstanding.\n\nif\n \n((\na\n \n==\n \nb\n)\n \n==\n \nc\n)\n \n{\n\n\n    \n// This block will be executed\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreMacros\nÂ¶\n\n\nIf \ntrue\n, the check will not warn on chained comparisons inside macros.\nDefault is \nfalse\n.",
    "configurations": []
  }
}