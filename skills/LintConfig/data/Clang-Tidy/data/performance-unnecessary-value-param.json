{
  "name": "performance-unnecessary-value-param",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/unnecessary-value-param.html",
    "fixable": true
  },
  "content": {
    "introduction": "Flags value parameter declarations of expensive to copy types that are copied\nfor each invocation but it would suffice to pass them by const reference.\n\nThe check is only applied to parameters of types that are expensive to copy\nwhich means they are not trivially copyable or have a non-trivial copy\nconstructor or destructor.\n\nTo ensure that it is safe to replace the value parameter with a const reference\nthe following heuristic is employed:\n\nthe parameter is const qualified;\n\n\nthe parameter is not const, but only const methods or operators are invoked\non it, or it is used as const reference or value argument in constructors or\nfunction calls.\n\nExample:\n\nvoid\n \nf\n(\nconst\n \nstring\n \nValue\n)\n \n{\n\n\n  \n// The warning will suggest making Value a reference.\n\n\n}\n\n\n\nvoid\n \ng\n(\nExpensiveToCopy\n \nValue\n)\n \n{\n\n\n  \n// The warning will suggest making Value a const reference.\n\n\n  \nValue\n.\nConstMethd\n();\n\n\n  \nExpensiveToCopy\n \nCopy\n(\nValue\n);\n\n\n}\n\nIf the parameter is not const, only copied or assigned once and has a\nnon-trivial move-constructor or move-assignment operator respectively the check\nwill suggest to move it.\n\nExample:\n\nvoid\n \nsetValue\n(\nstring\n \nValue\n)\n \n{\n\n\n  \nField\n \n=\n \nValue\n;\n\n\n}\n\nWill become:\n\n#include\n \n<utility>\n\n\n\nvoid\n \nsetValue\n(\nstring\n \nValue\n)\n \n{\n\n\n  \nField\n \n=\n \nstd\n::\nmove\n(\nValue\n);\n\n\n}\n\nBecause the fix-it needs to change the signature of the function, it may break\nbuilds if the function is used in multiple translation units or some codes\ndepends on function signatures.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types allowed to be passed by value.\nRegular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n matches every\ntype with suffix \nRef\n, \nref\n, \nReference\n and \nreference\n. The\ndefault is empty. If a name in the list contains the sequence \n::\n, it is\nmatched against the qualified type name (i.e. \nnamespace::Type\n),\notherwise it is matched against only the type name (i.e. \nType\n).\n\n\n\n\n\n\n\n\nIgnoreCoroutines\nÂ¶\n\n\nA boolean specifying whether the check should suggest passing parameters by\nreference in coroutines. Passing parameters by reference in coroutines may\nnot be safe, please see \ncppcoreguidelines-avoid-reference-coroutine-parameters\n\nfor more information. Default is \ntrue\n.",
    "configurations": []
  }
}