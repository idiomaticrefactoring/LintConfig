{
  "name": "readability-isolate-declaration",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/isolate-declaration.html",
    "fixable": true
  },
  "content": {
    "introduction": "Detects local variable declarations declaring more than one variable and\ntries to refactor the code to one statement per declaration.\n\nThe automatic code-transformation will use the same indentation as the original\nfor every created statement and add a line break after each statement.\nIt keeps the order of the variable declarations consistent, too.\n\nvoid\n \nf\n()\n \n{\n\n\n  \nint\n \n*\n \npointer\n \n=\n \nnullptr\n,\n \nvalue\n \n=\n \n42\n,\n \n*\n \nconst\n \nconst_ptr\n \n=\n \n&\nvalue\n;\n\n\n  \n// This declaration will be diagnosed and transformed into:\n\n\n  \n// int * pointer = nullptr;\n\n\n  \n// int value = 42;\n\n\n  \n// int * const const_ptr = &value;\n\n\n}\n\nThe check excludes places where it is necessary or common to declare\nmultiple variables in one statement and there is no other way supported in the\nlanguage. Please note that structured bindings are not considered.\n\n// It is not possible to transform this declaration and doing the declaration\n\n\n// before the loop will increase the scope of the variable 'Begin' and 'End'\n\n\n// which is undesirable.\n\n\nfor\n \n(\nint\n \nBegin\n \n=\n \n0\n,\n \nEnd\n \n=\n \n100\n;\n \nBegin\n \n<\n \nEnd\n;\n \n++\nBegin\n);\n\n\nif\n \n(\nint\n \nBegin\n \n=\n \n42\n,\n \nResult\n \n=\n \nsome_function\n(\nBegin\n);\n \nBegin\n \n==\n \nResult\n);\n\n\n\n// It is not possible to transform this declaration because the result is\n\n\n// not functionality preserving as 'j' and 'k' would not be part of the\n\n\n// 'if' statement anymore.\n\n\nif\n \n(\nSomeCondition\n())\n\n\n  \nint\n \ni\n \n=\n \n42\n,\n \nj\n \n=\n \n43\n,\n \nk\n \n=\n \nfunction\n(\ni\n,\nj\n);\n\nLimitations\nÂ¶\n\n\nGlobal variables and member variables are excluded.\n\n\nThe check currently does not support the automatic transformation of\nmember-pointer-types.\n\n\nstruct\n \nS\n \n{\n\n\n  \nint\n \na\n;\n\n\n  \nconst\n \nint\n \nb\n;\n\n\n  \nvoid\n \nf\n()\n \n{}\n\n\n};\n\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \n// Only a diagnostic message is emitted\n\n\n  \nint\n \nS\n::*\np\n \n=\n \n&\nS\n::\na\n,\n \nS\n::*\nconst\n \nq\n \n=\n \n&\nS\n::\na\n;\n\n\n}\n\n\n\n\n\n\nFurthermore, the transformation is very cautious when it detects various kinds\nof macros or preprocessor directives in the range of the statement. In this\ncase the transformation will not happen to avoid unexpected side-effects due to\nmacros.\n\n\n#define NULL 0\n\n\n#define MY_NICE_TYPE int **\n\n\n#define VAR_NAME(name) name##__LINE__\n\n\n#define A_BUNCH_OF_VARIABLES int m1 = 42, m2 = 43, m3 = 44;\n\n\n\nvoid\n \nmacros\n()\n \n{\n\n\n  \nint\n \n*\np1\n \n=\n \nNULL\n,\n \n*\np2\n \n=\n \nNULL\n;\n\n\n  \n// Will be transformed to\n\n\n  \n// int *p1 = NULL;\n\n\n  \n// int *p2 = NULL;\n\n\n\n  \nMY_NICE_TYPE\n \np3\n,\n \nv1\n,\n \nv2\n;\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n\n  \nint\n \nVAR_NAME\n(\nv3\n),\n\n\n      \nVAR_NAME\n(\nv4\n),\n\n\n      \nVAR_NAME\n(\nv5\n);\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n\n  \nA_BUNCH_OF_VARIABLES\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n\n  \nint\n \nUnconditional\n,\n\n\n#if CONFIGURATION\n\n\n      \nIfConfigured\n \n=\n \n42\n,\n\n\n#else\n\n\n      \nIfConfigured\n \n=\n \n0\n;\n\n\n#endif\n\n\n  \n// Won't be transformed, but a diagnostic is emitted.\n\n\n}",
    "configurations": []
  }
}