{
  "name": "bugprone-compare-pointer-to-member-virtual-function",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/compare-pointer-to-member-virtual-function.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects unspecified behavior about equality comparison between pointer to\nmember virtual function and anything other than null-pointer-constant.\n\nstruct\n \nA\n \n{\n\n\n  \nvoid\n \nf1\n();\n\n\n  \nvoid\n \nf2\n();\n\n\n  \nvirtual\n \nvoid\n \nf3\n();\n\n\n  \nvirtual\n \nvoid\n \nf4\n();\n\n\n\n  \nvoid\n \ng1\n(\nint\n);\n\n\n};\n\n\n\nvoid\n \nfn\n()\n \n{\n\n\n  \nbool\n \nr1\n \n=\n \n(\n&\nA\n::\nf1\n \n==\n \n&\nA\n::\nf2\n);\n  \n// ok\n\n\n  \nbool\n \nr2\n \n=\n \n(\n&\nA\n::\nf1\n \n==\n \n&\nA\n::\nf3\n);\n  \n// bugprone\n\n\n  \nbool\n \nr3\n \n=\n \n(\n&\nA\n::\nf1\n \n!=\n \n&\nA\n::\nf3\n);\n  \n// bugprone\n\n\n  \nbool\n \nr4\n \n=\n \n(\n&\nA\n::\nf3\n \n==\n \nnullptr\n);\n \n// ok\n\n\n  \nbool\n \nr5\n \n=\n \n(\n&\nA\n::\nf3\n \n==\n \n&\nA\n::\nf4\n);\n  \n// bugprone\n\n\n\n  \nvoid\n \n(\nA\n::*\nv1\n)()\n \n=\n \n&\nA\n::\nf3\n;\n\n\n  \nbool\n \nr6\n \n=\n \n(\nv1\n \n==\n \n&\nA\n::\nf1\n);\n \n// bugprone\n\n\n  \nbool\n \nr6\n \n=\n \n(\nv1\n \n==\n \nnullptr\n);\n \n// ok\n\n\n\n  \nvoid\n \n(\nA\n::*\nv2\n)()\n \n=\n \n&\nA\n::\nf2\n;\n\n\n  \nbool\n \nr7\n \n=\n \n(\nv2\n \n==\n \n&\nA\n::\nf1\n);\n \n// false positive, but potential risk if assigning other value to v2.\n\n\n\n  \nvoid\n \n(\nA\n::*\nv3\n)(\nint\n)\n \n=\n \n&\nA\n::\ng1\n;\n\n\n  \nbool\n \nr8\n \n=\n \n(\nv3\n \n==\n \n&\nA\n::\ng1\n);\n \n// ok, no virtual function match void(A::*)(int) signature.\n\n\n}\n\nProvide warnings on equality comparisons involve pointers to member virtual\nfunction or variables which is potential pointer to member virtual function and\nany entity other than a null-pointer constant.\n\nIn certain compilers, virtual function addresses are not conventional pointers\nbut instead consist of offsets and indexes within a virtual function table\n(vtable). Consequently, these pointers may vary between base and derived\nclasses, leading to unpredictable behavior when compared directly. This issue\nbecomes particularly challenging when dealing with pointers to pure virtual\nfunctions, as they may not even have a valid address, further complicating\ncomparisons.\n\nInstead, it is recommended to utilize the \ntypeid\n operator or other\nappropriate mechanisms for comparing objects to ensure robust and predictable\nbehavior in your codebase. By heeding this detection and adopting a more reliable\ncomparison method, you can mitigate potential issues related to unspecified\nbehavior, especially when dealing with pointers to member virtual functions or pure\nvirtual functions, thereby improving the overall stability and maintainability\nof your code. In scenarios involving pointers to member virtual functions, itâs\nonly advisable to employ \nnullptr\n for comparisons.\n\nLimitations\nÂ¶\n\n\nDoes not analyze values stored in a variable. For variable, only analyze all\nvirtual methods in the same \nclass\n or \nstruct\n and diagnose when assigning\na pointer to member virtual function to this variable is possible.",
    "configurations": []
  }
}