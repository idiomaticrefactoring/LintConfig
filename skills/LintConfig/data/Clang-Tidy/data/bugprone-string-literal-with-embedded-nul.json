{
  "name": "bugprone-string-literal-with-embedded-nul",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/string-literal-with-embedded-nul.html",
    "fixable": false
  },
  "content": {
    "introduction": "Finds occurrences of string literal with embedded NUL character and validates\ntheir usage.\n\nInvalid escaping\nÂ¶\n\n\nSpecial characters can be escaped within a string literal by using their\nhexadecimal encoding like \n\\x42\n. A common mistake is to escape them\nlike this \n\\0x42\n where the \n\\0\n stands for the NUL character.\n\n\nconst\n \nchar\n*\n \nExample\n[]\n \n=\n \n\"Invalid character: \n\\0\nx12 should be \n\\x12\n\"\n;\n\n\nconst\n \nchar\n*\n \nBytes\n[]\n \n=\n \n\"\n\\x03\\0\nx02\n\\0\nx01\n\\0\nx00\n\\0\nxFF\n\\0\nxFF\n\\0\nxFF\"\n;\n\nTruncated literal\nÂ¶\n\n\nString-like classes can manipulate strings with embedded NUL as they are\nkeeping track of the bytes and the length. This is not the case for a\n\nchar*\n (NUL-terminated) string.\n\n\nA common mistake is to pass a string-literal with embedded NUL to a string\nconstructor expecting a NUL-terminated string. The bytes after the first NUL\ncharacter are truncated.\n\n\nstd\n::\nstring\n \nstr\n(\n\"abc\n\\0\ndef\"\n);\n  \n// \"def\" is truncated\n\n\nstr\n \n+=\n \n\"\n\\0\n\"\n;\n                  \n// This statement is doing nothing\n\n\nif\n \n(\nstr\n \n==\n \n\"\n\\0\nabc\"\n)\n \nreturn\n;\n   \n// This expression is always true",
    "configurations": []
  }
}