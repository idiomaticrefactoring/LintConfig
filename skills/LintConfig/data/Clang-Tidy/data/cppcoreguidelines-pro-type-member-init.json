{
  "name": "cppcoreguidelines-pro-type-member-init",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-member-init.html",
    "fixable": true
  },
  "content": {
    "introduction": "The check flags user-provided constructor definitions that do not\ninitialize all fields that would be left in an undefined state by\ndefault construction, e.g. builtins, pointers and record types without\nuser-provided default constructors containing at least one such\ntype. If these fields arenât initialized, the constructor will leave\nsome of the memory in an undefined state.\n\nFor C++11 it suggests fixes to add in-class field initializers. For\nolder versions it inserts the field initializers into the constructor\ninitializer list. It will also initialize any direct base classes that\nneed to be zeroed in the constructor initializer list.\n\nThe check takes assignment of fields in the constructor body into\naccount but generates false positives for fields initialized in\nmethods invoked in the constructor body.\n\nThe check also flags variables with automatic storage duration that have record\ntypes without a user-provided constructor and are not initialized. The\nsuggested fix is to zero initialize the variable via \n{}\n for C++11 and\nbeyond or \n=\n \n{}\n for older language versions.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreArrays\nÂ¶\n\n\nIf set to \ntrue\n, the check will not warn about array members that are not\nzero-initialized during construction. For performance critical code, it may\nbe important to not initialize fixed-size array members. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nUseAssignment\nÂ¶\n\n\nIf set to \ntrue\n, the check will provide fix-its with literal initializers\n( \nint\n \ni\n \n=\n \n0;\n ) instead of curly braces ( \nint\n \ni{};\n ).\nDefault is \nfalse\n.\n\n\n\n\nThis rule is part of the \nType safety (Type.6)\n\nprofile from the C++ Core Guidelines.",
    "configurations": []
  }
}