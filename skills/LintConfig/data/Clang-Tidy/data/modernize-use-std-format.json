{
  "name": "modernize-use-std-format",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-format.html",
    "fixable": true
  },
  "content": {
    "introduction": "Converts calls to \nabsl::StrFormat\n, or other functions via\nconfiguration options, to C++20âs \nstd::format\n, or another function\nvia a configuration option, modifying the format string appropriately and\nremoving now-unnecessary calls to \nstd::string::c_str()\n and\n\nstd::string::data()\n.\n\nFor example, it turns lines like\n\nreturn\n \nabsl\n::\nStrFormat\n(\n\"The %s is %3d\"\n,\n \ndescription\n.\nc_str\n(),\n \nvalue\n);\n\ninto:\n\nreturn\n \nstd\n::\nformat\n(\n\"The {} is {:3}\"\n,\n \ndescription\n,\n \nvalue\n);\n\nThe check uses the same format-string-conversion algorithm as\n\nmodernize-use-std-print\n and its\nshortcomings and behaviour in combination with macros are described in the\ndocumentation for that check.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\n\n\nWhen \ntrue\n, the check will add casts when converting from variadic\nfunctions and printing signed or unsigned integer types (including\nfixed-width integer types from \n<cstdint>\n, \nptrdiff_t\n, \nsize_t\n\nand \nssize_t\n) as the opposite signedness to ensure that the output\nwould matches that of a simple wrapper for \nstd::sprintf\n that\naccepted a C-style variable argument list. For example, with\n\nStrictMode\n enabled,\n\n\n\n\nextern\n \nstd\n::\nstring\n \nstrprintf\n(\nconst\n \nchar\n \n*\nformat\n,\n \n...);\n\n\nint\n \ni\n \n=\n \n-42\n;\n\n\nunsigned\n \nint\n \nu\n \n=\n \n0xffffffff\n;\n\n\nreturn\n \nstrprintf\n(\n\"%u %d\n\\n\n\"\n,\n \ni\n,\n \nu\n);\n\n\n\n\n\n\nwould be converted to\n\n\nreturn\n \nstd\n::\nformat\n(\n\"{} {}\n\\n\n\"\n,\n \nstatic_cast\n<\nunsigned\n \nint\n>\n(\ni\n),\n \nstatic_cast\n<\nint\n>\n(\nu\n));\n\n\n\n\n\n\nto ensure that the output will continue to be the unsigned representation\nof -42 and the signed representation of 0xffffffff (often 4294967254\nand -1 respectively). When \nfalse\n (which is the default), these casts\nwill not be added which may cause a change in the output. Note that this\noption makes no difference for the default value of\n\nStrFormatLikeFunctions\n since \nabsl::StrFormat\n takes a function\nparameter pack and is not a variadic function.\n\n\n\n\n\n\n\n\nStrFormatLikeFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement that\nthe first parameter contains the printf-style format string and the\narguments to be formatted follow immediately afterwards. Qualified member\nfunction names are supported, but the replacement function name must be\nunqualified. The default value is \nabsl::StrFormat\n.\n\n\n\n\n\n\n\n\nReplacementFormatFunction\nÂ¶\n\n\nThe function that will be used to replace the function set by the\n\nStrFormatLikeFunctions\n option rather than the default\n\nstd::format\n. It is expected that the function provides an interface\nthat is compatible with \nstd::format\n. A suitable candidate would be\n\nfmt::format\n.\n\n\n\n\n\n\n\n\nFormatHeader\nÂ¶\n\n\nThe header that must be included for the declaration of\n\nReplacementFormatFunction\n so that a \n#include\n directive can be added if\nrequired. If \nReplacementFormatFunction\n is \nstd::format\n then this option will\ndefault to \n<format>\n, otherwise this option will default to nothing\nand no \n#include\n directive will be added.",
    "configurations": []
  }
}