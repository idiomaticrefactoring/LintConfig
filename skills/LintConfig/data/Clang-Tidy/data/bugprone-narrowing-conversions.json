{
  "name": "bugprone-narrowing-conversions",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html",
    "fixable": false
  },
  "content": {
    "introduction": "cppcoreguidelines-narrowing-conversions\n redirects here as an alias for\nthis check.\n\nChecks for silent narrowing conversions, e.g: \nint\n \ni\n \n=\n \n0;\n \ni\n \n+=\n \n0.1;\n. While\nthe issue is obvious in this former example, it might not be so in the\nfollowing: \nvoid\n \nMyClass::f(double\n \nd)\n \n{\n \nint_member_\n \n+=\n \nd;\n \n}\n.\n\nWe flag narrowing conversions from:\n\n\nan integer to a narrower integer (e.g. \nchar\n to \nunsigned\n \nchar\n)\nif WarnOnIntegerNarrowingConversion Option is set,\n\n\nan integer to a narrower floating-point (e.g. \nuint64_t\n to \nfloat\n)\nif WarnOnIntegerToFloatingPointNarrowingConversion Option is set,\n\n\na floating-point to an integer (e.g. \ndouble\n to \nint\n),\n\n\na floating-point to a narrower floating-point (e.g. \ndouble\n to \nfloat\n)\nif WarnOnFloatingPointNarrowingConversion Option is set.\n\n\n\n\n\n\nThis check will flag:\n\n\nAll narrowing conversions that are not marked by an explicit cast (c-style\nor \nstatic_cast\n). For example: \nint\n \ni\n \n=\n \n0;\n \ni\n \n+=\n \n0.1;\n,\n\nvoid\n \nf(int);\n \nf(0.1);\n,\n\n\nAll applications of binary operators with a narrowing conversions.\nFor example: \nint\n \ni;\n \ni+=\n \n0.1;\n.\n\nArithmetic with smaller integer types than \nint\n trigger implicit conversions,\nas explained under \nâIntegral Promotionâ on cppreference.com\n.\nThis check diagnoses more instances of narrowing than the compiler warning\n\n-Wconversion\n does. The example below demonstrates this behavior.\n\n// The following function definition demonstrates usage of arithmetic with\n\n\n// integer types smaller than `int` and how the narrowing conversion happens\n\n\n// implicitly.\n\n\nvoid\n \ncomputation\n(\nshort\n \nargument1\n,\n \nshort\n \nargument2\n)\n \n{\n\n\n  \n// Arithmetic written by humans:\n\n\n  \nshort\n \nresult\n \n=\n \nargument1\n \n+\n \nargument2\n;\n\n\n  \n// Arithmetic actually performed by C++:\n\n\n  \nshort\n \nresult\n \n=\n \nstatic_cast\n<\nshort\n>\n(\nstatic_cast\n<\nint\n>\n(\nargument1\n)\n \n+\n \nstatic_cast\n<\nint\n>\n(\nargument2\n));\n\n\n}\n\n\n\nvoid\n \nrecommended_resolution\n(\nshort\n \nargument1\n,\n \nshort\n \nargument2\n)\n \n{\n\n\n  \nshort\n \nresult\n \n=\n \nargument1\n \n+\n \nargument2\n;\n\n\n  \n//           ^ warning: narrowing conversion from 'int' to signed type 'short' is implementation-defined\n\n\n\n  \n// The cppcoreguidelines recommend to resolve this issue by using the GSL\n\n\n  \n// in one of two ways. Either by a cast that throws if a loss of precision\n\n\n  \n// would occur.\n\n\n  \nshort\n \nresult\n \n=\n \ngsl\n::\nnarrow\n<\nshort\n>\n(\nargument1\n \n+\n \nargument2\n);\n\n\n  \n// Or it can be resolved without checking the result risking invalid results.\n\n\n  \nshort\n \nresult\n \n=\n \ngsl\n::\nnarrow_cast\n<\nshort\n>\n(\nargument1\n \n+\n \nargument2\n);\n\n\n\n  \n// A classical `static_cast` will silence the warning as well if the GSL\n\n\n  \n// is not available.\n\n\n  \nshort\n \nresult\n \n=\n \nstatic_cast\n<\nshort\n>\n(\nargument1\n \n+\n \nargument2\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnIntegerNarrowingConversion\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing integer conversion\n(e.g. \nint\n to \nsize_t\n). \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnOnIntegerToFloatingPointNarrowingConversion\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing integer to floating-point\nconversion (e.g. \nsize_t\n to \ndouble\n). \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnOnFloatingPointNarrowingConversion\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing floating point conversion\n(e.g. \ndouble\n to \nfloat\n). \ntrue\n by default.\n\n\n\n\n\n\n\n\nWarnWithinTemplateInstantiation\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing conversions within template\ninstantiations. \nfalse\n by default.\n\n\n\n\n\n\n\n\nWarnOnEquivalentBitWidth\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on narrowing conversions that arise from\ncasting between types of equivalent bit width. (e.g.\n\nint n = uint(0);\n or \nlong long n = double(0);\n) \ntrue\n by default.\n\n\n\n\n\n\n\n\nIgnoreConversionFromTypes\nÂ¶\n\n\nNarrowing conversions from any type in this semicolon-separated list will be\nignored. This may be useful to weed out commonly occurring, but less commonly\nproblematic assignments such as \nint n = std::vector<char>().size();\n or\n\nint n = std::difference(it1, it2);\n. The default list is empty, but one\nsuggested list for a legacy codebase would be\n\nsize_t;ptrdiff_t;size_type;difference_type\n.\n\n\n\n\n\n\n\n\nPedanticMode\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on assigning a floating point constant\nto an integer value even if the floating point value is exactly\nrepresentable in the destination type (e.g. \nint\n \ni\n \n=\n \n1.0;\n).\n\nfalse\n by default.\n\nFAQ\nÂ¶\n\n\n\n\n\n\nWhat does ânarrowing conversion from âintâ to âfloatââ mean?\n\n\n\n\n\n\nAn IEEE754 Floating Point number can represent all integer values in the range\n[-2^PrecisionBits, 2^PrecisionBits] where PrecisionBits is the number of bits\nin the mantissa.\n\n\nFor \nfloat\n this would be [-2^23, 2^23], where \nint\n can represent values\nin the range [-2^31, 2^31-1].\n\n\n\n\n\n\nWhat does âimplementation-definedâ mean?\n\n\n\n\n\n\nYou may have encountered messages like ânarrowing conversion from âunsigned\nintâ to signed type âintâ is implementation-definedâ.\nThe C/C++ standard does not mandate twoâs complement for signed integers, and\nso the compiler is free to define what the semantics are for converting an\nunsigned integer to signed integer. Clangâs implementation uses the twoâs\ncomplement format.",
    "configurations": []
  }
}