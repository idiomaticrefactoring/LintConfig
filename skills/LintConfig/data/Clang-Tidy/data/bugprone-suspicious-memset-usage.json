{
  "name": "bugprone-suspicious-memset-usage",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/suspicious-memset-usage.html",
    "fixable": true
  },
  "content": {
    "introduction": "This check finds \nmemset()\n calls with potential mistakes in their arguments.\nConsidering the function as \nvoid*\n \nmemset(void*\n \ndestination,\n \nint\n \nfill_value,\n\n\nsize_t\n \nbyte_count)\n, the following cases are covered:\n\nCase 1: Fill value is a character ``â0â``\n\nFilling up a memory area with ASCII code 48 characters is not customary,\npossibly integer zeroes were intended instead.\nThe check offers a replacement of \n'0'\n with \n0\n. Memsetting character\npointers with \n'0'\n is allowed.\n\nCase 2: Fill value is truncated\n\nMemset converts \nfill_value\n to \nunsigned\n \nchar\n before using it. If\n\nfill_value\n is out of unsigned character range, it gets truncated\nand memory will not contain the desired pattern.\n\nCase 3: Byte count is zero\n\nCalling memset with a literal zero in its \nbyte_count\n argument is likely\nto be unintended and swapped with \nfill_value\n. The check offers to swap\nthese two arguments.\n\nCorresponding cpplint.py check name: \nruntime/memset\n.\n\nExamples:\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nint\n \ni\n[\n5\n]\n \n=\n \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n};\n\n\n  \nint\n \n*\nip\n \n=\n \ni\n;\n\n\n  \nchar\n \nc\n \n=\n \n'1'\n;\n\n\n  \nchar\n \n*\ncp\n \n=\n \n&\nc\n;\n\n\n  \nint\n \nv\n \n=\n \n0\n;\n\n\n\n  \n// Case 1\n\n\n  \nmemset\n(\nip\n,\n \n'0'\n,\n \n1\n);\n \n// suspicious\n\n\n  \nmemset\n(\ncp\n,\n \n'0'\n,\n \n1\n);\n \n// OK\n\n\n\n  \n// Case 2\n\n\n  \nmemset\n(\nip\n,\n \n0xabcd\n,\n \n1\n);\n \n// fill value gets truncated\n\n\n  \nmemset\n(\nip\n,\n \n0x00\n,\n \n1\n);\n   \n// OK\n\n\n\n  \n// Case 3\n\n\n  \nmemset\n(\nip\n,\n \nsizeof\n(\nint\n),\n \nv\n);\n \n// zero length, potentially swapped\n\n\n  \nmemset\n(\nip\n,\n \n0\n,\n \n1\n);\n           \n// OK\n\n\n}",
    "configurations": []
  }
}