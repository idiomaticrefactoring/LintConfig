{
  "name": "modernize-replace-auto-ptr",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/replace-auto-ptr.html",
    "fixable": true
  },
  "content": {
    "introduction": "This check replaces the uses of the deprecated class \nstd::auto_ptr\n by\n\nstd::unique_ptr\n (introduced in C++11). The transfer of ownership, done\nby the copy-constructor and the assignment operator, is changed to match\n\nstd::unique_ptr\n usage by using explicit calls to \nstd::move()\n.\n\nMigration example:\n\n-\nvoid\n \ntake_ownership_fn\n(\nstd\n::\nauto_ptr\n<\nint\n>\n \nint_ptr\n);\n\n\n+\nvoid\n \ntake_ownership_fn\n(\nstd\n::\nunique_ptr\n<\nint\n>\n \nint_ptr\n);\n\n\n\n \nvoid\n \nf\n(\nint\n \nx\n)\n \n{\n\n\n-\n  \nstd\n::\nauto_ptr\n<\nint\n>\n \na\n(\nnew\n \nint\n(\nx\n));\n\n\n-\n  \nstd\n::\nauto_ptr\n<\nint\n>\n \nb\n;\n\n\n+\n  \nstd\n::\nunique_ptr\n<\nint\n>\n \na\n(\nnew\n \nint\n(\nx\n));\n\n\n+\n  \nstd\n::\nunique_ptr\n<\nint\n>\n \nb\n;\n\n\n\n-\n  \nb\n \n=\n \na\n;\n\n\n-\n  \ntake_ownership_fn\n(\nb\n);\n\n\n+\n  \nb\n \n=\n \nstd\n::\nmove\n(\na\n);\n\n\n+\n  \ntake_ownership_fn\n(\nstd\n::\nmove\n(\nb\n));\n\n\n \n}\n\nSince \nstd::move()\n is a library function declared in \n<utility>\n it may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\nLimitations\nÂ¶\n\n\n\n\nIf headers modification is not activated or if a header is not allowed to be\nchanged this check will produce broken code (compilation error), where the\nheadersâ code will stay unchanged while the code using them will be changed.\n\n\nClient code that declares a reference to an \nstd::auto_ptr\n coming from\ncode that canât be migrated (such as a header coming from a 3\nrd\n\nparty library) will produce a compilation error after migration. This is\nbecause the type of the reference will be changed to \nstd::unique_ptr\n but\nthe type returned by the library wonât change, binding a reference to\n\nstd::unique_ptr\n from an \nstd::auto_ptr\n. This pattern doesnât make much\nsense and usually \nstd::auto_ptr\n are stored by value (otherwise what is\nthe point in using them instead of a reference or a pointer?).\n\n\n\n\n \n// <3rd-party header...>\n\n\n \nstd\n::\nauto_ptr\n<\nint\n>\n \nget_value\n();\n\n\n \nconst\n \nstd\n::\nauto_ptr\n<\nint\n>\n \n&\n \nget_ref\n();\n\n\n\n \n// <calling code (with migration)...>\n\n\n-\nstd\n::\nauto_ptr\n<\nint\n>\n \na\n(\nget_value\n());\n\n\n+\nstd\n::\nunique_ptr\n<\nint\n>\n \na\n(\nget_value\n());\n \n// ok, unique_ptr constructed from auto_ptr\n\n\n\n-\nconst\n \nstd\n::\nauto_ptr\n<\nint\n>\n \n&\n \np\n \n=\n \nget_ptr\n();\n\n\n+\nconst\n \nstd\n::\nunique_ptr\n<\nint\n>\n \n&\n \np\n \n=\n \nget_ptr\n();\n \n// won't compile\n\n\n\n\n\n\n\n\nNon-instantiated templates arenât modified.\n\n\n\n\ntemplate\n \n<\ntypename\n \nX\n>\n\n\nvoid\n \nf\n()\n \n{\n\n\n    \nstd\n::\nauto_ptr\n<\nX\n>\n \np\n;\n\n\n}\n\n\n\n// only 'f<int>()' (or similar) will trigger the replacement.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.",
    "configurations": []
  }
}