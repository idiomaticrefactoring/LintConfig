{
  "name": "cppcoreguidelines-no-suspend-with-lock",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/no-suspend-with-lock.html",
    "fixable": false
  },
  "content": {
    "introduction": "Flags coroutines that suspend while a lock guard is in scope at the\nsuspension point.\n\nWhen a coroutine suspends, any mutexes held by the coroutine will remain\nlocked until the coroutine resumes and eventually destructs the lock guard.\nThis can lead to long periods with a mutex held and runs the risk of deadlock.\n\nInstead, locks should be released before suspending a coroutine.\n\nThis check only checks suspending coroutines while a lock_guard is in scope;\nit does not consider manual locking or unlocking of mutexes, e.g., through\ncalls to \nstd::mutex::lock()\n.\n\nExamples:\n\nfuture\n \nbad_coro\n()\n \n{\n\n\n  \nstd\n::\nlock_guard\n \nlock\n{\nmtx\n};\n\n\n  \n++\nsome_counter\n;\n\n\n  \nco_await\n \nsomething\n();\n \n// Suspending while holding a mutex\n\n\n}\n\n\n\nfuture\n \ngood_coro\n()\n \n{\n\n\n  \n{\n\n\n    \nstd\n::\nlock_guard\n \nlock\n{\nmtx\n};\n\n\n    \n++\nsome_counter\n;\n\n\n  \n}\n\n\n  \n// Destroy the lock_guard to release the mutex before suspending the coroutine\n\n\n  \nco_await\n \nsomething\n();\n \n// Suspending while holding a mutex\n\n\n}\n\nThis check implements \nCP.52\n\nfrom the C++ Core Guidelines.",
    "configurations": []
  }
}