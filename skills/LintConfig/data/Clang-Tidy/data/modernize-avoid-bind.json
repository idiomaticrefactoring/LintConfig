{
  "name": "modernize-avoid-bind",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/avoid-bind.html",
    "fixable": true
  },
  "content": {
    "introduction": "The check finds uses of \nstd::bind\n and \nboost::bind\n and replaces them\nwith lambdas. Lambdas will use value-capture unless reference capture is\nexplicitly requested with \nstd::ref\n or \nboost::ref\n.\n\nIt supports arbitrary callables including member functions, function objects,\nand free functions, and all variations thereof. Anything that you can pass\nto the first argument of \nbind\n should be diagnosable. Currently, the only\nknown case where a fix-it is unsupported is when the same placeholder is\nspecified multiple times in the parameter list.\n\nGiven:\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\nThen:\n\nvoid\n \nf\n()\n \n{\n\n\n  \nint\n \nx\n \n=\n \n2\n;\n\n\n  \nauto\n \nclj\n \n=\n \nstd\n::\nbind\n(\nadd\n,\n \nx\n,\n \n_1\n);\n\n\n}\n\nis replaced by:\n\nvoid\n \nf\n()\n \n{\n\n\n  \nint\n \nx\n \n=\n \n2\n;\n\n\n  \nauto\n \nclj\n \n=\n \n[\n=\n](\nauto\n \n&&\n \narg1\n)\n \n{\n \nreturn\n \nadd\n(\nx\n,\n \narg1\n);\n \n};\n\n\n}\n\nstd::bind\n can be hard to read and can result in larger object files and\nbinaries due to type information that will not be produced by equivalent\nlambdas.\n\nOptions\nÂ¶\n\n\n\n\n\n\nPermissiveParameterList\nÂ¶\n\n\nIf the option is set to \ntrue\n, the check will append \nauto&&...\n to the end\nof every placeholder parameter list. Without this, it is possible for a fix-it\nto perform an incorrect transformation in the case where the result of the \nbind\n\nis used in the context of a type erased functor such as \nstd::function\n which\nallows mismatched arguments. Default is is \nfalse\n.\n\n\n\n\nFor example:\n\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nfunction\n<\nint\n(\nint\n,\nint\n)\n>\n \nignore_args\n \n=\n \nstd\n::\nbind\n(\nadd\n,\n \n2\n,\n \n2\n);\n\n\n  \nreturn\n \nignore_args\n(\n3\n,\n \n3\n);\n\n\n}\n\n\n\n\n\n\nis valid code, and returns \n4\n. The actual values passed to \nignore_args\n are\nsimply ignored. Without \nPermissiveParameterList\n, this would be transformed into\n\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nfunction\n<\nint\n(\nint\n,\nint\n)\n>\n \nignore_args\n \n=\n \n[]\n \n{\n \nreturn\n \nadd\n(\n2\n,\n \n2\n);\n \n}\n\n\n  \nreturn\n \nignore_args\n(\n3\n,\n \n3\n);\n\n\n}\n\n\n\n\n\n\nwhich will \nnot\n compile, since the lambda does not contain an \noperator()\n\nthat accepts 2 arguments. With permissive parameter list, it instead generates\n\n\nint\n \nadd\n(\nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n \nreturn\n \nx\n \n+\n \ny\n;\n \n}\n\n\nint\n \nfoo\n()\n \n{\n\n\n  \nstd\n::\nfunction\n<\nint\n(\nint\n,\nint\n)\n>\n \nignore_args\n \n=\n \n[](\nauto\n&&\n...)\n \n{\n \nreturn\n \nadd\n(\n2\n,\n \n2\n);\n \n}\n\n\n  \nreturn\n \nignore_args\n(\n3\n,\n \n3\n);\n\n\n}\n\n\n\n\n\n\nwhich is correct.\n\n\nThis check requires using C++14 or higher to run.",
    "configurations": []
  }
}