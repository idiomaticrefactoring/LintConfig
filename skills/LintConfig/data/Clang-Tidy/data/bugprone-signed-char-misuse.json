{
  "name": "bugprone-signed-char-misuse",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html",
    "fixable": false
  },
  "content": {
    "introduction": "cert-str34-c\n redirects here as an alias for this check. For the CERT alias,\nthe \nDiagnoseSignedUnsignedCharComparisons\n option is set to \nfalse\n.\n\nFinds those \nsigned\n \nchar\n -> integer conversions which might indicate a\nprogramming error. The basic problem with the \nsigned\n \nchar\n, that it might\nstore the non-ASCII characters as negative values. This behavior can cause a\nmisunderstanding of the written code both when an explicit and when an\nimplicit conversion happens.\n\nWhen the code contains an explicit \nsigned\n \nchar\n -> integer conversion, the\nhuman programmer probably expects that the converted value matches with the\ncharacter code (a value from [0..255]), however, the actual value is in\n[-128..127] interval. To avoid this kind of misinterpretation, the desired way\nof converting from a \nsigned\n \nchar\n to an integer value is converting to\n\nunsigned\n \nchar\n first, which stores all the characters in the positive\n[0..255] interval which matches the known character codes.\n\nIn case of implicit conversion, the programmer might not actually be aware\nthat a conversion happened and char value is used as an integer. There are\nsome use cases when this unawareness might lead to a functionally imperfect\ncode. For example, checking the equality of a \nsigned\n \nchar\n and an\n\nunsigned\n \nchar\n variable is something we should avoid in C++ code. During\nthis comparison, the two variables are converted to integers which have\ndifferent value ranges. For \nsigned\n \nchar\n, the non-ASCII characters are\nstored as a value in [-128..-1] interval, while the same characters are\nstored in the [128..255] interval for an \nunsigned\n \nchar\n.\n\nIt depends on the actual platform whether plain \nchar\n is handled as\n\nsigned\n \nchar\n by default and so it is caught by this check or not.\nTo change the default behavior you can use \n-funsigned-char\n and\n\n-fsigned-char\n compilation options.\n\nCurrently, this check warns in the following cases:\n\nsigned\n \nchar\n is assigned to an integer variable\n\n\nsigned\n \nchar\n and \nunsigned\n \nchar\n are compared with\nequality/inequality operator\n\n\nsigned\n \nchar\n is converted to an integer in the array subscript\n\nSee also:\n\nSTR34-C. Cast characters to unsigned char before converting to larger\ninteger sizes\n\nA good example from the CERT description when a \nchar\n variable is used to\nread from a file that might contain non-ASCII characters. The problem comes\nup when the code uses the \n-1\n integer value as EOF, while the 255 character\ncode is also stored as \n-1\n in twoâs complement form of char type.\nSee a simple example of this below. This code stops not only when it reaches\nthe end of the file, but also when it gets a character with the 255 code.\n\n#define EOF (-1)\n\n\n\nint\n \nread\n(\nvoid\n)\n \n{\n\n\n  \nchar\n \nCChar\n;\n\n\n  \nint\n \nIChar\n \n=\n \nEOF\n;\n\n\n\n  \nif\n \n(\nreadChar\n(\nCChar\n))\n \n{\n\n\n    \nIChar\n \n=\n \nCChar\n;\n\n\n  \n}\n\n\n  \nreturn\n \nIChar\n;\n\n\n}\n\nA proper way to fix the code above is converting the \nchar\n variable to\nan \nunsigned\n \nchar\n value first.\n\n#define EOF (-1)\n\n\n\nint\n \nread\n(\nvoid\n)\n \n{\n\n\n  \nchar\n \nCChar\n;\n\n\n  \nint\n \nIChar\n \n=\n \nEOF\n;\n\n\n\n  \nif\n \n(\nreadChar\n(\nCChar\n))\n \n{\n\n\n    \nIChar\n \n=\n \nstatic_cast\n<\nunsigned\n \nchar\n>\n(\nCChar\n);\n\n\n  \n}\n\n\n  \nreturn\n \nIChar\n;\n\n\n}\n\nAnother use case is checking the equality of two \nchar\n variables with\ndifferent signedness. Inside the non-ASCII value range this comparison between\na \nsigned\n \nchar\n and an \nunsigned\n \nchar\n always returns \nfalse\n.\n\nbool\n \ncompare\n(\nsigned\n \nchar\n \nSChar\n,\n \nunsigned\n \nchar\n \nUSChar\n)\n \n{\n\n\n  \nif\n \n(\nSChar\n \n==\n \nUSChar\n)\n\n\n    \nreturn\n \ntrue\n;\n\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\nThe easiest way to fix this kind of comparison is casting one of the arguments,\nso both arguments will have the same type.\n\nbool\n \ncompare\n(\nsigned\n \nchar\n \nSChar\n,\n \nunsigned\n \nchar\n \nUSChar\n)\n \n{\n\n\n  \nif\n \n(\nstatic_cast\n<\nunsigned\n \nchar\n>\n(\nSChar\n)\n \n==\n \nUSChar\n)\n\n\n    \nreturn\n \ntrue\n;\n\n\n  \nreturn\n \nfalse\n;\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nCharTypedefsToIgnore\nÂ¶\n\n\nA semicolon-separated list of typedef names. In this list, we can list\ntypedefs for \nchar\n or \nsigned\n \nchar\n, which will be ignored by the\ncheck. This is useful when a typedef introduces an integer alias like\n\nsal_Int8\n or \nint8_t\n. In this case, human misinterpretation is not\nan issue. Default is an empty string.\n\n\n\n\n\n\n\n\nDiagnoseSignedUnsignedCharComparisons\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on \nsigned\n \nchar\n/\nunsigned\n \nchar\n comparisons,\notherwise these comparisons are ignored. By default, this option is set to \ntrue\n.",
    "configurations": []
  }
}