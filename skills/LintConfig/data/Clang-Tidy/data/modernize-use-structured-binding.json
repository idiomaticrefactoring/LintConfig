{
  "name": "modernize-use-structured-binding",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-structured-binding.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds places where structured bindings could be used to decompose pairs and\nsuggests replacing them.\n\nThis check finds three code patterns and recommends using structured bindings\nfor clearer, more idiomatic C++17 code.\n\n1. Decompose a pair variable by assigning its members to separate variables\nright after its definition:\n\nauto\n \np\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\n\nint\n \nx\n \n=\n \np\n.\nfirst\n;\n\n\nint\n \ny\n \n=\n \np\n.\nsecond\n;\n\n\n\ninto\n:\n\n\n\nauto\n \n[\nx\n,\n \ny\n]\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\nUse \nstd::tie\n to decompose a pair into two predefined variables:\n\nint\n \na\n;\n\n\nint\n \nb\n;\n\n\nstd\n::\ntie\n(\na\n,\n \nb\n)\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\n\n\ninto\n:\n\n\n\nauto\n \n[\na\n,\n \nb\n]\n \n=\n \ngetPair\n<\nint\n,\n \nint\n>\n();\n\n3. Manually decompose a pair by assigning to its members to local variables\nin a range-based for loop:\n\nfor\n \n(\nauto\n \np\n \n:\n \nvecOfPairs\n)\n \n{\n\n\n  \nint\n \nx\n \n=\n \np\n.\nfirst\n;\n\n\n  \nint\n \ny\n \n=\n \np\n.\nsecond\n;\n\n\n  \n// ...\n\n\n}\n\n\n\ninto\n:\n\n\n\nfor\n \n(\nauto\n \n[\nx\n,\n \ny\n]\n \n:\n \nvecOfPairs\n)\n \n{\n\n\n  \n// use x and y\n\n\n}\n\nLimitations\nÂ¶\n\n\nThe check currently ignores variables defined with attributes or qualifiers\nexcept \nconst\n and \n&\n since itâs not very common:\n\n\nstatic\n \nauto\n \npair\n \n=\n \ngetPair\n();\n\n\nstatic\n \nint\n \nb\n \n=\n \npair\n.\nfirst\n;\n\n\nstatic\n \nint\n \nc\n \n=\n \npair\n.\nsecond\n;\n\n\n\n\n\n\nThe check doesnât handle some situations which could possibly be transferred\nto structured bindings, for example:\n\n\nconst\n \nauto\n&\n \nresults\n \n=\n \nmapping\n.\ntry_emplace\n(\n\"hello!\"\n);\n\n\nconst\n \niterator\n&\n \nit\n \n=\n \nresults\n.\nfirst\n;\n\n\nbool\n \nsucceed\n \n=\n \nresults\n.\nsecond\n;\n\n\n// succeed is not changed in the following code\n\n\n\n\n\n\nand:\n\n\nconst\n \nauto\n \nresults\n \n=\n \nmapping\n.\ntry_emplace\n(\n\"hello!\"\n);\n\n\nif\n \n(\nresults\n.\nsecond\n)\n \n{\n\n\n    \nhandle_inserted\n(\nresults\n.\nfirst\n);\n\n\n}",
    "configurations": []
  }
}