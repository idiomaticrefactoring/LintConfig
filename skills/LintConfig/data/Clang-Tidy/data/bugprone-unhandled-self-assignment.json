{
  "name": "bugprone-unhandled-self-assignment",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unhandled-self-assignment.html",
    "fixable": false
  },
  "content": {
    "introduction": "cert-oop54-cpp\n redirects here as an alias for this check. For the CERT alias,\nthe \nWarnOnlyIfThisHasSuspiciousField\n option is set to \nfalse\n.\n\nFinds user-defined copy assignment operators which do not protect the code\nagainst self-assignment either by checking self-assignment explicitly or\nusing the copy-and-swap or the copy-and-move method.\n\nBy default, this check searches only those classes which have any pointer or C\narray field to avoid false positives. In case of a pointer or a C array, itâs\nlikely that self-copy assignment breaks the object if the copy assignment\noperator was not written with care.\n\nSee also:\n\nOOP54-CPP. Gracefully handle self-copy assignment\n\nA copy assignment operator must prevent that self-copy assignment ruins the\nobject state. A typical use case is when the class has a pointer field\nand the copy assignment operator first releases the pointed object and\nthen tries to assign it:\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \ndelete\n \np\n;\n\n\n    \np\n \n=\n \nnew\n \nint\n(\n*\nrhs\n.\np\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nThere are two common C++ patterns to avoid this problem. The first is\nthe self-assignment check:\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \nif\n(\nthis\n \n==\n \n&\nrhs\n)\n\n\n      \nreturn\n \n*\nthis\n;\n\n\n\n    \ndelete\n \np\n;\n\n\n    \np\n \n=\n \nnew\n \nint\n(\n*\nrhs\n.\np\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nThe second one is the copy-and-swap method when we create a temporary copy\n(using the copy constructor) and then swap this temporary object with \nthis\n:\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nvoid\n \nswap\n(\nT\n \n&\nrhs\n)\n \n{\n\n\n    \nusing\n \nstd\n::\nswap\n;\n\n\n    \nswap\n(\np\n,\n \nrhs\n.\np\n);\n\n\n  \n}\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \nT\n(\nrhs\n).\nswap\n(\n*\nthis\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nThere is a third pattern which is less common. Letâs call it the copy-and-move\nmethod when we create a temporary copy (using the copy constructor) and then move\nthis temporary object into \nthis\n (needs a move assignment operator):\n\nclass\n \nT\n \n{\n\n\nint\n*\n \np\n;\n\n\n\npublic\n:\n\n\n  \nT\n(\nconst\n \nT\n \n&\nrhs\n)\n \n:\n \np\n(\nrhs\n.\np\n \n?\n \nnew\n \nint\n(\n*\nrhs\n.\np\n)\n \n:\n \nnullptr\n)\n \n{}\n\n\n  \n~\nT\n()\n \n{\n \ndelete\n \np\n;\n \n}\n\n\n\n  \n// ...\n\n\n\n  \nT\n&\n \noperator\n=\n(\nconst\n \nT\n \n&\nrhs\n)\n \n{\n\n\n    \nT\n \nt\n \n=\n \nrhs\n;\n\n\n    \n*\nthis\n \n=\n \nstd\n::\nmove\n(\nt\n);\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n\n  \nT\n&\n \noperator\n=\n(\nT\n \n&&\nrhs\n)\n \n{\n\n\n    \np\n \n=\n \nrhs\n.\np\n;\n\n\n    \nrhs\n.\np\n \n=\n \nnullptr\n;\n\n\n    \nreturn\n \n*\nthis\n;\n\n\n  \n}\n\n\n};\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnlyIfThisHasSuspiciousField\nÂ¶\n\n\nWhen \ntrue\n, the check will warn only if the container class of the copy\nassignment operator has any suspicious fields (pointer, C array and C++ smart\npointer).\nThis option is set to \ntrue\n by default.",
    "configurations": []
  }
}