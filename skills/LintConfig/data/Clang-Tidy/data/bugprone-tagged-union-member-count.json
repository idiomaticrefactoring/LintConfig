{
  "name": "bugprone-tagged-union-member-count",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/tagged-union-member-count.html",
    "fixable": false
  },
  "content": {
    "introduction": "Gives warnings for tagged unions, where the number of tags is\ndifferent from the number of data members inside the union.\n\nA struct or a class is considered to be a tagged union if it has\nexactly one union data member and exactly one enum data member and\nany number of other data members that are neither unions or enums.\nFurthermore, the types of the union and the enum members must\nnot come from system header files nor the \nstd\n namespace.\n\nExample:\n\nenum\n \nTags\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnion\n \n{\n \n// warning: tagged union has more data members (3) than tags (2)\n\n\n  \nenum\n \nTags\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nfloat\n \nF\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\nThe following example illustrates the exception for unions and enums from\nsystem header files and the \nstd\n namespace.\n\n#include\n \n<pthread.h>\n\n\n\nstruct\n \nNotTaggedUnion\n \n{\n\n\n  \nenum\n \nMyEnum\n \n{\n \nMyEnumConstant1\n,\n \nMyEnumConstant2\n \n}\n \nEn\n;\n\n\n  \npthread_mutex_t\n \nMutex\n;\n\n\n};\n\nThe \npthread_mutex_t\n type may be defined as a union behind a \ntypedef\n,\nin which case the check could mistake this type as a user-defined tagged union.\nAfter all, it has exactly one enum data member and exactly one union data member.\nTo avoid false-positive cases originating from this, unions and enums from\nsystem headers and the \nstd\n namespace are ignored when pinpointing the\nunion part and the enum part of a potential user-defined tagged union.\n\nHow enum constants are counted\nÂ¶\n\n\nThe main complicating factor when counting the number of enum constants is that\nsome of them might be auxiliary values that purposefully donât have a\ncorresponding union data member and are used for something else. For example\nthe last enum constant sometimes explicitly âpoints toâ the last declared valid\nenum constant or tracks how many enum constants have been declared.\n\n\nFor an illustration:\n\n\nenum\n \nTagWithLast\n \n{\n\n\n  \nTag1\n \n=\n \n0\n,\n\n\n  \nTag2\n \n=\n \n1\n,\n\n\n  \nTag3\n \n=\n \n2\n,\n\n\n  \nLastTag\n \n=\n \n2\n\n\n};\n\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n \n// is 0\n\n\n  \nTag2\n,\n \n// is 1\n\n\n  \nTag3\n,\n \n// is 2\n\n\n  \nTagCount\n,\n \n// is 3\n\n\n};\n\n\n\n\n\n\nThe check counts the number of distinct values among the enum constants and not\nthe enum constants themselves. This way the enum constants that are essentially\njust aliases of other enum constants are not included in the final count.\n\n\nHandling of counting enum constants (ones like \nTagCount\n in the previous\ncode example) is done by decreasing the number of enum values by one if the name\nof the last enum constant starts with a prefix or ends with a suffix specified in\n\nCountingEnumPrefixes\n, \nCountingEnumSuffixes\n and itâs value is\none less than the total number of distinct values in the enum.\n\n\nWhen the final count is adjusted based on this heuristic then a diagnostic note\nis emitted that shows which enum constant matched the criteria.\n\n\nThe heuristic can be disabled entirely (\nEnableCountingEnumHeuristic\n)\nor configured to follow your naming convention (\nCountingEnumPrefixes\n,\n\nCountingEnumSuffixes\n).\nThe strings specified in \nCountingEnumPrefixes\n,\n\nCountingEnumSuffixes\n are matched case insensitively.\n\n\nExample counts:\n\n\n// Enum count is 3, because the value 2 is counted only once\n\n\nenum\n \nTagWithLast\n \n{\n\n\n  \nTag1\n \n=\n \n0\n,\n\n\n  \nTag2\n \n=\n \n1\n,\n\n\n  \nTag3\n \n=\n \n2\n,\n\n\n  \nLastTag\n \n=\n \n2\n\n\n};\n\n\n\n// Enum count is 3, because TagCount is heuristically excluded\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n \n// is 0\n\n\n  \nTag2\n,\n \n// is 1\n\n\n  \nTag3\n,\n \n// is 2\n\n\n  \nTagCount\n,\n \n// is 3\n\n\n};\n\nOptions\nÂ¶\n\n\n\n\n\n\nEnableCountingEnumHeuristic\nÂ¶\n\n\n\n\nThis option enables or disables the counting enum heuristic.\nIt uses the prefixes and suffixes specified in the options\n\nCountingEnumPrefixes\n, \nCountingEnumSuffixes\n to find counting enum constants by\nusing them for prefix and suffix matching.\n\n\nThis option is enabled by default.\n\n\nWhen \nEnableCountingEnumHeuristic\n is \nfalse\n:\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nTagCount\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnion\n \n{\n\n\n  \nTagWithCounter\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\nWhen \nEnableCountingEnumHeuristic\n is \ntrue\n:\n\n\nenum\n \nTagWithCounter\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nTagCount\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnion\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounter\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nCountingEnumPrefixes\nÂ¶\n\n\n\n\nSee \nCountingEnumSuffixes\n below.\n\n\n\n\n\n\nCountingEnumSuffixes\nÂ¶\n\n\n\n\nCountingEnumPrefixes and CountingEnumSuffixes are lists of semicolon\nseparated strings that are used to search for possible counting enum constants.\nThese strings are matched case insensitively as prefixes and suffixes\nrespectively on the names of the enum constants.\nIf \nEnableCountingEnumHeuristic\n is \nfalse\n then these options do nothing.\n\n\nThe default value of \nCountingEnumSuffixes\n is \ncount\n and of\n\nCountingEnumPrefixes\n is the empty string.\n\n\nWhen \nEnableCountingEnumHeuristic\n is \ntrue\n and\n\nCountingEnumSuffixes\n is \ncount;size\n:\n\n\nenum\n \nTagWithCounterCount\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nTagCount\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionCount\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterCount\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\nenum\n \nTagWithCounterSize\n \n{\n\n\n  \nTag11\n,\n\n\n  \nTag22\n,\n\n\n  \nTag33\n,\n\n\n  \nTagSize\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionSize\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterSize\n \nKind\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nA\n;\n\n\n    \nlong\n \nB\n;\n\n\n    \nchar\n \n*\nStr\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\nWhen \nEnableCountingEnumHeuristic\n is \ntrue\n and\n\nCountingEnumPrefixes\n is \nmaxsize;last_\n\n\nenum\n \nTagWithCounterLast\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nlast_tag\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionLast\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterLast\n \ntag\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nshort\n \nS\n;\n\n\n    \nchar\n \n*\nC\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\nenum\n \nTagWithCounterMaxSize\n \n{\n\n\n  \nTag1\n,\n\n\n  \nTag2\n,\n\n\n  \nTag3\n,\n\n\n  \nMaxSizeTag\n,\n\n\n};\n\n\n\nstruct\n \nTaggedUnionMaxSize\n \n{\n \n// warning: tagged union has more data members (4) than tags (3)\n\n\n  \nTagWithCounterMaxSize\n \ntag\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nshort\n \nS\n;\n\n\n    \nchar\n \n*\nC\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\n\n\nWhen enabled, the check will also give a warning, when the number of tags\nis greater than the number of union data members.\n\n\nThis option is disabled by default.\n\n\nWhen \nStrictMode\n is \nfalse\n:\n\n\nstruct\n \nTaggedUnion\n \n{\n\n\n  \nenum\n \n{\n\n\n    \nTag1\n,\n\n\n    \nTag2\n,\n\n\n    \nTag3\n,\n\n\n  \n}\n \nTags\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};\n\n\n\n\n\n\nWhen \nStrictMode\n is \ntrue\n:\n\n\nstruct\n \nTaggedUnion\n \n{\n \n// warning: tagged union has fewer data members (2) than tags (3)\n\n\n  \nenum\n \n{\n\n\n    \nTag1\n,\n\n\n    \nTag2\n,\n\n\n    \nTag3\n,\n\n\n  \n}\n \nTags\n;\n\n\n  \nunion\n \n{\n\n\n    \nint\n \nI\n;\n\n\n    \nfloat\n \nF\n;\n\n\n  \n}\n \nData\n;\n\n\n};",
    "configurations": []
  }
}