{
  "name": "bugprone-sizeof-expression",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html",
    "fixable": false
  },
  "content": {
    "introduction": "The check finds usages of \nsizeof\n expressions which are most likely errors.\n\nThe \nsizeof\n operator yields the size (in bytes) of its operand, which may be\nan expression or the parenthesized name of a type. Misuse of this operator may\nbe leading to errors and possible software vulnerabilities.\n\nSuspicious usage of âsizeof(K)â\nÂ¶\n\n\nA common mistake is to query the \nsizeof\n of an integer literal. This is\nequivalent to query the size of its type (probably \nint\n). The intent of the\nprogrammer was probably to simply get the integer and not its size.\n\n\n#define BUFLEN 42\n\n\nchar\n \nbuf\n[\nBUFLEN\n];\n\n\nmemset\n(\nbuf\n,\n \n0\n,\n \nsizeof\n(\nBUFLEN\n));\n  \n// sizeof(42) ==> sizeof(int)\n\nSuspicious usage of âsizeof(expr)â\nÂ¶\n\n\nIn cases, where there is an enum or integer to represent a type, a common\nmistake is to query the \nsizeof\n on the integer or enum that represents the\ntype that should be used by \nsizeof\n. This results in the size of the integer\nand not of the type the integer represents:\n\n\nenum\n \ndata_type\n \n{\n\n\n  \nFLOAT_TYPE\n,\n\n\n  \nDOUBLE_TYPE\n\n\n};\n\n\n\nstruct\n \ndata\n \n{\n\n\n  \ndata_type\n \ntype\n;\n\n\n  \nvoid\n*\n \nbuffer\n;\n\n\n  \ndata_type\n \nget_type\n()\n \n{\n\n\n    \nreturn\n \ntype\n;\n\n\n  \n}\n\n\n};\n\n\n\nvoid\n \nf\n(\ndata\n \nd\n,\n \nint\n \nnumElements\n)\n \n{\n\n\n  \n// should be sizeof(float) or sizeof(double), depending on d.get_type()\n\n\n  \nint\n \nnumBytes\n \n=\n \nnumElements\n \n*\n \nsizeof\n(\nd\n.\nget_type\n());\n\n\n  \n...\n\n\n}\n\nSuspicious usage of âsizeof(this)â\nÂ¶\n\n\nThe \nthis\n keyword is evaluated to a pointer to an object of a given type.\nThe expression \nsizeof(this)\n is returning the size of a pointer. The\nprogrammer most likely wanted the size of the object and not the size of the\npointer.\n\n\nclass\n \nPoint\n \n{\n\n\n  \n[...]\n\n\n  \nsize_t\n \nsize\n()\n \n{\n \nreturn\n \nsizeof\n(\nthis\n);\n \n}\n  \n// should probably be sizeof(*this)\n\n\n  \n[...]\n\n\n};\n\nSuspicious usage of âsizeof(char*)â\nÂ¶\n\n\nThere is a subtle difference between declaring a string literal with\n\nchar*\n \nA\n \n=\n \n\"\"\n and \nchar\n \nA[]\n \n=\n \n\"\"\n. The first case has the type \nchar*\n\ninstead of the aggregate type \nchar[]\n. Using \nsizeof\n on an object\ndeclared with \nchar*\n type is returning the size of a pointer instead of\nthe number of characters (bytes) in the string literal.\n\n\nconst\n \nchar\n*\n \nkMessage\n \n=\n \n\"Hello World!\"\n;\n      \n// const char kMessage[] = \"...\";\n\n\nvoid\n \ngetMessage\n(\nchar\n*\n \nbuf\n)\n \n{\n\n\n  \nmemcpy\n(\nbuf\n,\n \nkMessage\n,\n \nsizeof\n(\nkMessage\n));\n  \n// sizeof(char*)\n\n\n}\n\nSuspicious usage of âsizeof(A*)â\nÂ¶\n\n\nA common mistake is to compute the size of a pointer instead of its pointee.\nThese cases may occur because of explicit cast or implicit conversion.\n\n\nint\n \nA\n[\n10\n];\n\n\nmemset\n(\nA\n,\n \n0\n,\n \nsizeof\n(\nA\n \n+\n \n0\n));\n\n\n\nstruct\n \nPoint\n \npoint\n;\n\n\nmemset\n(\npoint\n,\n \n0\n,\n \nsizeof\n(\n&\npoint\n));\n\nSuspicious usage of âsizeof(â¦)/sizeof(â¦)â\nÂ¶\n\n\nDividing \nsizeof\n expressions is typically used to retrieve the number of\nelements of an aggregate. This check warns on incompatible or suspicious cases.\n\n\nIn the following example, the entity has 10-bytes and is incompatible with the\ntype \nint\n which has 4 bytes.\n\n\nchar\n \nbuf\n[]\n \n=\n \n{\n \n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n \n};\n  \n// sizeof(buf) => 10\n\n\nvoid\n \ngetMessage\n(\nchar\n*\n \ndst\n)\n \n{\n\n\n  \nmemcpy\n(\ndst\n,\n \nbuf\n,\n \nsizeof\n(\nbuf\n)\n \n/\n \nsizeof\n(\nint\n));\n  \n// sizeof(int) => 4  [incompatible sizes]\n\n\n}\n\n\n\n\n\n\nIn the following example, the expression \nsizeof(Values)\n is returning the\nsize of \nchar*\n. One can easily be fooled by its declaration, but in parameter\ndeclaration the size â10â is ignored and the function is receiving a \nchar*\n.\n\n\nchar\n \nOrderedValues\n[\n10\n]\n \n=\n \n{\n \n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n \n};\n\n\nreturn\n \nCompareArray\n(\nchar\n \nValues\n[\n10\n])\n \n{\n\n\n  \nreturn\n \nmemcmp\n(\nOrderedValues\n,\n \nValues\n,\n \nsizeof\n(\nValues\n))\n \n==\n \n0\n;\n  \n// sizeof(Values) ==> sizeof(char*) [implicit cast to char*]\n\n\n}\n\nSuspicious âsizeofâ by âsizeofâ expression\nÂ¶\n\n\nMultiplying \nsizeof\n expressions typically makes no sense and is probably a\nlogic error. In the following example, the programmer used \n*\n instead of\n\n/\n.\n\n\nconst\n \nchar\n \nkMessage\n[]\n \n=\n \n\"Hello World!\"\n;\n\n\nvoid\n \ngetMessage\n(\nchar\n*\n \nbuf\n)\n \n{\n\n\n  \nmemcpy\n(\nbuf\n,\n \nkMessage\n,\n \nsizeof\n(\nkMessage\n)\n \n*\n \nsizeof\n(\nchar\n));\n  \n//  sizeof(kMessage) / sizeof(char)\n\n\n}\n\n\n\n\n\n\nThis check may trigger on code using the arraysize macro. The following code is\nworking correctly but should be simplified by using only the \nsizeof\n\noperator.\n\n\nextern\n \nObject\n \nobjects\n[\n100\n];\n\n\nvoid\n \nInitializeObjects\n()\n \n{\n\n\n  \nmemset\n(\nobjects\n,\n \n0\n,\n \narraysize\n(\nobjects\n)\n \n*\n \nsizeof\n(\nObject\n));\n  \n// sizeof(objects)\n\n\n}\n\nSuspicious usage of âsizeof(sizeof(â¦))â\nÂ¶\n\n\nGetting the \nsizeof\n of a \nsizeof\n makes no sense and is typically an error\nhidden through macros.\n\n\n#define INT_SZ sizeof(int)\n\n\nint\n \nbuf\n[]\n \n=\n \n{\n \n42\n \n};\n\n\nvoid\n \ngetInt\n(\nint\n*\n \ndst\n)\n \n{\n\n\n  \nmemcpy\n(\ndst\n,\n \nbuf\n,\n \nsizeof\n(\nINT_SZ\n));\n  \n// sizeof(sizeof(int)) is suspicious.\n\n\n}\n\nSuspicious usages of âsizeof(â¦)â in pointer arithmetic\nÂ¶\n\n\nArithmetic operators on pointers automatically scale the result with the size\nof the pointed typed.\nFurther use of \nsizeof\n around pointer arithmetic will typically result in an\nunintended result.\n\n\n\n\nScaling the result of pointer difference\nÂ¶\n\n\nSubtracting two pointers results in an integer expression (of type\n\nptrdiff_t\n) which expresses the distance between the two pointed objects in\nânumber of objects betweenâ.\nA common mistake is to think that the result is ânumber of bytes betweenâ, and\nscale the difference with \nsizeof\n, such as \nP1\n \n-\n \nP2\n \n==\n \nN\n \n*\n \nsizeof(T)\n\n(instead of \nP1\n \n-\n \nP2\n \n==\n \nN\n) or \n(P1\n \n-\n \nP2)\n \n/\n \nsizeof(T)\n instead of\n\nP1\n \n-\n \nP2\n.\n\n\nvoid\n \nsplitFour\n(\nconst\n \nObj\n*\n \nObjs\n,\n \nsize_t\n \nN\n,\n \nObj\n \nDelimiter\n)\n \n{\n\n\n  \nconst\n \nObj\n \n*\nP\n \n=\n \nObjs\n;\n\n\n  \nwhile\n \n(\nP\n \n<\n \nObjs\n \n+\n \nN\n)\n \n{\n\n\n    \nif\n \n(\n*\nP\n \n==\n \nDelimiter\n)\n \n{\n\n\n      \nbreak\n;\n\n\n    \n}\n\n\n  \n}\n\n\n\n  \nif\n \n(\nP\n \n-\n \nObjs\n \n!=\n \n4\n \n*\n \nsizeof\n(\nObj\n))\n \n{\n \n// Expecting a distance multiplied by sizeof is suspicious.\n\n\n    \nerror\n();\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nvoid\n \niterateIfEvenLength\n(\nint\n \n*\nBegin\n,\n \nint\n \n*\nEnd\n)\n \n{\n\n\n  \nauto\n \nN\n \n=\n \n(\nBegin\n \n-\n \nEnd\n)\n \n/\n \nsizeof\n(\nint\n);\n \n// Dividing by sizeof() is suspicious.\n\n\n  \nif\n \n(\nN\n \n%\n \n2\n)\n\n\n    \nreturn\n;\n\n\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\n\n\n\nStepping a pointer with a scaled integer\nÂ¶\n\n\nConversely, when performing pointer arithmetics to add or subtract from a\npointer, the arithmetic operator implicitly scales the value actually added to\nthe pointer with the size of the pointee, as \nPtr\n \n+\n \nN\n expects \nN\n to be\nânumber of objects to stepâ, and not ânumber of bytes to stepâ.\n\n\nSeeing the calculation of a pointer where \nsizeof\n appears is suspicious,\nand the result is typically unintended, often out of bounds.\n\nPtr\n \n+\n \nsizeof(T)\n will offset the pointer by \nsizeof(T)\n elements,\neffectively exponentiating the scaling factor to the power of 2.\n\n\nSimilarly, multiplying or dividing a numeric value with the \nsizeof\n of an\nelement or the whole buffer is suspicious, because the dimensional connection\nbetween the numeric value and the actual \nsizeof\n result can not always be\ndeduced.\nWhile scaling an integer up (multiplying) with \nsizeof\n is likely \nalways\n\nan issue, a scaling down (division) is not always inherently dangerous, in case\nthe developer is aware that the division happens between an appropriate number\nof _bytes_ and a \nsizeof\n value.\nTurning \nWarnOnOffsetDividedBySizeOf\n off will restrict the\nwarnings to the multiplication case.\n\n\nThis case also checks suspicious \nalignof\n and \noffsetof\n usages in\npointer arithmetic, as both return the âsizeâ in bytes and not elements,\npotentially resulting in doubly-scaled offsets.\n\n\nvoid\n \nprintEveryEvenIndexElement\n(\nint\n \n*\nArray\n,\n \nsize_t\n \nN\n)\n \n{\n\n\n  \nint\n \n*\nP\n \n=\n \nArray\n;\n\n\n  \nwhile\n \n(\nP\n \n<=\n \nArray\n \n+\n \nN\n \n*\n \nsizeof\n(\nint\n))\n \n{\n \n// Suspicious pointer arithmetic using sizeof()!\n\n\n    \nprintf\n(\n\"%d \"\n,\n \n*\nP\n);\n\n\n\n    \nP\n \n+=\n \n2\n \n*\n \nsizeof\n(\nint\n);\n \n// Suspicious pointer arithmetic using sizeof()!\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nstruct\n \nMessage\n \n{\n \n/* ... */\n;\n \nchar\n \nFlags\n[\n8\n];\n \n};\n\n\nvoid\n \nclearFlags\n(\nMessage\n \n*\nArray\n,\n \nsize_t\n \nN\n)\n \n{\n\n\n  \nconst\n \nMessage\n \n*\nEnd\n \n=\n \nArray\n \n+\n \nN\n;\n\n\n  \nwhile\n \n(\nArray\n \n<\n \nEnd\n)\n \n{\n\n\n    \nmemset\n(\nArray\n \n+\n \noffsetof\n(\nMessage\n,\n \nFlags\n),\n \n// Suspicious pointer arithmetic using offsetof()!\n\n\n           \n0\n,\n \nsizeof\n(\nMessage\n::\nFlags\n));\n\n\n    \n++\nArray\n;\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nFor this checked bogus pattern, \ncert-arr39-c\n redirects here as an alias of\nthis check.\n\n\nThis check corresponds to the CERT C Coding Standard rule\n\nARR39-C. Do not add or subtract a scaled integer to a pointer\n.\n\nLimitations\nÂ¶\n\n\nCases where the pointee type has a size of \n1\n byte (such as, and most\nimportantly, \nchar\n) are excluded.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnSizeOfConstant\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like\n\nsizeof(CONSTANT)\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfIntegerExpression\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like \nsizeof(expr)\n\nwhere the expression results in an integer. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfThis\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like \nsizeof(this)\n.\nDefault is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfCompareToConstant\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on an expression like\n\nsizeof(expr)\n \n<=\n \nk\n for a suspicious constant \nk\n while \nk\n is \n0\n or\ngreater than \n0x8000\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfPointerToAggregate\nÂ¶\n\n\nWhen \ntrue\n, the check will warn when the argument of \nsizeof\n is either a\npointer-to-aggregate type, an expression returning a pointer-to-aggregate\nvalue or an expression that returns a pointer from an array-to-pointer\nconversion (that may be implicit or explicit, for example \narray\n \n+\n \n2\n or\n\n(int\n \n*)array\n). Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfPointer\nÂ¶\n\n\nWhen \ntrue\n, the check will report all expressions where the argument of\n\nsizeof\n is an expression that produces a pointer (except for a few\nidiomatic expressions that are probably intentional and correct).\nThis detects occurrences of CWE 467. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nWarnOnOffsetDividedBySizeOf\nÂ¶\n\n\nWhen \ntrue\n, the check will warn on pointer arithmetic where the\nelement count is obtained from a division with \nsizeof(...)\n,\ne.g., \nPtr\n \n+\n \nBytes\n \n/\n \nsizeof(*T)\n. Default is \ntrue\n.\n\n\n\n\n\n\n\n\nWarnOnSizeOfInLoopTermination\nÂ¶\n\n\nWhen \ntrue\n, the check will warn about incorrect use of sizeof expression\nin loop termination condition. The warning triggers if the \nsizeof\n\nexpression appears to be incorrectly used to determine the number of\narray/buffer elements.\ne.g, \nlong\n \narr[10];\n \nfor(int\n \ni\n \n=\n \n0;\n \ni\n \n<\n \nsizeof(arr);\n \ni++)\n \n{\n \n...\n \n}\n. Default\nis \ntrue\n.",
    "configurations": []
  }
}