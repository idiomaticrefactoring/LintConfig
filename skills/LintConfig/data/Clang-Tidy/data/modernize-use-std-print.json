{
  "name": "modernize-use-std-print",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-print.html",
    "fixable": true
  },
  "content": {
    "introduction": "Converts calls to \nprintf\n, \nfprintf\n, \nabsl::PrintF\n and\n\nabsl::FPrintf\n to equivalent calls to C++23âs \nstd::print\n or\n\nstd::println\n as appropriate, modifying the format string appropriately.\nThe replaced and replacement functions can be customised by configuration\noptions. Each argument that is the result of a call to\n\nstd::string::c_str()\n and \nstd::string::data()\n will have that\nnow-unnecessary call removed in a similar manner to the\n\nreadability-redundant-string-cstr\n check.\n\nIn other words, it turns lines like:\n\nfprintf\n(\nstderr\n,\n \n\"The %s is %3d\n\\n\n\"\n,\n \ndescription\n.\nc_str\n(),\n \nvalue\n);\n\ninto:\n\nstd\n::\nprintln\n(\nstderr\n,\n \n\"The {} is {:3}\"\n,\n \ndescription\n,\n \nvalue\n);\n\nIf the \nReplacementPrintFunction\n or \nReplacementPrintlnFunction\n options\nare left at or set to their default values then this check is only enabled\nwith \n-std=c++23\n or later.\n\nMacros starting with \nPRI\n and \n__PRI\n from \n<inttypes.h>\n are\nexpanded, escaping is handled and adjacent strings are concatenated to form\na single \nStringLiteral\n before the format string is converted. Use of\nany other macros in the format string will cause a warning message to be\nemitted and no conversion will be performed. The converted format string\nwill always be a single string literal.\n\nThe check doesnât do a bad job, but itâs not perfect. In particular:\n\nIt assumes that the format string is correct for the arguments. If you\nget any warnings when compiling with \n-Wformat\n then misbehaviour is\npossible.\n\n\nAt the point that the check runs, the AST contains a single\n\nStringLiteral\n for the format string where escapes have been expanded.\nThe check tries to reconstruct escape sequences, they may not be the same\nas they were written (e.g. \n\"\\x41\\x0a\"\n will become \n\"A\\n\"\n and\n\n\"ab\"\n \n\"cd\"\n will become \n\"abcd\"\n.)\n\n\nIt supports field widths, precision, positional arguments, leading zeros,\nleading \n+\n, alignment and alternative forms.\n\n\nUse of any unsupported flags or specifiers will cause the entire\nstatement to be left alone and a warning to be emitted. Particular\nunsupported features are:\n\n\n\n\nThe \n%'\n flag for thousands separators.\n\n\nThe glibc extension \n%m\n.\n\n\n\n\n\n\nprintf\n and similar functions return the number of characters printed.\n\nstd::print\n does not. This means that any invocations that use the\nreturn value will not be converted. Unfortunately this currently includes\nexplicitly-casting to \nvoid\n. Deficiencies in this check mean that any\ninvocations inside \nGCC\n compound statements cannot be converted even\nif the resulting value is not used.\n\nIf conversion would be incomplete or unsafe then the entire invocation will\nbe left unchanged.\n\nIf the call is deemed suitable for conversion then:\n\nprintf\n, \nfprintf\n, \nabsl::PrintF\n, \nabsl::FPrintF\n and any\nfunctions specified by the \nPrintfLikeFunctions\n option or\n\nFprintfLikeFunctions\n are replaced with the function specified by the\n\nReplacementPrintlnFunction\n option if the format string ends with \n\\n\n\nor \nReplacementPrintFunction\n otherwise.\n\n\nthe format string is rewritten to use the \nstd::formatter\n language. If\na \n\\n\n is found at the end of the format string not preceded by \nr\n\nthen it is removed and \nReplacementPrintlnFunction\n is used rather than\n\nReplacementPrintFunction\n.\n\n\nany arguments that corresponded to \n%p\n specifiers that\n\nstd::formatter\n wouldnât accept are wrapped in a \nstatic_cast\n\nto \nconst\n \nvoid\n \n*\n.\n\n\nany arguments that corresponded to \n%s\n specifiers where the argument\nis of \nsigned\n \nchar\n or \nunsigned\n \nchar\n type are wrapped in a\n\nreinterpret_cast<const\n \nchar\n \n*>\n.\n\n\nany arguments where the format string and the parameter differ in\nsignedness will be wrapped in an appropriate \nstatic_cast\n if \nStrictMode\n\nis enabled.\n\n\nany arguments that end in a call to \nstd::string::c_str()\n or\n\nstd::string::data()\n will have that call removed.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\n\n\nWhen \ntrue\n, the check will add casts when converting from variadic\nfunctions like \nprintf\n and printing signed or unsigned integer types\n(including fixed-width integer types from \n<cstdint>\n, \nptrdiff_t\n,\n\nsize_t\n and \nssize_t\n) as the opposite signedness to ensure that\nthe output matches that of \nprintf\n. This does not apply when\nconverting from non-variadic functions such as \nabsl::PrintF\n and\n\nfmt::printf\n. For example, with \nStrictMode\n enabled:\n\n\n\n\nint\n \ni\n \n=\n \n-42\n;\n\n\nunsigned\n \nint\n \nu\n \n=\n \n0xffffffff\n;\n\n\nprintf\n(\n\"%u %d\n\\n\n\"\n,\n \ni\n,\n \nu\n);\n\n\n\n\n\n\nwould be converted to:\n\n\nstd\n::\nprint\n(\n\"{} {}\n\\n\n\"\n,\n \nstatic_cast\n<\nunsigned\n \nint\n>\n(\ni\n),\n \nstatic_cast\n<\nint\n>\n(\nu\n));\n\n\n\n\n\n\nto ensure that the output will continue to be the unsigned representation\nof \n-42\n and the signed representation of \n0xffffffff\n (often\n\n4294967254\n and \n-1\n respectively.) When \nfalse\n (which is the default),\nthese casts will not be added which may cause a change in the output.\n\n\n\n\n\n\n\n\nPrintfLikeFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement\nthat the first parameter contains the printf-style format string and the\narguments to be formatted follow immediately afterwards. Qualified member\nfunction names are supported, but the replacement function name must be\nunqualified. If neither this option nor \nFprintfLikeFunctions\n are set then\nthe default value is \nprintf; absl::PrintF\n, otherwise it is the empty\nstring.\n\n\n\n\n\n\n\n\nFprintfLikeFunctions\nÂ¶\n\n\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement\nthat the first parameter is retained, the second parameter contains the\nprintf-style format string and the arguments to be formatted follow\nimmediately afterwards. Qualified member function names are supported,\nbut the replacement function name must be unqualified. If neither this\noption nor \nPrintfLikeFunctions\n are set then the default value is\n\nfprintf;absl::FPrintF\n, otherwise it is the empty string.\n\n\n\n\n\n\n\n\nReplacementPrintFunction\nÂ¶\n\n\nThe function that will be used to replace \nprintf\n, \nfprintf\n etc.\nduring conversion rather than the default \nstd::print\n when the\noriginalformat string does not end with \n\\n\n. It is expected that the\nfunction provides an interface that is compatible with \nstd::print\n. A\nsuitable candidate would be \nfmt::print\n.\n\n\n\n\n\n\n\n\nReplacementPrintlnFunction\nÂ¶\n\n\nThe function that will be used to replace \nprintf\n, \nfprintf\n etc.\nduring conversion rather than the default \nstd::println\n when the\noriginal format string ends with \n\\n\n. It is expected that the\nfunction provides an interface that is compatible with \nstd::println\n.\nA suitable candidate would be \nfmt::println\n.\n\n\n\n\n\n\n\n\nPrintHeader\nÂ¶\n\n\nThe header that must be included for the declaration of\n\nReplacementPrintFunction\n so that a \n#include\n directive can be\nadded if required. If \nReplacementPrintFunction\n is \nstd::print\n\nthen this option will default to \n<print>\n, otherwise this option will\ndefault to nothing and no \n#include\n directive will be added.",
    "configurations": []
  }
}