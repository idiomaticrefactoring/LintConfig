{
  "name": "readability-qualified-auto",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/qualified-auto.html",
    "fixable": true
  },
  "content": {
    "introduction": "Adds pointer qualifications to \nauto\n-typed variables that are deduced to\npointers.\n\nLLVM Coding Standards\n\nadvises to make it obvious if a \nauto\n typed variable is a pointer. This\ncheck will transform \nauto\n to \nauto\n \n*\n when the type is deduced to be a\npointer.\n\nfor\n \n(\nauto\n \nData\n \n:\n \nMutatablePtrContainer\n)\n \n{\n\n\n  \nchange\n(\n*\nData\n);\n\n\n}\n\n\nfor\n \n(\nauto\n \nData\n \n:\n \nConstantPtrContainer\n)\n \n{\n\n\n  \nobserve\n(\n*\nData\n);\n\n\n}\n\nWould be transformed into:\n\nfor\n \n(\nauto\n \n*\nData\n \n:\n \nMutatablePtrContainer\n)\n \n{\n\n\n  \nchange\n(\n*\nData\n);\n\n\n}\n\n\nfor\n \n(\nconst\n \nauto\n \n*\nData\n \n:\n \nConstantPtrContainer\n)\n \n{\n\n\n  \nobserve\n(\n*\nData\n);\n\n\n}\n\nNote \nconst\n \nvolatile\n qualified types will retain their \nconst\n and\n\nvolatile\n qualifiers. Pointers to pointers will not be fully qualified.\n\nconst\n \nauto\n \nFoo\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz1\n);\n\n\nconst\n \nauto\n \nBar\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBaz2\n);\n\n\nvolatile\n \nauto\n \nFooBar\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz3\n);\n\n\nauto\n \nBarFoo\n \n=\n \ncast\n<\nint\n \n**>\n(\nBaz4\n);\n\nWould be transformed into:\n\nauto\n \n*\nconst\n \nFoo\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz1\n);\n\n\nconst\n \nauto\n \n*\nconst\n \nBar\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBaz2\n);\n\n\nauto\n \n*\nvolatile\n \nFooBar\n \n=\n \ncast\n<\nint\n \n*>\n(\nBaz3\n);\n\n\nauto\n \n*\nBarFoo\n \n=\n \ncast\n<\nint\n \n**>\n(\nBaz4\n);\n\nOptions\nÂ¶\n\n\n\n\n\n\nAddConstToQualified\nÂ¶\n\n\nWhen set to \ntrue\n the check will add const qualifiers variables defined as\n\nauto\n \n*\n or \nauto\n \n&\n when applicable.\nDefault value is \ntrue\n.\n\n\n\n\nauto\n \nFoo1\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar1\n);\n\n\nauto\n \n*\nFoo2\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar2\n);\n\n\nauto\n \n&\nFoo3\n \n=\n \ncast\n<\nconst\n \nint\n \n&>\n(\nBar3\n);\n\n\n\n\n\n\nIf AddConstToQualified is set to \nfalse\n, it will be transformed into:\n\n\nconst\n \nauto\n \n*\nFoo1\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar1\n);\n\n\nauto\n \n*\nFoo2\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar2\n);\n\n\nauto\n \n&\nFoo3\n \n=\n \ncast\n<\nconst\n \nint\n \n&>\n(\nBar3\n);\n\n\n\n\n\n\nOtherwise it will be transformed into:\n\n\nconst\n \nauto\n \n*\nFoo1\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar1\n);\n\n\nconst\n \nauto\n \n*\nFoo2\n \n=\n \ncast\n<\nconst\n \nint\n \n*>\n(\nBar2\n);\n\n\nconst\n \nauto\n \n&\nFoo3\n \n=\n \ncast\n<\nconst\n \nint\n \n&>\n(\nBar3\n);\n\n\n\n\n\n\nNote in the LLVM alias, the default value is \nfalse\n.\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types to ignore when \nauto\n is\ndeduced to that type or a pointer to that type. Note that this distinguishes\ntype aliases from the original type, so specifying e.g. \nmy_int\n will not\nsuppress reports about \nint\n even if it is defined as a \ntypedef\n alias\nfor \nint\n. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n\nmatches every type with suffix \nRef\n, \nref\n, \nReference\n and\n\nreference\n. If a name in the list contains the sequence \n::\n it is matched\nagainst the qualified type name (i.e. \nnamespace::Type\n), otherwise it is\nmatched against only the type name (i.e. \nType\n). E.g. to suppress reports\nfor \nstd::array\n iterators use \nstd::array<.*>::(const_)?iterator\n string.\nThe default is an empty string.\n\n\n\n\n\n\n\n\nIgnoreAliasing\nÂ¶\n\n\nIf set to \ntrue\n the check will use the underlying type to determine the type\nthat \nauto\n is deduced to. If set to \nfalse\n the check will not look beyond\nthe first type alias.\nDefault value is \ntrue\n.\n\n\nusing\n \nIntPtr\n \n=\n \nint\n*\n;\n\n\nIntPtr\n \nfoo\n();\n\n\n\nauto\n \nbar\n \n=\n \nfoo\n();\n\n\n\n\n\n\nIf \nIgnoreAliasing\n is set to \ntrue\n, it will be transformed into:\n\n\nauto\n \n*\nbar\n \n=\n \nfoo\n();\n\n\n\n\n\n\nOtherwise no changes will occur.\n\nLimitations\nÂ¶\n\n\nWhen \nIgnoreAliasing\n is set to \nfalse\n, there are cases where\nClang has not preserved the type alias and the underlying type will be used so\nfalse positives may occur.\n\n\nFor example:\n\n\nusing\n \nIntPtr\n \n=\n \nint\n \n*\n;\n\n\n\nvoid\n \nloopPtr\n(\nconst\n \nstd\n::\nvector\n<\nIntPtr\n>\n \n&\nVectorIntPtr\n)\n \n{\n\n\n\n  \n// May fail for IgnoreAliasing==false as AST does not have the 'IntPtr'\n\n\n  \nfor\n \n(\nauto\n \nData\n \n:\n \nVectorIntPtr\n)\n \n{\n\n\n  \n}\n\n\n}",
    "configurations": []
  }
}