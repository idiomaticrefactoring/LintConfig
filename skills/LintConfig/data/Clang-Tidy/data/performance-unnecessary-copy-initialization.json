{
  "name": "performance-unnecessary-copy-initialization",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/unnecessary-copy-initialization.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds local variable declarations that are initialized using the copy\nconstructor of a non-trivially-copyable type but it would suffice to obtain a\nconst reference.\n\nThe check is only applied if it is safe to replace the copy by a const\nreference. This is the case when the variable is const qualified or when it is\nonly used as a const, i.e. only const methods or operators are invoked on it,\nor it is used as const reference or value argument in constructors or function\ncalls.\n\nExample:\n\nconst\n \nstring\n&\n \nconstReference\n();\n\n\nvoid\n \nFunction\n()\n \n{\n\n\n  \n// The warning will suggest making this a const reference.\n\n\n  \nconst\n \nstring\n \nUnnecessaryCopy\n \n=\n \nconstReference\n();\n\n\n}\n\n\n\nstruct\n \nFoo\n \n{\n\n\n  \nconst\n \nstring\n&\n \nname\n()\n \nconst\n;\n\n\n};\n\n\nvoid\n \nFunction\n(\nconst\n \nFoo\n&\n \nfoo\n)\n \n{\n\n\n  \n// The warning will suggest making this a const reference.\n\n\n  \nstring\n \nUnnecessaryCopy1\n \n=\n \nfoo\n.\nname\n();\n\n\n  \nUnnecessaryCopy1\n.\nfind\n(\n\"bar\"\n);\n\n\n\n  \n// The warning will suggest making this a const reference.\n\n\n  \nstring\n \nUnnecessaryCopy2\n \n=\n \nUnnecessaryCopy1\n;\n\n\n  \nUnnecessaryCopy2\n.\nfind\n(\n\"bar\"\n);\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types allowed to be initialized by\ncopying. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n matches\nevery type with suffix \nRef\n, \nref\n, \nReference\n and \nreference\n.\nThe default is empty. If a name in the list contains the sequence \n::\n, it\nis matched against the qualified type name (i.e. \nnamespace::Type\n),\notherwise it is matched against only the type name (i.e. \nType\n).\n\n\n\n\n\n\n\n\nExcludedContainerTypes\nÂ¶\n\n\nA semicolon-separated list of names of types whose methods are allowed to\nreturn the const reference the variable is copied from. When an expensive to\ncopy variable is copy initialized by the return value from a type on this\nlist the check does not trigger. This can be used to exclude types known to\nbe const incorrect or where the lifetime or immutability of returned\nreferences is not tied to mutations of the container. An example are view\ntypes that donât own the underlying data. Like for \nAllowedTypes\n above,\nregular expressions are accepted and the inclusion of \n::\n determines whether\nthe qualified typename is matched or not.\n\nLimitations\nÂ¶\n\n\nThis check does not perform lifetime analysis and may suggest replacing copies\nwith const references that could become dangling. Be cautious when the\nreferenced object might be invalidated by subsequent operations.\n\n\nvoid\n \nconsume\n(\nconst\n \nS\n&\n);\n\n\n\nvoid\n \nfunc\n(\nstd\n::\nvector\n<\nS\n>\n \n&\nVec\n)\n \n{\n\n\n  \nconst\n \nauto\n \nIt\n \n=\n \nVec\n.\nbegin\n();\n\n\n  \nconst\n \nS\n \nValue\n(\n*\nIt\n);\n \n// The warning will suggest making this a const reference.\n\n\n  \nVec\n.\nerase\n(\nIt\n);\n \n// Container modifications could invalidate references.\n\n\n  \nconsume\n(\nValue\n);\n \n// Safe with copy, dangling reference otherwise.\n\n\n}",
    "configurations": []
  }
}