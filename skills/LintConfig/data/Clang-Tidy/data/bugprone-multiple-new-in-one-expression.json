{
  "name": "bugprone-multiple-new-in-one-expression",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/multiple-new-in-one-expression.html",
    "fixable": false
  },
  "content": {
    "introduction": "Finds multiple \nnew\n operator calls in a single expression, where the\nallocated memory by the first \nnew\n may leak if the second allocation fails\nand throws exception.\n\nC++ does often not specify the exact order of evaluation of the operands of an\noperator or arguments of a function. Therefore if a first allocation succeeds\nand a second fails, in an exception handler it is not possible to tell which\nallocation has failed and free the memory. Even if the order is fixed the\nresult of a first \nnew\n may be stored in a temporary location that is not\nreachable at the time when a second allocation fails. It is best to avoid any\nexpression that contains more than one \noperator\n \nnew\n call, if exception\nhandling is used to check for allocation errors.\n\nDifferent rules apply for are the short-circuit operators \n||\n and \n&&\n and\nthe \n,\n operator, where evaluation of one side must be completed before the\nother starts. Expressions of a list-initialization (initialization or\nconstruction using \n{\n and \n}\n characters) are evaluated in fixed order.\nSimilarly, condition of a \n?\n operator is evaluated before the branches are\nevaluated.\n\nThe check reports warning if two \nnew\n calls appear in one expression at\ndifferent sides of an operator, or if \nnew\n calls appear in different\narguments of a function call (that can be an object construction with \n()\n\nsyntax). These \nnew\n calls can be nested at any level.\nFor any warning to be emitted the \nnew\n calls should be in a code block where\nexception handling is used with catch for \nstd::bad_alloc\n or\n\nstd::exception\n. At \n||\n, \n&&\n, \n,\n, \n?\n (condition and one branch)\noperators no warning is emitted. No warning is emitted if both of the memory\nallocations are not assigned to a variable or not passed directly to a\nfunction. The reason is that in this case the memory may be intentionally not\nfreed or the allocated objects can be self-destructing objects.\n\nExamples:\n\nstruct\n \nA\n \n{\n\n\n  \nint\n \nVar\n;\n\n\n};\n\n\nstruct\n \nB\n \n{\n\n\n  \nB\n();\n\n\n  \nB\n(\nA\n \n*\n);\n\n\n  \nint\n \nVar\n;\n\n\n};\n\n\nstruct\n \nC\n \n{\n\n\n  \nint\n \n*\nX1\n;\n\n\n  \nint\n \n*\nX2\n;\n\n\n};\n\n\n\nvoid\n \nf\n(\nA\n \n*\n,\n \nB\n \n*\n);\n\n\nint\n \nf1\n(\nA\n \n*\n);\n\n\nint\n \nf1\n(\nB\n \n*\n);\n\n\nbool\n \nf2\n(\nA\n \n*\n);\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n\n  \nA\n \n*\nPtrA\n;\n\n\n  \nB\n \n*\nPtrB\n;\n\n\n  \ntry\n \n{\n\n\n    \n// Allocation of 'B'/'A' may fail after memory for 'A'/'B' was allocated.\n\n\n    \nf\n(\nnew\n \nA\n,\n \nnew\n \nB\n);\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined\n\n\n\n    \n// List (aggregate) initialization is used.\n\n\n    \nC\n \nC1\n{\nnew\n \nint\n,\n \nnew\n \nint\n};\n \n// no warning\n\n\n\n    \n// Allocation of 'B'/'A' may fail after memory for 'A'/'B' was allocated but not yet passed to function 'f1'.\n\n\n    \nint\n \nX\n \n=\n \nf1\n(\nnew\n \nA\n)\n \n+\n \nf1\n(\nnew\n \nB\n);\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined\n\n\n\n    \n// Allocation of 'B' may fail after memory for 'A' was allocated.\n\n\n    \n// From C++17 on memory for 'B' is allocated first but still may leak if allocation of 'A' fails.\n\n\n    \nPtrB\n \n=\n \nnew\n \nB\n(\nnew\n \nA\n);\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception\n\n\n\n    \n// 'new A' and 'new B' may be performed in any order.\n\n\n    \n// 'new B'/'new A' may fail after memory for 'A'/'B' was allocated but not assigned to 'PtrA'/'PtrB'.\n\n\n    \n(\nPtrA\n \n=\n \nnew\n \nA\n)\n->\nVar\n \n=\n \n(\nPtrB\n \n=\n \nnew\n \nB\n)\n->\nVar\n;\n \n// warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined\n\n\n\n    \n// Evaluation of 'f2(new A)' must be finished before 'f1(new B)' starts.\n\n\n    \n// If 'new B' fails the allocated memory for 'A' is supposedly handled correctly because function 'f2' could take the ownership.\n\n\n    \nbool\n \nZ\n \n=\n \nf2\n(\nnew\n \nA\n)\n \n||\n \nf1\n(\nnew\n \nB\n);\n \n// no warning\n\n\n\n    \nX\n \n=\n \n(\nf2\n(\nnew\n \nA\n)\n \n?\n \nf1\n(\nnew\n \nA\n)\n \n:\n \nf1\n(\nnew\n \nB\n));\n \n// no warning\n\n\n\n    \n// No warning if the result of both allocations is not passed to a function\n\n\n    \n// or stored in a variable.\n\n\n    \n(\nnew\n \nA\n)\n->\nVar\n \n=\n \n(\nnew\n \nB\n)\n->\nVar\n;\n \n// no warning\n\n\n\n    \n// No warning if at least one non-throwing allocation is used.\n\n\n    \nf\n(\nnew\n(\nstd\n::\nnothrow\n)\n \nA\n,\n \nnew\n \nB\n);\n \n// no warning\n\n\n  \n}\n \ncatch\n(\nstd\n::\nbad_alloc\n)\n \n{\n\n\n  \n}\n\n\n\n  \n// No warning if the allocation is outside a try block (or no catch handler exists for std::bad_alloc).\n\n\n  \n// (The fact if exceptions can escape from 'foo' is not taken into account.)\n\n\n  \nf\n(\nnew\n \nA\n,\n \nnew\n \nB\n);\n \n// no warning\n\n\n}",
    "configurations": []
  }
}