{
  "name": "bugprone-fold-init-type",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/fold-init-type.html",
    "fixable": false
  },
  "content": {
    "introduction": "The check flags type mismatches in\n\nfolds\n\nlike \nstd::accumulate\n that might result in loss of precision.\n\nstd::accumulate\n folds an input range into an initial value using\nthe type of the latter, with \noperator+\n by default. This can cause\nloss of precision through:\n\nTruncation: The following code uses a floating point range and an int\ninitial value, so truncation will happen at every application of\n\noperator+\n  and the result will be \n0\n, which might not be what the\nuser expected.\n\nauto\n \na\n \n=\n \n{\n0.5f\n,\n \n0.5f\n,\n \n0.5f\n,\n \n0.5f\n};\n\n\nreturn\n \nstd\n::\naccumulate\n(\nstd\n::\nbegin\n(\na\n),\n \nstd\n::\nend\n(\na\n),\n \n0\n);\n\nOverflow: The following code also returns \n0\n.\n\nauto\n \na\n \n=\n \n{\n65536L\nL\n \n*\n \n65536\n \n*\n \n65536\n};\n\n\nreturn\n \nstd\n::\naccumulate\n(\nstd\n::\nbegin\n(\na\n),\n \nstd\n::\nend\n(\na\n),\n \n0\n);",
    "configurations": []
  }
}