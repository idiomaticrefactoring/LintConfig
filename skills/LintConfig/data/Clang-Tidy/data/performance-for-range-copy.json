{
  "name": "performance-for-range-copy",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/for-range-copy.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds C++11 for ranges where the loop variable is copied in each iteration but\nit would suffice to obtain it by const reference.\n\nThe check is only applied to loop variables of types that are expensive to copy\nwhich means they are not trivially copyable or have a non-trivial copy\nconstructor or destructor.\n\nTo ensure that it is safe to replace the copy with a const reference the\nfollowing heuristic is employed:\n\nThe loop variable is const qualified.\n\n\nThe loop variable is not const, but only const methods or operators are\ninvoked on it, or it is used as const reference or value argument in\nconstructors or function calls.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWarnOnAllAutoCopies\nÂ¶\n\n\nWhen \ntrue\n, warns on any use of \nauto\n as the type of the range-based for\nloop variable. Default is \nfalse\n.\n\n\n\n\n\n\n\n\nAllowedTypes\nÂ¶\n\n\nA semicolon-separated list of names of types allowed to be copied in each\niteration. Regular expressions are accepted, e.g. \n[Rr]ef(erence)?$\n\nmatches every type with suffix \nRef\n, \nref\n, \nReference\n and\n\nreference\n. The default is empty. If a name in the list contains the\nsequence \n::\n, it is matched against the qualified type name\n(i.e. \nnamespace::Type\n), otherwise it is matched against only the\ntype name (i.e. \nType\n).",
    "configurations": []
  }
}