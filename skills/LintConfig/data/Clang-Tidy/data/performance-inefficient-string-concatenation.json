{
  "name": "performance-inefficient-string-concatenation",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/inefficient-string-concatenation.html",
    "fixable": false
  },
  "content": {
    "introduction": "This check warns about the performance overhead arising from concatenating\nstrings using the \noperator+\n, for instance:\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Bar\"\n);\n\n\na\n \n=\n \na\n \n+\n \nb\n;\n\nInstead of this structure you should use \noperator+=\n or \nstd::string\nâs\n(\nstd::basic_string\n) class member function \nappend()\n. For instance:\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n20000\n;\n \n++\ni\n)\n \n{\n\n\n    \na\n \n=\n \na\n \n+\n \n\"Bar\"\n \n+\n \nb\n;\n\n\n}\n\nCould be rewritten in a greatly more efficient way like:\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n20000\n;\n \n++\ni\n)\n \n{\n\n\n    \na\n.\nappend\n(\n\"Bar\"\n).\nappend\n(\nb\n);\n\n\n}\n\nAnd this can be rewritten too:\n\nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n&\n)\n \n{}\n\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nvoid\n \ng\n()\n \n{\n\n\n    \nf\n(\na\n \n+\n \n\"Bar\"\n \n+\n \nb\n);\n\n\n}\n\nIn a slightly more efficient way like:\n\nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n&\n)\n \n{}\n\n\nstd\n::\nstring\n \na\n(\n\"Foo\"\n),\n \nb\n(\n\"Baz\"\n);\n\n\nvoid\n \ng\n()\n \n{\n\n\n    \nf\n(\nstd\n::\nstring\n(\na\n).\nappend\n(\n\"Bar\"\n).\nappend\n(\nb\n));\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen \nfalse\n, the check will only check the string usage in \nwhile\n, \nfor\n\nand \nfor-range\n statements. Default is \nfalse\n.",
    "configurations": []
  }
}