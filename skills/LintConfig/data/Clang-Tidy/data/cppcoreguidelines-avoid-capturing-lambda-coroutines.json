{
  "name": "cppcoreguidelines-avoid-capturing-lambda-coroutines",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/avoid-capturing-lambda-coroutines.html",
    "fixable": false
  },
  "content": {
    "introduction": "Flags C++20 coroutine lambdas with non-empty capture lists that may cause\nuse-after-free errors and suggests avoiding captures or ensuring the lambda\nclosure object has a guaranteed lifetime.\n\nThis check implements \nCP.51\n\nfrom the C++ Core Guidelines.\n\nUsing coroutine lambdas with non-empty capture lists can be risky, as capturing\nvariables can lead to accessing freed memory after the first suspension point.\nThis issue can occur even with refcounted smart pointers and copyable types.\nWhen a lambda expression creates a coroutine, it results in a closure object\nwith storage, which is often on the stack and will eventually go out of scope.\nWhen the closure object goes out of scope, its captures also go out of scope.\nWhile normal lambdas finish executing before this happens, coroutine lambdas\nmay resume from suspension after the closure object has been destructed,\nresulting in use-after-free memory access for all captures.\n\nConsider the following example:\n\nint\n \nvalue\n \n=\n \nget_value\n();\n\n\nstd\n::\nshared_ptr\n<\nFoo\n>\n \nsharedFoo\n \n=\n \nget_foo\n();\n\n\n{\n\n\n    \nconst\n \nauto\n \nlambda\n \n=\n \n[\nvalue\n,\n \nsharedFoo\n]()\n \n->\n \nstd\n::\nfuture\n<\nvoid\n>\n\n\n    \n{\n\n\n        \nco_await\n \nsomething\n();\n\n\n        \n// \"sharedFoo\" and \"value\" have already been destroyed\n\n\n        \n// the \"shared\" pointer didn't accomplish anything\n\n\n    \n};\n\n\n    \nlambda\n();\n\n\n}\n \n// the lambda closure object has now gone out of scope\n\nIn this example, the lambda object is defined with two captures: value and\n\nsharedFoo\n. When \nlambda()\n is called, the lambda object is created on the\nstack, and the captures are copied into the closure object. When the coroutine\nis suspended, the lambda object goes out of scope, and the closure object is\ndestroyed. When the coroutine is resumed, the captured variables may have been\ndestroyed, resulting in use-after-free bugs.\n\nIn conclusion, the use of coroutine lambdas with non-empty capture lists can\nlead to use-after-free errors when resuming the coroutine after the closure\nobject has been destroyed. This check helps prevent such errors by flagging\nC++20 coroutine lambdas with non-empty capture lists and suggesting avoiding\ncaptures or ensuring the lambda closure object has a guaranteed lifetime.\n\nFollowing these guidelines can help ensure the safe and reliable use of\ncoroutine lambdas in C++ code.",
    "configurations": []
  }
}