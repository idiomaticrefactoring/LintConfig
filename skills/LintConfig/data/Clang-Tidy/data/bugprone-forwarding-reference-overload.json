{
  "name": "bugprone-forwarding-reference-overload",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html",
    "fixable": false
  },
  "content": {
    "introduction": "The check looks for perfect forwarding constructors that can hide copy or move\nconstructors. If a non const lvalue reference is passed to the constructor, the\nforwarding reference parameter will be a better match than the const reference\nparameter of the copy constructor, so the perfect forwarding constructor will\nbe called, which can be confusing.\nFor detailed description of this issue see: Scott Meyers, Effective Modern C++,\nItem 26.\n\nConsider the following example:\n\nclass\n \nPerson\n \n{\n\n\npublic\n:\n\n\n  \n// C1: perfect forwarding ctor\n\n\n  \ntemplate\n<\ntypename\n \nT\n>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// C2: perfect forwarding ctor with parameter default value\n\n\n  \ntemplate\n<\ntypename\n \nT\n>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n,\n \nint\n \nx\n \n=\n \n1\n)\n \n{}\n\n\n\n  \n// C3: perfect forwarding ctor guarded with enable_if\n\n\n  \ntemplate\n<\ntypename\n \nT\n,\n \ntypename\n \nX\n \n=\n \nenable_if_t\n<\nis_special\n<\nT\n>\n,\n \nvoid\n>>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// C4: variadic perfect forwarding ctor guarded with enable_if\n\n\n  \ntemplate\n<\ntypename\n...\n \nA\n,\n\n\n    \nenable_if_t\n<\nis_constructible_v\n<\ntuple\n<\nstring\n,\n \nint\n>\n,\n \nA\n&&\n...\n>\n,\n \nint\n>\n \n=\n \n0\n>\n\n\n  \nexplicit\n \nPerson\n(\nA\n&&\n...\n \na\n)\n \n{}\n\n\n\n  \n// C5: perfect forwarding ctor guarded with requires expression\n\n\n  \ntemplate\n<\ntypename\n \nT\n>\n\n\n  \nrequires\n \nrequires\n \n{\n \nis_special\n<\nT\n>\n;\n \n}\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// C6: perfect forwarding ctor guarded with concept requirement\n\n\n  \ntemplate\n<\nSpecial\n \nT\n>\n\n\n  \nexplicit\n \nPerson\n(\nT\n&&\n \nn\n)\n \n{}\n\n\n\n  \n// (possibly compiler generated) copy ctor\n\n\n  \nPerson\n(\nconst\n \nPerson\n&\n \nrhs\n);\n\n\n};\n\nThe check warns for constructors C1 and C2, because those can hide copy and\nmove constructors. We suppress warnings if the copy and the move constructors\nare both disabled (deleted or private), because there is nothing the perfect\nforwarding constructor could hide in this case. We also suppress warnings for\nconstructors like C3-C6 that are guarded with an \nenable_if\n or a concept,\nassuming the programmer was aware of the possible hiding.\n\nBackground\nÂ¶\n\n\nFor deciding whether a constructor is guarded with enable_if, we consider the\ntypes of the constructor parameters, the default values of template type parameters\nand the types of non-type template parameters with a default literal value. If any\npart of these types is \nstd::enable_if\n or \nstd::enable_if_t\n, we assume the\nconstructor is guarded.",
    "configurations": []
  }
}