{
  "name": "bugprone-redundant-branch-condition",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/redundant-branch-condition.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds condition variables in nested \nif\n statements that were also checked in\nthe outer \nif\n statement and were not changed.\n\nSimple example:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nif\n \n(\nonFire\n)\n\n\n    \nscream\n();\n\n\n}\n\nHere \nonFire\n is checked both in the outer \nif\n and the inner \nif\n\nstatement without a possible change between the two checks. The check warns for\nthis code and suggests removal of the second checking of variable \nonFire\n.\n\nThe checker also detects redundant condition checks if the condition variable\nis an operand of a logical âandâ (\n&&\n) or a logical âorâ (\n||\n) operator:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nif\n \n(\nonFire\n \n&&\n \npeopleInTheBuilding\n \n>\n \n0\n)\n\n\n    \nscream\n();\n\n\n}\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nif\n \n(\nonFire\n \n||\n \nisCollapsing\n())\n\n\n    \nscream\n();\n\n\n}\n\nIn the first case (logical âandâ) the suggested fix is to remove the redundant\ncondition variable and keep the other side of the \n&&\n. In the second case\n(logical âorâ) the whole \nif\n is removed similarly to the simple case on the\ntop.\n\nThe condition of the outer \nif\n statement may also be a logical âandâ\n(\n&&\n) expression:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n \n&&\n \nfireFighters\n \n<\n \n10\n)\n \n{\n\n\n  \nif\n \n(\nsomeOtherCondition\n())\n \n{\n\n\n    \nif\n \n(\nonFire\n)\n\n\n      \nscream\n();\n\n\n  \n}\n\n\n}\n\nThe error is also detected if both the outer statement is a logical âandâ\n(\n&&\n) and the inner statement is a logical âandâ (\n&&\n) or âorâ (\n||\n).\nThe inner \nif\n statement does not have to be a direct descendant of the outer\none.\n\nNo error is detected if the condition variable may have been changed between\nthe two checks:\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \ntryToExtinguish\n(\nonFire\n);\n\n\n  \nif\n \n(\nonFire\n \n&&\n \npeopleInTheBuilding\n \n>\n \n0\n)\n\n\n    \nscream\n();\n\n\n}\n\nEvery possible change is considered, thus if the condition variable is not\na local variable of the function, it is a volatile or it has an alias (pointer\nor reference) then no warning is issued.\n\nLimitations\nÂ¶\n\n\nThe \nelse\n branch is not checked currently for negated condition variable:\n\n\nbool\n \nonFire\n \n=\n \nisBurning\n();\n\n\nif\n \n(\nonFire\n)\n \n{\n\n\n  \nscream\n();\n\n\n}\n \nelse\n \n{\n\n\n  \nif\n \n(\n!\nonFire\n)\n \n{\n\n\n    \ncontinueWork\n();\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe checker currently only detects redundant checking of single condition\nvariables. More complex expressions are not checked:\n\n\nif\n \n(\npeopleInTheBuilding\n \n==\n \n1\n)\n \n{\n\n\n  \nif\n \n(\npeopleInTheBuilding\n \n==\n \n1\n)\n \n{\n\n\n    \ndoSomething\n();\n\n\n  \n}\n\n\n}",
    "configurations": []
  }
}