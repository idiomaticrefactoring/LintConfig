{
  "name": "modernize-pass-by-value",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/pass-by-value.html",
    "fixable": true
  },
  "content": {
    "introduction": "With move semantics added to the language and the standard library updated with\nmove constructors added for many types it is now interesting to take an\nargument directly by value, instead of by const-reference, and then copy. This\ncheck allows the compiler to take care of choosing the best way to construct\nthe copy.\n\nThe transformation is usually beneficial when the calling code passes an\n\nrvalue\n and assumes the move construction is a cheap operation. This short\nexample illustrates how the construction of the value happens:\n\nvoid\n \nfoo\n(\nstd\n::\nstring\n \ns\n);\n\n\nstd\n::\nstring\n \nget_str\n();\n\n\n\nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n \n&\nstr\n)\n \n{\n\n\n  \nfoo\n(\nstr\n);\n       \n// lvalue  -> copy construction\n\n\n  \nfoo\n(\nget_str\n());\n \n// prvalue -> move construction\n\n\n}\n\nNote\n\n\nCurrently, only constructors are transformed to make use of pass-by-value.\nContributions that handle other situations are welcome!\n\nPass-by-value in constructors\nÂ¶\n\n\nReplaces the uses of const-references constructor parameters that are copied\ninto class fields. The parameter is then moved with \nstd::move()\n.\n\n\nSince \nstd::move()\n is a library function declared in \n<utility>\n it may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\n\n \n#include\n \n<string>\n\n\n\n \nclass\n \nFoo\n \n{\n\n\n \npublic\n:\n\n\n-\n  \nFoo\n(\nconst\n \nstd\n::\nstring\n \n&\nCopied\n,\n \nconst\n \nstd\n::\nstring\n \n&\nReadOnly\n)\n\n\n-\n    \n:\n \nCopied\n(\nCopied\n),\n \nReadOnly\n(\nReadOnly\n)\n\n\n+\n  \nFoo\n(\nstd\n::\nstring\n \nCopied\n,\n \nconst\n \nstd\n::\nstring\n \n&\nReadOnly\n)\n\n\n+\n    \n:\n \nCopied\n(\nstd\n::\nmove\n(\nCopied\n)),\n \nReadOnly\n(\nReadOnly\n)\n\n\n   \n{}\n\n\n\n \nprivate\n:\n\n\n   \nstd\n::\nstring\n \nCopied\n;\n\n\n   \nconst\n \nstd\n::\nstring\n \n&\nReadOnly\n;\n\n\n \n};\n\n\n\n \nstd\n::\nstring\n \nget_cwd\n();\n\n\n\n \nvoid\n \nf\n(\nconst\n \nstd\n::\nstring\n \n&\nPath\n)\n \n{\n\n\n   \n// The parameter corresponding to 'get_cwd()' is move-constructed. By\n\n\n   \n// using pass-by-value in the Foo constructor we managed to avoid a\n\n\n   \n// copy-construction.\n\n\n   \nFoo\n \nfoo\n(\nget_cwd\n(),\n \nPath\n);\n\n\n \n}\n\n\n\n\n\n\nIf the parameter is used more than once no transformation is performed since\nmoved objects have an undefined state. It means the following code will be left\nuntouched:\n\n\n#include\n \n<string>\n\n\n\nvoid\n \npass\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n);\n\n\n\nstruct\n \nFoo\n \n{\n\n\n  \nFoo\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n)\n \n:\n \nStr\n(\nS\n)\n \n{\n\n\n    \npass\n(\nS\n);\n\n\n  \n}\n\n\n\n  \nstd\n::\nstring\n \nStr\n;\n\n\n};\n\nLimitations\nÂ¶\n\n\nA situation where the generated code can be wrong is when the object referenced\nis modified before the assignment in the init-list through a âhiddenâ reference.\n\n\nExample:\n\n\n \nstd\n::\nstring\n \ns\n(\n\"foo\"\n);\n\n\n\n \nstruct\n \nBase\n \n{\n\n\n   \nBase\n()\n \n{\n\n\n     \ns\n \n=\n \n\"bar\"\n;\n\n\n   \n}\n\n\n \n};\n\n\n\n \nstruct\n \nDerived\n \n:\n \nBase\n \n{\n\n\n-\n  \nDerived\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n)\n \n:\n \nField\n(\nS\n)\n\n\n+\n  \nDerived\n(\nstd\n::\nstring\n \nS\n)\n \n:\n \nField\n(\nstd\n::\nmove\n(\nS\n))\n\n\n   \n{\n \n}\n\n\n\n   \nstd\n::\nstring\n \nField\n;\n\n\n \n};\n\n\n\n \nvoid\n \nf\n()\n \n{\n\n\n-\n  \nDerived\n \nd\n(\ns\n);\n \n// d.Field holds \"bar\"\n\n\n+\n  \nDerived\n \nd\n(\ns\n);\n \n// d.Field holds \"foo\"\n\n\n \n}\n\n\n\n\n\n\n\n\nNote about delayed template parsing\nÂ¶\n\n\nWhen delayed template parsing is enabled, constructors part of templated\ncontexts; templated constructors, constructors in class templates, constructors\nof inner classes of template classes, etc., are not transformed. Delayed\ntemplate parsing is enabled by default on Windows as a Microsoft extension:\n\nClang Compiler Userâs Manual - Microsoft extensions\n.\n\n\nDelayed template parsing can be enabled using the \n-fdelayed-template-parsing\n\nflag and disabled using \n-fno-delayed-template-parsing\n.\n\n\nExample:\n\n\n  \ntemplate\n \n<\ntypename\n \nT\n>\n \nclass\n \nC\n \n{\n\n\n    \nstd\n::\nstring\n \nS\n;\n\n\n\n  \npublic\n:\n\n\n=\n  \n// using -fdelayed-template-parsing (default on Windows)\n\n\n=\n  \nC\n(\nconst\n \nstd\n::\nstring\n \n&\nS\n)\n \n:\n \nS\n(\nS\n)\n \n{}\n\n\n\n+\n  \n// using -fno-delayed-template-parsing (default on non-Windows systems)\n\n\n+\n  \nC\n(\nstd\n::\nstring\n \nS\n)\n \n:\n \nS\n(\nstd\n::\nmove\n(\nS\n))\n \n{}\n\n\n  \n};\n\n\n\n\n\n\n\n\nSee also\n\n\nFor more information about the pass-by-value idiom, read: \nWant Speed? Pass by Value\n.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIncludeStyle\nÂ¶\n\n\nA string specifying which include-style is used, \nllvm\n or \ngoogle\n. Default\nis \nllvm\n.\n\n\n\n\n\n\n\n\nValuesOnly\nÂ¶\n\n\nWhen \ntrue\n, the check only warns about copied parameters that are already\npassed by value. Default is \nfalse\n.",
    "configurations": []
  }
}