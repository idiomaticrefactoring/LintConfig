{
  "name": "modernize-use-emplace",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-emplace.html",
    "fixable": true
  },
  "content": {
    "introduction": "The check flags insertions to an STL-style container done by calling the\n\npush_back\n, \npush\n, or \npush_front\n methods with an\nexplicitly-constructed temporary of the container element type. In this case,\nthe corresponding \nemplace\n equivalent methods result in less verbose and\npotentially more efficient code.  Right now the check doesnât support\n\ninsert\n. It also doesnât support \ninsert\n functions for associative\ncontainers because replacing \ninsert\n with \nemplace\n may result in\n\nspeed regression\n, but it might get support with some addition flag in the future.\n\nThe \nContainersWithPushBack\n, \nContainersWithPush\n, and\n\nContainersWithPushFront\n options are used to specify the container\ntypes that support the \npush_back\n, \npush\n, and \npush_front\n operations\nrespectively. The default values for these options are as follows:\n\nContainersWithPushBack\n: \nstd::vector\n, \nstd::deque\n,\nand \nstd::list\n.\n\n\nContainersWithPush\n: \nstd::stack\n, \nstd::queue\n,\nand \nstd::priority_queue\n.\n\n\nContainersWithPushFront\n: \nstd::forward_list\n,\n\nstd::list\n, and \nstd::deque\n.\n\nThis check also reports when an \nemplace\n-like method is improperly used,\nfor example using \nemplace_back\n while also calling a constructor. This\ncreates a temporary that requires at best a move and at worst a copy. Almost\nall \nemplace\n-like functions in the STL are covered by this, with\n\ntry_emplace\n on \nstd::map\n and \nstd::unordered_map\n being the\nexception as it behaves slightly differently than all the others. More\ncontainers can be added with the \nEmplacyFunctions\n option, so long\nas the container defines a \nvalue_type\n type, and the \nemplace\n-like\nfunctions construct a \nvalue_type\n object.\n\nBefore:\n\nstd\n::\nvector\n<\nMyClass\n>\n \nv\n;\n\n\nv\n.\npush_back\n(\nMyClass\n(\n21\n,\n \n37\n));\n\n\nv\n.\nemplace_back\n(\nMyClass\n(\n21\n,\n \n37\n));\n\n\n\nstd\n::\nvector\n<\nstd\n::\npair\n<\nint\n,\n \nint\n>>\n \nw\n;\n\n\n\nw\n.\npush_back\n(\nstd\n::\npair\n<\nint\n,\n \nint\n>\n(\n21\n,\n \n37\n));\n\n\nw\n.\npush_back\n(\nstd\n::\nmake_pair\n(\n21L\n,\n \n37L\n));\n\n\nw\n.\nemplace_back\n(\nstd\n::\nmake_pair\n(\n21L\n,\n \n37L\n));\n\nAfter:\n\nstd\n::\nvector\n<\nMyClass\n>\n \nv\n;\n\n\nv\n.\nemplace_back\n(\n21\n,\n \n37\n);\n\n\nv\n.\nemplace_back\n(\n21\n,\n \n37\n);\n\n\n\nstd\n::\nvector\n<\nstd\n::\npair\n<\nint\n,\n \nint\n>>\n \nw\n;\n\n\nw\n.\nemplace_back\n(\n21\n,\n \n37\n);\n\n\nw\n.\nemplace_back\n(\n21L\n,\n \n37L\n);\n\n\nw\n.\nemplace_back\n(\n21L\n,\n \n37L\n);\n\nBy default, the check is able to remove unnecessary \nstd::make_pair\n and\n\nstd::make_tuple\n calls from \npush_back\n calls on containers of\n\nstd::pair\n and \nstd::tuple\n. Custom tuple-like types can be modified by\nthe \nTupleTypes\n option; custom make functions can be modified by the\n\nTupleMakeFunctions\n option.\n\nThe other situation is when we pass arguments that will be converted to a type\ninside a container.\n\nBefore:\n\nstd\n::\nvector\n<\nboost\n::\noptional\n<\nstd\n::\nstring\n>\n \n>\n \nv\n;\n\n\nv\n.\npush_back\n(\n\"abc\"\n);\n\nAfter:\n\nstd\n::\nvector\n<\nboost\n::\noptional\n<\nstd\n::\nstring\n>\n \n>\n \nv\n;\n\n\nv\n.\nemplace_back\n(\n\"abc\"\n);\n\nIn some cases the transformation would be valid, but the code wouldnât be\nexception safe. In this case the calls of \npush_back\n wonât be replaced.\n\nstd\n::\nvector\n<\nstd\n::\nunique_ptr\n<\nint\n>>\n \nv\n;\n\n\nv\n.\npush_back\n(\nstd\n::\nunique_ptr\n<\nint\n>\n(\nnew\n \nint\n(\n0\n)));\n\n\nauto\n \n*\nptr\n \n=\n \nnew\n \nint\n(\n1\n);\n\n\nv\n.\npush_back\n(\nstd\n::\nunique_ptr\n<\nint\n>\n(\nptr\n));\n\nThis is because replacing it with \nemplace_back\n could cause a leak of this\npointer if \nemplace_back\n would throw exception before emplacement (e.g. not\nenough memory to add a new element).\n\nFor more info read item 42 - âConsider emplacement instead of insertion.â of\nScott Meyers âEffective Modern C++â.\n\nThe default smart pointers that are considered are \nstd::unique_ptr\n,\n\nstd::shared_ptr\n, \nstd::auto_ptr\n. To specify other smart pointers or\nother classes use the \nSmartPointers\n option.\n\nCheck also doesnât fire if any argument of the constructor call would be:\n\na bit-field (bit-fields canât bind to rvalue/universal reference)\n\n\na \nnew\n expression (to avoid leak)\n\n\nif the argument would be converted via derived-to-base cast.\n\nThis check requires C++11 or higher to run.\n\nOptions\nÂ¶\n\n\n\n\n\n\nContainersWithPushBack\nÂ¶\n\n\nSemicolon-separated list of class names of custom containers that support\n\npush_back\n.\n\n\n\n\n\n\n\n\nContainersWithPush\nÂ¶\n\n\nSemicolon-separated list of class names of custom containers that support\n\npush\n.\n\n\n\n\n\n\n\n\nContainersWithPushFront\nÂ¶\n\n\nSemicolon-separated list of class names of custom containers that support\n\npush_front\n.\n\n\n\n\n\n\n\n\nIgnoreImplicitConstructors\nÂ¶\n\n\nWhen \ntrue\n, the check will ignore implicitly constructed arguments of\n\npush_back\n, e.g.\n\n\nstd\n::\nvector\n<\nstd\n::\nstring\n>\n \nv\n;\n\n\nv\n.\npush_back\n(\n\"a\"\n);\n \n// Ignored when IgnoreImplicitConstructors is `true`.\n\n\n\n\n\n\nDefault is \nfalse\n.\n\n\n\n\n\n\n\n\nSmartPointers\nÂ¶\n\n\nSemicolon-separated list of class names of custom smart pointers.\n\n\n\n\n\n\n\n\nTupleTypes\nÂ¶\n\n\nSemicolon-separated list of \nstd::tuple\n-like class names.\n\n\n\n\n\n\n\n\nTupleMakeFunctions\nÂ¶\n\n\nSemicolon-separated list of \nstd::make_tuple\n-like function names. Those\nfunction calls will be removed from \npush_back\n calls and turned into\n\nemplace_back\n.\n\n\n\n\n\n\n\n\nEmplacyFunctions\nÂ¶\n\n\nSemicolon-separated list of containers without their template parameters\nand some \nemplace\n-like method of the container. Example:\n\nvector::emplace_back\n. Those methods will be checked for improper use and\nthe check will report when a temporary is unnecessarily created. All STL\ncontainers with such member functions are supported by default.\n\n\n\n\n\n\nExample\nÂ¶\n\n\nstd\n::\nvector\n<\nMyTuple\n<\nint\n,\n \nbool\n,\n \nchar\n>>\n \nx\n;\n\n\nx\n.\npush_back\n(\nMakeMyTuple\n(\n1\n,\n \nfalse\n,\n \n'x'\n));\n\n\nx\n.\nemplace_back\n(\nMakeMyTuple\n(\n1\n,\n \nfalse\n,\n \n'x'\n));\n\n\n\n\n\n\ntransforms to:\n\n\nstd\n::\nvector\n<\nMyTuple\n<\nint\n,\n \nbool\n,\n \nchar\n>>\n \nx\n;\n\n\nx\n.\nemplace_back\n(\n1\n,\n \nfalse\n,\n \n'x'\n);\n\n\nx\n.\nemplace_back\n(\n1\n,\n \nfalse\n,\n \n'x'\n);\n\n\n\n\n\n\nwhen \nTupleTypes\n is set to \nMyTuple\n, \nTupleMakeFunctions\n\nis set to \nMakeMyTuple\n, and \nEmplacyFunctions\n is set to\n\nvector::emplace_back\n.",
    "configurations": []
  }
}