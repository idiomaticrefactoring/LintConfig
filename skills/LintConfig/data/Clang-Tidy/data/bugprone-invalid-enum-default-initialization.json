{
  "name": "bugprone-invalid-enum-default-initialization",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/invalid-enum-default-initialization.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects default initialization (to 0) of variables with \nenum\n type where\nthe enum has no enumerator with value of 0.\n\nIn C++ a default initialization is performed if a variable is initialized with\ninitializer list or in other implicit ways, and no value is specified at the\ninitialization. In such cases the value 0 is used for the initialization.\nThis also applies to enumerations even if it does not have an enumerator with\nvalue 0. In this way a variable with the \nenum\n type may contain initially an\ninvalid value (if the program expects that it contains only the listed\nenumerator values).\n\nThe check emits a warning only if an \nenum\n variable is default-initialized\n(contrary to not initialized) and the \nenum\n does not have an enumerator with\nvalue of 0. The type can be a scoped or non-scoped \nenum\n. Unions are not\nhandled by the check (if it contains a member of enumeration type).\n\nNote that the \nenum\n \nstd::errc\n is always ignored because it is expected\nto be default initialized, despite not defining an enumerator with the value 0.\n\nenum\n \nclass\n \nEnum1\n:\n \nint\n \n{\n\n\n  \nA\n \n=\n \n1\n,\n\n\n  \nB\n\n\n};\n\n\n\nenum\n \nclass\n \nEnum0\n:\n \nint\n \n{\n\n\n  \nA\n \n=\n \n0\n,\n\n\n  \nB\n\n\n};\n\n\n\nvoid\n \nf\n()\n \n{\n\n\n  \nEnum1\n \nX1\n{};\n \n// warn: 'X1' is initialized to 0\n\n\n  \nEnum1\n \nX2\n \n=\n \nEnum1\n();\n \n// warn: 'X2' is initialized to 0\n\n\n  \nEnum1\n \nX3\n;\n \n// no warning: 'X3' is not initialized\n\n\n  \nEnum0\n \nX4\n{};\n \n// no warning: type has an enumerator with value of 0\n\n\n}\n\n\n\nstruct\n \nS1\n \n{\n\n\n  \nEnum1\n \nA\n;\n\n\n  \nS\n()\n:\n \nA\n()\n \n{}\n \n// warn: 'A' is initialized to 0\n\n\n};\n\n\n\nstruct\n \nS2\n \n{\n\n\n  \nint\n \nA\n;\n\n\n  \nEnum1\n \nB\n;\n\n\n};\n\n\n\nS2\n \nVarS2\n{};\n \n// warn: member 'B' is initialized to 0\n\nThe check applies to initialization of arrays or structures with initialization\nlists in C code too. In these cases elements not specified in the list (and have\nenum type) are set to 0.\n\nenum\n \nEnum1\n \n{\n\n\n  \nEnum1_A\n \n=\n \n1\n,\n\n\n  \nEnum1_B\n\n\n};\n\n\nstruct\n \nStruct1\n \n{\n\n\n  \nint\n \na\n;\n\n\n  \nenum\n \nEnum1\n \nb\n;\n\n\n};\n\n\n\nenum\n \nEnum1\n \nArray1\n[\n2\n]\n \n=\n \n{\nEnum1_A\n};\n \n// warn: omitted elements are initialized to 0\n\n\nenum\n \nEnum1\n \nArray2\n[\n2\n][\n2\n]\n \n=\n \n{{\nEnum1_A\n},\n \n{\nEnum1_A\n}};\n \n// warn: last element of both nested arrays is initialized to 0\n\n\nenum\n \nEnum1\n \nArray3\n[\n2\n][\n2\n]\n \n=\n \n{{\nEnum1_A\n,\n \nEnum1_A\n}};\n \n// warn: elements of second array are initialized to 0\n\n\n\nstruct\n \nStruct1\n \nS1\n \n=\n \n{\n1\n};\n \n// warn: element 'b' is initialized to 0\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredEnums\nÂ¶\n\n\nSemicolon-separated list of regexes specifying enums for which this check wonât be\nenforced. Default is \n::std::errc\n.",
    "configurations": []
  }
}