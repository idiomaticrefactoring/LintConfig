{
  "name": "altera-unroll-loops",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/altera/unroll-loops.html",
    "fixable": false
  },
  "content": {
    "introduction": "Finds inner loops that have not been unrolled, as well as fully unrolled loops\nwith unknown loop bounds or a large number of iterations.\n\nUnrolling inner loops could improve the performance of OpenCL kernels. However,\nif they have unknown loop bounds or a large number of iterations, they cannot\nbe fully unrolled, and should be partially unrolled.\n\nNotes:\n\nThis check is unable to determine the number of iterations in a \nwhile\n or\n\ndo..while\n loop; hence if such a loop is fully unrolled, a note is emitted\nadvising the user to partially unroll instead.\n\n\nIn \nfor\n loops, our check only works with simple arithmetic increments (\n\n+\n, \n-\n, \n*\n, \n/\n). For all other increments, partial unrolling is\nadvised.\n\n\nDepending on the exit condition, the calculations for determining if the\nnumber of iterations is large may be off by 1. This should not be an issue\nsince the cut-off is generally arbitrary.\n\nBased on the \nAltera SDK for OpenCL: Best Practices Guide\n.\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n10\n;\n \ni\n++\n)\n \n{\n  \n// ok: outer loops should not be unrolled\n\n\n   \nint\n \nj\n \n=\n \n0\n;\n\n\n   \ndo\n \n{\n  \n// warning: this inner do..while loop should be unrolled\n\n\n      \nj\n++\n;\n\n\n   \n}\n \nwhile\n \n(\nj\n \n<\n \n15\n);\n\n\n\n   \nint\n \nk\n \n=\n \n0\n;\n\n\n   \n#pragma unroll\n\n\n   \nwhile\n \n(\nk\n \n<\n \n20\n)\n \n{\n  \n// ok: this inner loop is already unrolled\n\n\n      \nk\n++\n;\n\n\n   \n}\n\n\n}\n\n\n\nint\n \nA\n[\n1000\n];\n\n\n#pragma unroll\n\n\n// warning: this loop is large and should be partially unrolled\n\n\nfor\n \n(\nint\n \na\n \n:\n \nA\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \na\n);\n\n\n}\n\n\n\n#pragma unroll 5\n\n\n// ok: this loop is large, but is partially unrolled\n\n\nfor\n \n(\nint\n \na\n \n:\n \nA\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \na\n);\n\n\n}\n\n\n\n#pragma unroll\n\n\n// warning: this loop is large and should be partially unrolled\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n1000\n;\n \n++\ni\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \ni\n);\n\n\n}\n\n\n\n#pragma unroll 5\n\n\n// ok: this loop is large, but is partially unrolled\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n1000\n;\n \n++\ni\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \ni\n);\n\n\n}\n\n\n\n#pragma unroll\n\n\n// warning: << operator not supported, recommend partial unrolling\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \n1000\n;\n \ni\n<<\n1\n)\n \n{\n\n\n   \nprintf\n(\n\"%d\"\n,\n \ni\n);\n\n\n}\n\n\n\nstd\n::\nvector\n<\nint\n>\n \nsomeVector\n \n(\n100\n,\n \n0\n);\n\n\nint\n \ni\n \n=\n \n0\n;\n\n\n#pragma unroll\n\n\n// note: loop may be large, recommend partial unrolling\n\n\nwhile\n \n(\ni\n \n<\n \nsomeVector\n.\nsize\n())\n \n{\n\n\n   \nsomeVector\n[\ni\n]\n++\n;\n\n\n}\n\n\n\n#pragma unroll\n\n\n// note: loop may be large, recommend partial unrolling\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n\n   \nprintf\n(\n\"In loop\"\n);\n\n\n}\n\n\n\n#pragma unroll 5\n\n\n// ok: loop may be large, but is partially unrolled\n\n\nwhile\n \n(\ni\n \n<\n \nsomeVector\n.\nsize\n())\n \n{\n\n\n   \nsomeVector\n[\ni\n]\n++\n;\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nMaxLoopIterations\nÂ¶\n\n\nDefines the maximum number of loop iterations that a fully unrolled loop\ncan have. By default, it is set to \n100\n.\n\n\nIn practice, this refers to the integer value of the upper bound\nwithin the loop statementâs condition expression.",
    "configurations": []
  }
}