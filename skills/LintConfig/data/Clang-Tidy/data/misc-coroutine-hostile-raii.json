{
  "name": "misc-coroutine-hostile-raii",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/coroutine-hostile-raii.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects when objects of certain hostile RAII types persists across suspension\npoints in a coroutine. Such hostile types include scoped-lockable types and\ntypes belonging to a configurable denylist.\n\nSome objects require that they be destroyed on the same thread that created\nthem. Traditionally this requirement was often phrased as âmust be a local\nvariableâ, under the assumption that local variables always work this way.\nHowever this is incorrect with C++20 coroutines, since an intervening\n\nco_await\n may cause the coroutine to suspend and later be resumed on\nanother thread.\n\nThe lifetime of an object that requires being destroyed on the same thread\nmust not encompass a \nco_await\n or \nco_yield\n point. If you create/destroy\nan object, you must do so without allowing the coroutine to suspend in the\nmeantime.\n\nFollowing types are considered as hostile:\n\nScoped-lockable types: A scoped-lockable object persisting across a\nsuspension point is problematic as the lock held by this object could\nbe unlocked by a different thread. This would be undefined behaviour.\nThis includes all types annotated with the \nscoped_lockable\n attribute.\n\n\nTypes belonging to a configurable denylist.\n\n// Call some async API while holding a lock.\n\n\ntask\n \ncoro\n()\n \n{\n\n\n  \nconst\n \nstd\n::\nlock_guard\n \nl\n(\n&\nmu_\n);\n\n\n\n  \n// Oops! The async Bar function may finish on a different\n\n\n  \n// thread from the one that created the lock_guard (and called\n\n\n  \n// Mutex::Lock). After suspension, Mutex::Unlock will be called on the wrong thread.\n\n\n  \nco_await\n \nBar\n();\n\n\n}\n\nOptions\nÂ¶\n\n\n\n\n\n\nRAIITypesList\nÂ¶\n\n\nA semicolon-separated list of qualified types which should not be allowed to\npersist across suspension points.\nEg: \nmy::lockable;a::b;::my::other::lockable\n\nThe default value of this option is \nstd::lock_guard;std::scoped_lock\n.\n\n\n\n\n\n\n\n\nAllowedAwaitablesList\nÂ¶\n\n\nA semicolon-separated list of qualified types of awaitables types which can\nbe safely awaited while having hostile RAII objects in scope.\n\n\nco_await\n-ing an expression of \nawaitable\n type is considered\nsafe if the \nawaitable\n type is part of this list.\nRAII objects persisting across such a \nco_await\n expression are\nconsidered safe and hence are not flagged.\n\n\nExample usage:\n\n\n// Consider option AllowedAwaitablesList = \"safe_awaitable\"\n\n\nstruct\n \nsafe_awaitable\n \n{\n\n\n  \nbool\n \nawait_ready\n()\n \nnoexcept\n \n{\n \nreturn\n \nfalse\n;\n \n}\n\n\n  \nvoid\n \nawait_suspend\n(\nstd\n::\ncoroutine_handle\n<>\n)\n \nnoexcept\n \n{}\n\n\n  \nvoid\n \nawait_resume\n()\n \nnoexcept\n \n{}\n\n\n};\n\n\nauto\n \nwait\n()\n \n{\n \nreturn\n \nsafe_awaitable\n{};\n \n}\n\n\n\ntask\n \ncoro\n()\n \n{\n\n\n  \n// This persists across both the co_await's but is not flagged\n\n\n  \n// because the awaitable is considered safe to await on.\n\n\n  \nconst\n \nstd\n::\nlock_guard\n \nl\n(\n&\nmu_\n);\n\n\n  \nco_await\n \nsafe_awaitable\n{};\n\n\n  \nco_await\n \nwait\n();\n\n\n}\n\n\n\n\n\n\nEg: \nmy::safe::awaitable;other::awaitable\n\nDefault is an empty string.\n\n\n\n\n\n\n\n\nAllowedCallees\nÂ¶\n\n\nA semicolon-separated list of callee function names which can\nbe safely awaited while having hostile RAII objects in scope.\nExample usage:\n\n\n// Consider option AllowedCallees = \"noop\"\n\n\ntask\n \nnoop\n()\n \n{\n \nco_return\n;\n \n}\n\n\n\ntask\n \ncoro\n()\n \n{\n\n\n  \n// This persists across the co_await but is not flagged\n\n\n  \n// because the awaitable is considered safe to await on.\n\n\n  \nconst\n \nstd\n::\nlock_guard\n \nl\n(\n&\nmu_\n);\n\n\n  \nco_await\n \nnoop\n();\n\n\n}\n\n\n\n\n\n\nEg: \nmy::safe::await;other::await\n\nDefault is an empty string.",
    "configurations": []
  }
}