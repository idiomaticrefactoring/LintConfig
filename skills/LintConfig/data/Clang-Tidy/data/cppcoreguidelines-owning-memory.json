{
  "name": "cppcoreguidelines-owning-memory",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/owning-memory.html",
    "fixable": false
  },
  "content": {
    "introduction": "This check implements the type-based semantics of \ngsl::owner<T*>\n, which\nallows static analysis on code, that uses raw pointers to handle resources\nlike dynamic memory, but wonât introduce RAII concepts.\n\nThis check implements \nI.11\n,\n\nC.33\n,\n\nR.3\n\nand \nGSL.Views\n\nfrom the C++ Core Guidelines.\nThe definition of a \ngsl::owner<T*>\n is straight forward\n\nnamespace\n \ngsl\n \n{\n \ntemplate\n \n<\ntypename\n \nT\n>\n \nowner\n \n=\n \nT\n;\n \n}\n\nIt is therefore simple to introduce the owner even without using an implementation of\nthe \nGuideline Support Library\n.\n\nAll checks are purely type based and not (yet) flow sensitive.\n\nThe following examples will demonstrate the correct and incorrect\ninitializations of owners, assignment is handled the same way.\nNote that both \nnew\n and \nmalloc()\n-like resource functions are\nconsidered to produce resources.\n\n// Creating an owner with factory functions is checked.\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nfunction_that_returns_owner\n()\n \n{\n \nreturn\n \ngsl\n::\nowner\n<\nint\n*>\n(\nnew\n \nint\n(\n42\n));\n \n}\n\n\n\n// Dynamic memory must be assigned to an owner\n\n\nint\n*\n \nSomething\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// BAD, will be caught\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// Good\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n[\n42\n];\n \n// Good as well\n\n\n\n// Returned owner must be assigned to an owner\n\n\nint\n*\n \nSomething\n \n=\n \nfunction_that_returns_owner\n();\n \n// Bad, factory function\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nfunction_that_returns_owner\n();\n \n// Good, result lands in owner\n\n\n\n// Something not a resource or owner should not be assigned to owners\n\n\nint\n \nStack\n \n=\n \n42\n;\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwned\n \n=\n \n&\nStack\n;\n \n// Bad, not a resource assigned\n\nIn the case of dynamic memory as resource, only \ngsl::owner<T*>\n variables are allowed\nto be deleted.\n\n// Example Bad, non-owner as resource handle, will be caught.\n\n\nint\n*\n \nNonOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// First warning here, since new must land in an owner\n\n\ndelete\n \nNonOwner\n;\n \n// Second warning here, since only owners are allowed to be deleted\n\n\n\n// Example Good, Ownership correctly stated\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// Good\n\n\ndelete\n \nOwner\n;\n \n// Good as well, statically enforced, that only owners get deleted\n\nThe check will furthermore ensure, that functions, that expect a\n\ngsl::owner<T*>\n as argument get called with either a \ngsl::owner<T*>\n or\na newly created resource.\n\nvoid\n \nexpects_owner\n(\ngsl\n::\nowner\n<\nint\n*>\n \no\n)\n \n{\n \ndelete\n \no\n;\n \n}\n\n\n\n// Bad Code\n\n\nint\n \nNonOwner\n \n=\n \n42\n;\n\n\nexpects_owner\n(\n&\nNonOwner\n);\n \n// Bad, will get caught\n\n\n\n// Good Code\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner\n \n=\n \nnew\n \nint\n(\n42\n);\n\n\nexpects_owner\n(\nOwner\n);\n \n// Good\n\n\nexpects_owner\n(\nnew\n \nint\n(\n42\n));\n \n// Good as well, recognized created resource\n\n\n\n// Port legacy code for better resource-safety\n\n\ngsl\n::\nowner\n<\nFILE\n*>\n \nFile\n \n=\n \nfopen\n(\n\"my_file.txt\"\n,\n \n\"rw+\"\n);\n\n\nFILE\n*\n \nBadFile\n \n=\n \nfopen\n(\n\"another_file.txt\"\n,\n \n\"w\"\n);\n \n// Bad, warned\n\n\n\n// ... use the file\n\n\n\nfclose\n(\nFile\n);\n \n// Ok, File is annotated as 'owner<>'\n\n\nfclose\n(\nBadFile\n);\n \n// BadFile is not an 'owner<>', will be warned\n\nOptions\nÂ¶\n\n\n\n\n\n\nLegacyResourceProducers\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of legacy functions that create\nresources but cannot introduce \ngsl::owner<>\n.\nDefaults to \n::malloc;::aligned_alloc;::realloc;::calloc;::fopen;::freopen;::tmpfile\n.\n\n\n\n\n\n\n\n\nLegacyResourceConsumers\nÂ¶\n\n\nSemicolon-separated list of fully qualified names of legacy functions expecting\nresource owners as pointer arguments but cannot introduce \ngsl::owner<>\n.\nDefaults to \n::free;::realloc;::freopen;::fclose\n.\n\nLimitations\nÂ¶\n\n\nUsing \ngsl::owner<T*>\n in a typedef or alias is not handled correctly.\n\n\nusing\n \nheap_int\n \n=\n \ngsl\n::\nowner\n<\nint\n*>\n;\n\n\nheap_int\n \nallocated\n \n=\n \nnew\n \nint\n(\n42\n);\n \n// False positive!\n\n\n\n\n\n\nThe \ngsl::owner<T*>\n is declared as a templated type alias.\nIn template functions and classes, like in the example below, the information\nof the type aliases gets lost. Therefore using \ngsl::owner<T*>\n in a heavy templated\ncode base might lead to false positives.\n\n\nKnown code constructs that do not get diagnosed correctly are:\n\n\n\n\nstd::exchange\n\n\nstd::vector<gsl::owner<T*>>\n\n\n\n\n// This template function works as expected. Type information doesn't get lost.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \ndelete_owner\n(\ngsl\n::\nowner\n<\nT\n*>\n \nowned_object\n)\n \n{\n\n\n  \ndelete\n \nowned_object\n;\n \n// Everything alright\n\n\n}\n\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nfunction_that_returns_owner\n()\n \n{\n \nreturn\n \ngsl\n::\nowner\n<\nint\n*>\n(\nnew\n \nint\n(\n42\n));\n \n}\n\n\n\n// Type deduction does not work for auto variables.\n\n\n// This is caught by the check and will be noted accordingly.\n\n\nauto\n \nOwnedObject\n \n=\n \nfunction_that_returns_owner\n();\n \n// Type of OwnedObject will be int*\n\n\n\n// Problematic function template that looses the typeinformation on owner\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nbad_template_function\n(\nT\n \nsome_object\n)\n \n{\n\n\n  \n// This line will trigger the warning, that a non-owner is assigned to an owner\n\n\n  \ngsl\n::\nowner\n<\nT\n*>\n \nnew_owner\n \n=\n \nsome_object\n;\n\n\n}\n\n\n\n// Calling the function with an owner still yields a false positive.\n\n\nbad_template_function\n(\ngsl\n::\nowner\n<\nint\n*>\n(\nnew\n \nint\n(\n42\n)));\n\n\n\n\n// The same issue occurs with templated classes like the following.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nclass\n \nOwnedValue\n \n{\n\n\npublic\n:\n\n\n  \nconst\n \nT\n \ngetValue\n()\n \nconst\n \n{\n \nreturn\n \n_val\n;\n \n}\n\n\nprivate\n:\n\n\n  \nT\n \n_val\n;\n\n\n};\n\n\n\n// Code, that yields a false positive.\n\n\nOwnedValue\n<\ngsl\n::\nowner\n<\nint\n*>>\n \nOwner\n(\nnew\n \nint\n(\n42\n));\n \n// Type deduction yield T -> int *\n\n\n// False positive, getValue returns int* and not gsl::owner<int*>\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwnedInt\n \n=\n \nOwner\n.\ngetValue\n();\n\n\n\n\n\n\nAnother limitation of the current implementation is only the type based\nchecking. Suppose you have code like the following:\n\n\n// Two owners with assigned resources\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner1\n \n=\n \nnew\n \nint\n(\n42\n);\n\n\ngsl\n::\nowner\n<\nint\n*>\n \nOwner2\n \n=\n \nnew\n \nint\n(\n42\n);\n\n\n\nOwner2\n \n=\n \nOwner1\n;\n \n// Conceptual Leak of initial resource of Owner2!\n\n\nOwner1\n \n=\n \nnullptr\n;\n\n\n\n\n\n\nThe semantic of a \ngsl::owner<T*>\n is mostly like a \nstd::unique_ptr<T>\n,\ntherefore assignment of two \ngsl::owner<T*>\n is considered a move, which\nrequires that the resource \nOwner2\n must have been released before the\nassignment. This kind of condition could be caught in later improvements of\nthis check with flowsensitive analysis. Currently, the \nClang Static Analyzer\n\ncatches this bug for dynamic memory, but not for general types of resources.",
    "configurations": []
  }
}