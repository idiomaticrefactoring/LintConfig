{
  "name": "cppcoreguidelines-pro-type-const-cast",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-const-cast.html",
    "fixable": false
  },
  "content": {
    "introduction": "Imposes limitations on the use of \nconst_cast\n within C++ code. It depends on\nthe \nStrictMode\n option setting to determine whether it should flag all\ninstances of \nconst_cast\n or only those that remove either \nconst\n or\n\nvolatile\n qualifier.\n\nModifying a variable that has been declared as \nconst\n in C++ is generally\nconsidered undefined behavior, and this remains true even when using\n\nconst_cast\n. In C++, the \nconst\n qualifier indicates that a variable is\nintended to be read-only, and the compiler enforces this by disallowing any\nattempts to change the value of that variable.\n\nRemoving the \nvolatile\n qualifier in C++ can have serious consequences. This\nqualifier indicates that a variableâs value can change unpredictably, and\nremoving it may lead to undefined behavior, optimization problems, and\ndebugging challenges. Itâs essential to retain the \nvolatile\n qualifier in\nsituations where the variableâs volatility is a crucial aspect of program\ncorrectness and reliability.\n\nThis rule is part of the \nType safety (Type 3)\n\nprofile and \nES.50: Donât cast away const\n\nrule from the C++ Core Guidelines.\n\nOptions\nÂ¶\n\n\n\n\n\n\nStrictMode\nÂ¶\n\n\nWhen this setting is set to \ntrue\n, it means that any usage of \nconst_cast\n\nis not allowed. On the other hand, when itâs set to \nfalse\n, it permits\ncasting to \nconst\n or \nvolatile\n types. Default value is \nfalse\n.",
    "configurations": []
  }
}