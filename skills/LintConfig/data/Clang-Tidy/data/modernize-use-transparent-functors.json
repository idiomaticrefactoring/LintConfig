{
  "name": "modernize-use-transparent-functors",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-transparent-functors.html",
    "fixable": true
  },
  "content": {
    "introduction": "Prefer transparent functors to non-transparent ones. When using transparent\nfunctors, the type does not need to be repeated. The code is easier to read,\nmaintain and less prone to errors. It is not possible to introduce unwanted\nconversions.\n\n// Non-transparent functor\n\n\nstd\n::\nmap\n<\nint\n,\n \nstd\n::\nstring\n,\n \nstd\n::\ngreater\n<\nint\n>>\n \ns\n;\n\n\n\n// Transparent functor.\n\n\nstd\n::\nmap\n<\nint\n,\n \nstd\n::\nstring\n,\n \nstd\n::\ngreater\n<>>\n \ns\n;\n\n\n\n// Non-transparent functor\n\n\nusing\n \nMyFunctor\n \n=\n \nstd\n::\nless\n<\nMyType\n>\n;\n\nIt is not always a safe transformation though. The following case will be\nuntouched to preserve the semantics.\n\n// Non-transparent functor\n\n\nstd\n::\nmap\n<\nconst\n \nchar\n \n*\n,\n \nstd\n::\nstring\n,\n \nstd\n::\ngreater\n<\nstd\n::\nstring\n>>\n \ns\n;\n\nOptions\nÂ¶\n\n\n\n\n\n\nSafeMode\nÂ¶\n\n\nIf the option is set to \ntrue\n, the check will not diagnose cases where\nusing a transparent functor cannot be guaranteed to produce identical results\nas the original code. The default value for this option is \nfalse\n.\n\n\n\n\nThis check requires using C++14 or higher to run.",
    "configurations": []
  }
}