{
  "name": "readability-magic-numbers",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/magic-numbers.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects magic numbers, integer or floating point literals that are embedded in\ncode and not introduced via constants or symbols.\n\nMany coding guidelines advise replacing the magic values with symbolic\nconstants to improve readability. Here are a few references:\n\nRule ES.45: Avoid âmagic constantsâ; use symbolic constants in C++ Core Guidelines\n\n\nRule 5.1.1 Use symbolic names instead of literal values in code in High Integrity C++\n\n\nItem 17 in âC++ Coding Standards: 101 Rules, Guidelines and Best\nPracticesâ by Herb Sutter and Andrei Alexandrescu\n\n\nChapter 17 in âClean Code - A handbook of agile software craftsmanship.â\nby Robert C. Martin\n\n\nRule 20701 in âTRAIN REAL TIME DATA PROTOCOL Coding Rulesâ by Armin-Hagen\nWeiss, Bombardier\n\n\nhttp://wiki.c2.com/?MagicNumber\n\nExamples of magic values:\n\ntemplate\n<\ntypename\n \nT\n,\n \nsize_t\n \nN\n>\n\n\nstruct\n \nCustomType\n \n{\n\n\n   \nT\n \narr\n[\nN\n];\n\n\n};\n\n\n\nstruct\n \nOtherType\n \n{\n\n\n   \nCustomType\n<\nint\n,\n \n30\n>\n \ncontainer\n;\n\n\n}\n\n\nCustomType\n<\nint\n,\n \n30\n>\n \nvalues\n;\n\n\n\ndouble\n \ncircleArea\n \n=\n \n3.1415926535\n \n*\n \nradius\n \n*\n \nradius\n;\n\n\n\ndouble\n \ntotalCharge\n \n=\n \n1.08\n \n*\n \nitemPrice\n;\n\n\n\nint\n \ngetAnswer\n()\n \n{\n\n\n   \nreturn\n \n-3\n;\n \n// FILENOTFOUND\n\n\n}\n\n\n\nfor\n \n(\nint\n \nmm\n \n=\n \n1\n;\n \nmm\n \n<=\n \n12\n;\n \n++\nmm\n)\n \n{\n\n\n   \nstd\n::\ncout\n \n<<\n \nmonth\n[\nmm\n]\n \n<<\n \n'\\n'\n;\n\n\n}\n\nExample with magic values refactored:\n\ntemplate\n<\ntypename\n \nT\n,\n \nsize_t\n \nN\n>\n\n\nstruct\n \nCustomType\n \n{\n\n\n   \nT\n \narr\n[\nN\n];\n\n\n};\n\n\n\nconst\n \nsize_t\n \nNUMBER_OF_ELEMENTS\n \n=\n \n30\n;\n\n\nusing\n \ncontainerType\n \n=\n \nCustomType\n<\nint\n,\n \nNUMBER_OF_ELEMENTS\n>\n;\n\n\n\nstruct\n \nOtherType\n \n{\n\n\n   \ncontainerType\n \ncontainer\n;\n\n\n}\n\n\ncontainerType\n \nvalues\n;\n\n\n\ndouble\n \ncircleArea\n \n=\n \nM_PI\n \n*\n \nradius\n \n*\n \nradius\n;\n\n\n\nconst\n \ndouble\n \nTAX_RATE\n \n=\n \n0.08\n;\n  \n// or make it variable and read from a file\n\n\n\ndouble\n \ntotalCharge\n \n=\n \n(\n1.0\n \n+\n \nTAX_RATE\n)\n \n*\n \nitemPrice\n;\n\n\n\nint\n \ngetAnswer\n()\n \n{\n\n\n   \nreturn\n \nE_FILE_NOT_FOUND\n;\n\n\n}\n\n\n\nfor\n \n(\nint\n \nmm\n \n=\n \n1\n;\n \nmm\n \n<=\n \nMONTHS_IN_A_YEAR\n;\n \n++\nmm\n)\n \n{\n\n\n   \nstd\n::\ncout\n \n<<\n \nmonth\n[\nmm\n]\n \n<<\n \n'\\n'\n;\n\n\n}\n\nFor integral literals by default only \n0\n and \n1\n (and \n-1\n) integer values\nare accepted without a warning. This can be overridden with the\n\nIgnoredIntegerValues\n option. Negative values are accepted if their\nabsolute value is present in the \nIgnoredIntegerValues\n list.\n\nAs a special case for integral values, all powers of two can be accepted\nwithout warning by enabling the \nIgnorePowersOf2IntegerValues\n option.\n\nFor floating point literals by default the \n0.0\n floating point value is\naccepted without a warning. The set of ignored floating point literals can\nbe configured using the \nIgnoredFloatingPointValues\n option.\nFor each value in that set, the given string value is converted to a\nfloating-point value representation used by the target architecture. If a\nfloating-point literal value compares equal to one of the converted values,\nthen that literal is not diagnosed by this check. Because floating-point\nequality is used to determine whether to diagnose or not, the user needs to\nbe aware of the details of floating-point representations for any values that\ncannot be precisely represented for their target architecture.\n\nFor each value in the \nIgnoredFloatingPointValues\n set, both the\nsingle-precision form and double-precision form are accepted (for example, if\n3.14 is in the set, neither 3.14f nor 3.14 will produce a warning).\n\nScientific notation is supported for both source code input and option.\nAlternatively, the check for the floating point numbers can be disabled for\nall floating point values by enabling the\n\nIgnoreAllFloatingPointValues\n option.\n\nSince values \n0\n and \n0.0\n are so common as the base counter of loops,\nor initialization values for sums, they are always accepted without warning,\neven if not present in the respective ignored values list.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoredIntegerValues\nÂ¶\n\n\nSemicolon-separated list of magic positive integers that will be accepted\nwithout a warning. Default values are \n{1, 2, 3, 4}\n, and \n0\n is accepted\nunconditionally.\n\n\n\n\n\n\n\n\nIgnorePowersOf2IntegerValues\nÂ¶\n\n\nBoolean value indicating whether to accept all powers-of-two integer values\nwithout warning. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoredFloatingPointValues\nÂ¶\n\n\nSemicolon-separated list of magic positive floating point values that will\nbe accepted without a warning. Default values are \n{1.0, 100.0}\n and \n0.0\n\nis accepted unconditionally.\n\n\n\n\n\n\n\n\nIgnoreAllFloatingPointValues\nÂ¶\n\n\nBoolean value indicating whether to accept all floating point values without\nwarning. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreBitFieldsWidths\nÂ¶\n\n\nBoolean value indicating whether to accept magic numbers as bit field widths\nwithout warning. This is useful for example for register definitions which\nare generated from hardware specifications. Default value is \ntrue\n.\n\n\n\n\n\n\n\n\nIgnoreTypeAliases\nÂ¶\n\n\nBoolean value indicating whether to accept magic numbers in \ntypedef\n or\n\nusing\n declarations. Default value is \nfalse\n.\n\n\n\n\n\n\n\n\nIgnoreUserDefinedLiterals\nÂ¶\n\n\nBoolean value indicating whether to accept magic numbers in user-defined\nliterals. Default value is \nfalse\n.",
    "configurations": []
  }
}