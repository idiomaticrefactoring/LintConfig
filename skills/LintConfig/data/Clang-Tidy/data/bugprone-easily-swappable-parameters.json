{
  "name": "bugprone-easily-swappable-parameters",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/easily-swappable-parameters.html",
    "fixable": false
  },
  "content": {
    "introduction": "Finds function definitions where parameters of convertible types follow each\nother directly, making call sites prone to calling the function with\nswapped (or badly ordered) arguments.\n\nvoid\n \ndrawPoint\n(\nint\n \nX\n,\n \nint\n \nY\n)\n \n{\n \n/* ... */\n \n}\n\n\nFILE\n \n*\nopen\n(\nconst\n \nchar\n \n*\nDir\n,\n \nconst\n \nchar\n \n*\nName\n,\n \nFlags\n \nMode\n)\n \n{\n \n/* ... */\n \n}\n\nA potential call like \ndrawPoint(-2,\n \n5)\n or\n\nopenPath(\"a.txt\",\n \n\"tmp\",\n \nRead)\n is perfectly legal from the languageâs\nperspective, but might not be what the developer of the function intended.\n\nMore elaborate and type-safe constructs, such as opaque typedefs or strong\ntypes should be used instead, to prevent a mistaken order of arguments.\n\nstruct\n \nCoord2D\n \n{\n \nint\n \nX\n;\n \nint\n \nY\n;\n \n};\n\n\nvoid\n \ndrawPoint\n(\nconst\n \nCoord2D\n \nPos\n)\n \n{\n \n/* ... */\n \n}\n\n\n\nFILE\n \n*\nopen\n(\nconst\n \nPath\n \n&\nDir\n,\n \nconst\n \nFilename\n \n&\nName\n,\n \nFlags\n \nMode\n)\n \n{\n \n/* ... */\n \n}\n\nDue to the potentially elaborate refactoring and API-breaking that is necessary\nto strengthen the type safety of a project, no automatic fix-its are offered.\n\nOptions\nÂ¶\n\n\n\n\nExtension/relaxation options\nÂ¶\n\n\nRelaxation (or extension) options can be used to broaden the scope of the\nanalysis and fine-tune the enabling of more mixes between types.\nSome mixes may depend on coding style or preference specific to a project,\nhowever, it should be noted that enabling \nall\n of these relaxations model the\nway of mixing at call sites the most.\nThese options are expected to make the check report for more functions, and\nreport longer mixable ranges.\n\n\n\n\n\n\nQualifiersMix\nÂ¶\n\n\nWhether to consider parameters of some \ncvr-qualified\n \nT\n and a\ndifferently \ncvr-qualified\n \nT\n (i.e. \nT\n and \nconst\n \nT\n, \nconst\n \nT\n\nand \nvolatile\n \nT\n, etc.) mixable between one another.\nIf \nfalse\n, the check will consider differently qualified types unmixable.\n\nTrue\n turns the warnings on.\nDefaults to \nfalse\n.\n\n\nThe following example produces a diagnostic only if \nQualifiersMix\n is\nenabled:\n\n\nvoid\n \n*\nmemcpy\n(\nconst\n \nvoid\n \n*\nDestination\n,\n \nvoid\n \n*\nSource\n,\n \nstd\n::\nsize_t\n \nN\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\n\n\n\n\n\n\nModelImplicitConversions\nÂ¶\n\n\nWhether to consider parameters of type \nT\n and \nU\n mixable if there\nexists an implicit conversion from \nT\n to \nU\n and \nU\n to \nT\n.\nIf \nfalse\n, the check will not consider implicitly convertible types for\nmixability.\n\nTrue\n turns warnings for implicit conversions on.\nDefaults to \ntrue\n.\n\n\nThe following examples produce a diagnostic only if\n\nModelImplicitConversions\n is enabled:\n\n\nvoid\n \nfun\n(\nint\n \nInt\n,\n \ndouble\n \nDouble\n)\n \n{\n \n/* ... */\n \n}\n\n\nvoid\n \ncompare\n(\nconst\n \nchar\n \n*\nCharBuf\n,\n \nstd\n::\nstring\n \nString\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\n\n\nNote\n\n\nChanging the qualifiers of an expressionâs type (e.g. from \nint\n to\n\nconst\n \nint\n) is defined as an \nimplicit conversion\n in the C++\nStandard.\nHowever, the check separates this decision-making on the mixability of\ndifferently qualified types based on whether \nQualifiersMix\n was\nenabled.\n\n\nFor example, the following code snippet will only produce a diagnostic\nif \nboth\n \nQualifiersMix\n and \nModelImplicitConversions\n are enabled:\n\n\nvoid\n \nfun2\n(\nint\n \nInt\n,\n \nconst\n \ndouble\n \nDouble\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering options\nÂ¶\n\n\nFiltering options can be used to lessen the size of the diagnostics emitted by\nthe checker, whether the aim is to ignore certain constructs or dampen the\nnoisiness.\n\n\n\n\n\n\nMinimumLength\nÂ¶\n\n\nThe minimum length required from an adjacent parameter sequence to be\ndiagnosed.\nDefaults to \n2\n.\nMight be any positive integer greater or equal to \n2\n.\nIf \n0\n or \n1\n is given, the default value \n2\n will be used instead.\n\n\nFor example, if \n3\n is specified, the examples above will not be matched.\n\n\n\n\n\n\n\n\nIgnoredParameterNames\nÂ¶\n\n\nThe list of parameter \nnames\n that should never be considered part of a\nswappable adjacent parameter sequence.\nThe value is a \n;\n-separated list of names.\nTo ignore unnamed parameters, add \nââ\n to the list verbatim (not the\nempty string, but the two quotes, potentially escaped!).\n\nThis option is case-sensitive!\n\n\nBy default, the following parameter names, and their Uppercase-initial\nvariants are ignored:\n\nââ\n (unnamed parameters), \niterator\n, \nbegin\n, \nend\n, \nfirst\n, \nlast\n,\n\nlhs\n, \nrhs\n.\n\n\n\n\n\n\n\n\nIgnoredParameterTypeSuffixes\nÂ¶\n\n\nThe list of parameter \ntype name suffixes\n that should never be\nconsidered part of a swappable adjacent parameter sequence.\nParameters which type, as written in the source code, end with an element\nof this option will be ignored.\nThe value is a \n;\n-separated list of names.\n\nThis option is case-sensitive!\n\n\nBy default, the following, and their lowercase-initial variants are ignored:\n\nbool\n, \nIt\n, \nIterator\n, \nInputIt\n, \nForwardIt\n, \nBidirIt\n, \nRandomIt\n,\n\nrandom_iterator\n, \nReverseIt\n, \nreverse_iterator\n,\n\nreverse_const_iterator\n, \nRandomIt\n, \nrandom_iterator\n, \nReverseIt\n,\n\nreverse_iterator\n, \nreverse_const_iterator\n, \nConst_Iterator\n,\n\nConstIterator\n, \nconst_reverse_iterator\n, \nConstReverseIterator\n.\nIn addition, \n_Bool\n (but not \n_bool\n) is also part of the default value.\n\n\n\n\n\n\n\n\nSuppressParametersUsedTogether\nÂ¶\n\n\nSuppresses diagnostics about parameters that are used together or in a\nsimilar fashion inside the functionâs body.\nDefaults to \ntrue\n.\nSpecifying \nfalse\n will turn off the heuristics.\n\n\nCurrently, the following heuristics are implemented which will suppress the\nwarning about the parameter pair involved:\n\n\n\n\nThe parameters are used in the same expression, e.g. \nf(a,\n \nb)\n or\n\na\n \n<\n \nb\n.\n\n\nThe parameters are further passed to the same function to the same\nparameter of that function, of the same overload.\nE.g. \nf(a,\n \n1)\n and \nf(b,\n \n2)\n to some \nf(T,\n \nint)\n.\n\n\n\n\nNote\n\n\nThe check does not perform path-sensitive analysis, and as such,\nâsame functionâ in this context means the same function declaration.\nIf the same member function of a type on two distinct instances are\ncalled with the parameters, it will still be regarded as\nâsame functionâ.\n\n\n\n\n\n\nThe same member field is accessed, or member method is called of the\ntwo parameters, e.g. \na.foo()\n and \nb.foo()\n.\n\n\nSeparate \nreturn\n statements return either of the parameters on\ndifferent code paths.\n\n\n\n\n\n\n\n\n\n\nNamePrefixSuffixSilenceDissimilarityThreshold\nÂ¶\n\n\nThe number of characters two parameter names might be different on \neither\n\nthe head or the tail end with the rest of the name the same so that the\nwarning about the two parameters are silenced.\nDefaults to \n1\n.\nMight be any positive integer.\nIf \n0\n, the filtering heuristic based on the parametersâ names is turned\noff.\n\n\nThis option can be used to silence warnings about parameters where the\nnaming scheme indicates that the order of those parameters do not matter.\n\n\nFor example, the parameters \nLHS\n and \nRHS\n are 1-dissimilar suffixes\nof each other: \nL\n and \nR\n is the different character, while \nHS\n\nis the common suffix.\nSimilarly, parameters \ntext1,\n \ntext2,\n \ntext3\n are 1-dissimilar prefixes\nof each other, with the numbers at the end being the dissimilar part.\nIf the value is at least \n1\n, such cases will not be reported.\n\nLimitations\nÂ¶\n\n\nThis check is designed to check function signatures!\n\n\nThe check does not investigate functions that are generated by the compiler\nin a context that is only determined from a call site.\nThese cases include variadic functions, functions in C code that do not have\nan argument list, and C++ template instantiations.\nMost of these cases, which are otherwise swappable from a callerâs standpoint,\nhave no way of getting âfixedâ at the definition point.\nIn the case of C++ templates, only primary template definitions and explicit\nspecializations are matched and analyzed.\n\n\nNone of the following cases produce a diagnostic:\n\n\nint\n \nprintf\n(\nconst\n \nchar\n \n*\nFormat\n,\n \n...)\n \n{\n \n/* ... */\n \n}\n\n\nint\n \nsomeOldCFunction\n()\n \n{\n \n/* ... */\n \n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \nU\n>\n\n\nint\n \nadd\n(\nT\n \nX\n,\n \nU\n \nY\n)\n \n{\n \nreturn\n \nX\n \n+\n \nY\n \n};\n\n\n\nvoid\n \ntheseAreNotWarnedAbout\n()\n \n{\n\n\n    \nprintf\n(\n\"%d %d\n\\n\n\"\n,\n \n1\n,\n \n2\n);\n   \n// Two ints passed, they could be swapped.\n\n\n    \nsomeOldCFunction\n(\n1\n,\n \n2\n,\n \n3\n);\n \n// Similarly, multiple ints passed.\n\n\n\n    \nadd\n(\n1\n,\n \n2\n);\n \n// Instantiates 'add<int, int>', but that's not a user-defined function.\n\n\n}\n\n\n\n\n\n\nDue to the limitation above, parameters which type are further dependent upon\ntemplate instantiations to \nprove\n that they mix with another parameterâs is\nnot diagnosed.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nstruct\n \nVector\n \n{\n\n\n  \ntypedef\n \nT\n \nelement_type\n;\n\n\n};\n\n\n\n// Diagnosed: Explicit instantiation was done by the user, we can prove it\n\n\n// is the same type.\n\n\nvoid\n \ninstantiated\n(\nint\n \nA\n,\n \nVector\n<\nint\n>::\nelement_type\n \nB\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n// Diagnosed: The two parameter types are exactly the same.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nexact\n(\ntypename\n \nVector\n<\nT\n>::\nelement_type\n \nA\n,\n\n\n           \ntypename\n \nVector\n<\nT\n>::\nelement_type\n \nB\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n// Skipped: The two parameters are both 'T' but we cannot prove this\n\n\n// without actually instantiating.\n\n\ntemplate\n \n<\ntypename\n \nT\n>\n\n\nvoid\n \nfalseNegative\n(\nT\n \nA\n,\n \ntypename\n \nVector\n<\nT\n>::\nelement_type\n \nB\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n\n\n\nIn the context of \nimplicit conversions\n (when \nModelImplicitConversions\n is\nenabled), the modelling performed by the check\nwarns if the parameters are swappable and the swapped order matches implicit\nconversions.\nIt does not model whether there exists an unrelated third type from which\n\nboth\n parameters can be given in a function call.\nThis means that in the following example, even while \nstrs()\n clearly carries\nthe possibility to be called with swapped arguments (as long as the arguments\nare string literals), will not be warned about.\n\n\nstruct\n \nString\n \n{\n\n\n    \nString\n(\nconst\n \nchar\n \n*\nBuf\n);\n\n\n};\n\n\n\nstruct\n \nStringView\n \n{\n\n\n    \nStringView\n(\nconst\n \nchar\n \n*\nBuf\n);\n\n\n    \noperator\n \nconst\n \nchar\n \n*\n()\n \nconst\n;\n\n\n};\n\n\n\n// Skipped: Directly swapping expressions of the two type cannot mix.\n\n\n// (Note: StringView -> const char * -> String would be **two**\n\n\n// user-defined conversions, which is disallowed by the language.)\n\n\nvoid\n \nstrs\n(\nString\n \nStr\n,\n \nStringView\n \nSV\n)\n \n{\n \n/* ... */\n \n}\n\n\n\n// Diagnosed: StringView implicitly converts to and from a buffer.\n\n\nvoid\n \ncStr\n(\nStringView\n \nSV\n,\n \nconst\n \nchar\n \n*\nBuf\n()\n \n{\n \n/* ... */\n \n}",
    "configurations": []
  }
}