{
  "name": "bugprone-not-null-terminated-result",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/not-null-terminated-result.html",
    "fixable": true
  },
  "content": {
    "introduction": "Finds function calls where it is possible to cause a not null-terminated\nresult. Usually the proper length of a string is \nstrlen(src)\n \n+\n \n1\n or equal\nlength of this expression, because the null terminator needs an extra space.\nWithout the null terminator it can result in undefined behavior when the\nstring is read.\n\nThe following and their respective \nwchar_t\n based functions are checked:\n\nmemcpy\n, \nmemcpy_s\n, \nmemchr\n, \nmemmove\n, \nmemmove_s\n,\n\nstrerror_s\n, \nstrncmp\n, \nstrxfrm\n\nThe following is a real-world example where the programmer forgot to increase\nthe passed third argument, which is \nsize_t\n \nlength\n. That is why the length\nof the allocated memory is not enough to hold the null terminator.\n\nstatic\n \nchar\n \n*\nstringCpy\n(\nconst\n \nstd\n::\nstring\n \n&\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nresult\n \n=\n \nreinterpret_cast\n<\nchar\n \n*>\n(\nmalloc\n(\nstr\n.\nsize\n()));\n\n\n  \nmemcpy\n(\nresult\n,\n \nstr\n.\ndata\n(),\n \nstr\n.\nsize\n());\n\n\n  \nreturn\n \nresult\n;\n\n\n}\n\nIn addition to issuing warnings, fix-it rewrites all the necessary code.\nIt also tries to adjust the capacity of the destination array:\n\nstatic\n \nchar\n \n*\nstringCpy\n(\nconst\n \nstd\n::\nstring\n \n&\nstr\n)\n \n{\n\n\n  \nchar\n \n*\nresult\n \n=\n \nreinterpret_cast\n<\nchar\n \n*>\n(\nmalloc\n(\nstr\n.\nsize\n()\n \n+\n \n1\n));\n\n\n  \nstrcpy\n(\nresult\n,\n \nstr\n.\ndata\n());\n\n\n  \nreturn\n \nresult\n;\n\n\n}\n\nNote: It cannot guarantee to rewrite every of the path-sensitive memory\nallocations.\n\nTransformation rules of âmemcpy()â\nÂ¶\n\n\nIt is possible to rewrite the \nmemcpy()\n and \nmemcpy_s()\n calls as the\nfollowing four functions:  \nstrcpy()\n, \nstrncpy()\n, \nstrcpy_s()\n,\n\nstrncpy_s()\n, where the latter two are the safer versions of the former two.\nIt rewrites the \nwchar_t\n based memory handler functions respectively.\n\n\n\n\nRewrite based on the destination array\nÂ¶\n\n\n\n\nIf copy to the destination array cannot overflow [1] the new function should\nbe the older copy function (ending with \ncpy\n), because it is more\nefficient than the safe version.\n\n\nIf copy to the destination array can overflow [1] and\n\nWantToUseSafeFunctions\n is set to \ntrue\n and it is possible to\nobtain the capacity of the destination array then the new function could be\nthe safe version (ending with \ncpy_s\n).\n\n\nIf the new function is could be safe version and C++ files are analyzed and\nthe destination array is plain \nchar\n/\nwchar_t\n without \nun/signed\n\nthen the length of the destination array can be omitted.\n\n\nIf the new function is could be safe version and the destination array is\n\nun/signed\n it needs to be casted to plain \nchar\n \n*\n/\nwchar_t\n \n*\n.\n\n\n\n\n\n\n[1] It is possible to overflow:\n\n\nIf the capacity of the destination array is unknown.\n\n\nIf the given length is equal to the destination arrayâs capacity.\n\n\n\n\n\n\n\n\n\n\n\n\nRewrite based on the length of the source string\nÂ¶\n\n\n\n\nIf the given length is \nstrlen(source)\n or equal length of this expression\nthen the new function should be the older copy function (ending with\n\ncpy\n), as it is more efficient than the safe version (ending with\n\ncpy_s\n).\n\n\nOtherwise we assume that the programmer wanted to copy âNâ characters, so the\nnew function is \nncpy\n-like which copies âNâ characters.\n\nTransformations with âstrlen()â or equal length of this expression\nÂ¶\n\n\nIt transforms the \nwchar_t\n based memory and string handler functions\nrespectively (where only \nstrerror_s\n does not have \nwchar_t\n based alias).\n\n\n\n\nMemory handler functions\nÂ¶\n\n\nmemcpy\n\nPlease visit the\n\nTransformation rules of âmemcpy()â\n section.\n\n\nmemchr\n\nUsually there is a C-style cast and it is needed to be removed, because the\nnew function \nstrchr\nâs return type is correct. The given length is going\nto be removed.\n\n\nmemmove\n\nIf safe functions are available the new function is \nmemmove_s\n, which has\na new second argument which is the length of the destination array, it is\nadjusted, and the length of the source string is incremented by one.\nIf safe functions are not available the given length is incremented by one.\n\n\nmemmove_s\n\nThe given length is incremented by one.\n\n\n\n\n\n\nString handler functions\nÂ¶\n\n\nstrerror_s\n\nThe given length is incremented by one.\n\n\nstrncmp\n\nIf the third argument is the first or the second argumentâs \nlength\n \n+\n \n1\n\nit has to be truncated without the \n+\n \n1\n operation.\n\n\nstrxfrm\n\nThe given length is incremented by one.\n\nOptions\nÂ¶\n\n\n\n\n\n\nWantToUseSafeFunctions\nÂ¶\n\n\nThe value \ntrue\n specifies that the target environment is considered to\nimplement â_sâ suffixed memory and string handler functions which are safer\nthan older versions (e.g. âmemcpy_s()â). The default value is \ntrue\n.",
    "configurations": []
  }
}