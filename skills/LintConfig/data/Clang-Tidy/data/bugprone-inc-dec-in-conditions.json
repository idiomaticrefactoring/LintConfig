{
  "name": "bugprone-inc-dec-in-conditions",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/inc-dec-in-conditions.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects when a variable is both incremented/decremented and referenced inside a\ncomplex condition and suggests moving them outside to avoid ambiguity in the\nvariableâs value.\n\nWhen a variable is modified and also used in a complex condition, it can lead\nto unexpected behavior. The side-effect of changing the variableâs value within\nthe condition can make the code difficult to reason about. Additionally, the\ndeveloperâs intended timing for the modification of the variable may not be\nclear, leading to misunderstandings and errors. This can be particularly\nproblematic when the condition involves logical operators like \n&&\n and\n\n||\n, where the order of evaluation can further complicate the situation.\n\nConsider the following example:\n\nint\n \ni\n \n=\n \n0\n;\n\n\n// ...\n\n\nif\n \n(\ni\n++\n \n<\n \n5\n \n&&\n \ni\n \n>\n \n0\n)\n \n{\n\n\n  \n// do something\n\n\n}\n\nIn this example, the result of the expression may not be what the developer\nintended. The original intention of the developer could be to increment \ni\n\nafter the entire condition is evaluated, but in reality, i will be incremented\nbefore \ni\n \n>\n \n0\n is executed. This can lead to unexpected behavior and bugs in\nthe code. To fix this issue, the developer should separate the increment\noperation from the condition and perform it separately. For example, they can\nincrement \ni\n in a separate statement before or after the condition is\nevaluated. This ensures that the value of \ni\n is predictable and consistent\nthroughout the code.\n\nint\n \ni\n \n=\n \n0\n;\n\n\n// ...\n\n\ni\n++\n;\n\n\nif\n \n(\ni\n \n<=\n \n5\n \n&&\n \ni\n \n>\n \n0\n)\n \n{\n\n\n  \n// do something\n\n\n}\n\nAnother common issue occurs when multiple increments or decrements are\nperformed on the same variable inside a complex condition. For example:\n\nint\n \ni\n \n=\n \n4\n;\n\n\n// ...\n\n\nif\n \n(\ni\n++\n \n<\n \n5\n \n||\n \n--\ni\n \n>\n \n2\n)\n \n{\n\n\n  \n// do something\n\n\n}\n\nThere is a potential issue with this code due to the order of evaluation in\nC++. The \n||\n operator used in the condition statement guarantees that if\nthe first operand evaluates to \ntrue\n, the second operand will not be\nevaluated. This means that if \ni\n were initially \n4\n, the first operand\n\ni\n \n<\n \n5\n would evaluate to \ntrue\n and the second operand \ni\n \n>\n \n2\n would\nnot be evaluated. As a result, the decrement operation \n--i\n would not be\nexecuted and \ni\n would hold value \n5\n, which may not be the intended\nbehavior for the developer.\n\nTo avoid this potential issue, the both increment and decrement operation on\n\ni\n should be moved outside the condition statement.",
    "configurations": []
  }
}