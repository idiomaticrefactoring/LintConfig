{
  "name": "bugprone-branch-clone",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/branch-clone.html",
    "fixable": false
  },
  "content": {
    "introduction": "Checks for repeated branches in \nif/else\n \nif/else\n chains, consecutive\nrepeated branches in \nswitch\n statements and identical true and false\nbranches in conditional operators.\n\nif\n \n(\ntest_value\n(\nx\n))\n \n{\n\n\n  \ny\n++\n;\n\n\n  \ndo_something\n(\nx\n,\n \ny\n);\n\n\n}\n \nelse\n \n{\n\n\n  \ny\n++\n;\n\n\n  \ndo_something\n(\nx\n,\n \ny\n);\n\n\n}\n\nIn this simple example (which could arise e.g. as a copy-paste error) the\n\nthen\n and \nelse\n branches are identical and the code is equivalent the\nfollowing shorter and cleaner code:\n\ntest_value\n(\nx\n);\n \n// can be omitted unless it has side effects\n\n\ny\n++\n;\n\n\ndo_something\n(\nx\n,\n \ny\n);\n\nIf this is the intended behavior, then there is no reason to use a conditional\nstatement; otherwise the issue can be solved by fixing the branch that is\nhandled incorrectly.\n\nThe check detects repeated branches in longer \nif/else\n \nif/else\n chains\nwhere it would be even harder to notice the problem.\n\nThe check also detects repeated inner and outer \nif\n statements that may\nbe a result of a copy-paste error. This check cannot currently detect\nidentical inner and outer \nif\n statements if code is between the \nif\n\nconditions. An example is as follows.\n\nvoid\n \ntest_warn_inner_if_1\n(\nint\n \nx\n)\n \n{\n\n\n  \nif\n \n(\nx\n \n==\n \n1\n)\n \n{\n    \n// warns, if with identical inner if\n\n\n    \nif\n \n(\nx\n \n==\n \n1\n)\n    \n// inner if is here\n\n\n      \n;\n\n\n  \nif\n \n(\nx\n \n==\n \n1\n)\n \n{\n    \n// does not warn, cannot detect\n\n\n    \nint\n \ny\n \n=\n \nx\n;\n\n\n    \nif\n \n(\nx\n \n==\n \n1\n)\n\n\n      \n;\n\n\n  \n}\n\n\n}\n\nIn \nswitch\n statements the check only reports repeated branches when they are\nconsecutive, because it is relatively common that the \ncase:\n labels have\nsome natural ordering and rearranging them would decrease the readability of\nthe code. For example:\n\nswitch\n \n(\nch\n)\n \n{\n\n\ncase\n \n'a'\n:\n\n\n  \nreturn\n \n10\n;\n\n\ncase\n \n'A'\n:\n\n\n  \nreturn\n \n10\n;\n\n\ncase\n \n'b'\n:\n\n\n  \nreturn\n \n11\n;\n\n\ncase\n \n'B'\n:\n\n\n  \nreturn\n \n11\n;\n\n\ndefault\n:\n\n\n  \nreturn\n \n10\n;\n\n\n}\n\nHere the check reports that the \n'a'\n and \n'A'\n branches are identical\n(and that the \n'b'\n and \n'B'\n branches are also identical), but does not\nreport that the \ndefault:\n branch is also identical to the first two branches.\nIf this is indeed the correct behavior, then it could be implemented as:\n\nswitch\n \n(\nch\n)\n \n{\n\n\ncase\n \n'a'\n:\n\n\ncase\n \n'A'\n:\n\n\n  \nreturn\n \n10\n;\n\n\ncase\n \n'b'\n:\n\n\ncase\n \n'B'\n:\n\n\n  \nreturn\n \n11\n;\n\n\ndefault\n:\n\n\n  \nreturn\n \n10\n;\n\n\n}\n\nHere the check does not warn for the repeated \nreturn\n \n10;\n, which is good if\nwe want to preserve that \n'a'\n is before \n'b'\n and \ndefault:\n is the last\nbranch.\n\nSwitch cases marked with the \n[[fallthrough]]\n attribute are ignored.\n\nFinally, the check also examines conditional operators and reports code like:\n\nreturn\n \ntest_value\n(\nx\n)\n \n?\n \nx\n \n:\n \nx\n;\n\nUnlike if statements, the check does not detect chains of conditional\noperators.\n\nNote: This check also reports situations where branches become identical only\nafter preprocessing.",
    "configurations": []
  }
}