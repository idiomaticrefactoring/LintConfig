{
  "name": "bugprone-incorrect-enable-if",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/incorrect-enable-if.html",
    "fixable": true
  },
  "content": {
    "introduction": "Detects incorrect usages of \nstd::enable_if\n that donât name the nested\n\ntype\n type.\n\nIn C++11 introduced \nstd::enable_if\n as a convenient way to leverage SFINAE.\nOne form of using \nstd::enable_if\n is to declare an unnamed template type\nparameter with a default type equal to\n\ntypename\n \nstd::enable_if<condition>::type\n. If the author forgets to name\nthe nested type \ntype\n, then the code will always consider the candidate\ntemplate even if the condition is not met.\n\nBelow are some examples of code using \nstd::enable_if\n correctly and\nincorrect examples that this check flags.\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \ntypename\n \nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>::\ntype\n>\n\n\nvoid\n \nvalid_usage\n()\n \n{\n \n...\n \n}\n\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n>>\n\n\nvoid\n \nvalid_usage_with_trait_helpers\n()\n \n{\n \n...\n \n}\n\n\n\n// The below code is not a correct application of SFINAE. Even if\n\n\n// T::some_trait is not true, the function will still be considered in the\n\n\n// set of function candidates. It can either incorrectly select the function\n\n\n// when it should not be a candidates, and/or lead to hard compile errors\n\n\n// if the body of the template does not compile if the condition is not\n\n\n// satisfied.\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>>\n\n\nvoid\n \ninvalid_usage\n()\n \n{\n \n...\n \n}\n\n\n\n// The tool suggests the following replacement for 'invalid_usage':\n\n\ntemplate\n \n<\ntypename\n \nT\n,\n \ntypename\n \n=\n \ntypename\n \nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>::\ntype\n>\n\n\nvoid\n \nfixed_invalid_usage\n()\n \n{\n \n...\n \n}\n\nC++14 introduced the trait helper \nstd::enable_if_t\n which reduces the\nlikelihood of this error. C++20 introduces constraints, which generally\nsupersede the use of \nstd::enable_if\n. See\n\nmodernize-type-traits\n for another tool\nthat will replace \nstd::enable_if\n with\n\nstd::enable_if_t\n, and see\n\nmodernize-use-constraints\n for another\ntool that replaces \nstd::enable_if\n with C++20 constraints. Consider these\nnewer mechanisms where possible.",
    "configurations": []
  }
}