{
  "name": "bugprone-empty-catch",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/empty-catch.html",
    "fixable": false
  },
  "content": {
    "introduction": "Detects and suggests addressing issues with empty catch statements.\n\ntry\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n \ncatch\n(\nconst\n \nstd\n::\nexception\n&\n)\n \n{\n\n\n}\n\nHaving empty catch statements in a codebase can be a serious problem that\ndevelopers should be aware of. Catch statements are used to handle exceptions\nthat are thrown during program execution. When an exception is thrown, the\nprogram jumps to the nearest catch statement that matches the type of the\nexception.\n\nEmpty catch statements, also known as âswallowingâ exceptions, catch the\nexception but do nothing with it. This means that the exception is not handled\nproperly, and the program continues to run as if nothing happened. This can\nlead to several issues, such as:\n\nHidden Bugs\n: If an exception is caught and ignored, it can lead to hidden\nbugs that are difficult to diagnose and fix. The root cause of the problem\nmay not be apparent, and the program may continue to behave in unexpected\nways.\n\n\nSecurity Issues\n: Ignoring exceptions can lead to security issues, such as\nbuffer overflows or null pointer dereferences. Hackers can exploit these\nvulnerabilities to gain access to sensitive data or execute malicious code.\n\n\nPoor Code Quality\n: Empty catch statements can indicate poor code quality\nand a lack of attention to detail. This can make the codebase difficult to\nmaintain and update, leading to longer development cycles and increased\ncosts.\n\n\nUnreliable Code\n: Code that ignores exceptions is often unreliable and can\nlead to unpredictable behavior. This can cause frustration for users and\nerode trust in the software.\n\nTo avoid these issues, developers should always handle exceptions properly.\nThis means either fixing the underlying issue that caused the exception or\npropagating the exception up the call stack to a higher-level handler.\nIf an exception is not important, it should still be logged or reported in\nsome way so that it can be tracked and addressed later.\n\nIf the exception is something that can be handled locally, then it should be\nhandled within the catch block. This could involve logging the exception or\ntaking other appropriate action to ensure that the exception is not ignored.\n\nHere is an example:\n\ntry\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n \ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nex\n)\n \n{\n\n\n  \n// Properly handle the exception, e.g.:\n\n\n  \nstd\n::\ncerr\n \n<<\n \n\"Exception caught: \"\n \n<<\n \nex\n.\nwhat\n()\n \n<<\n \nstd\n::\nendl\n;\n\n\n}\n\nIf the exception cannot be handled locally and needs to be propagated up the\ncall stack, it should be re-thrown or new exception should be thrown.\n\nHere is an example:\n\ntry\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n \ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nex\n)\n \n{\n\n\n  \n// Re-throw the exception\n\n\n  \nthrow\n;\n\n\n}\n\nIn some cases, catching the exception at this level may not be necessary, and\nit may be appropriate to let the exception propagate up the call stack.\nThis can be done simply by not using \ntry/catch\n block.\n\nHere is an example:\n\nvoid\n \nfunction\n()\n \n{\n\n\n  \n// Some code that can throw an exception\n\n\n}\n\n\n\nvoid\n \ncallerFunction\n()\n \n{\n\n\n  \ntry\n \n{\n\n\n    \nfunction\n();\n\n\n  \n}\n \ncatch\n \n(\nconst\n \nstd\n::\nexception\n&\n \nex\n)\n \n{\n\n\n    \n// Handling exception on higher level\n\n\n    \nstd\n::\ncerr\n \n<<\n \n\"Exception caught: \"\n \n<<\n \nex\n.\nwhat\n()\n \n<<\n \nstd\n::\nendl\n;\n\n\n  \n}\n\n\n}\n\nOther potential solution to avoid empty catch statements is to modify the code\nto avoid throwing the exception in the first place. This can be achieved by\nusing a different API, checking for error conditions beforehand, or handling\nerrors in a different way that does not involve exceptions. By eliminating the\nneed for try-catch blocks, the code becomes simpler and less error-prone.\n\nHere is an example:\n\n// Old code:\n\n\ntry\n \n{\n\n\n  \nmapContainer\n[\n\"Key\"\n].\ncallFunction\n();\n\n\n}\n \ncatch\n(\nconst\n \nstd\n::\nout_of_range\n&\n)\n \n{\n\n\n}\n\n\n\n// New code\n\n\nif\n \n(\nauto\n \nit\n \n=\n \nmapContainer\n.\nfind\n(\n\"Key\"\n);\n \nit\n \n!=\n \nmapContainer\n.\nend\n())\n \n{\n\n\n  \nit\n->\nsecond\n.\ncallFunction\n();\n\n\n}\n\nIn conclusion, empty catch statements are a bad practice that can lead to\nhidden bugs, security issues, poor code quality, and unreliable code. By\nhandling exceptions properly, developers can ensure that their code is\nrobust, secure, and maintainable.\n\nOptions\nÂ¶\n\n\n\n\n\n\nIgnoreCatchWithKeywords\nÂ¶\n\n\nThis option can be used to ignore specific catch statements containing\ncertain keywords. If a \ncatch\n statement body contains (case-insensitive)\nany of the keywords listed in this semicolon-separated option, then the\ncatch will be ignored, and no warning will be raised.\nDefault value: \n@TODO;@FIXME\n.\n\n\n\n\n\n\n\n\nAllowEmptyCatchForExceptions\nÂ¶\n\n\nThis option can be used to ignore empty catch statements for specific\nexception types. By default, the check will raise a warning if an empty\ncatch statement is detected, regardless of the type of exception being\ncaught. However, in certain situations, such as when a developer wants to\nintentionally ignore certain exceptions or handle them in a different way,\nit may be desirable to allow empty catch statements for specific exception\ntypes.\nTo configure this option, a semicolon-separated list of exception type names\nshould be provided. If an exception type name in the list is caught in an\nempty catch statement, no warning will be raised.\nDefault value: empty string.",
    "configurations": []
  }
}