{
  "name": "readability-enum-initial-value",
  "meta": {
    "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/enum-initial-value.html",
    "fixable": true
  },
  "content": {
    "introduction": "Enforces consistent style for enumeratorsâ initialization, covering three\nstyles: none, first only, or all initialized explicitly.\n\nAn inconsistent style and strictness to defining the initializing value of\nenumerators may cause issues if the enumeration is extended with new\nenumerators that obtain their integer representation implicitly.\n\nThe following three cases are accepted:\n\nNo\n enumerators are explicit initialized.\n\n\nExactly \nthe first\n enumerator is explicit initialized.\n\n\nAll\n enumerators are explicit initialized.\n\nenum\n \nA\n \n{\n    \n// (1) Valid, none of enumerators are initialized.\n\n\n  \na0\n,\n\n\n  \na1\n,\n\n\n  \na2\n,\n\n\n};\n\n\n\nenum\n \nB\n \n{\n    \n// (2) Valid, the first enumerator is initialized.\n\n\n  \nb0\n \n=\n \n0\n,\n\n\n  \nb1\n,\n\n\n  \nb2\n,\n\n\n};\n\n\n\nenum\n \nC\n \n{\n    \n// (3) Valid, all of enumerators are initialized.\n\n\n  \nc0\n \n=\n \n0\n,\n\n\n  \nc1\n \n=\n \n1\n,\n\n\n  \nc2\n \n=\n \n2\n,\n\n\n};\n\n\n\nenum\n \nD\n \n{\n    \n// warning: initial values in enum 'D' are not consistent,\n\n\n            \n//          consider explicit initialization of all, none or only\n\n\n            \n//          the first enumerator\n\n\n  \nd0\n \n=\n \n0\n,\n\n\n  \nd1\n,\n       \n// note: uninitialized enumerator 'd1' defined here\n\n\n  \nd2\n \n=\n \n2\n,\n\n\n};\n\n\n\nenum\n \nE\n \n{\n    \n// warning: initial values in enum 'E' are not consistent,\n\n\n            \n//          consider explicit initialization of all, none or only\n\n\n            \n//          the first enumerator\n\n\n  \ne0\n \n=\n \n0\n,\n\n\n  \ne1\n,\n       \n// note: uninitialized enumerator 'e1' defined here\n\n\n  \ne2\n \n=\n \n2\n,\n\n\n  \ne3\n,\n       \n// note: uninitialized enumerator 'e3' defined here\n\n\n            \n// Dangerous, as the numeric values of e3 and e5 are both 3,\n\n\n            \n// and this is not explicitly visible in the code!\n\n\n  \ne4\n \n=\n \n2\n,\n\n\n  \ne5\n,\n       \n// note: uninitialized enumerator 'e5' defined here\n\n\n};\n\nThis check corresponds to the CERT C Coding Standard recommendation \nINT09-C. Ensure enumeration constants map to unique values\n.\n\ncert-int09-c\n redirects here as an alias of this check.\n\nOptions\nÂ¶\n\n\n\n\n\n\nAllowExplicitZeroFirstInitialValue\nÂ¶\n\n\nIf set to \nfalse\n, the first enumerator must not be explicitly initialized to\na literal \n0\n.\nDefault is \ntrue\n.\n\n\nenum\n \nF\n \n{\n\n\n  \nf0\n \n=\n \n0\n,\n \n// Not allowed if AllowExplicitZeroFirstInitialValue is false.\n\n\n  \nf1\n,\n\n\n  \nf2\n,\n\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\nAllowExplicitSequentialInitialValues\nÂ¶\n\n\nIf set to \nfalse\n, explicit initialization to sequential values are not\nallowed.\nDefault is \ntrue\n.\n\n\nenum\n \nG\n \n{\n\n\n  \ng0\n \n=\n \n1\n,\n \n// Not allowed if AllowExplicitSequentialInitialValues is false.\n\n\n  \ng1\n \n=\n \n2\n,\n\n\n  \ng2\n \n=\n \n3\n,",
    "configurations": []
  }
}