{
    "ClassNamingConventions": {
        "description": "Description\n\nConfigurable naming conventions for type declarations. This rule reports\ntype declarations which do not match the regex that applies to their\nspecific kind (e.g. enum or interface). Each regex can be configured through\nproperties.\n\nBy default, this rule uses the standard Java naming convention (Pascal case).\n\nThe rule can detect utility classes and enforce a different naming convention\non those. E.g. setting the propertyutilityClassPatternto[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)reports any utility class, whose name\ndoes not end in \"Util(s)\", \"Helper\" or \"Constants\".\n\nFor this rule, a utility class is defined as: a concrete class that does not\ninherit from a super class or implement any interface and only has static fields\nor methods.\n\nThis rule detects test classes using the following convention: Test classes are top-level classes, that\neither inherit from JUnit 3 TestCase or have at least one method annotated with the Test annotations from\nJUnit4/5 or TestNG.\n\nExample(s):\n\nUse this rule with the default properties by just referencing it:\n\nUse this rule and customize it:",
        "option": "Name\tDefault Value\tDescription\nclassPattern\t[A-Z][a-zA-Z0-9]*\tRegex which applies to concrete class names\nabstractClassPattern\t[A-Z][a-zA-Z0-9]*\tRegex which applies to abstract class names\ninterfacePattern\t[A-Z][a-zA-Z0-9]*\tRegex which applies to interface names\nenumPattern\t[A-Z][a-zA-Z0-9]*\tRegex which applies to enum names\nannotationPattern\t[A-Z][a-zA-Z0-9]*\tRegex which applies to annotation names\nutilityClassPattern\t[A-Z][a-zA-Z0-9]*\tRegex which applies to utility class names\ntestClassPattern\t^(Test|IT).*$|^[A-Z][a-zA-Z0-9]*(Test|Tests|TestCase|IT|ITCase)$\tRegex which applies to test class names. Since PMD 6.52.0."
    }
}