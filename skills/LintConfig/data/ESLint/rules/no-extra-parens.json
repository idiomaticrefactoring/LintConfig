{
    "no-extra-parens": {
        "description": "Description\n\nThis rule always ignores extra parentheses around the following:\n\n- RegExp literals such as(/abc/).test(var)to avoid conflicts with thewrap-regexrule\n- immediately-invoked function expressions (also known as IIFEs) such asvar x = (function () {})();andvar x = (function () {}());to avoid conflicts with thewrap-iiferule\n- arrow function arguments to avoid conflicts with thearrow-parensrule\n\nProblems reported by this rule can be fixed automatically, except when removing the parentheses would create a new directive, because that could change the semantics of the code.\nFor example, the following script printsobjectto the console, but if the parentheses around\"use strict\"were removed, it would printundefinedinstead.\n\n<!--\n// this is a script\n// -->\n\n(\"use strict\");\n\nfunction test() {\n    console.log(typeof this);\n}\n\ntest();\n\nIn this case, the rule will not try to remove the parentheses around\"use strict\"but will still report them as a problem.",
        "option": "This rule has a string option:\n\n- \"all\"(default) disallows unnecessary parentheses aroundanyexpression.\n- \"functions\"disallows unnecessary parenthesesonlyaround function expressions.\n\nThis rule has an object option for exceptions to the\"all\"option:\n\n- \"conditionalAssign\": falseallows extra parentheses around assignments in conditional test expressions.\n- \"returnAssign\": falseallows extra parentheses around assignments inreturnstatements.\n- \"nestedBinaryExpressions\": falseallows extra parentheses in nested binary expressions.\n- \"ternaryOperandBinaryExpressions\": falseallows extra parentheses around binary expressions that are operands of ternary?:.\n- \"ignoreJSX\": \"none|all|multi-line|single-line\"allows extra parentheses around no/all/multi-line/single-line JSX components. Defaults tonone.\n- \"enforceForArrowConditionals\": falseallows extra parentheses around ternary expressions which are the body of an arrow function.\n- \"enforceForSequenceExpressions\": falseallows extra parentheses around sequence expressions.\n- \"enforceForNewInMemberExpressions\": falseallows extra parentheses aroundnewexpressions in member expressions.\n- \"enforceForFunctionPrototypeMethods\": falseallows extra parentheses around immediate.calland.applymethod calls on function expressions and around function expressions in the same context.\n- \"allowParensAfterCommentPattern\": \"any-string-pattern\"allows extra parentheses preceded by a comment that matches a regular expression.\n\nall\n\nExamples ofincorrectcode for this rule with the default\"all\"option:\n\n/* eslint no-extra-parens: \"error\" */\n\na = (b * c);\n\n(a * b) + c;\n\nfor (a in (b, c));\n\nfor (a in (b));\n\nfor (a of (b));\n\ntypeof (a);\n\n(Object.prototype.toString.call());\n\nclass A {\n    [(x)] = 1;\n}\n\nclass B {\n    x = (y + z);\n}\n\nExamples ofcorrectcode for this rule with the default\"all\"option:\n\n/* eslint no-extra-parens: \"error\" */\n\n(0).toString();\n\n({}.toString.call());\n\n(function(){}) ? a() : b();\n\n(/^a$/).test(x);\n\nfor (a of (b, c));\n\nfor (a of b);\n\nfor (a in b, c);\n\nfor (a in b);\n\nclass A {\n    [x] = 1;\n}\n\nclass B {\n    x = y + z;\n}\n\nconditionalAssign\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"conditionalAssign\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"conditionalAssign\": false }] */\n\nwhile ((foo = bar())) {}\n\nif ((foo = bar())) {}\n\ndo; while ((foo = bar()))\n\nfor (;(a = b););\n\nreturnAssign\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"returnAssign\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"returnAssign\": false }] */\n\nfunction a1(b) {\n  return (b = 1);\n}\n\nfunction a2(b) {\n  return b ? (c = d) : (c = e);\n}\n\nb => (b = 1);\n\nb => b ? (c = d) : (c = e);\n\nnestedBinaryExpressions\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"nestedBinaryExpressions\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"nestedBinaryExpressions\": false }] */\n\nx = a || (b && c);\nx = a + (b * c);\nx = (a * b) / c;\n\nternaryOperandBinaryExpressions\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"ternaryOperandBinaryExpressions\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"ternaryOperandBinaryExpressions\": false }] */\n\n(a && b) ? foo : bar;\n\n(a - b > a) ? foo : bar;\n\nfoo ? (bar || baz) : qux;\n\nfoo ? bar : (baz || qux);\n\nignoreJSX\n\nExamples ofcorrectcode for this rule with thealland{ \"ignoreJSX\": \"all\" }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"all\" }] */\nconst ThisComponent = (<div />)\nconst ThatComponent = (\n    <div\n        prop={true}\n    />\n)\n\nExamples ofincorrectcode for this rule with thealland{ \"ignoreJSX\": \"multi-line\" }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"multi-line\" }] */\nconst ThisComponent = (<div />)\nconst ThatComponent = (<div><p /></div>)\n\nExamples ofcorrectcode for this rule with thealland{ \"ignoreJSX\": \"multi-line\" }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"multi-line\" }] */\nconst ThisComponent = (\n    <div>\n        <p />\n    </div>\n)\nconst ThatComponent = (\n    <div\n        prop={true}\n    />\n)\n\nExamples ofincorrectcode for this rule with thealland{ \"ignoreJSX\": \"single-line\" }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"single-line\" }] */\nconst ThisComponent = (\n    <div>\n        <p />\n    </div>\n)\nconst ThatComponent = (\n    <div\n        prop={true}\n    />\n)\n\nExamples ofcorrectcode for this rule with thealland{ \"ignoreJSX\": \"single-line\" }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { ignoreJSX: \"single-line\" }] */\nconst ThisComponent = (<div />)\nconst ThatComponent = (<div><p /></div>)\n\nenforceForArrowConditionals\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"enforceForArrowConditionals\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForArrowConditionals\": false }] */\n\nconst b = a => 1 ? 2 : 3;\nconst d = c => (1 ? 2 : 3);\n\nenforceForSequenceExpressions\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"enforceForSequenceExpressions\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForSequenceExpressions\": false }] */\n\n(a, b);\n\nif ((val = foo(), val < 10)) {}\n\nwhile ((val = foo(), val < 10));\n\nenforceForNewInMemberExpressions\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"enforceForNewInMemberExpressions\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForNewInMemberExpressions\": false }] */\n\nconst foo = (new Bar()).baz;\n\nconst quux = (new Bar())[baz];\n\n(new Bar()).doSomething();\n\nenforceForFunctionPrototypeMethods\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"enforceForFunctionPrototypeMethods\": false }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"enforceForFunctionPrototypeMethods\": false }] */\n\nconst foo = (function () {}).call();\n\nconst bar = (function () {}).apply();\n\nconst baz = (function () {}.call());\n\nconst quux = (function () {}.apply());\n\nallowParensAfterCommentPattern\n\nTo make this rule allow extra parentheses preceded by specific comments, set this option to a string pattern that will be passed to theRegExpconstructor.\n\nExamples ofcorrectcode for this rule with the\"all\"and{ \"allowParensAfterCommentPattern\": \"@type\" }options:\n\n/* eslint no-extra-parens: [\"error\", \"all\", { \"allowParensAfterCommentPattern\": \"@type\" }] */\n\nconst span = /**@type {HTMLSpanElement}*/(event.currentTarget);\n\nif (/** @type {Foo | Bar} */(options).baz) console.log('Lint free');\n\nfoo(/** @type {Bar} */ (bar), options, {\n    name: \"name\",\n    path: \"path\",\n});\n\nif (foo) {\n    /** @type {Bar} */\n    (bar).prop = false;\n}\n\nfunctions\n\nExamples ofincorrectcode for this rule with the\"functions\"option:\n\n/* eslint no-extra-parens: [\"error\", \"functions\"] */\n\n((function foo() {}))();\n\nvar y = (function () {return 1;});\n\nExamples ofcorrectcode for this rule with the\"functions\"option:\n\n/* eslint no-extra-parens: [\"error\", \"functions\"] */\n\n(0).toString();\n\n(Object.prototype.toString.call());\n\n({}.toString.call());\n\n(function(){} ? a() : b());\n\n(/^a$/).test(x);\n\na = (b * c);\n\n(a * b) + c;\n\ntypeof (a);"
    }
}