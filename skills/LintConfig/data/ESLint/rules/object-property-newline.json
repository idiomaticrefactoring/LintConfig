{
    "object-property-newline": {
        "description": "Description\n\nMotivations\n\nThis rule makes it possible to ensure, as some style guides require, that property specifications appear on separate lines for better readability. For example, you can prohibit all of these:\n\nconst newObject = {a: 1, b: [2, {a: 3, b: 4}]};\nconst newObject = {\n    a: 1, b: [2, {a: 3, b: 4}]\n};\nconst newObject = {\n    a: 1,\n    b: [2, {a: 3, b: 4}]\n};\nconst newObject = {\n    a: 1,\n    b: [\n        2,\n        {a: 3, b: 4}\n    ]\n};\n\nInstead of those, you can comply with the rule by writing\n\nconst newObject = {\n    a: 1,\n    b: [2, {\n        a: 3,\n        b: 4\n    }]\n};\n\nor\n\nconst newObject = {\n    a: 1,\n    b: [\n        2,\n        {\n            a: 3,\n            b: 4\n        }\n    ]\n};\n\nAnother benefit of this rule is specificity of diffs when a property is changed:\n\n// More specific\n var obj = {\n     foo: \"foo\",\n-    bar: \"bar\",\n+    bar: \"bazz\",\n     baz: \"baz\"\n };\n\n// Less specific\n-var obj = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n+var obj = { foo: \"foo\", bar: \"bazz\", baz: \"baz\" };\n\nOptional Exception\n\nThe rule offers one object option,allowAllPropertiesOnSameLine(a deprecated synonym isallowMultiplePropertiesPerLine). If you set it totrue, object literals such as the first two above, with all property specifications on the same line, will be permitted, but one like\n\nconst newObject = {\n    a: 'a.m.', b: 'p.m.',\n    c: 'daylight saving time'\n};\n\nwill be prohibited, because two properties, but not all properties, appear on the same line.\n\nNotations\n\nThis rule applies equally to all property specifications, regardless of notation, including:\n\n- a: 1(ES5)\n- a(ES2015 shorthand property)\n- [`prop${a}`](ES2015 computed property name)\n\nThus, the rule (without the optional exception) prohibits both of these:\n\nconst newObject = {\n    a: 1, [\n        process.argv[4]\n    ]: '01'\n};\nconst newObject = {\n    a: 1, [process.argv[4]]: '01'\n};\n\n(This behavior differs from that of the JSCS rule cited below, which does not treat the leading[of a computed property name as part of that property specification. The JSCS rule prohibits the second of these formats but permits the first.)\n\nMultiline Properties\n\nThe rule prohibits the colocation on any line of at least 1 character of one property specification with at least 1 character of any other property specification. For example, the rule prohibits\n\nconst newObject = {a: [\n    'Officiële website van de Europese Unie',\n    'Официален уебсайт на Европейския съюз'\n], b: 2};\n\nbecause 1 character of the specification ofa(i.e. the trailing]of its value) is on the same line as the specification ofb.\n\nThe optional exception does not excuse this case, because the entire collection of property specifications spans 4 lines, not 1.\n\nInter-property Delimiters\n\nThe comma and any whitespace that delimit property specifications are not considered parts of them. Therefore, the rule permits both of these formats:\n\nconst newFunction = multiplier => ({\n    a: 2 * multiplier,\n    b: 4 * multiplier,\n    c: 8 * multiplier\n});\nconst newFunction = multiplier => ({\n    a: 2 * multiplier\n    , b: 4 * multiplier\n    , c: 8 * multiplier\n});\n\n(This behavior differs from that of the JSCS rule cited below, which permits the first but prohibits the second format.)\n\n–fix\n\nIf this rule is invoked with the command-line--fixoption, object literals that violate the rule are generally modified to comply with it. The modification in each case is to move a property specification to the next line whenever there is part or all of a previous property specification on the same line. For example,\n\nconst newObject = {\n    a: 'a.m.', b: 'p.m.',\n    c: 'daylight saving time'\n};\n\nis converted to\n\nconst newObject = {\n    a: 'a.m.',\nb: 'p.m.',\n    c: 'daylight saving time'\n};\n\nThe modification does not depend on whether the object option is set totrue. In other words, ESLint never collects all the property specifications onto a single line, even when the object option would permit that.\n\nESLint does not correct a violation of this rule if a comment immediately precedes the second or subsequent property specification on a line, since ESLint cannot determine which line to put the comment onto.\n\nAs illustrated above, the--fixoption, applied to this rule, does not comply with other rules, such asindent, but, if those other rules are also in effect, the option applies them, too.\n\nExamples ofincorrectcode for this rule, with no object option or withallowAllPropertiesOnSameLineset tofalse:\n\n/*eslint object-property-newline: \"error\"*/\n\nconst obj0 = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n\nconst obj1 = {\n    foo: \"foo\", bar: \"bar\", baz: \"baz\"\n};\n\nconst obj2 = {\n    foo: \"foo\", bar: \"bar\",\n    baz: \"baz\"\n};\n\nconst obj3 = {\n    [process.argv[3] ? \"foo\" : \"bar\"]: 0, baz: [\n        1,\n        2,\n        4,\n        8\n    ]\n};\n\nconst a = \"antidisestablishmentarianistically\";\nconst b = \"yugoslavyalılaştırabildiklerimizdenmişsiniz\";\nconst obj4 = {a, b};\n\nconst domain = process.argv[4];\nconst obj5 = {\n    foo: \"foo\", [\n    domain.includes(\":\") ? \"complexdomain\" : \"simpledomain\"\n]: true};\n\nExamples ofcorrectcode for this rule, with no object option or withallowAllPropertiesOnSameLineset tofalse:\n\n/*eslint object-property-newline: \"error\"*/\n\nconst obj1 = {\n    foo: \"foo\",\n    bar: \"bar\",\n    baz: \"baz\"\n};\n\nconst obj2 = {\n    foo: \"foo\"\n    , bar: \"bar\"\n    , baz: \"baz\"\n};\n\nconst user = process.argv[2];\nconst obj3 = {\n    user,\n    [process.argv[3] ? \"foo\" : \"bar\"]: 0,\n    baz: [\n        1,\n        2,\n        4,\n        8\n    ]\n};\n\nExamples of additionalcorrectcode for this rule with the{ \"allowAllPropertiesOnSameLine\": true }option:\n\n/*eslint object-property-newline: [\"error\", { \"allowAllPropertiesOnSameLine\": true }]*/\n\nconst obj = { foo: \"foo\", bar: \"bar\", baz: \"baz\" };\n\nconst obj2 = {\n    foo: \"foo\", bar: \"bar\", baz: \"baz\"\n};\nconst user = process.argv[2];\nconst obj3 = {\n    user, [process.argv[3] ? \"foo\" : \"bar\"]: 0, baz: [1, 2, 4, 8]\n};",
        "option": "This rule has no specific options."
    }
}