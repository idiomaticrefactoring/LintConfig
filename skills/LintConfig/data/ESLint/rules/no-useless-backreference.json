{
    "no-useless-backreference": {
        "description": "Description\n\nThis rule aims to detect and disallow the following backreferences in regular expression:\n\n- Backreference to a group that is in another alternative, e.g.,/(a)|\\1b/. In such constructed regular expression, the backreference is expected to match what’s been captured in, at that point, a non-participating group.\n- Backreference to a group that appears later in the pattern, e.g.,/\\1(a)/. The group hasn’t captured anything yet, and ECMAScript doesn’t support forward references. Inside lookbehinds, which match backward, the opposite applies and this rule disallows backreference to a group that appears before in the same lookbehind, e.g.,/(?<=(a)\\1)b/.\n- Backreference to a group from within the same group, e.g.,/(\\1)/. Similar to the previous, the group hasn’t captured anything yet, and ECMAScript doesn’t support nested references.\n- Backreference to a group that is in a negative lookaround, if the backreference isn’t in the same negative lookaround, e.g.,/a(?!(b)).\\1/. A negative lookaround (lookahead or lookbehind) succeeds only if its pattern cannot match, meaning that the group has failed.\n\nBy the ECMAScript specification, all backreferences listed above are valid, always succeed to match zero-length, and cannot match anything else. Consequently, they don’t produce parsing or runtime errors, but also don’t affect the behavior of their regular expressions. They are syntactically valid but useless.\n\nThis might be surprising to developers coming from other languages where some of these backreferences can be used in a meaningful way.\n\n// in some other languages, this pattern would successfully match \"aab\"\n\n/^(?:(a)(?=a)|\\1b)+$/.test(\"aab\"); // false\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-useless-backreference: \"error\"*/\n\n/^(?:(a)|\\1b)$/; // reference to (a) into another alternative\n\n/^(?:(a)|b(?:c|\\1))$/; // reference to (a) into another alternative\n\n/^(?:a|b(?:(c)|\\1))$/; // reference to (c) into another alternative\n\n/\\1(a)/; // forward reference to (a)\n\nRegExp('(a)\\\\2(b)'); // forward reference to (b)\n\n/(?:a)(b)\\2(c)/; // forward reference to (c)\n\n/\\k<foo>(?<foo>a)/; // forward reference to (?<foo>a)\n\n/(?<=(a)\\1)b/; // backward reference to (a) from within the same lookbehind\n\n/(?<!(a)\\1)b/; // backward reference to (a) from within the same lookbehind\n\nnew RegExp('(\\\\1)'); // nested reference to (\\1)\n\n/^((a)\\1)$/; // nested reference to ((a)\\1)\n\n/a(?<foo>(.)b\\1)/; // nested reference to (?<foo>(.)b\\1)\n\n/a(?!(b)).\\1/; // reference to (b) into a negative lookahead\n\n/(?<!(a))b\\1/; // reference to (a) into a negative lookbehind\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-useless-backreference: \"error\"*/\n\n/^(?:(a)|(b)\\2)$/; // reference to (b)\n\n/(a)\\1/; // reference to (a)\n\nRegExp('(a)\\\\1(b)'); // reference to (a)\n\n/(a)(b)\\2(c)/; // reference to (b)\n\n/(?<foo>a)\\k<foo>/; // reference to (?<foo>a)\n\n/(?<=\\1(a))b/; // reference to (a), correctly before the group as they're in the same lookbehind\n\n/(?<=(a))b\\1/; // reference to (a), correctly after the group as the backreference isn't in the lookbehind\n\nnew RegExp('(.)\\\\1'); // reference to (.)\n\n/^(?:(a)\\1)$/; // reference to (a)\n\n/^((a)\\2)$/; // reference to (a)\n\n/a(?<foo>(.)b\\2)/; // reference to (.)\n\n/a(?!(b|c)\\1)./; // reference to (b|c), correct as it's from within the same negative lookahead\n\n/(?<!\\1(a))b/; // reference to (a), correct as it's from within the same negative lookbehind\n\nPlease note that this rule does not aim to detect and disallow a potentially erroneous use of backreference syntax in regular expressions, like the use in character classes or an attempt to reference a group that doesn’t exist. Depending on the context, a\\1…\\9sequence that is not a syntactically valid backreference may produce syntax error, or be parsed as something else (e.g., as a legacy octal escape sequence).\n\nExamples of additionalcorrectcode for this rule:\n\n/*eslint no-useless-backreference: \"error\"*/\n\n// comments describe behavior in a browser\n\n/^[\\1](a)$/.test(\"\\x01a\"); // true. In a character class, \\1 is treated as an octal escape sequence.\n/^\\1$/.test(\"\\x01\"); // true. Since the group 1 doesn't exist, \\1 is treated as an octal escape sequence.\n/^(a)\\1\\2$/.test(\"aa\\x02\"); // true. In this case, \\1 is a backreference, \\2 is an octal escape sequence.",
        "option": "This rule has no options."
    }
}