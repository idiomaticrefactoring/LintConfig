{
    "padding-line-between-statements": {
        "description": "Description\n\nThis rule does nothing if no configurations are provided.\n\nA configuration is an object which has 3 properties;blankLine,prevandnext. For example,{ blankLine: \"always\", prev: \"var\", next: \"return\" }means “one or more blank lines are required between a variable declaration and areturnstatement.”\nYou can supply any number of configurations. If a statement pair matches multiple configurations, the last matched configuration will be used.\n\n{\n    \"padding-line-between-statements\": [\n        \"error\",\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        { \"blankLine\": LINEBREAK_TYPE, \"prev\": STATEMENT_TYPE, \"next\": STATEMENT_TYPE },\n        ...\n    ]\n}\n\n- LINEBREAK_TYPEis one of the following.\"any\"just ignores the statement pair.\"never\"disallows blank lines.\"always\"requires one or more blank lines. Note it does not count lines that comments exist as blank lines.\n- \"any\"just ignores the statement pair.\n- \"never\"disallows blank lines.\n- \"always\"requires one or more blank lines. Note it does not count lines that comments exist as blank lines.\n- STATEMENT_TYPEis one of the following, or an array of the following.\"*\"is wildcard. This matches any statements.\"block\"is lonely blocks.\"block-like\"is block like statements. This matches statements that the last token is the closing brace of blocks; e.g.{ },if (a) { }, andwhile (a) { }. Also matches immediately invoked function expression statements.\"break\"isbreakstatements.\"case\"iscaseclauses inswitchstatements.\"cjs-export\"isexportstatements of CommonJS; e.g.module.exports = 0,module.exports.foo = 1, andexports.foo = 2. This is a special case of assignment.\"cjs-import\"isimportstatements of CommonJS; e.g.const foo = require(\"foo\"). This is a special case of variable declarations.\"class\"isclassdeclarations.\"const\"isconstvariable declarations, both single-line and multiline.\"continue\"iscontinuestatements.\"debugger\"isdebuggerstatements.\"default\"isdefaultclauses inswitchstatements.\"directive\"is directive prologues. This matches directives; e.g.\"use strict\".\"do\"isdo-whilestatements. This matches all statements that the first token isdokeyword.\"empty\"is empty statements.\"export\"isexportdeclarations.\"expression\"is expression statements.\"for\"isforloop families. This matches all statements that the first token isforkeyword.\"function\"is function declarations.\"if\"isifstatements.\"iife\"is immediately invoked function expression statements. This matches calls on a function expression, optionally prefixed with a unary operator.\"import\"isimportdeclarations.\"let\"isletvariable declarations, both single-line and multiline.\"multiline-block-like\"is block like statements. This is the same asblock-liketype, but only if the block is multiline.\"multiline-const\"is multilineconstvariable declarations.\"multiline-expression\"is expression statements. This is the same asexpressiontype, but only if the statement is multiline.\"multiline-let\"is multilineletvariable declarations.\"multiline-var\"is multilinevarvariable declarations.\"return\"isreturnstatements.\"singleline-const\"is single-lineconstvariable declarations.\"singleline-let\"is single-lineletvariable declarations.\"singleline-var\"is single-linevarvariable declarations.\"switch\"isswitchstatements.\"throw\"isthrowstatements.\"try\"istrystatements.\"var\"isvarvariable declarations, both single-line and multiline.\"while\"iswhileloop statements.\"with\"iswithstatements.\n- \"*\"is wildcard. This matches any statements.\n- \"block\"is lonely blocks.\n- \"block-like\"is block like statements. This matches statements that the last token is the closing brace of blocks; e.g.{ },if (a) { }, andwhile (a) { }. Also matches immediately invoked function expression statements.\n- \"break\"isbreakstatements.\n- \"case\"iscaseclauses inswitchstatements.\n- \"cjs-export\"isexportstatements of CommonJS; e.g.module.exports = 0,module.exports.foo = 1, andexports.foo = 2. This is a special case of assignment.\n- \"cjs-import\"isimportstatements of CommonJS; e.g.const foo = require(\"foo\"). This is a special case of variable declarations.\n- \"class\"isclassdeclarations.\n- \"const\"isconstvariable declarations, both single-line and multiline.\n- \"continue\"iscontinuestatements.\n- \"debugger\"isdebuggerstatements.\n- \"default\"isdefaultclauses inswitchstatements.\n- \"directive\"is directive prologues. This matches directives; e.g.\"use strict\".\n- \"do\"isdo-whilestatements. This matches all statements that the first token isdokeyword.\n- \"empty\"is empty statements.\n- \"export\"isexportdeclarations.\n- \"expression\"is expression statements.\n- \"for\"isforloop families. This matches all statements that the first token isforkeyword.\n- \"function\"is function declarations.\n- \"if\"isifstatements.\n- \"iife\"is immediately invoked function expression statements. This matches calls on a function expression, optionally prefixed with a unary operator.\n- \"import\"isimportdeclarations.\n- \"let\"isletvariable declarations, both single-line and multiline.\n- \"multiline-block-like\"is block like statements. This is the same asblock-liketype, but only if the block is multiline.\n- \"multiline-const\"is multilineconstvariable declarations.\n- \"multiline-expression\"is expression statements. This is the same asexpressiontype, but only if the statement is multiline.\n- \"multiline-let\"is multilineletvariable declarations.\n- \"multiline-var\"is multilinevarvariable declarations.\n- \"return\"isreturnstatements.\n- \"singleline-const\"is single-lineconstvariable declarations.\n- \"singleline-let\"is single-lineletvariable declarations.\n- \"singleline-var\"is single-linevarvariable declarations.\n- \"switch\"isswitchstatements.\n- \"throw\"isthrowstatements.\n- \"try\"istrystatements.\n- \"var\"isvarvariable declarations, both single-line and multiline.\n- \"while\"iswhileloop statements.\n- \"with\"iswithstatements.\n\nThis configuration would require blank lines before allreturnstatements, like thenewline-before-returnrule.\n\nExamples ofincorrectcode for the[{ blankLine: \"always\", prev: \"*\", next: \"return\" }]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"*\", next: \"return\" }\n]*/\n\nfunction foo() {\n    bar();\n    return;\n}\n\nExamples ofcorrectcode for the[{ blankLine: \"always\", prev: \"*\", next: \"return\" }]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"*\", next: \"return\" }\n]*/\n\nfunction foo1() {\n    bar();\n\n    return;\n}\n\nfunction foo2() {\n    return;\n}\n\nThis configuration would require blank lines after every sequence of variable declarations, like thenewline-after-varrule.\n\nExamples ofincorrectcode for the[{ blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"}, { blankLine: \"any\", prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"},\n    { blankLine: \"any\",    prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}\n]*/\n\nfunction foo1() {\n    var a = 0;\n    bar();\n}\n\nfunction foo2() {\n    let a = 0;\n    bar();\n}\n\nfunction foo3() {\n    const a = 0;\n    bar();\n}\n\nclass C {\n    static {\n        let a = 0;\n        bar();\n    }\n}\n\nExamples ofcorrectcode for the[{ blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"}, { blankLine: \"any\", prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"const\", \"let\", \"var\"], next: \"*\"},\n    { blankLine: \"any\",    prev: [\"const\", \"let\", \"var\"], next: [\"const\", \"let\", \"var\"]}\n]*/\n\nfunction foo1() {\n    var a = 0;\n    var b = 0;\n\n    bar();\n}\n\nfunction foo2() {\n    let a = 0;\n    const b = 0;\n\n    bar();\n}\n\nfunction foo3() {\n    const a = 0;\n    const b = 0;\n\n    bar();\n}\n\nclass C {\n    static {\n        let a = 0;\n        let b = 0;\n\n        bar();\n    }\n}\n\nThis configuration would require blank lines after all directive prologues, like thelines-around-directiverule.\n\nExamples ofincorrectcode for the[{ blankLine: \"always\", prev: \"directive\", next: \"*\" }, { blankLine: \"any\", prev: \"directive\", next: \"directive\" }]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"directive\", next: \"*\" },\n    { blankLine: \"any\",    prev: \"directive\", next: \"directive\" }\n]*/\n\n\"use strict\";\nfoo();\n\nExamples ofcorrectcode for the[{ blankLine: \"always\", prev: \"directive\", next: \"*\" }, { blankLine: \"any\", prev: \"directive\", next: \"directive\" }]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: \"directive\", next: \"*\" },\n    { blankLine: \"any\",    prev: \"directive\", next: \"directive\" }\n]*/\n\n\"use strict\";\n\"use asm\";\n\nfoo();\n\nThis configuration would require blank lines between clauses inswitchstatements.\n\nExamples ofincorrectcode for the[{ blankLine: \"always\", prev: [\"case\", \"default\"], next: \"*\" }]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"case\", \"default\"], next: \"*\" }\n]*/\n\nswitch (foo) {\n    case 1:\n        bar();\n        break;\n    case 2:\n    case 3:\n        baz();\n        break;\n    default:\n        quux();\n}\n\nExamples ofcorrectcode for the[{ blankLine: \"always\", prev: [\"case\", \"default\"], next: \"*\" }]configuration:\n\n/*eslint padding-line-between-statements: [\n    \"error\",\n    { blankLine: \"always\", prev: [\"case\", \"default\"], next: \"*\" }\n]*/\n\nswitch (foo) {\n    case 1:\n        bar();\n        break;\n\n    case 2:\n\n    case 3:\n        baz();\n        break;\n\n    default:\n        quux();\n}",
        "option": "This rule has no specific options."
    }
}