{
    "no-use-before-define": {
        "description": "Description\n\nThis rule will warn when it encounters a reference to an identifier that has not yet been declared.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-use-before-define: \"error\"*/\n\nalert(a);\nvar a = 10;\n\nf();\nfunction f() {}\n\nfunction g() {\n    return b;\n}\nvar b = 1;\n\n{\n    alert(c);\n    let c = 1;\n}\n\n{\n    class C extends C {}\n}\n\n{\n    class C {\n        static x = \"foo\";\n        [C.x]() {}\n    }\n}\n\n{\n    const C = class {\n        static x = C;\n    }\n}\n\n{\n    const C = class {\n        static {\n            C.x = \"foo\";\n        }\n    }\n}\n\nexport { foo };\nconst foo = 1;\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-use-before-define: \"error\"*/\n\nvar a;\na = 10;\nalert(a);\n\nfunction f() {}\nf(1);\n\nvar b = 1;\nfunction g() {\n    return b;\n}\n\n{\n    let c;\n    c++;\n}\n\n{\n    class C {\n        static x = C;\n    }\n}\n\n{\n    const C = class C {\n        static x = C;\n    }\n}\n\n{\n    const C = class {\n        x = C;\n    }\n}\n\n{\n    const C = class C {\n        static {\n            C.x = \"foo\";\n        }\n    }\n}\n\nconst foo = 1;\nexport { foo };",
        "option": "{\n    \"no-use-before-define\": [\"error\", {\n        \"functions\": true,\n        \"classes\": true,\n        \"variables\": true,\n        \"allowNamedExports\": false,\n        \"enums\": true,\n        \"typedefs\": true,\n        \"ignoreTypeReferences\": true\n    }]\n}\n\n- functions(boolean) -\nThis flag determines whether or not the rule checks function declarations.\nIf this istrue, the rule warns on every reference to a function before the function declaration.\nOtherwise, the rule ignores those references.\nFunction declarations are hoisted, so it’s safe to disable this option (note that some idiomatic patterns, such asmutual recursion, are incompatible with enabling this option).\nDefault istrue.\n- classes(boolean) -\nThis flag determines whether or not the rule checks class declarations of upper scopes.\nIf this istrue, the rule warns on every reference to a class before the class declaration.\nOtherwise, the rule ignores such references, provided the declaration is in an upper function scope.\nClass declarations are not hoisted, so it might be dangerous to disable this option.\nDefault istrue.\n- variables(boolean) -\nThis flag determines whether or not the rule checks variable declarations in upper scopes.\nIf this istrue, the rule warns on every reference to a variable before the variable declaration.\nOtherwise, the rule ignores a reference if the declaration is in an upper scope, while still reporting the reference if it’s in the same scope as the declaration.\nDefault istrue.\n- allowNamedExports(boolean) -\nIf this flag is set totrue, the rule always allows references inexport {};declarations.\nThese references are safe even if the variables are declared later in the code.\nDefault isfalse.\n\nThis rule additionally supports TypeScript type syntax. The following options enable checking for the references totype,interfaceandenumdeclarations:\n\n- enums(boolean) -\nIf it istrue, the rule warns every reference to anenumbefore it is defined.\nDefault istrue.\n- typedefs(boolean) -\nIf it istrue, this rule warns every reference to a typealiasorinterfacebefore its declaration. Iffalse, the rule allows using typealiases andinterfaces before they are defined.\nDefault istrue.\n- ignoreTypeReferences(boolean) -\nIf it istrue, rule will ignore all type references, such as in type annotations and assertions.\nDefault istrue.\n\nThis rule accepts\"nofunc\"string as an option.\"nofunc\"is the same as{ \"functions\": false, \"classes\": true, \"variables\": true, \"allowNamedExports\": false, \"enums\": true, \"typedefs\": true, \"ignoreTypeReferences\": true }.\n\nfunctions\n\nExamples ofcorrectcode for the{ \"functions\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"functions\": false }]*/\n\nf();\nfunction f() {}\n\nThis option allows references to function declarations. For function expressions and arrow functions, please see thevariablesoption.\n\nclasses\n\nExamples ofincorrectcode for the{ \"classes\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"classes\": false }]*/\n\nnew A();\nclass A {\n}\n\n{\n    class C extends C {}\n}\n\n{\n    class C extends D {}\n    class D {}\n}\n\n{\n    class C {\n        static x = \"foo\";\n        [C.x]() {}\n    }\n}\n\n{\n    class C {\n        static {\n            new D();\n        }\n    }\n    class D {}\n}\n\nExamples ofcorrectcode for the{ \"classes\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"classes\": false }]*/\n\nfunction foo() {\n    return new A();\n}\n\nclass A {\n}\n\nvariables\n\nExamples ofincorrectcode for the{ \"variables\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"variables\": false }]*/\n\nconsole.log(foo);\nvar foo = 1;\n\nf();\nconst f = () => {};\n\ng();\nconst g = function() {};\n\n{\n    const C = class {\n        static x = C;\n    }\n}\n\n{\n    const C = class {\n        static x = foo;\n    }\n    const foo = 1;\n}\n\n{\n    class C {\n        static {\n            this.x = foo;\n        }\n    }\n    const foo = 1;\n}\n\nExamples ofcorrectcode for the{ \"variables\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"variables\": false }]*/\n\nfunction baz() {\n    console.log(foo);\n}\nvar foo = 1;\n\nconst a = () => f();\nfunction b() { return f(); }\nconst c = function() { return f(); }\nconst f = () => {};\n\nconst e = function() { return g(); }\nconst g = function() {}\n\n{\n    const C = class {\n        x = foo;\n    }\n    const foo = 1;\n}\n\nallowNamedExports\n\nExamples ofcorrectcode for the{ \"allowNamedExports\": true }option:\n\n/*eslint no-use-before-define: [\"error\", { \"allowNamedExports\": true }]*/\n\nexport { a, b, f, C };\n\nconst a = 1;\n\nlet b;\n\nfunction f () {}\n\nclass C {}\n\nExamples ofincorrectcode for the{ \"allowNamedExports\": true }option:\n\n/*eslint no-use-before-define: [\"error\", { \"allowNamedExports\": true }]*/\n\nexport default a;\nconst a = 1;\n\nconst b = c;\nexport const c = 1;\n\nexport function foo() {\n    return d;\n}\nconst d = 1;\n\nenums (TypeScript only)\n\nExamples ofincorrectcode for the{ \"enums\": true }option:\n\n/*eslint no-use-before-define: [\"error\", { \"enums\": true }]*/\n\nconst x = Foo.FOO;\n\nenum Foo {\n  FOO,\n}\n\nExamples ofcorrectcode for the{ \"enums\": true }option:\n\n/*eslint no-use-before-define: [\"error\", { \"enums\": true }]*/\n\nenum Foo {\n  FOO,\n}\n\nconst x = Foo.FOO;\n\ntypedefs (TypeScript only)\n\nExamples ofincorrectcode for the{ \"enums\": true }with{ \"ignoreTypeReferences\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"typedefs\": true, \"ignoreTypeReferences\": false }]*/\n\nlet myVar: StringOrNumber;\n\ntype StringOrNumber = string | number;\n\nconst x: Foo = {};\n\ninterface Foo {}\n\nExamples ofcorrectcode for the{ \"typedefs\": true }with{ \"ignoreTypeReferences\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"typedefs\": true, \"ignoreTypeReferences\": false }]*/\n\ntype StringOrNumber = string | number;\n\nlet myVar: StringOrNumber;\n\ninterface Foo {}\n\nconst x: Foo = {};\n\nignoreTypeReferences (TypeScript only)\n\nExamples ofincorrectcode for the{ \"ignoreTypeReferences\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"ignoreTypeReferences\": false }]*/\n\nlet var1: StringOrNumber;\n\ntype StringOrNumber = string | number;\n\nlet var2: Enum;\n\nenum Enum {}\n\nExamples ofcorrectcode for the{ \"ignoreTypeReferences\": false }option:\n\n/*eslint no-use-before-define: [\"error\", { \"ignoreTypeReferences\": false }]*/\n\ntype StringOrNumber = string | number;\n\nlet myVar: StringOrNumber;\n\nenum Enum {}\n\nlet var2: Enum;\n\nnofunc\n\nExamples ofincorrectcode for the\"nofunc\"option:\n\n/*eslint no-use-before-define: [\"error\", \"nofunc\"]*/\n\na();\nvar a = function() {};\n\nconsole.log(foo);\nvar foo = 1;\n\nfunction f() {\n    return b;\n}\nvar b = 1;\n\nnew A();\nclass A {\n}\n\nfunction g() {\n    return new B();\n}\nclass B {\n}\n\nexport default bar;\nconst bar = 1;\n\nexport { baz };\nconst baz = 1;\n\n/*eslint no-use-before-define: [\"error\", \"nofunc\"]*/\n\nfunction foo(): Foo {\n\treturn Foo.FOO;\n}\n\t\nenum Foo {\n\tFOO,\n}\n\nExamples ofcorrectcode for the\"nofunc\"option:\n\n/*eslint no-use-before-define: [\"error\", \"nofunc\"]*/\n\nf();\nfunction f() {}\n\nclass A {\n}\nnew A();\n\nvar a = 10;\nalert(a);\n\nconst foo = 1;\nexport { foo };\n\nconst bar = 1;\nexport default bar;\n\n/*eslint no-use-before-define: [\"error\", \"nofunc\"]*/\n\t\nenum Foo {\n\tFOO,\n}\n\nconst foo = Foo.Foo;"
    }
}