{
    "no-unused-vars": {
        "description": "Description\n\nThis rule is aimed at eliminating unused variables, functions, and function parameters.\n\nA variablefoois considered to be used if any of the following are true:\n\n- It is called (foo()) or constructed (new foo())\n- It is read (let bar = foo)\n- It is passed into a function as an argument (doSomething(foo))\n- It is read inside of a function that is passed to another function (doSomething(function() { foo(); }))\n\nA variable isnotconsidered to be used if it is only ever declared (let foo = 5) or assigned to (foo = 7).\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-unused-vars: \"error\"*/\n/*global some_unused_var*/\n\n// It checks variables you have defined as global\nsome_unused_var = 42;\n\nlet x;\n\n// Write-only variables are not considered as used.\nlet y = 10;\ny = 5;\n\n// A read for a modification of itself is not considered as used.\nlet z = 0;\nz = z + 1;\n\n// By default, unused arguments cause warnings.\n(function(foo) {\n    return 5;\n})();\n\n// Unused recursive functions also cause warnings.\nfunction fact(n) {\n    if (n < 2) return 1;\n    return n * fact(n - 1);\n}\n\n// When a function definition destructures an array, unused entries from the array also cause warnings.\nfunction getY([x, y]) {\n    return y;\n}\ngetY([\"a\", \"b\"]);\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-unused-vars: \"error\"*/\n\nconst x = 10;\nalert(x);\n\n// foo is considered used here\nmyFunc(function foo() {\n    // ...\n}.bind(this));\n\n(function(foo) {\n    return foo;\n})();\n\nvar myFunc;\nmyFunc = setTimeout(function() {\n    // myFunc is considered used\n    myFunc();\n}, 50);\n\n// Only the second argument from the destructured array is used.\nfunction getY([, y]) {\n    return y;\n}\ngetY([\"a\", \"b\"]);\n\nexported\n\nIn environments outside of CommonJS or ECMAScript modules, you may usevarto create a global variable that may be used by other scripts. You can use the/* exported variableName */comment block to indicate that this variable is being exported and therefore should not be considered unused.\n\nNote that/* exported */has no effect for any of the following:\n\n- whenlanguageOptions.sourceTypeismodule(default) orcommonjs\n- whenlanguageOptions.parserOptions.ecmaFeatures.globalReturnistrue\n\nThe line comment// exported variableNamewill not work asexportedis not line-specific.\n\n/* exported global_var */\n\nvar global_var = 42;\n\nExamples ofcorrectcode for/* exported variableName */operation withno-unused-vars:\n\n/*eslint no-unused-vars: \"error\"*/\n/* exported global_var */\n\nvar global_var = 42;",
        "option": "This rule takes one argument which can be a string or an object. The string settings are the same as those of thevarsproperty (explained below).\n\nBy default this rule is enabled withalloption for caught errors and variables, andafter-usedfor arguments.\n\n{\n    \"rules\": {\n        \"no-unused-vars\": [\"error\", {\n            \"vars\": \"all\",\n            \"args\": \"after-used\",\n            \"caughtErrors\": \"all\",\n            \"ignoreRestSiblings\": false,\n            \"ignoreUsingDeclarations\": false,\n            \"reportUsedIgnorePattern\": false\n        }]\n    }\n}\n\nvars\n\nThevarsoption has two settings:\n\n- \"all\"checks all variables for usage, including those in the global scope. However, it excludes variables targeted by other options likeargsandcaughtErrors. This is the default setting.\n- \"local\"allows variables in the global scope to be unused.\n\nvars: local\n\nExamples ofcorrectcode for the{ \"vars\": \"local\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"vars\": \"local\" }]*/\n/*global some_unused_var */\n\nsome_unused_var = 42;\n\nExamples ofcorrectcode for the{ \"vars\": \"local\" }option with\"languageOptions\": { \"sourceType\": \"script\" }:\n\n/*eslint no-unused-vars: [\"error\", { \"vars\": \"local\" }]*/\n\nconst foo = 42;\n\nlet bar;\n\nlet baz = 42;\n\nvar qux;\n\nvar quux = 42;\n\nvarsIgnorePattern\n\nThevarsIgnorePatternoption specifies exceptions not to check for usage: variables whose names match a regexp pattern. For example, variables whose names containignoredorIgnored. However, it excludes variables targeted by other options likeargsIgnorePatternandcaughtErrorsIgnorePattern.\n\nExamples ofcorrectcode for the{ \"varsIgnorePattern\": \"[iI]gnored\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"[iI]gnored\" }]*/\n\nconst firstVarIgnored = 1;\nconst secondVar = 2;\nconsole.log(secondVar);\n\nargs\n\nTheargsoption has three settings:\n\n- after-used- unused positional arguments that occur before the last used argument will not be checked, but all named arguments and all positional arguments after the last used argument will be checked.\n- all- all named arguments must be used.\n- none- do not check arguments.\n\nargs: after-used\n\nExamples ofincorrectcode for the default{ \"args\": \"after-used\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"args\": \"after-used\" }]*/\n\n// 2 errors, for the parameters after the last used parameter (bar)\n// \"baz\" is defined but never used\n// \"qux\" is defined but never used\n(function(foo, bar, baz, qux) {\n    return bar;\n})();\n\nExamples ofcorrectcode for the default{ \"args\": \"after-used\" }option:\n\n/*eslint no-unused-vars: [\"error\", {\"args\": \"after-used\"}]*/\n\n(function(foo, bar, baz, qux) {\n    return qux;\n})();\n\nargs: all\n\nExamples ofincorrectcode for the{ \"args\": \"all\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"args\": \"all\" }]*/\n\n// 2 errors\n// \"foo\" is defined but never used\n// \"baz\" is defined but never used\n(function(foo, bar, baz) {\n    return bar;\n})();\n\nargs: none\n\nExamples ofcorrectcode for the{ \"args\": \"none\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"args\": \"none\" }]*/\n\n(function(foo, bar, baz) {\n    return bar;\n})();\n\nargsIgnorePattern\n\nTheargsIgnorePatternoption specifies exceptions not to check for usage: arguments whose names match a regexp pattern. For example, variables whose names begin with an underscore.\n\nExamples ofcorrectcode for the{ \"argsIgnorePattern\": \"^_\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"argsIgnorePattern\": \"^_\" }]*/\n\nfunction foo(x, _y) {\n    return x + 1;\n}\nfoo();\n\ncaughtErrors\n\nThecaughtErrorsoption is used forcatchblock arguments validation.\n\nIt has two settings:\n\n- all- all named arguments must be used. This is the default setting.\n- none- do not check error objects.\n\ncaughtErrors: all\n\nNot specifying this option is equivalent of assigning it toall.\n\nExamples ofincorrectcode for the{ \"caughtErrors\": \"all\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"all\" }]*/\n\n// 1 error\n// \"err\" is defined but never used\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}\n\ncaughtErrors: none\n\nExamples ofcorrectcode for the{ \"caughtErrors\": \"none\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"none\" }]*/\n\ntry {\n    //...\n} catch (err) {\n    console.error(\"errors\");\n}\n\ncaughtErrorsIgnorePattern\n\nThecaughtErrorsIgnorePatternoption specifies exceptions not to check for usage: catch arguments whose names match a regexp pattern. For example, variables whose names begin with a string ‘ignore’.\n\nExamples ofcorrectcode for the{ \"caughtErrorsIgnorePattern\": \"^ignore\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"caughtErrors\": \"all\", \"caughtErrorsIgnorePattern\": \"^ignore\" }]*/\n\ntry {\n    //...\n} catch (ignoreErr) {\n    console.error(\"errors\");\n}\n\ndestructuredArrayIgnorePattern\n\nThedestructuredArrayIgnorePatternoption specifies exceptions not to check for usage: elements of array destructuring patterns whose names match a regexp pattern. For example, variables whose names begin with an underscore.\n\nExamples ofcorrectcode for the{ \"destructuredArrayIgnorePattern\": \"^_\" }option:\n\n/*eslint no-unused-vars: [\"error\", { \"destructuredArrayIgnorePattern\": \"^_\" }]*/\n\nconst [a, _b, c] = [\"a\", \"b\", \"c\"];\nconsole.log(a+c);\n\nconst { x: [_a, foo] } = bar;\nconsole.log(foo);\n\nfunction baz([_c, x]) {\n    x;\n}\nbaz();\n\nfunction test({p: [_q, r]}) {\n    r;\n}\ntest();\n\nlet _m, n;\nfoo.forEach(item => {\n    [_m, n] = item;\n    console.log(n);\n});\n\nlet _o, p;\n_o = 1;\n[_o, p] = foo;\np;\n\nignoreRestSiblings\n\nTheignoreRestSiblingsoption is a boolean (default:false). Using aRest Propertyit is possible to “omit” properties from an object, but by default the sibling properties are marked as “unused”. With this option enabled the rest property’s siblings are ignored.\n\nExamples ofcorrectcode for the{ \"ignoreRestSiblings\": true }option:\n\n/*eslint no-unused-vars: [\"error\", { \"ignoreRestSiblings\": true }]*/\n\n// 'foo' and 'bar' were ignored because they have a rest property sibling.\nconst { foo, ...rest } = data;\nconsole.log(rest);\n\n// OR\n\nlet bar;\n({ bar, ...rest } = data);\n\nignoreClassWithStaticInitBlock\n\nTheignoreClassWithStaticInitBlockoption is a boolean (default:false). Static initialization blocks allow you to initialize static variables and execute code during the evaluation of a class definition, meaning the static block code is executed without creating a new instance of the class. When set totrue, this option ignores classes containing static initialization blocks.\n\nExamples ofincorrectcode for the{ \"ignoreClassWithStaticInitBlock\": true }option\n\n/*eslint no-unused-vars: [\"error\", { \"ignoreClassWithStaticInitBlock\": true }]*/\n\nclass Foo {\n    static myProperty = \"some string\";\n    static mymethod() {\n        return \"some string\";\n    }\n}\n\nclass Bar {\n    static {\n        let baz; // unused variable\n    }\n}\n\nExamples ofcorrectcode for the{ \"ignoreClassWithStaticInitBlock\": true }option\n\n/*eslint no-unused-vars: [\"error\", { \"ignoreClassWithStaticInitBlock\": true }]*/\n\nclass Foo {\n    static {\n        let bar = \"some string\";\n\n        console.log(bar);\n    }\n}\n\nignoreUsingDeclarations\n\nTheignoreUsingDeclarationsoption is a boolean (default:false). Explicit resource management allows automatic teardown of disposables by callingSymbol.disposeorSymbol.asyncDisposemethod implicitly at the end of the variable’s scope. When this option is set totrue, this rule ignores variables declared withusingorawait using.\n\nExamples ofincorrectcode for the{ \"ignoreUsingDeclarations\": true }option:\n\n/*eslint no-unused-vars: [\"error\", { \"ignoreUsingDeclarations\": true }]*/\nconst resource = getResource();\n\nExamples ofcorrectcode for the{ \"ignoreUsingDeclarations\": true }option:\n\n/*eslint no-unused-vars: [\"error\", { \"ignoreUsingDeclarations\": true }]*/\n\nusing syncResource = getSyncResource();\nawait using asyncResource = getAsyncResource();\n\nreportUsedIgnorePattern\n\nThereportUsedIgnorePatternoption is a boolean (default:false).\nUsing this option will report variables that match any of the valid ignore\npattern options (varsIgnorePattern,argsIgnorePattern,caughtErrorsIgnorePattern, ordestructuredArrayIgnorePattern) if they have been used.\n\nExamples ofincorrectcode for the{ \"reportUsedIgnorePattern\": true }option:\n\n/*eslint no-unused-vars: [\"error\", { \"reportUsedIgnorePattern\": true, \"varsIgnorePattern\": \"[iI]gnored\" }]*/\n\nconst firstVarIgnored = 1;\nconst secondVar = 2;\nconsole.log(firstVarIgnored, secondVar);\n\nExamples ofcorrectcode for the{ \"reportUsedIgnorePattern\": true }option:\n\n/*eslint no-unused-vars: [\"error\", { \"reportUsedIgnorePattern\": true, \"varsIgnorePattern\": \"[iI]gnored\" }]*/\n\nconst firstVar = 1;\nconst secondVar = 2;\nconsole.log(firstVar, secondVar);"
    }
}