{
    "no-self-assign": {
        "description": "Description\n\nThis rule is aimed at eliminating self assignments.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-self-assign: \"error\"*/\n\nfoo = foo;\n\n[a, b] = [a, b];\n\n[a, ...b] = [x, ...b];\n\n({a, b} = {a, x});\n\nfoo &&= foo;\nfoo ||= foo;\nfoo ??= foo;\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-self-assign: \"error\"*/\n\nfoo = bar;\n[a, b] = [b, a];\n\n// This pattern is warned by the `no-use-before-define` rule.\nlet foo = foo;\n\n// The default values have an effect.\n[foo = 1] = [foo];\n\n// non-self-assignments with properties.\nobj.a = obj.b;\nobj.a.b = obj.c.b;\nobj.a.b = obj.a.c;\nobj[a] = obj[\"a\"];\n\n// This ignores if there is a function call.\nobj.a().b = obj.a().b;\na().b = a().b;\n\n// `&=` and `|=` have an effect on non-integers.\nfoo &= foo;\nfoo |= foo;\n\n// Known limitation: this does not support computed properties except single literal or single identifier.\nobj[a + b] = obj[a + b];\nobj[\"a\" + \"b\"] = obj[\"a\" + \"b\"];",
        "option": "This rule has the option to check properties as well.\n\n{\n    \"no-self-assign\": [\"error\", {\"props\": true}]\n}\n\n- props- if this istrue,no-self-assignrule warns self-assignments of properties. Default istrue.\n\nprops\n\nExamples ofcorrectcode with the{ \"props\": false }option:\n\n/*eslint no-self-assign: [\"error\", {\"props\": false}]*/\n\n// self-assignments with properties.\nobj.a = obj.a;\nobj.a.b = obj.a.b;\nobj[\"a\"] = obj[\"a\"];\nobj[a] = obj[a];"
    }
}