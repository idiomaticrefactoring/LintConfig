{
    "require-atomic-updates": {
        "description": "Description\n\nThis rule aims to report assignments to variables or properties in cases where the assignments may be based on outdated values.\n\nVariables\n\nThis rule reports an assignment to a variable when it detects the following execution flow in a generator or async function:\n\n- The variable is read.\n- Ayieldorawaitpauses the function.\n- After the function is resumed, a value is assigned to the variable from step 1.\n\nThe assignment in step 3 is reported because it may be incorrectly resolved because the value of the variable from step 1 may have changed between steps 2 and 3. In particular, if the variable can be accessed from other execution contexts (for example, if it is not a local variable and therefore other functions can change it), the value of the variable may have changed elsewhere while the function was paused in step 2.\n\nNote that the rule does not report the assignment in step 3 in any of the following cases:\n\n- If the variable is read again between steps 2 and 3.\n- If the variable cannot be accessed while the function is paused (for example, if it’s a local variable).\n\nExamples ofincorrectcode for this rule:\n\n/* eslint require-atomic-updates: error */\n\nlet result;\n\nasync function foo() {\n    result += await something;\n}\n\nasync function bar() {\n    result = result + await something;\n}\n\nasync function baz() {\n    result = result + doSomething(await somethingElse);\n}\n\nasync function qux() {\n    if (!result) {\n        result = await initialize();\n    }\n}\n\nfunction* generator() {\n    result += yield;\n}\n\nExamples ofcorrectcode for this rule:\n\n/* eslint require-atomic-updates: error */\n\nlet result;\n\nasync function foobar() {\n    result = await something + result;\n}\n\nasync function baz() {\n    const tmp = doSomething(await somethingElse);\n    result += tmp;\n}\n\nasync function qux() {\n    if (!result) {\n        const tmp = await initialize();\n        if (!result) {\n            result = tmp;\n        }\n    }\n}\n\nasync function quux() {\n    let localVariable = 0;\n    localVariable += await something;\n}\n\nfunction* generator() {\n    result = (yield) + result;\n}\n\nProperties\n\nThis rule reports an assignment to a property through a variable when it detects the following execution flow in a generator or async function:\n\n- The variable or object property is read.\n- Ayieldorawaitpauses the function.\n- After the function is resumed, a value is assigned to a property.\n\nThis logic is similar to the logic for variables, but stricter because the property in step 3 doesn’t have to be the same as the property in step 1. It is assumed that the flow depends on the state of the object as a whole.\n\nExample ofincorrectcode for this rule:\n\n/* eslint require-atomic-updates: error */\n\nasync function foo(obj) {\n    if (!obj.done) {\n        obj.something = await getSomething();\n    }\n}\n\nExample ofcorrectcode for this rule:\n\n/* eslint require-atomic-updates: error */\n\nasync function foo(obj) {\n    if (!obj.done) {\n        const tmp = await getSomething();\n        if (!obj.done) {\n            obj.something = tmp;\n        }\n    }\n}",
        "option": "This rule has an object option:\n\n- \"allowProperties\": When set totrue, the rule does not report assignments to properties. Default isfalse.\n\nallowProperties\n\nExample ofcorrectcode for this rule with the{ \"allowProperties\": true }option:\n\n/* eslint require-atomic-updates: [\"error\", { \"allowProperties\": true }] */\n\nasync function foo(obj) {\n    if (!obj.done) {\n        obj.something = await getSomething();\n    }\n}"
    }
}