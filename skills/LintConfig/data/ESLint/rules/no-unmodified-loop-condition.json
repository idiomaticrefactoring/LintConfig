{
    "no-unmodified-loop-condition": {
        "description": "Description\n\nThis rule finds references which are inside of loop conditions, then checks the\nvariables of those references are modified in the loop.\n\nIf a reference is inside of a binary expression or a ternary expression, this rule checks the result of\nthe expression instead.\nIf a reference is inside of a dynamic expression (e.g.CallExpression,YieldExpression, â€¦), this rule ignores it.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-unmodified-loop-condition: \"error\"*/\n\nlet node = something;\n\nwhile (node) {\n    doSomething(node);\n}\nnode = other;\n\nfor (let j = 0; j < 5;) {\n    doSomething(j);\n}\n\nwhile (node !== root) {\n    doSomething(node);\n}\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-unmodified-loop-condition: \"error\"*/\n\nwhile (node) {\n    doSomething(node);\n    node = node.parent;\n}\n\nfor (let j = 0; j < items.length; ++j) {\n    doSomething(items[j]);\n}\n\n// OK, the result of this binary expression is changed in this loop.\nwhile (node !== root) {\n    doSomething(node);\n    node = node.parent;\n}\n\n// OK, the result of this ternary expression is changed in this loop.\nwhile (node ? A : B) {\n    doSomething(node);\n    node = node.parent;\n}\n\n// A property might be a getter which has side effect...\n// Or \"doSomething\" can modify \"obj.foo\".\nwhile (obj.foo) {\n    doSomething(obj);\n}\n\n// A function call can return various values.\nwhile (check(obj)) {\n    doSomething(obj);\n}",
        "option": "This rule has no options."
    }
}