{
    "no-shadow": {
        "description": "Description\n\nThis rule aims to eliminate shadowed variable declarations.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-shadow: \"error\"*/\n\nconst a = 3;\nfunction b() {\n    const a = 10;\n}\n\nconst c = function () {\n    const a = 10;\n}\n\nfunction d(a) {\n    a = 10;\n}\nd(a);\n\nif (true) {\n    const a = 5;\n}\n\nconst f = wrap(function f() {});\n\nconst C = wrap(class C {});\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-shadow: \"error\"*/\n\nconst a = 3;\nfunction b(c) {\n    const d = 10;\n    if (c) {\n        const e = 20;\n    }\n}\n\n/*\n * Function and class names are allowed to shadow a variable\n * if the function/class expression is assigned to the variable\n * as its initializer or default value.\n */\nconst f = function f() {};\nconst g = foo ? (bar || function g() {}) : baz;\nconst { h = function h() {} } = obj;\nfunction qux(i = function i() {}) {}\nconst C = class C {};",
        "option": "This rule takes one option, an object, with the following properties:\n\n- \"builtinGlobals\"\n- \"hoist\"\n- \"allow\"\n- \"ignoreOnInitialization\"\n- \"ignoreTypeValueShadow\"(TypeScript only)\n- \"ignoreFunctionTypeParameterNameValueShadow\"(TypeScript only)\n\n{\n    \"no-shadow\": [\"error\", { \"builtinGlobals\": false, \"hoist\": \"functions\", \"allow\": [], \"ignoreOnInitialization\": false }]\n}\n\nbuiltinGlobals\n\nThebuiltinGlobalsoption isfalseby default.\nIf it istrue, the rule prevents shadowing of built-in global variables:Object,Array,Number, and so on.\n\nExamples ofincorrectcode for the{ \"builtinGlobals\": true }option:\n\n/*eslint no-shadow: [\"error\", { \"builtinGlobals\": true }]*/\n\nfunction foo() {\n    const Object = 0;\n}\n\nhoist\n\nThehoistoption has five settings:\n\n- functions(by default) - reports shadowing before the outer functions are defined.\n- all- reports all shadowing before the outer variables/functions are defined.\n- never- never report shadowing before the outer variables/functions are defined.\n- types(TypeScript only) - reports shadowing before the outer types are defined.\n- functions-and-types(TypeScript only) - reports shadowing before the outer functions and types are defined.\n\nhoist: functions\n\nExamples ofincorrectcode for the default{ \"hoist\": \"functions\" }option:\n\n/*eslint no-shadow: [\"error\", { \"hoist\": \"functions\" }]*/\n\nif (true) {\n    const b = 6;\n}\n\nfunction b() {}\n\nAlthoughconst bin theifstatement is before thefunctiondeclaration in the outer scope, it is incorrect.\n\nExamples ofcorrectcode for the default{ \"hoist\": \"functions\" }option:\n\n/*eslint no-shadow: [\"error\", { \"hoist\": \"functions\" }]*/\n\nif (true) {\n    const a = 3;\n}\n\nconst a = 5;\n\nBecauseconst ain theifstatement is before thevariabledeclaration in the outer scope, it is correct.\n\nhoist: all\n\nExamples ofincorrectcode for the{ \"hoist\": \"all\" }option:\n\n/*eslint no-shadow: [\"error\", { \"hoist\": \"all\" }]*/\n\nif (true) {\n    const a = 3;\n    const b = 6;\n}\n\nconst a = 5;\nfunction b() {}\n\nhoist: never\n\nExamples ofcorrectcode for the{ \"hoist\": \"never\" }option:\n\n/*eslint no-shadow: [\"error\", { \"hoist\": \"never\" }]*/\n\nif (true) {\n    const a = 3;\n    const b = 6;\n}\n\nconst a = 5;\nfunction b() {}\n\nBecauseconst aandconst bin theifstatement are before the declarations in the outer scope, they are correct.\n\nhoist: types\n\nExamples ofincorrectcode for the{ \"hoist\": \"types\" }option:\n\n/*eslint no-shadow: [\"error\", { \"hoist\": \"types\" }]*/\n\ntype Bar<Foo> = 1;\ntype Foo = 1;\n\nhoist: functions-and-types\n\nExamples ofincorrectcode for the{ \"hoist\": \"functions-and-types\" }option:\n\n/*eslint no-shadow: [\"error\", { \"hoist\": \"functions-and-types\" }]*/\n\n// types\ntype Bar<Foo> = 1;\ntype Foo = 1;\n\n// functions\nif (true) {\n  const b = 6;\n}\n\nfunction b() {}\n\nallow\n\nTheallowoption is an array of identifier names for which shadowing is allowed. For example,\"resolve\",\"reject\",\"done\",\"cb\".\n\nExamples ofcorrectcode for the{ \"allow\": [\"done\"] }option:\n\n/*eslint no-shadow: [\"error\", { \"allow\": [\"done\"] }]*/\n\nimport async from 'async';\n\nfunction foo(done) {\n  async.map([1, 2], function (e, done) {\n    done(null, e * 2)\n  }, done);\n}\n\nfoo(function (err, result) {\n  console.log({ err, result });\n});\n\nignoreOnInitialization\n\nTheignoreOnInitializationoption isfalseby default. If it istrue, it prevents reporting shadowing of variables in their initializers when the shadowed variable is presumably still uninitialized.\n\nThe shadowed variable must be on the left side. The shadowing variable must be on the right side and declared in a callback function or in an IIFE.\n\nExamples ofincorrectcode for the{ \"ignoreOnInitialization\": \"true\" }option:\n\n/*eslint no-shadow: [\"error\", { \"ignoreOnInitialization\": true }]*/\n\nconst x = x => x;\n\nBecause the shadowing variablexwill shadow the already initialized shadowed variablex.\n\nExamples ofcorrectcode for the{ \"ignoreOnInitialization\": true }option:\n\n/*eslint no-shadow: [\"error\", { \"ignoreOnInitialization\": true }]*/\n\nconst x = foo(x => x)\n\nconst y = (y => y)()\n\nThe rationale for callback functions is the assumption that they will be called during the initialization, so that at the time when the shadowing variable will be used, the shadowed variable has not yet been initialized.\n\nignoreTypeValueShadow\n\nWhether to ignore types named the same as a variable. Default:true.\n\nThis is generally safe because you cannot use variables in type locations without a typeof operator, so there’s little risk of confusion.\n\nExamples ofcorrectcode with{ \"ignoreTypeValueShadow\": true }:\n\n/*eslint no-shadow: [\"error\", { \"ignoreTypeValueShadow\": true }]*/\n\ntype Foo = number;\ninterface Bar {\n  prop: number;\n}\n\nfunction f() {\n  const Foo = 1;\n  const Bar = 'test';\n}\n\nNote:Shadowing specifically refers to two identical identifiers that are in different, nested scopes. This is different from redeclaration, which is when two identical identifiers are in the same scope. Redeclaration is covered by theno-redeclarerule instead.\n\nignoreFunctionTypeParameterNameValueShadow\n\nWhether to ignore function parameters named the same as a variable. Default:true.\n\nEach of a function type’s arguments creates a value variable within the scope of the function type. This is done so that you can reference the type later using the typeof operator:\n\ntype Func = (test: string) => typeof test;\n\ndeclare const fn: Func;\nconst result = fn('str'); // typeof result === string\n\nThis means that function type arguments shadow value variable names in parent scopes:\n\nlet test = 1;\ntype TestType = typeof test; // === number\ntype Func = (test: string) => typeof test; // this \"test\" references the argument, not the variable\n\ndeclare const fn: Func;\nconst result = fn('str'); // typeof result === string\n\nIf you do not use thetypeofoperator in a function type return type position, you can safely turn this option on.\n\nExamples ofcorrectcode with{ \"ignoreFunctionTypeParameterNameValueShadow\": true }:\n\n/*eslint no-shadow: [\"error\", { \"ignoreFunctionTypeParameterNameValueShadow\": true }]*/\n\nconst test = 1;\ntype Func = (test: string) => typeof test;\n\nWhy does the rule report on enum members that share the same name as a variable in a parent scope?\n\nThis isn’t a bug — the rule is working exactly as intended! The report is correct because of a lesser-known aspect of enums: enum members introduce a variable within the enum’s own scope, allowing them to be referenced without needing a qualifier.\n\nHere’s a simple example to explain:\n\nconst A = 2;\nenum Test {\n  A = 1,\n  B = A,\n}\n\nconsole.log(Test.B); // what should be logged?\n\nAt first glance, you might think it should log2, because the outer variable A’s value is2. However, it actually logs1, the value ofTest.A. This happens because inside the enumB = Ais treated asB = Test.A. Due to this behavior, the enum member has shadowed the outer variable declaration."
    }
}