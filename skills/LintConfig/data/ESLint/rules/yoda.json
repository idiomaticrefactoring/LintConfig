{
    "yoda": {
        "description": "Description\n\nThis rule aims to enforce consistent style of conditions which compare a variable to a literal value.",
        "option": "This rule can take a string option:\n\n- If it is the default\"never\", then comparisons must never be Yoda conditions.\n- If it is\"always\", then the literal value must always come first.\n\nThe default\"never\"option can have exception options in an object literal:\n\n- If the\"exceptRange\"property istrue, the ruleallowsYoda conditions in range comparisons which are wrapped directly in parentheses, including the parentheses of aniforwhilecondition. The default value isfalse. Arangecomparison tests whether a variable is inside or outside the range between two literal values.\n- If the\"onlyEquality\"property istrue, the rule reports Yoda conditionsonlyfor the equality operators==and===. The default value isfalse.\n\nTheonlyEqualityoption allows a superset of the exceptions whichexceptRangeallows, thus both options are not useful together.\n\nnever\n\nExamples ofincorrectcode for the default\"never\"option:\n\n/*eslint yoda: \"error\"*/\n\nif (\"red\" === color) {\n    // ...\n}\n\nif (`red` === color) {\n    // ...\n}\n\nif (`red` === `${color}`) {\n    // ...\n}\n\nif (true == flag) {\n    // ...\n}\n\nif (5 > count) {\n    // ...\n}\n\nif (-1 < str.indexOf(substr)) {\n    // ...\n}\n\nif (0 <= x && x < 1) {\n    // ...\n}\n\nExamples ofcorrectcode for the default\"never\"option:\n\n/*eslint yoda: \"error\"*/\n\nif (5 & value) {\n    // ...\n}\n\nif (value === \"red\") {\n    // ...\n}\n\nif (value === `red`) {\n    // ...\n}\n\nif (`${value}` === `red`) {\n\n}\n\nexceptRange\n\nExamples ofcorrectcode for the\"never\", { \"exceptRange\": true }options:\n\n/*eslint yoda: [\"error\", \"never\", { \"exceptRange\": true }]*/\n\nfunction isReddish(color) {\n    return (color.hue < 60 || 300 < color.hue);\n}\n\nif (x < -1 || 1 < x) {\n    // ...\n}\n\nif (count < 10 && (0 <= rand && rand < 1)) {\n    // ...\n}\n\nif (`blue` < x && x < `green`) {\n    // ...\n}\n\nfunction howLong(arr) {\n    return (0 <= arr.length && arr.length < 10) ? \"short\" : \"long\";\n}\n\nonlyEquality\n\nExamples ofcorrectcode for the\"never\", { \"onlyEquality\": true }options:\n\n/*eslint yoda: [\"error\", \"never\", { \"onlyEquality\": true }]*/\n\nif (x < -1 || 9 < x) {\n}\n\nif (x !== 'foo' && 'bar' != x) {\n}\n\nif (x !== `foo` && `bar` != x) {\n}\n\nalways\n\nExamples ofincorrectcode for the\"always\"option:\n\n/*eslint yoda: [\"error\", \"always\"]*/\n\nif (color == \"blue\") {\n    // ...\n}\n\nif (color == `blue`) {\n    // ...\n}\n\nExamples ofcorrectcode for the\"always\"option:\n\n/*eslint yoda: [\"error\", \"always\"]*/\n\nif (\"blue\" == value) {\n    // ...\n}\n\nif (`blue` == value) {\n    // ...\n}\n\nif (`blue` == `${value}`) {\n    // ...\n}\n\nif (-1 < str.indexOf(substr)) {\n    // ...\n}"
    }
}