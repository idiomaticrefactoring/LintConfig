{
    "arrow-parens": {
        "description": "Description\n\nThis rule enforces parentheses around arrow function parameters regardless of arity. For example:\n\n// Bad\na => {}\n\n// Good\n(a) => {}\n\nFollowing this style will help you find arrow functions (=>) which may be mistakenly included in a condition\nwhen a comparison such as>=was the intent.\n\n// Bad\nif (a => 2) {\n}\n\n// Good\nif (a >= 2) {\n}\n\nThe rule can also be configured to discourage the use of parens when they are not required:\n\n// Bad\n(a) => {}\n\n// Good\na => {}",
        "option": "This rule has a string option and an object one.\n\nString options are:\n\n- \"always\"(default) requires parens around arguments in all cases.\n- \"as-needed\"enforces no parens where they can be omitted.\n\nObject properties for variants of the\"as-needed\"option:\n\n- \"requireForBlockBody\": truemodifies the as-needed rule in order to require parens if the function body is in an instructions block (surrounded by braces).\n\nalways\n\nExamples ofincorrectcode for this rule with the default\"always\"option:\n\n/*eslint arrow-parens: [\"error\", \"always\"]*/\n\na => {};\na => a;\na => {'\\n'};\na.then(foo => {});\na.then(foo => a);\na(foo => { if (true) {} });\n\nExamples ofcorrectcode for this rule with the default\"always\"option:\n\n/*eslint arrow-parens: [\"error\", \"always\"]*/\n\n() => {};\n(a) => {};\n(a) => a;\n(a) => {'\\n'}\na.then((foo) => {});\na.then((foo) => { if (true) {} });\n\nIf Statements\n\nOne of the benefits of this option is that it prevents the incorrect use of arrow functions in conditionals:\n\nvar a = 1;\nvar b = 2;\n// ...\nif (a => b) {\n console.log('bigger');\n} else {\n console.log('smaller');\n}\n// outputs 'bigger', not smaller as expected\n\nThe contents of theifstatement is an arrow function, not a comparison.\n\nIf the arrow function is intentional, it should be wrapped in parens to remove ambiguity.\n\nvar a = 1;\nvar b = 0;\n// ...\nif ((a) => b) {\n console.log('truthy value returned');\n} else {\n console.log('falsy value returned');\n}\n// outputs 'truthy value returned'\n\nThe following is another example of this behavior:\n\nvar a = 1, b = 2, c = 3, d = 4;\nvar f = a => b ? c: d;\n// f = ?\n\nfis an arrow function which takesaas an argument and returns the result ofb ? c: d.\n\nThis should be rewritten like so:\n\nvar a = 1, b = 2, c = 3, d = 4;\nvar f = (a) => b ? c: d;\n\nas-needed\n\nExamples ofincorrectcode for this rule with the\"as-needed\"option:\n\n/*eslint arrow-parens: [\"error\", \"as-needed\"]*/\n\n(a) => {};\n(a) => a;\n(a) => {'\\n'};\na.then((foo) => {});\na.then((foo) => a);\na((foo) => { if (true) {} });\nconst f = /** @type {number} */(a) => a + a;\nconst g = /* comment */ (a) => a + a;\nconst h = (a) /* comment */ => a + a;\n\nExamples ofcorrectcode for this rule with the\"as-needed\"option:\n\n/*eslint arrow-parens: [\"error\", \"as-needed\"]*/\n\n() => {};\na => {};\na => a;\na => {'\\n'};\na.then(foo => {});\na.then(foo => { if (true) {} });\n(a, b, c) => a;\n(a = 10) => a;\n([a, b]) => a;\n({a, b}) => a;\nconst f = (/** @type {number} */a) => a + a;\nconst g = (/* comment */ a) => a + a;\nconst h = (a /* comment */) => a + a;\n\nrequireForBlockBody\n\nExamples ofincorrectcode for the{ \"requireForBlockBody\": true }option:\n\n/*eslint arrow-parens: [2, \"as-needed\", { \"requireForBlockBody\": true }]*/\n\n(a) => a;\na => {};\na => {'\\n'};\na.map((x) => x * x);\na.map(x => {\n  return x * x;\n});\na.then(foo => {});\n\nExamples ofcorrectcode for the{ \"requireForBlockBody\": true }option:\n\n/*eslint arrow-parens: [2, \"as-needed\", { \"requireForBlockBody\": true }]*/\n\n(a) => {};\n(a) => {'\\n'};\na => ({});\n() => {};\na => a;\na.then((foo) => {});\na.then((foo) => { if (true) {} });\na((foo) => { if (true) {} });\n(a, b, c) => a;\n(a = 10) => a;\n([a, b]) => a;\n({a, b}) => a;"
    }
}