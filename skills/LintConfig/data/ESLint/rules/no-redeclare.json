{
    "no-redeclare": {
        "description": "Description\n\nThis rule is aimed at eliminating variables that have multiple declarations in the same scope.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-redeclare: \"error\"*/\n\nvar a = 3;\nvar a = 10;\n\nclass C {\n    foo() {\n        var b = 3;\n        var b = 10;\n    }\n\n    static {\n        var c = 3;\n        var c = 10;\n    }\n}\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-redeclare: \"error\"*/\n\nvar a = 3;\na = 10;\n\nclass C {\n    foo() {\n        var b = 3;\n        b = 10;\n    }\n\n    static {\n        var c = 3;\n        c = 10;\n    }\n}",
        "option": "This rule takes one optional argument, an object with a boolean property\"builtinGlobals\". It defaults totrue.\nIf set totrue, this rule also checks redeclaration of built-in globals, such asObject,Array,Number…\n\nbuiltinGlobals\n\nThe\"builtinGlobals\"option will check for redeclaration of built-in globals in global scope.\n\nExamples ofincorrectcode for the{ \"builtinGlobals\": true }option:\n\n/*eslint no-redeclare: [\"error\", { \"builtinGlobals\": true }]*/\n\nvar Object = 0;\n\nNote that when usingsourceType: \"commonjs\"(orecmaFeatures.globalReturn, if using the default parser), the top scope of a program is not actually the global scope, but rather a “module” scope. When this is the case, declaring a variable named after a builtin global is not a redeclaration, but rather a shadowing of the global variable. In that case, theno-shadowrule with the\"builtinGlobals\"option should be used."
    }
}