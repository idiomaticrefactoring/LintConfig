{
    "no-implicit-coercion": {
        "description": "Description\n\nThis rule is aimed to flag shorter notations for the type conversion, then suggest a more self-explanatory notation.",
        "option": "This rule has three main options and one override option to allow some coercions as required.\n\n- \"boolean\"(trueby default) - When this istrue, this rule warns shorter type conversions forbooleantype.\n- \"number\"(trueby default) - When this istrue, this rule warns shorter type conversions fornumbertype.\n- \"string\"(trueby default) - When this istrue, this rule warns shorter type conversions forstringtype.\n- \"disallowTemplateShorthand\"(falseby default) - When this istrue, this rule warnsstringtype conversions using${expression}form.\n- \"allow\"(emptyby default) - Each entry in this array can be one of~,!!,+,- -,-, or*that are to be allowed.\n\nNote that operator+inallowlist would allow+foo(number coercion) as well as\"\" + foo(string coercion).\n\nboolean\n\nExamples ofincorrectcode for the default{ \"boolean\": true }option:\n\n/*eslint no-implicit-coercion: \"error\"*/\n\nconst b = !!foo;\nconst b1 = ~foo.indexOf(\".\");\n// bitwise not is incorrect only with `indexOf`/`lastIndexOf` method calling.\n\nExamples ofcorrectcode for the default{ \"boolean\": true }option:\n\n/*eslint no-implicit-coercion: \"error\"*/\n\nconst b = Boolean(foo);\nconst b1 = foo.indexOf(\".\") !== -1;\n\nconst n = ~foo; // This is a just bitwise not.\n\nnumber\n\nExamples ofincorrectcode for the default{ \"number\": true }option:\n\n/*eslint no-implicit-coercion: \"error\"*/\n\nconst n = +foo;\nconst n1 = -(-foo);\nconst n2 = foo - 0;\nconst n3 = 1 * foo;\n\nExamples ofcorrectcode for the default{ \"number\": true }option:\n\n/*eslint no-implicit-coercion: \"error\"*/\n\nconst n = Number(foo);\nconst n1 = parseFloat(foo);\nconst n2 = parseInt(foo, 10);\n\nconst n3 = foo * 1/4; // `* 1` is allowed when followed by the `/` operator\n\nstring\n\nExamples ofincorrectcode for the default{ \"string\": true }option:\n\n/*eslint no-implicit-coercion: \"error\"*/\n\nconst s = \"\" + foo;\nconst s1 = `` + foo;\nfoo += \"\";\nfoo += ``;\n\nExamples ofcorrectcode for the default{ \"string\": true }option:\n\n/*eslint no-implicit-coercion: \"error\"*/\n\nconst s = String(foo);\nfoo = String(foo);\n\ndisallowTemplateShorthand\n\nThis option isnotaffected by thestringoption.\n\nExamples ofincorrectcode for the{ \"disallowTemplateShorthand\": true }option:\n\n/*eslint no-implicit-coercion: [\"error\", { \"disallowTemplateShorthand\": true }]*/\n\nconst s = `${foo}`;\n\nExamples ofcorrectcode for the{ \"disallowTemplateShorthand\": true }option:\n\n/*eslint no-implicit-coercion: [\"error\", { \"disallowTemplateShorthand\": true }]*/\n\nconst s = String(foo);\n\nconst s1 = `a${foo}`;\n\nconst s2 = `${foo}b`;\n\nconst s3 = `${foo}${bar}`;\n\nconst s4 = tag`${foo}`;\n\nExamples ofcorrectcode for the default{ \"disallowTemplateShorthand\": false }option:\n\n/*eslint no-implicit-coercion: [\"error\", { \"disallowTemplateShorthand\": false }]*/\n\nconst s = `${foo}`;\n\nallow\n\nUsingallowlist, we can override and allow specific operators.\n\nExamples ofcorrectcode for the sample{ \"allow\": [\"!!\", \"~\"] }option:\n\n/*eslint no-implicit-coercion: [2, { \"allow\": [\"!!\", \"~\"] } ]*/\n\nconst b = !!foo;\nconst b1 = ~foo.indexOf(\".\");"
    }
}