{
    "no-implicit-globals": {
        "description": "Description\n\nvarandfunctiondeclarations\n\nWhen working with browser scripts, developers often forget that variable and function declarations at the top-level scope become global variables on thewindowobject. As opposed to modules which have their own scope. Globals should be explicitly assigned towindoworselfif that is the intent. Otherwise variables intended to be local to the script should be wrapped in an IIFE.\n\nThis rule disallowsvarandfunctiondeclarations at the top-level script scope. This does not apply to ES and CommonJS modules since they have a module scope.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-implicit-globals: \"error\"*/\n\nvar foo = 1;\n\nfunction bar() {}\n\nExamples ofcorrectcode for this rule:\n\n/*eslint no-implicit-globals: \"error\"*/\n\n// explicitly set on window\nwindow.foo = 1;\nwindow.bar = function() {};\n\n// intended to be scope to this file\n(function() {\n  var foo = 1;\n\n  function bar() {}\n})();\n\nExamples ofcorrectcode for this rule with\"languageOptions\": { \"sourceType\": \"module\" }in the ESLint configuration:\n\n/*eslint no-implicit-globals: \"error\"*/\n\n// foo and bar are local to module\nvar foo = 1;\nfunction bar() {}\n\nGlobal variable leaks\n\nWhen the code is not instrictmode, an assignment to an undeclared variable creates\na new global variable. This will happen even if the code is in a function.\n\nThis does not apply to ES modules since the module code is implicitly instrictmode.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-implicit-globals: \"error\"*/\n\nfoo = 1;\n\nBar.prototype.baz = function () {\n    a = 1; // Intended to be this.a = 1;\n};\n\nRead-only global variables\n\nThis rule also disallows redeclarations of read-only global variables and assignments to read-only global variables.\n\nA read-only global variable can be a built-in ES global (e.g.Array), or a global variable defined asreadonlyin the configuration file or in a/*global */comment.\n\nSee also:Specify Globals\n\nExamples ofincorrectcode for this rule:\n\n/*eslint no-implicit-globals: \"error\"*/\n\n/*global foo:readonly*/\n\nfoo = 1;\n\nArray = [];\nvar Object;\n\nexported\n\nYou can use/* exported variableName */block comments in the same way as inno-unused-vars. See theno-unused-varsexported sectionfor details.\n\nExamples ofcorrectcode for/* exported variableName */operation:\n\n/* eslint no-implicit-globals: error */\n/* exported global_var */\n\nvar global_var = 42;",
        "option": "This rule has an object option with one option:\n\n- Set\"lexicalBindings\"totrueif you want this rule to checkconst,letandclassdeclarations as well.\n\nconst,letandclassdeclarations\n\nLexical declarationsconstandlet, as well asclassdeclarations, create variables that are block-scoped.\n\nHowever, when declared in the top-level of a browser script these variables are not ‘script-scoped’.\nThey are actually created in the global scope and could produce name collisions withvar,constandletvariables andfunctionandclassdeclarations from other scripts.\nThis does not apply to ES and CommonJS  modules.\n\nIf the variable is intended to be local to the script, wrap the code with a block or with an immediately-invoked function expression (IIFE).\n\nExamples ofcorrectcode for this rule with\"lexicalBindings\"option set tofalse(default):\n\n/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": false}]*/\n\nconst foo = 1;\n\nlet baz;\n\nclass Bar {}\n\nExamples ofincorrectcode for this rule with\"lexicalBindings\"option set totrue:\n\n/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\nconst foo = 1;\n\nlet baz;\n\nclass Bar {}\n\nExamples ofcorrectcode for this rule with\"lexicalBindings\"option set totrue:\n\n/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\n{\n    const foo = 1;\n    let baz;\n    class Bar {}\n}\n\n(function() {\n    const foo = 1;\n    let baz;\n    class Bar {}\n}());\n\nIf you intend to create a globalconstorletvariable or a globalclassdeclaration, to be used from other scripts,\nbe aware that there are certain differences when compared to the traditional methods, which arevardeclarations and assigning to a property of the globalwindowobject:\n\n- Lexically declared variables cannot be conditionally created. A script cannot check for the existence of\na variable and then create a new one.varvariables are also always created, but redeclarations do not\ncause runtime exceptions.\n- Lexically declared variables do not create properties on the global object, which is what a consuming script might expect.\n- Lexically declared variables are shadowing properties of the global object, which might produce errors if a\nconsuming script is using both the variable and the property.\n- Lexically declared variables can produce a permanent Temporal Dead Zone (TDZ) if the initialization throws an exception.\nEven thetypeofcheck is not safe from TDZ reference exceptions.\n\nExamples ofincorrectcode for this rule with\"lexicalBindings\"option set totrue:\n\n/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\nconst MyGlobalFunction = (function() {\n    const a = 1;\n    let b = 2;\n    return function() {\n        return a + b;\n    }\n}());\n\nExamples ofcorrectcode for this rule with\"lexicalBindings\"option set totrue:\n\n/*eslint no-implicit-globals: [\"error\", {\"lexicalBindings\": true}]*/\n\nwindow.MyGlobalFunction = (function() {\n    const a = 1;\n    let b = 2;\n    return function() {\n        return a + b;\n    }\n}());"
    }
}