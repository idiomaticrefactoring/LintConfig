{
    "grouped-accessor-pairs": {
        "description": "Description\n\nThis rule requires grouped definitions of accessor functions for the same property in object literals, class declarations and class expressions.\n\nOptionally, this rule can also enforce consistent order (getBeforeSetorsetBeforeGet).\n\nThis rule does not enforce the existence of the pair for a getter or a setter. Seeaccessor-pairsif you also want to enforce getter/setter pairs.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint grouped-accessor-pairs: \"error\"*/\n\nconst foo = {\n    get a() {\n        return this.val;\n    },\n    b: 1,\n    set a(value) {\n        this.val = value;\n    }\n};\n\nconst bar = {\n    set b(value) {\n        this.val = value;\n    },\n    a: 1,\n    get b() {\n        return this.val;\n    }\n}\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    b(){}\n    get a() {\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    b(){}\n    static set a(value) {\n        this.val = value;\n    }\n}\n\nExamples ofcorrectcode for this rule:\n\n/*eslint grouped-accessor-pairs: \"error\"*/\n\nconst foo = {\n    get a() {\n        return this.val;\n    },\n    set a(value) {\n        this.val = value;\n    },\n    b: 1\n};\n\nconst bar = {\n    set b(value) {\n        this.val = value;\n    },\n    get b() {\n        return this.val;\n    },\n    a: 1\n}\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    get a() {\n        return this.val;\n    }\n    b(){}\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n    b(){}\n}",
        "option": "This rule has a primary string and an optional secondary object option.\nThe string option specifies the order:\n\n- \"anyOrder\"(default) does not enforce order.\n- \"getBeforeSet\"if a property has both getter and setter, requires the getter to be defined before the setter.\n- \"setBeforeGet\"if a property has both getter and setter, requires the setter to be defined before the getter.\n\nThe optional object option allows opting-in to check additional object-likes:\n\n- enforceForTSTypes: also check TypeScript types (interfaces and type literals)\n\ngetBeforeSet\n\nExamples ofincorrectcode for this rule with the\"getBeforeSet\"option:\n\n/*eslint grouped-accessor-pairs: [\"error\", \"getBeforeSet\"]*/\n\nconst foo = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    get a() {\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        this.val = value;\n    }\n    static get a() {\n        return this.val;\n    }\n}\n\nExamples ofcorrectcode for this rule with the\"getBeforeSet\"option:\n\n/*eslint grouped-accessor-pairs: [\"error\", \"getBeforeSet\"]*/\n\nconst foo = {\n    get a() {\n        return this.val;\n    },\n    set a(value) {\n        this.val = value;\n    }\n};\n\nclass Foo {\n    get a() {\n        return this.val;\n    }\n    set a(value) {\n        this.val = value;\n    }\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n}\n\nsetBeforeGet\n\nExamples ofincorrectcode for this rule with the\"setBeforeGet\"option:\n\n/*eslint grouped-accessor-pairs: [\"error\", \"setBeforeGet\"]*/\n\nconst foo = {\n    get a() {\n        return this.val;\n    },\n    set a(value) {\n        this.val = value;\n    }\n};\n\nclass Foo {\n    get a() {\n        return this.val;\n    }\n    set a(value) {\n        this.val = value;\n    }\n}\n\nconst Bar = class {\n    static get a() {\n        return this.val;\n    }\n    static set a(value) {\n        this.val = value;\n    }\n}\n\nExamples ofcorrectcode for this rule with the\"setBeforeGet\"option:\n\n/*eslint grouped-accessor-pairs: [\"error\", \"setBeforeGet\"]*/\n\nconst foo = {\n    set a(value) {\n        this.val = value;\n    },\n    get a() {\n        return this.val;\n    }\n};\n\nclass Foo {\n    set a(value) {\n        this.val = value;\n    }\n    get a() {\n        return this.val;\n    }\n}\n\nconst Bar = class {\n    static set a(value) {\n        this.val = value;\n    }\n    static get a() {\n        return this.val;\n    }\n}\n\nenforceForTSTypes\n\nExamples ofincorrectcode for this rule with[\"anyOrder\", { enforceForTSTypes: true }]:\n\n/*eslint grouped-accessor-pairs: [\"error\", \"anyOrder\", { enforceForTSTypes: true }] */\n\ninterface I {\n    get a(): string,\n    between: true,\n    set a(value: string): void\n}\n\ntype T = {\n    get a(): string,\n    between: true,\n    set a(value: string): void\n};\n\nExamples ofcorrectcode for this rule with[\"anyOrder\", { enforceForTSTypes: true }]:\n\n/*eslint grouped-accessor-pairs: [\"error\", \"anyOrder\", { enforceForTSTypes: true }] */\n\ninterface I {\n    get a(): string,\n    set a(value: string): void,\n}\n\ntype T = {\n    set a(value: string): void,\n    get a(): string,\n};"
    }
}