{
    "no-invalid-this": {
        "description": "Description\n\nThis rule aims to flag usage ofthiskeywords in contexts where the value ofthisisundefined.\n\nTop-levelthisin scripts is always considered valid because it refers to the global object regardless of the strict mode.\n\nTop-levelthisin ECMAScript modules is always considered invalid because its value isundefined.\n\nForthisinside functions, this rule basically checks whether or not the function containingthiskeyword is a constructor or a method. Note that arrow functions have lexicalthis, and that therefore this rule checks their enclosing contexts.\n\nThis rule judges from following conditions whether or not the function is a constructor:\n\n- The name of the function starts with uppercase.\n- The function is assigned to a variable which starts with an uppercase letter.\n- The function is a constructor of ES2015 Classes.\n\nThis rule judges from following conditions whether or not the function is a method:\n\n- The function is on an object literal.\n- The function is assigned to a property.\n- The function is a method/getter/setter of ES2015 Classes.\n\nAnd this rule allowsthiskeywords in functions below:\n\n- Thecall/apply/bindmethod of the function is called directly.\n- The function is a callback of array methods (such as.forEach()) ifthisArgis given.\n- The function has@thistag in its JSDoc comment.\n\nAnd this rule always allowsthiskeywords in the following contexts:\n\n- At the top level of scripts.\n- In class field initializers.\n- In class static blocks.\n\nOtherwise are considered problems.\n\nThis rule appliesonlyin strict mode.\nWith\"languageOptions\": { \"sourceType\": \"module\" }in the ESLint configuration, your code is in strict mode even without a\"use strict\"directive.\n\nExamples ofincorrectcode for this rule in strict mode:\n\n/*eslint no-invalid-this: \"error\"*/\n\n\"use strict\";\n\n(function() {\n    this.a = 0;\n    baz(() => this);\n})();\n\nfunction foo() {\n    this.a = 0;\n    baz(() => this);\n}\n\nconst bar = function() {\n    this.a = 0;\n    baz(() => this);\n};\n\nfoo(function() {\n    this.a = 0;\n    baz(() => this);\n});\n\nconst obj = {\n    aaa: function() {\n        return function foo() {\n            // There is in a method `aaa`, but `foo` is not a method.\n            this.a = 0;\n            baz(() => this);\n        };\n    }\n};\n\nfoo.forEach(function() {\n    this.a = 0;\n    baz(() => this);\n});\n\nExamples ofcorrectcode for this rule in strict mode:\n\n/*eslint no-invalid-this: \"error\"*/\n\n\"use strict\";\n\nthis.a = 0;\nbaz(() => this);\n\nfunction Foo() {\n    // OK, this is in a legacy style constructor.\n    this.a = 0;\n    baz(() => this);\n}\n\nclass Bar {\n    constructor() {\n        // OK, this is in a constructor.\n        this.a = 0;\n        baz(() => this);\n    }\n}\n\nconst obj = {\n    foo: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n};\n\nconst obj1 = {\n    foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n};\n\nconst obj2 = {\n    get foo() {\n        // OK, this is in a method (this function is on object literal).\n        return this.a;\n    }\n};\n\nconst obj3 = Object.create(null, {\n    foo: {value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }}\n});\n\nObject.defineProperty(obj, \"foo\", {\n    value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }\n});\n\nObject.defineProperties(obj, {\n    foo: {value: function foo() {\n        // OK, this is in a method (this function is on object literal).\n        this.a = 0;\n    }}\n});\n\nfunction Foo() {\n    this.foo = function foo() {\n        // OK, this is in a method (this function assigns to a property).\n        this.a = 0;\n        baz(() => this);\n    };\n}\n\nobj.foo = function foo() {\n    // OK, this is in a method (this function assigns to a property).\n    this.a = 0;\n};\n\nFoo.prototype.foo = function foo() {\n    // OK, this is in a method (this function assigns to a property).\n    this.a = 0;\n};\n\nclass Baz {\n\n    // OK, this is in a class field initializer.\n    a = this.b;\n\n    // OK, static initializers also have valid this.\n    static a = this.b;\n\n    foo() {\n        // OK, this is in a method.\n        this.a = 0;\n        baz(() => this);\n    }\n\n    static foo() {\n        // OK, this is in a method (static methods also have valid this).\n        this.a = 0;\n        baz(() => this);\n    }\n\n    static {\n        // OK, static blocks also have valid this.\n        this.a = 0;\n        baz(() => this);\n    }\n}\n\nconst bar = (function foo() {\n    // OK, the `bind` method of this function is called directly.\n    this.a = 0;\n}).bind(obj);\n\nfoo.forEach(function() {\n    // OK, `thisArg` of `.forEach()` is given.\n    this.a = 0;\n    baz(() => this);\n}, thisArg);\n\n/** @this Foo */\nfunction foo() {\n    // OK, this function has a `@this` tag in its JSDoc comment.\n    this.a = 0;\n}",
        "option": "This rule has an object option, with one option:\n\n- \"capIsConstructor\": false(defaulttrue) disables the assumption that a function which name starts with an uppercase is a constructor.\n\ncapIsConstructor\n\nBy default, this rule always allows the use ofthisin functions which name starts with an uppercase and anonymous functions that are assigned to a variable which name starts with an uppercase, assuming that those functions are used as constructor functions.\n\nSet\"capIsConstructor\"tofalseif you want those functions to be treated as ‘regular’ functions.\n\nExamples ofincorrectcode for this rule with\"capIsConstructor\"option set tofalse:\n\n/*eslint no-invalid-this: [\"error\", { \"capIsConstructor\": false }]*/\n\n\"use strict\";\n\nfunction Foo() {\n    this.a = 0;\n}\n\nconst bar = function Foo() {\n    this.a = 0;\n}\n\nconst Bar = function() {\n    this.a = 0;\n};\n\nBaz = function() {\n    this.a = 0;\n};\n\nExamples ofcorrectcode for this rule with\"capIsConstructor\"option set tofalse:\n\n/*eslint no-invalid-this: [\"error\", { \"capIsConstructor\": false }]*/\n\n\"use strict\";\n\nobj.Foo = function Foo() {\n    // OK, this is in a method.\n    this.a = 0;\n};\n\nThis rule additionally supports TypeScript type syntax.\n\nExamples ofincorrectTypeScript code for this rule:\n\n/*eslint no-invalid-this: \"error\"*/\n\nfunction foo(bar: string) {\n    this.prop;\n    console.log(bar)\n}\n\n/** @this Obj */\nfoo(function() {\n    console.log(this);\n    z(x => console.log(x, this));\n});\n\nfunction foo() {\n  class C {\n    accessor [this.a] = foo;\n  }\n}\n\nExamples ofcorrectTypeScript code for this rule:\n\n/*eslint no-invalid-this: \"error\"*/\n\ninterface SomeType {\n    prop: string;\n}\n\nfunction foo(this: SomeType) {\n    this.prop;\n}\n\nclass A {\n    a = 5;\n    b = this.a;\n    accessor c = this.a;\n}"
    }
}