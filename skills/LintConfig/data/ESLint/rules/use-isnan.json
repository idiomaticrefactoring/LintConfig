{
    "use-isnan": {
        "description": "Description\n\nThis rule disallows comparisons toNaN.\n\nExamples ofincorrectcode for this rule:\n\n/*eslint use-isnan: \"error\"*/\n\nif (foo == NaN) {\n    // ...\n}\n\nif (foo != NaN) {\n    // ...\n}\n\nif (foo == Number.NaN) {\n    // ...\n}\n\nif (foo != Number.NaN) {\n    // ...\n}\n\nExamples ofcorrectcode for this rule:\n\n/*eslint use-isnan: \"error\"*/\n\nif (isNaN(foo)) {\n    // ...\n}\n\nif (!isNaN(foo)) {\n    // ...\n}",
        "option": "This rule has an object option, with two options:\n\n- \"enforceForSwitchCase\": true(default) additionally disallowscase NaNandswitch(NaN)inswitchstatements.\n- \"enforceForIndexOf\": trueadditionally disallows the use ofindexOfandlastIndexOfmethods withNaN. Default isfalse, meaning that this rule by default does not warn aboutindexOf(NaN)orlastIndexOf(NaN)method calls.\n\nenforceForSwitchCase\n\nTheswitchstatement internally uses the===comparison to match the expressionâ€™s value to a case clause.\nTherefore, it can never matchcase NaN. Also,switch(NaN)can never match a case clause.\n\nExamples ofincorrectcode for this rule with\"enforceForSwitchCase\"option set totrue(default):\n\n/*eslint use-isnan: [\"error\", {\"enforceForSwitchCase\": true}]*/\n\nswitch (foo) {\n    case NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}\n\nswitch (foo) {\n    case Number.NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (Number.NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}\n\nExamples ofcorrectcode for this rule with\"enforceForSwitchCase\"option set totrue(default):\n\n/*eslint use-isnan: [\"error\", {\"enforceForSwitchCase\": true}]*/\n\nif (Number.isNaN(foo)) {\n    bar();\n} else {\n    switch (foo) {\n        case 1:\n            baz();\n            break;\n        // ...\n    }\n}\n\nif (Number.isNaN(a)) {\n    bar();\n} else if (Number.isNaN(b)) {\n    baz();\n} // ...\n\nExamples ofcorrectcode for this rule with\"enforceForSwitchCase\"option set tofalse:\n\n/*eslint use-isnan: [\"error\", {\"enforceForSwitchCase\": false}]*/\n\nswitch (foo) {\n    case NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}\n\nswitch (foo) {\n    case Number.NaN:\n        bar();\n        break;\n    case 1:\n        baz();\n        break;\n    // ...\n}\n\nswitch (Number.NaN) {\n    case a:\n        bar();\n        break;\n    case b:\n        baz();\n        break;\n    // ...\n}\n\nenforceForIndexOf\n\nThe following methods internally use the===comparison to match the given value with an array element:\n\n- Array.prototype.indexOf\n- Array.prototype.lastIndexOf\n\nTherefore, for any arrayfoo,foo.indexOf(NaN)andfoo.lastIndexOf(NaN)will always return-1.\n\nSet\"enforceForIndexOf\"totrueif you want this rule to reportindexOf(NaN)andlastIndexOf(NaN)method calls.\n\nExamples ofincorrectcode for this rule with\"enforceForIndexOf\"option set totrue:\n\n/*eslint use-isnan: [\"error\", {\"enforceForIndexOf\": true}]*/\n\nconst hasNaN = myArray.indexOf(NaN) >= 0;\n\nconst firstIndex = myArray.indexOf(NaN);\n\nconst lastIndex = myArray.lastIndexOf(NaN);\n\nconst indexWithSequenceExpression = myArray.indexOf((doStuff(), NaN));\n\nconst firstIndexFromSecondElement = myArray.indexOf(NaN, 1);\n\nconst lastIndexFromSecondElement = myArray.lastIndexOf(NaN, 1);\n\nExamples ofcorrectcode for this rule with\"enforceForIndexOf\"option set totrue:\n\n/*eslint use-isnan: [\"error\", {\"enforceForIndexOf\": true}]*/\n\nfunction myIsNaN(val) {\n    return typeof val === \"number\" && isNaN(val);\n}\n\nfunction indexOfNaN(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        if (myIsNaN(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nfunction lastIndexOfNaN(arr) {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (myIsNaN(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nconst hasNaN = myArray.some(myIsNaN);\n\nconst hasNaN1 = indexOfNaN(myArray) >= 0;\n\nconst firstIndex = indexOfNaN(myArray);\n\nconst lastIndex = lastIndexOfNaN(myArray);\n\n// ES2015\nconst hasNaN2 = myArray.some(Number.isNaN);\n\n// ES2015\nconst firstIndex1 = myArray.findIndex(Number.isNaN);\n\n// ES2016\nconst hasNaN3 = myArray.includes(NaN);\n\nKnown Limitations\n\nThis option checks methods with the given names,even ifthe object which has the method isnotan array."
    }
}