{
    "prefer-destructuring": {
        "description": "Description\n\nThis rule enforces the use of ES6 destructuring to extract values from arrays and objects in variable declarations and assignment expressions, instead of direct property or index access.",
        "option": "This rule takes two arguments, both of which are objects. The first object parameter determines what types of destructuring the rule applies to.\n\nIn the first object, there are two properties,arrayandobject, that can be used to turn on or off the destructuring requirement for each of those types independently. By default, both aretrue.\n\n{\n  \"rules\": {\n    \"prefer-destructuring\": [\"error\", {\n      \"array\": true,\n      \"object\": true\n    }]\n  }\n}\n\nFor example, the following configuration enforces only object destructuring, but not array destructuring:\n\n{\n  \"rules\": {\n    \"prefer-destructuring\": [\"error\", {\"object\": true, \"array\": false}]\n  }\n}\n\nExamples ofincorrectcode for this rule:\n\n/* eslint prefer-destructuring: \"error\" */\n\n// With `array` enabled\nconst foo = array[0];\nbar.baz = array[0];\n\n// With `object` enabled\nconst qux = object.qux;\nconst quux = object['quux'];\n\nExamples ofcorrectcode for this rule:\n\n/* eslint prefer-destructuring: \"error\" */\n\n// With `array` enabled\nconst [ foo ] = array;\nconst arr = array[someIndex];\n[bar.baz] = array;\n\n\n// With `object` enabled\nconst { baz } = object;\n\nconst obj = object.bar;\n\nlet bar;\n({ bar } = object);\n\nAlternatively, you can use separate configurations for different assignment types. The first argument accepts two other keys instead ofarrayandobject.\n\nOne key isVariableDeclaratorand the other isAssignmentExpression, which can be used to control the destructuring requirement for each of those types independently. Each property is an object containing two properties,arrayandobject, which can be used to control the destructuring requirement for each ofarrayandobjectindependently for variable declarations and assignment expressions.  By default,arrayandobjectare set totruefor bothVariableDeclaratorandAssignmentExpression.\n\n{\n  \"rules\": {\n    \"prefer-destructuring\": [\"error\", {\n      \"VariableDeclarator\": {\n        \"array\": true,\n        \"object\": true\n      },\n      \"AssignmentExpression\": {\n        \"array\": true,\n        \"object\": true\n      }\n    }]\n  }\n}\n\nExamples ofcorrectcode when object destructuring inVariableDeclaratoris enforced:\n\n/* eslint prefer-destructuring: [\"error\", {VariableDeclarator: {object: true}}] */\nconst {bar: foo} = object;\n\nExamples ofcorrectcode when array destructuring inAssignmentExpressionis enforced:\n\n/* eslint prefer-destructuring: [\"error\", {AssignmentExpression: {array: true}}] */\n[bar] = array;\n\nenforceForRenamedProperties\n\nThe rule has a second object argument with a single key,enforceForRenamedProperties, which determines whether theobjectdestructuring applies to renamed variables.\n\n{\n  \"rules\": {\n    \"prefer-destructuring\": [\"error\",\n    {\n      \"object\": true\n    },\n    {\n      \"enforceForRenamedProperties\": true\n    }]\n  }\n}\n\nExamples ofincorrectcode whenenforceForRenamedPropertiesis enabled:\n\n/* eslint \"prefer-destructuring\": [\"error\", { \"object\": true }, { \"enforceForRenamedProperties\": true }] */\nconst foo = object.bar;\n\nExamples ofcorrectcode whenenforceForRenamedPropertiesis enabled:\n\n/* eslint \"prefer-destructuring\": [\"error\", { \"object\": true }, { \"enforceForRenamedProperties\": true }] */\nconst { bar: foo } = object;\n\nExamples of additionalcorrectcode whenenforceForRenamedPropertiesis enabled:\n\n/* eslint \"prefer-destructuring\": [\"error\", { \"object\": true }, { \"enforceForRenamedProperties\": true }] */\nclass C {\n    #x;\n    foo() {\n        const bar = this.#x; // private identifiers are not allowed in destructuring\n    }\n}\n\nNote: It is not possible to determine if a variable will be referring to an object or an array at runtime. This rule therefore guesses the assignment type by checking whether the key being accessed is an integer. This can lead to the following possibly confusing situations:\n\n- Accessing an object property whose key is an integer will fall under the categoryarraydestructuring.\n- Accessing an array element through a computed index will fall under the categoryobjectdestructuring.\n\nThe--fixoption on the command line fixes only problems reported in variable declarations, and among them only those that fall under the categoryobjectdestructuring. Furthermore, the name of the declared variable has to be the same as the name used for non-computed member access in the initializer. For example,const foo = object.foocan be automatically fixed by this rule. Problems that involve computed member access (e.g.,const foo = object[foo]) or renamed properties (e.g.,const foo = object.bar) are not automatically fixed."
    }
}