{
    "no-restricted-syntax": {
        "description": "Description\n\nThis rule disallows specified (that is, user-defined) syntax.",
        "option": "This rule takes a list of strings, where each string is an AST selector:\n\n{\n    \"rules\": {\n        \"no-restricted-syntax\": [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"]\n    }\n}\n\nAlternatively, the rule also accepts objects, where the selector and an optional custom message are specified:\n\n{\n    \"rules\": {\n        \"no-restricted-syntax\": [\n            \"error\",\n            {\n                \"selector\": \"FunctionExpression\",\n                \"message\": \"Function expressions are not allowed.\"\n            },\n            {\n                \"selector\": \"CallExpression[callee.name='setTimeout'][arguments.length!=2]\",\n                \"message\": \"setTimeout must always be invoked with two arguments.\"\n            }\n        ]\n    }\n}\n\nIf a custom message is specified with themessageproperty, ESLint will use that message when reporting occurrences of the syntax specified in theselectorproperty.\n\nThe string and object formats can be freely mixed in the configuration as needed.\n\nExamples ofincorrectcode for this rule with the\"FunctionExpression\", \"WithStatement\", BinaryExpression[operator='in']options:\n\n/* eslint no-restricted-syntax: [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"] */\n\nwith (me) {\n    dontMess();\n}\n\nconst doSomething = function () {};\n\nfoo in bar;\n\nExamples ofcorrectcode for this rule with the\"FunctionExpression\", \"WithStatement\", BinaryExpression[operator='in']options:\n\n/* eslint no-restricted-syntax: [\"error\", \"FunctionExpression\", \"WithStatement\", \"BinaryExpression[operator='in']\"] */\n\nme.dontMess();\n\nfunction doSomething() {};\n\nfoo instanceof bar;"
    }
}