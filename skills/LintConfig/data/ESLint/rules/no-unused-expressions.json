{
    "no-unused-expressions": {
        "description": "Description\n\nThis rule aims to eliminate unused expressions which have no effect on the state of the program.\n\nThis rule does not apply to function calls or constructor calls with thenewoperator, because they could haveside effectson the state of the program.\n\nlet i = 0;\nfunction increment() { i += 1; }\nincrement(); // return value is unused, but i changed as a side effect\n\nlet nThings = 0;\nfunction Thing() { nThings += 1; }\nnew Thing(); // constructed object is unused, but nThings changed as a side effect\n\nThis rule does not apply to directives (which are in the form of literal string expressions such as\"use strict\";at the beginning of a script, module, or function) when using ES5+ environments. In ES3 environments, directives are treated as unused expressions by default, but this behavior can be changed using theignoreDirectivesoption.\n\nSequence expressions (those using a comma, such asa = 1, b = 2) are always considered unused unless their return value is assigned or used in a condition evaluation, or a function call is made with the sequence expression value.",
        "option": "This rule, in its default state, does not require any arguments. If you would like to enable one or more of the following you may pass an object with the options set as follows:\n\n- allowShortCircuitset totruewill allow you to use short circuit evaluations in your expressions (Default:false).\n- allowTernaryset totruewill enable you to use ternary operators in your expressions similarly to short circuit evaluations (Default:false).\n- allowTaggedTemplatesset totruewill enable you to use tagged template literals in your expressions (Default:false).\n- enforceForJSXset totruewill flag unused JSX element expressions (Default:false).\n- ignoreDirectivesset totruewill prevent directives from being reported as unused expressions when linting withecmaVersion: 3(Default:false).\n\nThese options allow unused expressionsonly if allof the code paths either directly change the state (for example, assignment statement) or could haveside effects(for example, function call).\n\nExamples ofincorrectcode for the default{ \"allowShortCircuit\": false, \"allowTernary\": false }options:\n\n/*eslint no-unused-expressions: \"error\"*/\n\n0\n\nif(0) 0\n\n{0}\n\nf(0), {}\n\na && b()\n\na, b()\n\nc = a, b;\n\na() && function namedFunctionInExpressionContext () {f();}\n\n(function anIncompleteIIFE () {});\n\ninjectGlobal`body{ color: red; }`\n\nExamples ofcorrectcode for the default{ \"allowShortCircuit\": false, \"allowTernary\": false }options:\n\n/*eslint no-unused-expressions: \"error\"*/\n\n{} // In this context, this is a block statement, not an object literal\n\n{ myLabel: foo() } // In this context, this is a block statement with a label and expression, not an object literal\n\nfunction namedFunctionDeclaration () {}\n\n(function aGenuineIIFE () {}());\n\nf()\n\na = 0\n\nnew C\n\ndelete a.b\n\nvoid a\n\nNote that one or more string expression statements (with or without semi-colons) will only be considered as unused if they are not in the beginning of a script, module, or function (alone and uninterrupted by other statements). Otherwise, they will be treated as part of a “directive prologue”, a section potentially usable by JavaScript engines. This includes “strict mode” directives.\n\nExamples ofcorrectcode for this rule in regard to directives:\n\n/*eslint no-unused-expressions: \"error\"*/\n\n\"use strict\";\n\"use asm\"\n\"use stricter\";\n\"use babel\"\n\"any other strings like this in the directive prologue\";\n\"this is still the directive prologue\";\n\nfunction foo() {\n    \"bar\";\n}\n\nclass Foo {\n    someMethod() {\n        \"use strict\";\n    }\n}\n\nExamples ofincorrectcode for this rule in regard to directives:\n\n/*eslint no-unused-expressions: \"error\"*/\n\ndoSomething();\n\"use strict\"; // this isn't in a directive prologue, because there is a non-directive statement before it\n\nfunction foo() {\n    \"bar\" + 1;\n}\n\nclass Foo {\n    static {\n        \"use strict\"; // class static blocks do not have directive prologues\n    }\n}\n\nallowShortCircuit\n\nExamples ofincorrectcode for the{ \"allowShortCircuit\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }]*/\n\na || b\n\nExamples ofcorrectcode for the{ \"allowShortCircuit\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true }]*/\n\na && b()\na() || (b = c)\n\nallowTernary\n\nExamples ofincorrectcode for the{ \"allowTernary\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowTernary\": true }]*/\n\na ? b : 0\na ? b : c()\n\nExamples ofcorrectcode for the{ \"allowTernary\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowTernary\": true }]*/\n\na ? b() : c()\na ? (b = c) : d()\n\nallowShortCircuit and allowTernary\n\nExamples ofcorrectcode for the{ \"allowShortCircuit\": true, \"allowTernary\": true }options:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowShortCircuit\": true, \"allowTernary\": true }]*/\n\na ? b() || (c = d) : e()\n\nallowTaggedTemplates\n\nExamples ofincorrectcode for the{ \"allowTaggedTemplates\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowTaggedTemplates\": true }]*/\n\n`some untagged template string`;\n\nExamples ofcorrectcode for the{ \"allowTaggedTemplates\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"allowTaggedTemplates\": true }]*/\n\ntag`some tagged template string`;\n\nenforceForJSX\n\nJSX is most-commonly used in the React ecosystem, where it is compiled toReact.createElementexpressions. Though free from side-effects, these calls are not automatically flagged by theno-unused-expressionrule. If you’re using React, or any other side-effect-free JSX pragma, this option can be enabled to flag these expressions.\n\nExamples ofincorrectcode for the{ \"enforceForJSX\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"enforceForJSX\": true }]*/\n\n<MyComponent />;\n\n<></>;\n\nExamples ofcorrectcode for the{ \"enforceForJSX\": true }option:\n\n/*eslint no-unused-expressions: [\"error\", { \"enforceForJSX\": true }]*/\n\nconst myComponentPartial = <MyComponent />;\n\nconst myFragment = <></>;\n\nignoreDirectives\n\nWhen set tofalse(default), this rule reports directives (like\"use strict\") as unused expressions when linting withecmaVersion: 3. This default behavior exists because ES3 environments do not formally support directives, meaning such strings are effectively unused expressions in that specific context.\n\nSet this option totrueto prevent directives from being reported as unused, even whenecmaVersion: 3is specified. This option is primarily useful for projects that need to maintain a single codebase containing directives while supporting both older ES3 environments and modern (ES5+) environments.\n\nNote:In ES5+ environments, directives are always ignored regardless of this setting.\n\nExamples ofincorrectcode for the{ \"ignoreDirectives\": false }option andecmaVersion: 3:\n\n/*eslint no-unused-expressions: [\"error\", { \"ignoreDirectives\": false }]*/\n\n\"use strict\";\n\"use asm\"\n\"use stricter\";\n\"use babel\"\n\"any other strings like this in the directive prologue\";\n\"this is still the directive prologue\";\n\nfunction foo() {\n    \"bar\";\n}\n\nExamples ofcorrectcode for the{ \"ignoreDirectives\": true }option andecmaVersion: 3:\n\n/*eslint no-unused-expressions: [\"error\", { \"ignoreDirectives\": true }]*/\n\n\"use strict\";\n\"use asm\"\n\"use stricter\";\n\"use babel\"\n\"any other strings like this in the directive prologue\";\n\"this is still the directive prologue\";\n\nfunction foo() {\n    \"bar\";\n}\n\nTypeScript Support\n\nThis rule supports TypeScript-specific expressions and follows these guidelines:\n\n- Directives (like'use strict') are allowed in module and namespace declarations\n- Type-related expressions are treated as unused if their wrapped value expressions are unused:Type assertions (x as number,<number>x)Non-null assertions (x!)Type instantiations (Set<number>)\n- Type assertions (x as number,<number>x)\n- Non-null assertions (x!)\n- Type instantiations (Set<number>)\n\nNote: Although type expressions never have runtime side effects (e.g.,x!is equivalent toxat runtime), they can be used to assert types for testing purposes.\n\nExamples ofcorrectcode for this rule when using TypeScript:\n\n/* eslint no-unused-expressions: \"error\" */\n\n// Type expressions wrapping function calls are allowed\nfunction getSet() {\n    return Set;\n}\ngetSet()<number>;\ngetSet() as Set<unknown>;\ngetSet()!;\n\n// Directives in modules and namespaces\nmodule Foo {\n    'use strict';\n    'hello world';\n}\n\nnamespace Bar {\n    'use strict';\n    export class Baz {}\n}\n\nExamples ofincorrectcode for this rule when using TypeScript:\n\n/* eslint no-unused-expressions: \"error\" */\n\n// Standalone type expressions\nSet<number>;\n1 as number;\nwindow!;\n\n// Expressions inside namespaces\nnamespace Bar {\n    123;\n}"
    }
}