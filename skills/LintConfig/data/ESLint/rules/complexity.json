{
    "complexity": {
        "description": "Description\n\nThis rule is aimed at reducing code complexity by capping the amount of cyclomatic complexity allowed in a program. As such, it will warn when the cyclomatic complexity crosses the configured threshold (default is20).\n\nExamples ofincorrectcode for a maximum of2:\n\n/*eslint complexity: [\"error\", 2]*/\n\nfunction a(x) {\n    if (true) {\n        return x;\n    } else if (false) {\n        return x+1;\n    } else {\n        return 4; // 3rd path\n    }\n}\n\nfunction b() {\n    foo ||= 1;\n    bar &&= 1;\n}\n\nfunction c(a = {}) { // default parameter -> 2nd path\n    const { b = 'default' } = a; // default value during destructuring -> 3rd path\n}\n\nfunction d(a) {\n    return a?.b?.c; // optional chaining with two optional properties creates two additional branches\n}\n\nExamples ofcorrectcode for a maximum of2:\n\n/*eslint complexity: [\"error\", 2]*/\n\nfunction a(x) {\n    if (true) {\n        return x;\n    } else {\n        return 4;\n    }\n}\n\nfunction b() {\n    foo ||= 1;\n}\n\nClass field initializers and class static blocks are implicit functions. Therefore, their complexity is calculated separately for each initializer and each static block, and it doesnâ€™t contribute to the complexity of the enclosing code.\n\nExamples of additionalincorrectcode for a maximum of2:\n\n/*eslint complexity: [\"error\", 2]*/\n\nclass C {\n    x = a || b || c; // this initializer has complexity = 3\n}\n\nclass D { // this static block has complexity = 3\n    static {\n        if (foo) {\n            bar = baz || qux;\n        }\n    }\n}\n\nExamples of additionalcorrectcode for a maximum of2:\n\n/*eslint complexity: [\"error\", 2]*/\n\nfunction foo() { // this function has complexity = 1\n    class C {\n        x = a + b; // this initializer has complexity = 1\n        y = c || d; // this initializer has complexity = 2\n        z = e && f; // this initializer has complexity = 2\n\n        static p = g || h; // this initializer has complexity = 2\n        static q = i ? j : k; // this initializer has complexity = 2\n\n        static { // this static block has complexity = 2\n            if (foo) {\n                baz = bar;\n            }\n        }\n\n        static { // this static block has complexity = 2\n            qux = baz || quux;\n        }\n    }\n}",
        "option": "This rule has a number or object option:\n\n- \"max\"(default:20) enforces a maximum complexity\n- \"variant\": \"classic\" | \"modified\"(default:\"classic\") cyclomatic complexity variant to use\n\nmax\n\nCustomize the threshold with themaxproperty.\n\n\"complexity\": [\"error\", { \"max\": 2 }]\n\nDeprecated:the object propertymaximumis deprecated. Please use the propertymaxinstead.\n\nOr use the shorthand syntax:\n\n\"complexity\": [\"error\", 2]\n\nvariant\n\nCyclomatic complexity variant to use:\n\n- \"classic\"(default) - Classic McCabe cyclomatic complexity\n- \"modified\"- Modified cyclomatic complexity\n\nModified cyclomatic complexityis the same as the classic cyclomatic complexity, but eachswitchstatement only increases the complexity value by1, regardless of how manycasestatements it contains.\n\nExamples ofcorrectcode for this rule with the{ \"max\": 3, \"variant\": \"modified\" }option:\n\n/*eslint complexity: [\"error\", {\"max\": 3, \"variant\": \"modified\"}]*/\n\nfunction a(x) {     // initial modified complexity is 1\n    switch (x) {    // switch statement increases modified complexity by 1\n        case 1:\n            1;\n            break;\n        case 2:\n            2;\n            break;\n        case 3:\n            if (x === 'foo') {  // if block increases modified complexity by 1\n                3;\n            }\n            break;\n        default:\n            4;\n    }\n}\n\nThe classic cyclomatic complexity of the above function is5, but the modified cyclomatic complexity is only3."
    }
}