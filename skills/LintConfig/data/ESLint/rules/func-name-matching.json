{
    "func-name-matching": {
        "description": "Description\n\nThis rule requires function names to match the name of the variable or property to which they are assigned. The rule will ignore property assignments where the property name is a literal that is not a valid identifier in the ECMAScript version specified in your configuration (default ES5).\n\nExamples ofincorrectcode for this rule:\n\n/*eslint func-name-matching: \"error\"*/\n\nlet foo = function bar() {};\nfoo = function bar() {};\nconst obj = {foo: function bar() {}};\nobj.foo = function bar() {};\nobj['foo'] = function bar() {};\n({['foo']: function bar() {}});\n\nclass C {\n    foo = function bar() {};\n}\n\n/*eslint func-name-matching: [\"error\", \"never\"] */\n\nlet foo = function foo() {};\nfoo = function foo() {};\nconst obj = {foo: function foo() {}};\nobj.foo = function foo() {};\nobj['foo'] = function foo() {};\n({['foo']: function foo() {}});\n\nclass C {\n    foo = function foo() {};\n}\n\nExamples ofcorrectcode for this rule:\n\n/*eslint func-name-matching: \"error\"*/\n// equivalent to /*eslint func-name-matching: [\"error\", \"always\"]*/\n\nconst foo = function foo() {};\nconst foo1 = function() {};\nconst foo2 = () => {};\nfoo = function foo() {};\n\nconst obj = {foo: function foo() {}};\nobj.foo = function foo() {};\nobj['foo'] = function foo() {};\nobj['foo//bar'] = function foo() {};\nobj[foo] = function bar() {};\n\nconst obj1 = {[foo]: function bar() {}};\nconst obj2 = {'foo//bar': function foo() {}};\nconst obj3 = {foo: function() {}};\n\nobj['x' + 2] = function bar(){};\nconst [ bar ] = [ function bar(){} ];\n({[foo]: function bar() {}})\n\nclass C {\n    foo = function foo() {};\n    baz = function() {};\n}\n\n// private names are ignored\nclass D {\n    #foo = function foo() {};\n    #bar = function foo() {};\n    baz() {\n        this.#foo = function foo() {};\n        this.#foo = function bar() {};\n    }\n}\n\nmodule.exports = function foo(name) {};\nmodule['exports'] = function foo(name) {};\n\n/*eslint func-name-matching: [\"error\", \"never\"] */\n\nlet foo = function bar() {};\nconst foo1 = function() {};\nconst foo2 = () => {};\nfoo = function bar() {};\n\nconst obj = {foo: function bar() {}};\nobj.foo = function bar() {};\nobj['foo'] = function bar() {};\nobj['foo//bar'] = function foo() {};\nobj[foo] = function foo() {};\n\nconst obj1 = {foo: function bar() {}};\nconst obj2 = {[foo]: function foo() {}};\nconst obj3 = {'foo//bar': function foo() {}};\nconst obj4 = {foo: function() {}};\n\nobj['x' + 2] = function bar(){};\nconst [ bar ] = [ function bar(){} ];\n({[foo]: function bar() {}})\n\nclass C {\n    foo = function bar() {};\n    baz = function() {};\n}\n\n// private names are ignored\nclass D {\n    #foo = function foo() {};\n    #bar = function foo() {};\n    baz() {\n        this.#foo = function foo() {};\n        this.#foo = function bar() {};\n    }\n}\n\nmodule.exports = function foo(name) {};\nmodule['exports'] = function foo(name) {};",
        "option": "This rule takes an optional string of\"always\"or\"never\"(when omitted, it defaults to\"always\"), and an optional options object with two propertiesconsiderPropertyDescriptorandincludeCommonJSModuleExports.\n\nconsiderPropertyDescriptor\n\nA boolean value that defaults tofalse. IfconsiderPropertyDescriptoris set to true, the check will take into account the use ofObject.create,Object.defineProperty,Object.defineProperties, andReflect.defineProperty.\n\nExamples ofcorrectcode for the{ considerPropertyDescriptor: true }option:\n\n/*eslint func-name-matching: [\"error\", { \"considerPropertyDescriptor\": true }]*/\n// equivalent to /*eslint func-name-matching: [\"error\", \"always\", { \"considerPropertyDescriptor\": true }]*/\nconst obj = {};\nObject.create(obj, {foo:{value: function foo() {}}});\nObject.defineProperty(obj, 'bar', {value: function bar() {}});\nObject.defineProperties(obj, {baz:{value: function baz() {} }});\nReflect.defineProperty(obj, 'foo', {value: function foo() {}});\n\nExamples ofincorrectcode for the{ considerPropertyDescriptor: true }option:\n\n/*eslint func-name-matching: [\"error\", { \"considerPropertyDescriptor\": true }]*/\n// equivalent to /*eslint func-name-matching: [\"error\", \"always\", { \"considerPropertyDescriptor\": true }]*/\nconst obj = {};\nObject.create(obj, {foo:{value: function bar() {}}});\nObject.defineProperty(obj, 'bar', {value: function baz() {}});\nObject.defineProperties(obj, {baz:{value: function foo() {} }});\nReflect.defineProperty(obj, 'foo', {value: function value() {}});\n\nincludeCommonJSModuleExports\n\nA boolean value that defaults tofalse. IfincludeCommonJSModuleExportsis set to true,module.exportsandmodule[\"exports\"]will be checked by this rule.\n\nExamples ofincorrectcode for the{ includeCommonJSModuleExports: true }option:\n\n/*eslint func-name-matching: [\"error\", { \"includeCommonJSModuleExports\": true }]*/\n// equivalent to /*eslint func-name-matching: [\"error\", \"always\", { \"includeCommonJSModuleExports\": true }]*/\n\nmodule.exports = function foo(name) {};\nmodule['exports'] = function foo(name) {};"
    }
}