{
  "name": "no-unused-expressions",
  "meta": {
    "description": "Disallow unused expressions",
    "url": "https://eslint.org/docs/latest/rules/no-unused-expressions",
    "type": "",
    "status": {
      "deprecated": false,
      "removed": false,
      "frozen": false
    },
    "capabilities": {
      "recommended": false,
      "fixable": false,
      "has_suggestions": false
    }
  },
  "content": {
    "introduction": "Disallow unused expressions\nTable of ContentsRule DetailsOptionsallowShortCircuitallowTernaryallowShortCircuit and allowTernaryallowTaggedTemplatesenforceForJSXignoreDirectivesTypeScript SupportVersionResources\nAn unused expression which has no effect on the state of the program indicates a logic error.\nFor example,n + 1;is not a syntax error, but it might be a typing mistake where a programmer meant an assignment statementn += 1;instead. Sometimes, such unused expressions may be eliminated by some build tools in production environment, which possibly breaks application logic.",
    "sub_configuration_introduction": "This rule, in its default state, does not require any arguments. If you would like to enable one or more of the following you may pass an object with the options set as follows:\nallowShortCircuitset totruewill allow you to use short circuit evaluations in your expressions (Default:false).allowTernaryset totruewill enable you to use ternary operators in your expressions similarly to short circuit evaluations (Default:false).allowTaggedTemplatesset totruewill enable you to use tagged template literals in your expressions (Default:false).enforceForJSXset totruewill flag unused JSX element expressions (Default:false).ignoreDirectivesset totruewill prevent directives from being reported as unused expressions when linting withecmaVersion: 3(Default:false).\nThese options allow unused expressionsonly if allof the code paths either directly change the state (for example, assignment statement) or could haveside effects(for example, function call).\nExamples ofincorrectcode for the default{ \"allowShortCircuit\": false, \"allowTernary\": false }options:\nExamples ofcorrectcode for the default{ \"allowShortCircuit\": false, \"allowTernary\": false }options:\nNote that one or more string expression statements (with or without semi-colons) will only be considered as unused if they are not in the beginning of a script, module, or function (alone and uninterrupted by other statements). Otherwise, they will be treated as part of a “directive prologue”, a section potentially usable by JavaScript engines. This includes “strict mode” directives.\nExamples ofcorrectcode for this rule in regard to directives:\nExamples ofincorrectcode for this rule in regard to directives:\nExamples ofincorrectcode for the{ \"allowShortCircuit\": true }option:\nExamples ofcorrectcode for the{ \"allowShortCircuit\": true }option:\nExamples ofincorrectcode for the{ \"allowTernary\": true }option:\nExamples ofcorrectcode for the{ \"allowTernary\": true }option:\nExamples ofcorrectcode for the{ \"allowShortCircuit\": true, \"allowTernary\": true }options:\nExamples ofincorrectcode for the{ \"allowTaggedTemplates\": true }option:\nExamples ofcorrectcode for the{ \"allowTaggedTemplates\": true }option:\nJSX is most-commonly used in the React ecosystem, where it is compiled toReact.createElementexpressions. Though free from side-effects, these calls are not automatically flagged by theno-unused-expressionrule. If you’re using React, or any other side-effect-free JSX pragma, this option can be enabled to flag these expressions.\nExamples ofincorrectcode for the{ \"enforceForJSX\": true }option:\nExamples ofcorrectcode for the{ \"enforceForJSX\": true }option:\nWhen set tofalse(default), this rule reports directives (like\"use strict\") as unused expressions when linting withecmaVersion: 3. This default behavior exists because ES3 environments do not formally support directives, meaning such strings are effectively unused expressions in that specific context.\nSet this option totrueto prevent directives from being reported as unused, even whenecmaVersion: 3is specified. This option is primarily useful for projects that need to maintain a single codebase containing directives while supporting both older ES3 environments and modern (ES5+) environments.\nNote:In ES5+ environments, directives are always ignored regardless of this setting.\nExamples ofincorrectcode for the{ \"ignoreDirectives\": false }option andecmaVersion: 3:\nExamples ofcorrectcode for the{ \"ignoreDirectives\": true }option andecmaVersion: 3:\nThis rule supports TypeScript-specific expressions and follows these guidelines:\nDirectives (like'use strict') are allowed in module and namespace declarationsType-related expressions are treated as unused if their wrapped value expressions are unused:Type assertions (x as number,<number>x)Non-null assertions (x!)Type instantiations (Set<number>)\nNote: Although type expressions never have runtime side effects (e.g.,x!is equivalent toxat runtime), they can be used to assert types for testing purposes.\nExamples ofcorrectcode for this rule when using TypeScript:\nExamples ofincorrectcode for this rule when using TypeScript:",
    "config_examples": []
  }
}