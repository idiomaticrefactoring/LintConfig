{
  "name": "no-restricted-imports",
  "meta": {
    "description": "Disallow specified modules when loaded by import",
    "url": "https://eslint.org/docs/latest/rules/no-restricted-imports",
    "type": "",
    "status": {
      "deprecated": false,
      "removed": false,
      "frozen": false
    },
    "capabilities": {
      "recommended": false,
      "fixable": false,
      "has_suggestions": false
    }
  },
  "content": {
    "introduction": "Disallow specified modules when loaded byimport\nTable of ContentsRule DetailsOptionspathsimportNamesallowImportNamesallowTypeImports (TypeScript only)patternsgroupregexcaseSensitiveimportNamesallowImportNamesimportNamePatternallowImportNamePatternallowTypeImports (TypeScript only)Known LimitationsWhen Not To Use ItVersionResources\nImports are an ES6/ES2015 standard for making the functionality of other modules available in your current module. In CommonJS this is implemented through therequire()call which makes this ESLint rule roughly equivalent to its CommonJS counterpartno-restricted-modules.\nWhy would you want to restrict imports?\nSome imports might not make sense in a particular environment. For example, Node.js’fsmodule would not make sense in an environment that didn’t have a file system.Some modules provide similar or identical functionality, thinklodashandunderscore. Your project may have standardized on a module. You want to make sure that the other alternatives are not being used as this would unnecessarily bloat the project and provide a higher maintenance cost of two dependencies when one would suffice.",
    "sub_configuration_introduction": "This rule has both string and object options to specify the imported modules to restrict.\nUsing string option, you can specify  the name of a module that you want to restrict from being imported as a value in the rule options array:\nExamples ofincorrectcode for string option:\nString options also restrict the module from being exported, as in this example:\nExamples ofcorrectcode for string option:\nYou may also specify a custom message for a particular module using thenameandmessageproperties inside an object, where the value of thenameis the name of the module andmessageproperty contains the custom message. (The custom message is appended to the default error message from the rule.)\nExamples ofincorrectcode for string option:\nThis is an object option whose value is an array containing the names of the modules you want to restrict.\nExamples ofincorrectcode forpaths:\nCustom messages for a particular module can also be specified inpathsarray using objects withnameandmessage.\nThis option inpathsis an array and can be used to specify the names of certain bindings exported from a module. Import names specified insidepathsarray affect the module specified in thenameproperty of corresponding object, so it is required to specify thenameproperty first when you are usingimportNamesormessageoption.\nSpecifying\"default\"string inside theimportNamesarray will restrict the default export from being imported.\nExamples ofincorrectcode whenimportNamesinpathshas\"default\":\nExamples ofincorrectcode forimportNamesinpaths:\nExamples ofcorrectcode forimportNamesinpaths:\nIf the local name assigned to a default export is the same as a string inimportNames, this will not cause an error.\nThis option is an array. Inverse ofimportNames,allowImportNamesallows the imports that are specified inside this array. So it restricts all imports from a module, except specified allowed ones.\nNote:allowImportNamescannot be used in combination withimportNames.\nExamples ofincorrectcode forallowImportNamesinpaths:\nDisallowing all import names except ‘AllowedObject’.\nExamples ofcorrectcode forallowImportNamesinpaths:\nDisallowing all import names except ‘AllowedObject’.\nWhether to allowType-Only Importsfor a path. This includes type-onlyexportstatements, as they are equivalent to re-exporting animport. Default:false.\nExamples ofincorrectcode forallowTypeImportsinpaths:\nExamples ofcorrectcode forallowTypeImportsinpaths:\nThis is also an object option whose value is an array. This option allows you to specify multiple modules to restrict usinggitignore-style patterns or regular expressions.\nWherepathsoption takes exact import paths,patternsoption can be used to specify the import paths with more flexibility, allowing for the restriction of multiple modules within the same directory. For example:\nThis configuration restricts import of theimport-foomodule but wouldn’t restrict the import ofimport-foo/barorimport-foo/baz. You can usepatternsto restrict both:\nThis configuration restricts imports not just fromimport-foousingpath, but alsoimport-foo/barandimport-foo/bazusingpatterns.\nTo re-include a module when usinggitignore-style patterns, add a negation (!) mark before the pattern. (Make sure these negated patterns are placed last in the array, as order matters)\nYou can also use regular expressions to restrict modules (see theregexoption).\nExamples ofincorrectcode forpatternsoption:\nIn this example,\"!import1/private/*\"is not reincluding the modules insideprivatebecause the negation mark (!) does not reinclude the files if it’s parent directory is excluded by a pattern. In this case,import1/privatedirectory is already excluded by theimport1/*pattern. (The excluded directory can be reincluded using\"!import1/private\".)\nExamples ofcorrectcode forpatternsoption:\nThepatternsarray can also include objects. Thegroupproperty is used to specify thegitignore-style patterns for restricting modules and themessageproperty is used to specify a custom message.\nEither of thegrouporregexproperties is required when using thepatternsoption.\nExamples ofincorrectcode forgroupoption:\nExamples ofcorrectcode for thisgroupoption:\nTheregexproperty is used to specify the regex patterns for restricting modules.\nNote:regexcannot be used in combination withgroup.\nExamples ofincorrectcode forregexoption:\nExamples ofcorrectcode forregexoption:\nThis is a boolean option and sets the patterns specified in thegrouporregexproperties to be case-sensitive whentrue. Default isfalse.\nExamples ofincorrectcode forcaseSensitive: trueoption:\nExamples ofcorrectcode forcaseSensitive: trueoption:\nYou can also specifyimportNameswithin objects inside thepatternsarray. In this case, the specified names apply only to the associatedgrouporregexproperty.\nExamples ofincorrectcode forimportNamesinpatterns:\nExamples ofcorrectcode forimportNamesinpatterns:\nYou can also specifyallowImportNameswithin objects inside thepatternsarray. In this case, the specified names apply only to the associatedgrouporregexproperty.\nNote:allowImportNamescannot be used in combination withimportNames,importNamePatternorallowImportNamePattern.\nExamples ofincorrectcode forallowImportNamesinpatterns:\nExamples ofcorrectcode forallowImportNamesinpatterns:\nThis option allows you to use regex patterns to restrict import names:\nExamples ofincorrectcode forimportNamePatternoption:\nExamples ofcorrectcode forimportNamePatternoption:\nYou can also use this option to allow only side-effect imports by setting it to a pattern that matches any name, such as^.\nExamples ofincorrectcode forimportNamePatternoption:\nExamples ofcorrectcode forimportNamePatternoption:\nThis is a string option. Inverse ofimportNamePattern, this option allows imports that matches the specified regex pattern. So it restricts all imports from a module, except specified allowed patterns.\nNote:allowImportNamePatterncannot be used in combination withimportNames,importNamePatternorallowImportNames.\nExamples ofincorrectcode forallowImportNamePatternoption:\nExamples ofcorrectcode forallowImportNamePatternoption:\nWhether to allowType-Only Importsfor a path. This includes type-onlyexportstatements, as they are equivalent to re-exporting animport. Default:false.\nExamples ofincorrectcode forallowTypeImportsinpatterns:\nExamples ofcorrectcode forallowTypeImportsinpatterns:",
    "config_examples": []
  }
}