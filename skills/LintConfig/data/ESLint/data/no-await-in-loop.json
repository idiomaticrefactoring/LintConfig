{
  "name": "no-await-in-loop",
  "meta": {
    "description": "Disallow await inside of loops",
    "url": "https://eslint.org/docs/latest/rules/no-await-in-loop",
    "type": "",
    "status": {
      "deprecated": false,
      "removed": false,
      "frozen": false
    },
    "capabilities": {
      "recommended": false,
      "fixable": false,
      "has_suggestions": false
    }
  },
  "content": {
    "introduction": "Disallowawaitinside of loops\nTable of ContentsRule DetailsExamplesWhen Not To Use ItVersionResources\nPerforming an operation on each element of an iterable is a common task. However, performing anawaitas part of each operation may indicate that the program is not taking full advantage of\nthe parallelization benefits ofasync/await.\nOften, the code can be refactored to create all the promises at once, then get access to the\nresults usingPromise.all()(or one of the otherpromise concurrency methods). Otherwise, each successive operation will not start until the\nprevious one has completed.\nConcretely, the following function could be refactored as shown:\nasyncfunctionfoo(things){constresults=[];for(constthingofthings){// Bad: each loop iteration is delayed until the entire asynchronous operation completesresults.push(awaitdoAsyncWork(thing));}returnresults;}12345678Copy code to clipboard\nasyncfunctionfoo(things){constpromises=[];for(constthingofthings){// Good: all asynchronous operations are immediately started.promises.push(doAsyncWork(thing));}// Now that all the asynchronous operations are running, here we wait until they all complete.constresults=awaitPromise.all(promises);returnresults;}12345678910Copy code to clipboard\nThis can be beneficial for subtle error-handling reasons as well. Given an array of promises that might reject,\nsequential awaiting puts the program at risk of unhandled promise rejections. The exact behavior of unhandled\nrejections depends on the environment running your code, but they are generally considered harmful regardless.\nIn Node.js, for example,unhandled rejections cause a program to terminateunless configured otherwise.\nasyncfunctionfoo(){constarrayOfPromises=somethingThatCreatesAnArrayOfPromises();for(constpromiseofarrayOfPromises){// Bad: if any of the promises reject, an exception is thrown, and// subsequent loop iterations will not run. Therefore, rejections later// in the array will become unhandled rejections that cannot be caught// by a caller.constvalue=awaitpromise;console.log(value);}}1234567891011Copy code to clipboard\nasyncfunctionfoo(){constarrayOfPromises=somethingThatCreatesAnArrayOfPromises();// Good: Any rejections will cause a single exception to be thrown here,// which may be caught and handled by the caller.constarrayOfValues=awaitPromise.all(arrayOfPromises);for(constvalueofarrayOfValues){console.log(value);}}123456789Copy code to clipboard",
    "sub_configuration_introduction": "This rule has no options.",
    "config_examples": []
  }
}