{
    "useNamingConvention": {
        "description": "Description\n\nEnforce naming conventions for everything across a codebase.\nEnforcingnaming conventionshelps to keep the codebase consistent,\nand reduces overhead when thinking about the namecaseof a variable.\nThe following section describes the default conventions enforced by the rule.\nYou can also enforce custom conventions with therule options.",
        "option": "The rule provides several options that are detailed in the following subsections.\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"strictCase\": false,            \"requireAscii\": false,            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.+)\",                \"formats\": [                  \"camelCase\"                ]              }            ]          }        }      }    }  }}\nstrictCaseSection titled “strictCase”\nWhen this option is set totrue, it forbids consecutive uppercase characters incamelCaseandPascalCase.\nDefault:true\nFor instance,HTTPServeroraHTTPServerare not permitted forstrictCase: true.\nThese names should be renamed toHttpServerandaHttpServer:\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"strictCase\": true          }        }      }    }  }}\n1class HTTPServer {}\ncode-block.js:1:7lint/style/useNamingConventionFIXABLE━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ℹTwo consecutive uppercase characters are not allowed in PascalCase becausestrictCaseis set to `true`.>1 │class HTTPServer {│^^^^^^^^^^2 │}3 │ℹIf you want to use consecutive uppercase characters in PascalCase, then set thestrictCaseoption to `false`.See the ruleoptionsfor more details.ℹSafe fix:Rename this symbol inPascalCase.1│-class·HTTPServer·{1│+class·HttpServer·{22│}33│\nWhenstrictCaseis set tofalse, consecutive uppercase characters are allowed.\nFor example,HTTPServerandaHTTPServerwould be considered valid then:\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"strictCase\": false          }        }      }    }  }}\n1class HTTPServer {}\nrequireAsciiSection titled “requireAscii”\nWhentrue, names must only consist of ASCII characters only,\nforbidding names likecaféor안녕하세요that include non-ASCII characters.\nWhenrequireAsciiis set tofalse, names may include non-ASCII characters.\nFor example,caféand안녕하세요would be considered valid then.\nDefault:true\nconventionsSection titled “conventions”\nTheconventionsoption allows applying custom conventions.\nThe option takes an array of conventions.\nEvery convention is an object that includes an optionalselectorand one or more requirements (matchandformats).\nFor example, you can enforce the use ofCONSTANT_CASEfor globalconstdeclarations:\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"const\",                  \"scope\": \"global\"                },                \"formats\": [                  \"CONSTANT_CASE\"                ]              }            ]          }        }      }    }  }}\nA selector describes which declarations the convention applies to.\nYou can select a declaration based on several criteria:\nkind: the kind of the declaration among:\nany (default kind if the kind is unset)\ntypeLike: classes, enums, type aliases, and interfaces\nclass\nenum\nenumMember\ninterface\ntypeAlias\nfunction: named function declarations and expressions\nnamespaceLike: TypeScript namespaces, import and export namespaces (import * as namespace from)\nnamespace: TypeScript namespaces\nimportNamespace\nexportNamespace\nimportAlias: default imports and aliases of named imports\nexportAlias: aliases of re-exported names\nvariable: const, let, using, and var declarations\nconst\nlet\nvar\nusing\nfunctionParameter\ncatchParameter\nindexParameter: parameters of index signatures\ntypeParameter: generic type parameter\nclassMember: class properties, parameter properties, methods, getters, and setters\nclassProperty: class properties, including parameter properties\nclassMethod\nclassGetter\nclassSetter\nobjectLiteralMember: literal object properties, methods, getters, and setters\nobjectLiteralProperty\nobjectLiteralMethod\nobjectLiteralGetter\nobjectLiteralSetter\ntypeMember: properties, methods, getters, and setters declared in type aliases and interfaces\ntypeProperty\ntypeMethod\ntypeGetter\ntypeSetter\nany (default kind if the kind is unset)\ntypeLike: classes, enums, type aliases, and interfaces\nclass\nenum\nenumMember\ninterface\ntypeAlias\nfunction: named function declarations and expressions\nnamespaceLike: TypeScript namespaces, import and export namespaces (import * as namespace from)\nnamespace: TypeScript namespaces\nimportNamespace\nexportNamespace\nimportAlias: default imports and aliases of named imports\nexportAlias: aliases of re-exported names\nvariable: const, let, using, and var declarations\nconst\nlet\nvar\nusing\nfunctionParameter\ncatchParameter\nindexParameter: parameters of index signatures\ntypeParameter: generic type parameter\nclassMember: class properties, parameter properties, methods, getters, and setters\nclassProperty: class properties, including parameter properties\nclassMethod\nclassGetter\nclassSetter\nobjectLiteralMember: literal object properties, methods, getters, and setters\nobjectLiteralProperty\nobjectLiteralMethod\nobjectLiteralGetter\nobjectLiteralSetter\ntypeMember: properties, methods, getters, and setters declared in type aliases and interfaces\ntypeProperty\ntypeMethod\ntypeGetter\ntypeSetter\nmodifiers: an array of modifiers among:\nabstract: applies to class members and classes\nprivate: applies to class members\nprotected: applies to class members\nreadonly: applies to class members and type members\nstatic: applies to class members\nabstract: applies to class members and classes\nprivate: applies to class members\nprotected: applies to class members\nreadonly: applies to class members and type members\nstatic: applies to class members\nscope: where the declaration appears. Allowed values:\nany: anywhere (default value if the scope is unset)\nglobal: the global scope (also includes the namespace scopes)\nany: anywhere (default value if the scope is unset)\nglobal: the global scope (also includes the namespace scopes)\nFor each declaration,\ntheconventionsarray is traversed in-order until a selector selects the declaration.\nThe requirements of the convention are so verified on the declaration.\nA convention must set at least one requirement among:\nmatch: a regular expression that the name of the declaration must match.\nformats: the string case that the name must follow.\nThe supported cases are: PascalCase, CONSTANT_CASE, camelCase, and snake_case.\nIf onlyformatsis set, it’s checked against the name of the declaration.\nIn the following configuration, we requirestatic readonlyclass properties to be inCONSTANT_CASE.\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classProperty\",                  \"modifiers\": [                    \"static\",                    \"readonly\"                  ]                },                \"formats\": [                  \"CONSTANT_CASE\"                ]              }            ]          }        }      }    }  }}\nThe following code is then reported by the rule:\n1class C {2    static readonly prop = 0;}\ncode-block.ts:2:21lint/style/useNamingConvention━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ℹThisreadonly static class propertyname should be inCONSTANT_CASE.1 │class C {>2 │static readonly prop = 0;│^^^^3 │}4 │\nA convention can make another one useless.\nIn the following configuration, the second convention is useless because the first one always applies to class members, including class properties.\nYou should always place first more specific conventions.\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\"                },                \"formats\": [                  \"camelCase\"                ]              },              {                \"selector\": {                  \"kind\": \"classProperty\"                },                \"formats\": [                  \"camelCase\",                  \"CONSTANT_CASE\"                ]              }            ]          }        }      }    }  }}\nIf onlymatchis set and the regular expression has no capturing groups,\nthenmatchis checked against the name of the declaration directly.\nIn the following configuration, all variable names must have a minimum of 3 characters and a maximum of 20 characters.\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"variable\"                },                \"match\": \".{3,}\"              }            ]          }        }      }    }  }}\nIf bothmatchandformatsare set, thenformatsis checked against the first capture of the regular expression.\nOnly the first capture is tested. Other captures are ignored.\nIf nothing is captured, thenformatsis ignored.\nIn the following example, we require that:\nA private property starts with _ and consists of at least two characters.\nThe captured name (the name without the leading _) is in camelCase.\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.+)\",                \"formats\": [                  \"camelCase\"                ]              }            ]          }        }      }    }  }}\nIfmatchis set andformatsis unset, then the part of the name captured by the regular expression is forwarded to the next conventions of the array that selects the declaration.\nThe following configuration has exactly the same effect as the previous one.\nThe first convention applies to any private class member name.\nIt stipulates that the name must have a leading underscore.\nThe regular expression captures the part of the name without the leading underscore.\nBecauseformatsis not set, the capture is forwarded to the next convention that applies to a private class member name.\nIn our case, the next convention applies.\nThe capture is then checked againstformats.\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.+)\"16                // We don't need to specify `formats` because the capture is forwarded to the next conventions.              },              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"formats\": [                  \"camelCase\"                ]              }            ]          }        }      }    }  }}\nThe forwarding has particularly useful to factorize some conventions.\nFor example, the following configuration…\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.+)\",                \"formats\": [                  \"camelCase\"                ]              },              {                \"selector\": {                  \"kind\": \"classMember\"                },                \"formats\": [                  \"camelCase\"                ]              }            ]          }        }      }    }  }}\ncan be factorized to…\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.+)\"              },              {                \"selector\": {                  \"kind\": \"classMember\"                },                \"formats\": [                  \"camelCase\"                ]              }            ]          }        }      }    }  }}\nIf a declaration is not selected or if a capture is forwarded while there are no more conventions,\nthen the declaration name is verified against the default conventions.\nBecause the default conventions already ensure that class members are in [“camelCase”],\nthe previous example can be simplified to:\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.+)\"16                // We don't need to specify `formats` because the capture is forwarded to the next conventions.              }18              // default conventions            ]          }        }      }    }  }}\nIf the capture is identical to the initial name (it is not a part of the initial name),\nthen, leading and trailing underscore and dollar signs are trimmed before being checked against default conventions.\nIn the previous example, the capture is a part of the name because_is not included in the capture, thus, no trimming is performed.\nYou can reset all default conventions by adding a convention at the end of the array that accepts anything:\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [8              // your conventions9              // ...10\n11              // Otherwise, accept anything              {                \"match\": \".*\"              }            ]          }        }      }    }  }}\nLet’s take a more complex example with the following conventions:\nA variable name isi,j, or follows the next selected convention (convention (2)).An identifier contains at least two characters and follow the next selected convention (the default convention).Aprivateclass member name starts with an underscore_and the name without the underscore follows the next selected convention (convention (4) for some of them, and the default convention for others).Astatic readonlyclass property name is inCONSTANT_CASE.A global constant is inCONSTANT_CASEand can be enclosed by double underscores or to be named_SPECIAL_.An interface name starts withI, except for interfaces ending withError, and is inPascalCase.All other names follow the default conventions\n{  \"linter\": {    \"rules\": {      \"style\": {        \"useNamingConvention\": {          \"options\": {            \"conventions\": [              {                \"selector\": {                  \"kind\": \"variable\"                },                \"match\": \"[ij]|(.*)\"              },              {                \"match\": \"(.{2,})\"              },              {                \"selector\": {                  \"kind\": \"classMember\",                  \"modifiers\": [                    \"private\"                  ]                },                \"match\": \"_(.*)\"              },              {                \"selector\": {                  \"kind\": \"classProperty\",                  \"modifiers\": [                    \"static\",                    \"readonly\"                  ]                },                \"formats\": [                  \"CONSTANT_CASE\"                ]              },              {                \"selector\": {                  \"kind\": \"const\",                  \"scope\": \"global\"                },                \"match\": \"__(.+)__|_SPECIAL_|(.+)\",                \"formats\": [                  \"CONSTANT_CASE\"                ]              },              {                \"selector\": {                  \"kind\": \"interface\"                },                \"match\": \"I(.*)|(.*?)Error\",                \"formats\": [                  \"PascalCase\"                ]              }57              // default conventions            ]          }        }      }    }  }}\nHers some examples:\nA private class property named _ is reported by the rule because it contains a single character.\nAccording to the second convention, the name should contain at least two characters.\nA variable a_variable is reported by the rule because it doesn’t respect the default convention that forbid variable names in snake_case.\nThe variable name is first verified against the first convention.\nIt is forwarded to the second convention, which is also respected, because it is neither i nor j.\nThe name is captured and is forwarded to the next convention.\nIn our case, the next convention is the default one.\nRegular expression syntaxSection titled “Regular expression syntax”\nThematchoption takes a regular expression that supports the following syntaxes:\nGreedy quantifiers *, ?, +, {n}, {n,m}, {n,}, {m}\nNon-greedy quantifiers *?, ??, +?, {n}?, {n,m}?, {n,}?, {m}?\nAny character matcher .\nCharacter classes [a-z], [xyz], [^a-z]\nAlternations |\nCapturing groups ()\nNon-capturing groups (?:)\nCase-insensitive groups (?i:) and case-sensitive groups (?-i:)\nA limited set of escaped characters including all special characters\nand regular string escape characters \\f, \\n, \\r, \\t, \\v.\nNote that you can also escape special characters using character classes.\nFor example, \\$ and [$] are two valid patterns that escape $."
    }
}