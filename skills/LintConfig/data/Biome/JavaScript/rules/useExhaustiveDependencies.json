{
    "useExhaustiveDependencies": {
        "description": "Description\n\nEnforce correct dependency usage within React hooks.\nReact components have access to varioushooksthat can perform\nvarious actions like querying and updating state.\nFor hooks that trigger whenever a variable changes (such asuseEffectanduseMemo),\nReact relies on the hook’s listed dependencies array to determine when to re-compute Effects and re-render the page.\nThis can lead to unexpected behavior when dependencies are incorrectly specified:\n\n1function ticker() {2  const [count, setCount] = useState(0);3\n4  /** Increment the count once per second. */5  function onTick() {6    setCount(count + 1);7  }8\n9  // React _thinks_ this code doesn't depend on anything else, so10  // it will only use the _initial_ version of `onTick` when rendering the component.11  // As a result, our normally-dynamic counter will always display 1!12  // This is referred to as a \"stale closure\", and is a common pitfall for beginners.13  useEffect(() => {14    const id = setInterval(onTick, 1000);15    return () => clearInterval(id);16  }, []);17\n18  return <h1>Counter: {count}</h1>;19}\n\n1function apples() {2  const [count, setCount] = useState(0);3  const [message, setMessage] = useState(\"We have 0 apples!\");4\n5  // React _thinks_ this code depends on BOTH `count` and `message`, and will re-run the hook whenever6  // `message` is changed despite it not actually being used inside the closure.7  // In fact, this will create an infinite loop due to our hook updating `message` and triggering itself again!8  useEffect(() => {9    setMessage(`We have ${count} apples!`)10  }, [count, message]);11\n12}\nThis rule attempts to prevent such issues by diagnosing potentially incorrect or invalid usages of hook dependencies.\nDefault BehaviorSection titled “Default Behavior”\nBy default, the following hooks (and their Preact counterparts) will have their arguments checked by this rule:\nuseEffect\nuseLayoutEffect\nuseInsertionEffect\nuseCallback\nuseMemo\nuseImperativeHandle\nStable resultsSection titled “Stable results”\nWhen a hook is known to have a stable return value (one whose identity doesn’t change across invocations),\nthat value doesn’t need to andshould notbe specified as a dependency.\nFor example, setters returned by React’suseStatehook will not change throughout the lifetime of a program\nand should therefore be omitted.\nBy default, the following hooks are considered to have stable return values:\nuseState (index 1)\nuseReducer (index 1)\nuseTransition (index 1)\nuseRef\nuseEffectEvent\nIf you want to add custom hooks to the rule’s diagnostics or specify your own functions with stable results,\nsee theoptionssection for more information.",
        "option": "hooksSection titled “hooks”\nAllows specifying custom hooks (from libraries or internal projects) whose dependencies\nshould be checked and/or which are known to have stable return values.\nFor every hook whose dependencies you want validated, you must specify the index of both the closure\nusing the dependencies and the dependencies array to validate it against.\nExampleSection titled “Example”\n{  \"linter\": {    \"rules\": {      \"correctness\": {        \"useExhaustiveDependencies\": {          \"options\": {            \"hooks\": [              {                \"name\": \"useLocation\",                \"closureIndex\": 0,                \"dependenciesIndex\":               },              {                \"name\": \"useQuery\",                \"closureIndex\": 2,                \"dependenciesIndex\":               }            ]          }        }      }    }  }}\nThis would enable checks on the following code snippets:\n1function Foo() {2  let stateVar = 1;3  useLocation(() => {console.log(stateVar)}, []);}\ncode-block.js:3:3lint/correctness/useExhaustiveDependenciesFIXABLE━━━━━━━━━━━━━━━━━━━━━━━━━━━━━✖This hookdoes not specifyits dependency onstateVar.1 │function Foo() {2 │let stateVar = 1;>3 │useLocation(() => {console.log(stateVar)}, []);│^^^^^^^^^^^4 │}5 │ℹThis dependency is being used here, but is not specified in the hook dependency list.1 │function Foo() {2 │let stateVar = 1;>3 │useLocation(() => {console.log(stateVar)}, []);│^^^^^^^^4 │}5 │ℹReact relies on hook dependencies to determine when to re-compute Effects.Failing to specify dependencies can result in Effectsnot updating correctlywhen state changes.These “stale closures” are a common source of surprising bugs.ℹEither include it or remove the dependency array.ℹUnsafe fix:Add the missing dependency to the list.3 │··useLocation(()·=>·{console.log(stateVar)},·[stateVar]);│++++++++\n1function Foo() {2  let stateVar = 1;3  useQuery([stateVar], \"smthng\", () => {console.log(stateVar)});}\nConfiguring stable resultsSection titled “Configuring stable results”\nAs previously discussed, the lint rule takes into account so-calledstable resultsand will ensure any such variables arenotspecified as dependencies.\nYou can specify custom functions as returning stable results in one of four ways:\n\"stableResult\": true— marks the return value as stable. An example\nof a React hook that would be configured like this isuseRef().\"stableResult\": []— expects the return value to be an array and\nmarks the given indices as stable. An example of a React\nhook that would be configured like this isuseState().\"stableResult\": 1— shorthand for option 2 (\"stableResult\": []).\nUseful for hooks that only have a single stable return.\"stableResult\": [\"setValue\"]— expects the return value to be an\nobject and marks the properties with the given keys as stable.\nExampleSection titled “Example”\n{  \"linter\": {    \"rules\": {      \"correctness\": {        \"useExhaustiveDependencies\": {          \"options\": {            \"hooks\": [              {                \"name\": \"useDispatch\",                \"stableResult\": true              }            ]          }        }      }    }  }}\nWith this configuration, the following is valid:\n1const dispatch = useDispatch();2// No need to list `dispatch` as dependency since it doesn't change3const doAction = useCallback(() => dispatch(someAction()), []);\nreportUnnecessaryDependenciesSection titled “reportUnnecessaryDependencies”\nIf set tofalse, the rule will not trigger diagnostics for unused dependencies passed to hooks that do not use them.\nCautionOver-specifying dependencies can reduce application performance or even cause infinite loops, so caution is advised.\nDefault:true\nExampleSection titled “Example”\n{  \"linter\": {    \"rules\": {      \"correctness\": {        \"useExhaustiveDependencies\": {          \"options\": {            \"reportUnnecessaryDependencies\": false          }        }      }    }  }}\n1import { useEffect } from \"react\";2\n3function Foo() {4  let stateVar = 1;5  // not used but still OK6  useEffect(() => {}, [stateVar]);}\nreportMissingDependenciesArraySection titled “reportMissingDependenciesArray”\nIf enabled, the rule will also trigger diagnostics for hooks that lack dependency arrays altogether,\nrequiring any hooks lacking dependencies to explicitly specify an empty array.\nDefault:false\nExampleSection titled “Example”\n{  \"linter\": {    \"rules\": {      \"correctness\": {        \"useExhaustiveDependencies\": {          \"options\": {            \"reportMissingDependenciesArray\": true          }        }      }    }  }}\n1function noArrayYesProblem() {2  let stateVar = 1;3  React.useEffect(() => {});}\ncode-block.jsx:3:9lint/correctness/useExhaustiveDependencies━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━✖This hook does not have a dependencies array.1 │function noArrayYesProblem() {2 │let stateVar = 1;>3 │React.useEffect(() => {});│^^^^^^^^^4 │}5 │ℹReact relies on hook dependencies to determine when to re-compute Effects.Add an explicit array (i.e.[]) and list the callback’s dependencies inside it."
    }
}