{
    "noUndeclaredDependencies": {
        "description": "Description\n\nDisallow the use of dependencies that aren’t specified in thepackage.json.\nIndirect dependencies will trigger the rule because they aren’t declared in thepackage.json.\nThis means that if the package@org/foohas a dependency onlodash, and then you useimport \"lodash\"somewhere in your project, the rule will trigger a diagnostic for this import.\nThe rule is meant to catch those dependencies that aren’t declared inside the closestpackage.json, and\nisn’t meant to detect dependencies declared in other manifest files, e.g. the rootpackage.jsonin a monorepo setting.\nThe rule ignores imports that are not valid package names.\nThis includes internal imports that start with#and@/and imports with a protocol such asnode:,bun:,jsr:,https:.\nTo ensure that Visual Studio Code uses relative imports when it automatically imports a variable,\nyou may setjavascript.preferences.importModuleSpecifierandtypescript.preferences.importModuleSpecifiertorelative.",
        "option": "This rule supports the following options:\ndevDependencies: If set to false, then the rule will show an error when devDependencies are imported. Defaults to true.\npeerDependencies: If set to false, then the rule will show an error when peerDependencies are imported. Defaults to true.\noptionalDependencies: If set to false, then the rule will show an error when optionalDependencies are imported. Defaults to true.\nYou can set the options like this:\n{  \"linter\": {    \"rules\": {      \"correctness\": {        \"noUndeclaredDependencies\": {          \"options\": {            \"devDependencies\": false,            \"peerDependencies\": false,            \"optionalDependencies\": false          }        }      }    }  }}\nYou can also use an array of globs instead of literal booleans.\nWhen using an array of globs, the setting will be set totrue(no errors reported)\nif the name of the file being linted (i.e. not the imported file/module) matches a single glob\nin the array, andfalseotherwise.\nExample using thedevDependenciesoptionSection titled “Example using the devDependencies option”\nIn this example, only test files can use dependencies in thedevDependenciessection.dependencies,peerDependencies, andoptionalDependenciesare always available.\n{  \"linter\": {    \"rules\": {      \"correctness\": {        \"noUndeclaredDependencies\": {          \"options\": {            \"devDependencies\": [              \"**/tests/*.test.js\",              \"**/tests/*.spec.js\"            ]          }        }      }    }  }}\npackage.json\n{  \"devDependencies\": {    \"vite\": \"*\"  }}\nsrc/index.js\n1// cannot import from a non-test file2import \"vite\";\n/src/index.js:2:8lint/correctness/noUndeclaredDependencies━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━✖Dependencyviteisn’t specified in/package.json.1 │// cannot import from a non-test file>2 │import “vite”;│^^^^^^3 │ℹviteis part of yourdevDependencies, but it’s not intended to be used in this file.ℹYou may want to consider moving it to thedependenciessection.\ntests/foo.test.js\n1// this works, because the file matches a glob from the options2import \"vite\";"
    }
}