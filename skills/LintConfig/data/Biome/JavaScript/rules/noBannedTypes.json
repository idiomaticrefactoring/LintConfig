{
    "noBannedTypes": {
        "description": "Description\n\nDisallow primitive type aliases and misleading types.\nThis rule aims to prevent usage of potentially “misleading” types and type aliases\nwhich may behave unexpectedly.\nDisallow “boxed object” types likeBooleanandNumberSection titled “Disallow “boxed object” types like Boolean and Number”\nJavaScript’s 8 data types are described in TypeScript by the lowercase typesundefined,null,boolean,number,string,bigint,symbol, andobject.\nThe latter 6 also have uppercase variants, which instead representinterfaceswith the shared properties of their primitive counterparts.\nDue to the nature of structural typing, these uppercase types accept both primitive values and non-primitive “boxed object”s\nlikenew Boolean(true), despite the two behaving differently in many circumstances like equality and truthiness.\nIt is thus considered best practice to avoid these “boxed types” in favor of their lowercase\nprimitive counterparts.\nDisallow the unsafeFunctiontypeSection titled “Disallow the unsafe Function type”\nTypeScript’s built-inFunctiontype is capable of accepting callbacks of any shape or form,\nbehaving equivalent to(...rest: any[]) => any(which uses the unsafeanytype) when called directly.It also accepts classes or plain objects that happen to possess all properties of theFunctionclass,\nwhich is likewise a potential source of confusion.\nAs such, it is almost always preferable to explicitly specify function parameters and return types where possible.When a generic “catch-all” callback type is required, one of the following can be used instead:\n() => void: A function that accepts no parameters and whose return value is ignored\n(...args: never) => unknown: A “top type” for functions that can be assigned any function type,\nbut can’t be called directly\nDisallow the misleading empty object type{}Section titled “Disallow the misleading empty object type {}”\n{}, also known as the “empty object” type,doesn’tactually represent an empty object (despite what many new to TypeScript may assume).Due to TypeScript’s type system beingstructuralinstead of nominal, it actually acceptsany non-nullish value,\nThe following example is thus perfectly valid TypeScript:\n\n1const n: {} = 0;\nOften, developers writing{}actually mean one of the following:\nobject: Represents any object value\nunknown: Represents any value at all, including null and undefined\n{ [k: keyof any]: never } or Record<keyof any, never>: Represent object types whose properties are all of type never (and cannot be used)\n{ [myUniqueInternalSymbol]?: never }: Represents an object type whose only “property” is an unexported unique symbol, thereby forcing external consumers to omit it1. \nThis can be used as a type guard for use in extends clauses or a type annotation for use in excess property checks,\nboth with their own respective use cases and pitfalls.\nTo avoid confusion, this rule forbids the use of the type{}, except in two situations:\nIn type constraints to restrict a generic type to non-nullable types:\n\n1function f<T extends {}>(x: T) {2    assert(x != null);3}\nIn a type intersection to narrow a type to its non-nullable equivalent type:\n\n1type NonNullableMyType = MyType & {};\nIn this last case, you can also use theNonNullableutility type to the same effect:\n\n1// equivalent to `{}`2type AnythingNotNullish = NonNullable<unknown>;",
        "option": "This rule has no specific options."
    }
}