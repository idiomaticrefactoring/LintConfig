{
    "Duplicate Method Call": {
        "description": "Description\n\nIntroduction\n\nDuplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nLet's look at an example that is quite common in the Rails world:\n\nruby\ndef not_production?\n  Rails.env.development? || Rails.env.test?\nend\n\nWhile this duplicate usage of Rails.env might seem innocuous there are 2 problems with it:\n\n1.) Efficiency\n\nruby\nRails.env.development? || Rails.env.test?\n\nis not as efficient as it could be. If the call to env is not memoized your basically paying twice in terms of computation for something that you should only pay once.\n\nHere\n\nruby\nRails.env.development? || Rails.env.test?\n\nyou have 4 method calls while here:\n\nruby\nenv = Rails.env\nenv.development? || env.test?\n\nyou have one assignment (which is very cheap in terms of computation) and 3 method calls.\nThe difference might not be much here but just imagine you're writing a high performance app or you doing some expensive database calls in each method call.\n\nIt doesn't really matter though if the efficiency difference is significant. This is a matter of principle - we believe that being efficient is one of the vital traits of good software.\n\n2.) Maintainability\n\nThe second point is a bit more subtle. This\n\nruby\nenv = Rails.env\nenv.development? || env.test?\n\nis a lot more intention revealing than\n\nruby\nRails.env.development? || Rails.env.test?\n\nHere\n\nruby\nenv = Rails.env\nenv.development? || env.test?\n\nI'm very clear on what I do: I get the environment and then I run some checks on it.\n\nHere\n\nruby\nRails.env.development? || Rails.env.test?\n\nI'm not very clear on what I do and it requires quite more mental effort: Ok, so I'm talking to Rails, getting the environment and then running a check on it ...or .....oh, I get the same Rails constant again, get the same environment and run another check on it.\n\nExample\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\nruby\ndef double_thing\n  @other.thing + @other.thing\nend\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\nruby\ndef double_thing\n  thing = @other.thing\n  thing + thing\nend\n\nA slightly different approach would be to replace all calls in double_thing by calls to thing:\n\n```ruby\nclass Other\n  def double_thing\n    thing + thing\n  end\n\ndef thing\n    @other.thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n\nCurrent support in Reek\n\nReek's Duplicate Method Call detector checks for repeated identical method calls within\nany one method definition. This is intended to complement the checks performed by tools\nsuch as Flay and Simian.\n\nEdge cases\n\nBe aware that there are some edge cases like this code:\n\nruby\nclass Foo\n  def bar(switch)\n    case switch\n    when :a\n      ->(arg) { arg.call_me(:maybe); do_something }\n    when :b\n      ->(arg) { arg.call_me(:maybe); do_something_else }\n    when :c\n      ->(arg) { arg.call_me(:maybe); do_something_different }\n    end\n  end\nend\n\nReek cannot reliably detect that each call's receiver is a different arg and will report:\n\n[5, 7, 9]:DuplicateMethodCall: Foo#bar calls 'arg.call_me(:maybe)' 3 times\n\nIf you're running into this problem you can disable this smell detector for this method either via\nconfiguration:\n\n```yaml\n\nDuplicateMethodCall:\n  exclude:\n    - 'Foo#bar'\n```\n\nor via source code comment:\n\nruby\nclass Foo\n  # :reek:DuplicateMethodCall\n  def bar(switch)\n    # ....\n  end\nend",
        "option": "Reek's Duplicate Method Call detector currently offers the Basic Smell Options, plus:\n\nOption | Value | Effect\n-------|-------|-------\nmax_calls |  integer | The maximum number of duplicate calls allowed within a method. Defaults to 1.\nallow_calls | an array of strings or regular expressions | Ignores any context who matches it |\n\nAdjusting max_calls\n\nImagine code like this:\n\nruby\nclass Alfa\n  def bravo\n    charlie.delta\n    charlie.delta\n  end\nend\n\nThis would report:\n\nsrc.rb -- 1 warning:\n  [4, 5]:DuplicateMethodCall: Alfa#bravo calls 'charlie.delta' 2 times\n\nIf you want to allow those double calls here you can disable it in 2 different ways:\n\n1.) Via source code comment:\n\nruby\nclass Alfa\n  # :reek:DuplicateMethodCall { max_calls: 2 }\n  def bravo\n    charlie.delta\n    charlie.delta\n  end\nend\n\n2.) Via configuration file:\n\nyaml\nDuplicateMethodCall:\n  max_calls: 2\n\nNote though that the latter way will set max_calls to 2 for all instances\nof the smell detector which might not be what you want - in this case\nyou'll have to use source code comments.\n\nAdjusting allow_calls\n\nImagine code like this:\n\nruby\nclass Alfa\n  def bravo\n    charlie.delta\n    charlie.delta\n    echo.foxtrot\n    echo.foxtrot\n  end\nend\n\nThis would report:\n\nsrc.rb -- 2 warnings:\n  [4, 5]:DuplicateMethodCall: Alfa#bravo calls charlie.delta 2 times\n  [6, 7]:DuplicateMethodCall: Alfa#bravo calls echo.foxtrot 2 times\n\nSo let's say you're ok with the echo.foxtrot calls you can stop reporting them like this:\n\n1.) Via source code comment:\n\nruby\nclass Alfa\n  # :reek:DuplicateMethodCall { allow_calls: ['echo.foxtrot'] }\n  def bravo\n    charlie.delta\n    charlie.delta\n    echo.foxtrot\n    echo.foxtrot\n  end\nend\n\n2.) Via configuration file:\n\nyaml\nDuplicateMethodCall:\n  allow_calls:\n  - 'echo.foxtrot'\n\nNote though that the latter way will allow those calls across your source code which might not be what you want.\nIn this case you'll have to use source code comments."
    }
}