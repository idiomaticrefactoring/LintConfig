{
    "Feature Envy": {
        "description": "Description\n\nIntroduction\n\nFeature Envy occurs when a code fragment references another object more often than it references itself, or when several clients do the same series of manipulations on a particular type of object.\n\nFeature Envy reduces the code's ability to communicate intent: code that \"belongs\" on one class but which is located in another can be hard to find, and may upset the \"System of Names\" in the host class.\n\nFeature Envy also affects the design's flexibility: A code fragment that is in the wrong class creates couplings that may not be natural within the application's domain, and creates a loss of cohesion in the unwilling host class.\n\nFeature Envy often arises because it must manipulate other objects (usually its arguments) to get them into a useful form, and one force preventing them (the arguments) doing this themselves is that the common knowledge lives outside the arguments, or the arguments are of too basic a type to justify extending that type. Therefore there must be something which 'knows' about the contents or purposes of the arguments.  That thing would have to be more than just a basic type, because the basic types are either containers which don't know about their contents, or they are single objects which can't capture their relationship with their fellows of the same type. So, this thing with the extra knowledge should be reified into a class, and the utility method will most likely belong there.\n\nExample\n\nRunning Reek on:\n\nruby\nclass Warehouse\n  def sale_price(item)\n    (item.price - item.rebate) * @vat\n  end\nend\n\nwould report:\n\nbash\nWarehouse#sale_price refers to item more than self (FeatureEnvy)\n\nsince this:\n\nruby\n(item.price - item.rebate)\n\nbelongs to the Item class, not the Warehouse.\n\nCurrent Support in Reek\n\nFeature Envy reports any method that refers to self less often than it refers to (ie. send messages to) some other object.\n\nEdge cases\n\nBe aware that there are some edge cases like this code:\n\nruby\nclass Foo\n  def initialize\n    @map = {\n      a: ->(arg) { arg.css('table') },\n      b: ->(arg) { arg.css('div') },\n      c: ->(arg) { arg.css('span') }\n    }\n  end\nend\n\nReek cannot reliably detect that each call's receiver is a different arg and will report:\n\n[4, 5, 6]:FeatureEnvy: Foo#initialize refers to 'arg' more than self (maybe move it to another class?)\n\nIf you're running into this problem you can disable this smell detector for this method either via\nconfiguration:\n\n```yaml\n\nFeatureEnvy:\n  exclude:\n    - 'Foo#bar'\n```\n\nor via source code comment:\n\nruby\nclass Foo\n  # :reek:FeatureEnvy\n  def initialize\n    @map = {\n    # ....\n  end\nend\n\nDifferences to Utility Function\n\nFeature Envy is only triggered if there are some references to self and Utility Function is triggered if there are no references to self.",
        "option": "Feature Envy supports the Basic Smell Options."
    }
}