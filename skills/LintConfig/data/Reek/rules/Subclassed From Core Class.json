{
    "Subclassed From Core Class": {
        "description": "Description\n\nIntroduction\n\nCandidate classes for the Subclassed From Core Class smell are classes which inherit from Core Classes like Hash, String and Array.\n\nInheriting from Core Classes means that you are going to have a bad time debugging (the explanation below is taken from here):\n\nWhat do you think this code should do?\n\n```ruby\nList = Class.new(Array)\n\nl = List.new\nl << 1\nl << 2\nputs l.reverse.class # => Array\n```\n\nIf you said “it prints Array” you’d be right.\nLet’s talk about a more pernicious issue: Strings.\n\n```ruby\nclass MyString < String\n  def to_s\n    \"lol\"\n  end\nend\n\ns = MyString.new\ns.concat \"Hey\"\n\nputs s      # => Hey\nputs s.to_s # => lol\nputs \"#{s}\" # => Hey\n```\n\nThat’s right! With Strings, Ruby doesn’t call #to_s: it puts the value in directly.\nGenerally speaking, subclassing isn’t the right idea here.\n\nExample\n\nGiven\n\n```ruby\nclass Ary < Array\nend\n\nclass Str < String\nend\n```\n\nReek would report the Subclassed From Core Class smell for both classes. Instead of subclassing them you want a data structure that uses one of these core classes internally, but isn’t exactly like one. For instance:\n\n```ruby\nrequire 'forwardable'\n\nclass List\n  extend Forwardable\n  def_delegators :@list, :<<, :length # and anything else\n\ndef initialize(list = [])\n    @list = list\n  end\n\ndef reverse\n    List.new(@list.reverse)\n  end\nend\n\nl = List.new\nl << 1\nl << 2\nputs l.reverse.class  # => List\n```",
        "option": "Subclassed From Core Class offers the Basic Smell Options."
    }
}