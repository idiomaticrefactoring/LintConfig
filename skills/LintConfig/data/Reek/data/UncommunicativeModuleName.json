{
  "name": "UncommunicativeModuleName",
  "default_configuration": {
    "enabled": true,
    "exclude": [],
    "reject": [
      "/^.$/",
      "/[0-9]$/"
    ],
    "accept": []
  },
  "description": "An _Uncommunicative Module Name_ is a module name that doesn't communicate its\nintent well enough. This code smell is a case of\n[Uncommunicative Name](Uncommunicative-Name.md).",
  "configuration_docs": "Reek's _Uncommunicative Module Name_ detector supports the [Basic Smell Options](Basic-Smell-Options.md), plus:\n| Option         | Value       | Effect  |\n| ---------------|-------------|---------|\n| `reject` | array of strings | The set of names that Reek uses to check for bad names. Defaults to single-letter names and names ending with a number. |\n| `accept` | array or strings | The set of names that Reek will accept (and not report) even if they match one of the `reject` expressions. Empty by default.|\nAn example configuration could look like this:\n```yaml\n---\nUncommunicativeModuleName:\naccept:\n- lassy\n- Util\nreject:\n- Helper\n```\nReek will convert whatever you give it as a string to the corresponding regex, so \"Helper\" from above will be converted to /Helper/ internally.\nApplying a configuration to a source file like this:\n```ruby\nclass Classy1; end # Should not be reported\nclass Util; end # Should not be reported\nclass BaseHelper; end # Should be reported\n```\nReek would report:\n```\nsmelly.rb -- 1 warning:\n[3]:UncommunicativeModuleName: BaseHelper has the name 'BaseHelper'\n```\nSometimes just strings are not enough for configuration. E.g. consider this code sample:\n```ruby\nclass Klassy",
  "reference_url": "https://raw.githubusercontent.com/troessner/reek/master/docs/Uncommunicative-Module-Name.md"
}