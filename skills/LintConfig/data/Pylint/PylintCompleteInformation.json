{
  "F0002": {
    "description": "[Status: stable] [Name: astroid-error] [Message: %s: %s] Description: Used when an unexpected error occurred while building the Astroid representation. This is usually accompanied by a traceback. Please report such errors ! Additional details: This is a message linked to an internal problem in pylint. There's nothing to change in your code, but maybe in pylint's configuration or installation. Created by the main checker.",
    "option": {}
  },
  "F0011": {
    "description": "[Status: stable] [Name: config-parse-error] [Message: error while parsing the configuration: %s] Description: Used when an exception occurred while parsing a pylint configuration file. Additional details: This is a message linked to a problem in your configuration not your code. Created by the main checker.",
    "option": {}
  },
  "F0001": {
    "description": "[Status: stable] [Name: fatal] [Message: %s] Description: Used when an error occurred preventing the analysis of a module (unable to find it for instance). Additional details: This is a message linked to an internal problem in pylint. There's nothing to change in your code. Created by the main checker.",
    "option": {}
  },
  "F0202": {
    "description": "[Status: stable] [Name: method-check-failed] [Message: Unable to check methods signature (%s / %s)] Description: Used when Pylint has been unable to check methods signature compatibility for an unexpected reason. Please report this kind if you don't make sense of it. Additional details: This is a message linked to an internal problem in pylint. There's nothing to change in your code. Created by the classes checker.",
    "option": {}
  },
  "F0010": {
    "description": "[Status: stable] [Name: parse-error] [Message: error while code parsing: %s] Description: Used when an exception occurred while building the Astroid representation which could be handled by astroid. Additional details: This is a message linked to an internal problem in pylint. There's nothing to change in your code. Created by the main checker.",
    "option": {}
  },
  "E0110": {
    "description": "[Status: stable] [Name: abstract-class-instantiated] [Message: Abstract class %r with abstract methods instantiated] Description: Used when an abstract class with `abc.ABCMeta` as metaclass has abstract methods and is instantiated. Problematic code: import abc class Animal(abc.ABC): @abc.abstractmethod def make_sound(self): pass sheep = Animal() # [abstract-class-instantiated] Correct code: import abc class Animal(abc.ABC): @abc.abstractmethod def make_sound(self): pass class Sheep(Animal): def make_sound(self): print(\"bhaaaaa\") sheep = Sheep() Created by the basic checker.",
    "option": {}
  },
  "E0203": {
    "description": "[Status: stable] [Name: access-member-before-definition] [Message: Access to member %r before its definition line %s] Description: Used when an instance member is accessed before it's actually assigned. Problematic code: class Unicorn: def __init__(self, fluffiness_level): if self.fluffiness_level > 9000: # [access-member-before-definition] print(\"It's OVER-FLUFFYYYY ! *crush glasses*\") self.fluffiness_level = fluffiness_level Correct code: class Unicorn: def __init__(self, fluffiness_level): self.fluffiness_level = fluffiness_level if self.fluffiness_level > 9000: print(\"It's OVER-FLUFFYYYY ! *crush glasses*\") Created by the classes checker.",
    "option": {}
  },
  "E0237": {
    "description": "[Status: stable] [Name: assigning-non-slot] [Message: Assigning to attribute %r not defined in class slots] Description: Used when assigning to an attribute not defined in the class slots. Problematic code: class Student: __slots__ = (\"name\",) def __init__(self, name, surname): self.name = name self.surname = surname # [assigning-non-slot] self.setup() def setup(self): pass Correct code: class Student: __slots__ = (\"name\", \"surname\") def __init__(self, name, surname): self.name = name self.surname = surname self.setup() def setup(self): pass Created by the classes checker.",
    "option": {}
  },
  "E1111": {
    "description": "[Status: stable] [Name: assignment-from-no-return] [Message: Assigning result of a function call, where the function has no return] Description: Used when an assignment is done on a function call but the inferred function doesn't return anything. Problematic code: def add(x, y): print(x + y) value = add(10, 10) # [assignment-from-no-return] Correct code: def add(x, y): return x + y value = add(10, 10) Created by the typecheck checker.",
    "option": {}
  },
  "E1128": {
    "description": "[Status: stable] [Name: assignment-from-none] [Message: Assigning result of a function call, where the function returns None] Description: Used when an assignment is done on a function call but the inferred function returns nothing but None. Problematic code: def function(): return None f = function() # [assignment-from-none] Correct code: def function(): return None f = function() if function() else 1 Created by the typecheck checker.",
    "option": {}
  },
  "E1145": {
    "description": "[Status: stable] [Name: async-context-manager-with-regular-with] [Message: Context manager '%s' is async and should be used with 'async with'.] Description: Used when an async context manager is used with a regular 'with' statement instead of 'async with'. Problematic code: from contextlib import asynccontextmanager @asynccontextmanager async def async_context(): yield with async_context(): # [async-context-manager-with-regular-with] print(\"This will cause an error at runtime\") Correct code: import asyncio from contextlib import asynccontextmanager @asynccontextmanager async def async_context(): yield async def main(): async with async_context(): print(\"This works correctly\") Related links: PEP 492 - Coroutines with async and await syntax contextlib.asynccontextmanager Created by the typecheck checker.",
    "option": {}
  },
  "E1142": {
    "description": "[Status: stable] [Name: await-outside-async] [Message: 'await' should be used within an async function] Description: Emitted when await is used outside an async function. Problematic code: import asyncio def main(): await asyncio.sleep(1) # [await-outside-async] Correct code: import asyncio async def main(): await asyncio.sleep(1) Related links: PEP 492 Created by the typecheck checker.",
    "option": {}
  },
  "E0014": {
    "description": "[Status: stable] [Name: bad-configuration-section] [Message: Out-of-place setting encountered in top level configuration-section '%s' : '%s'] Description: Used when we detect a setting in the top level of a toml configuration that shouldn't be there. Additional details: This error was raised when we encountered an unexpected value type in a toml configuration between pylint 2.12 and pylint 2.14 (before the argparse refactor). Created by the main checker.",
    "option": {}
  },
  "E0701": {
    "description": "[Status: stable] [Name: bad-except-order] [Message: Bad except clauses order (%s)] Description: Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be caught by the most specific handler. Problematic code: try: print(int(input())) except Exception: raise except TypeError: # [bad-except-order] # This block cannot be reached since TypeError exception # is caught by previous exception handler. raise Correct code: try: print(int(input())) except TypeError: raise except Exception: raise Created by the exceptions checker.",
    "option": {}
  },
  "E0705": {
    "description": "[Status: stable] [Name: bad-exception-cause] [Message: Exception cause set to something which is not an exception, nor None] Description: Used when using the syntax \"raise ... from ...\", where the exception cause is not an exception, nor None. Problematic code: def divide(x, y): result = 0 try: result = x / y except ZeroDivisionError: # +1: [bad-exception-cause] raise ValueError(f\"Division by zero when dividing {x} by {y} !\") from result return result Correct code: def divide(x, y): result = 0 try: result = x / y except ZeroDivisionError as exc: raise ValueError(f\"Division by zero when dividing {x} by {y} !\") from exc return result Related links: The raise statement Explicit Exception Chaining per PEP 3134 Created by the exceptions checker.",
    "option": {}
  },
  "E1300": {
    "description": "[Status: stable] [Name: bad-format-character] [Message: Unsupported format character %r (%#02x) at index %d] Description: Used when an unsupported format character is used in a format string. Problematic code: print(\"%s %z\" % (\"hello\", \"world\")) # [bad-format-character] Correct code: print(\"%s %s\" % (\"hello\", \"world\")) Additional details: This check is currently only active for \"old-style\" string formatting as seen in the examples. See Issue #6085 for more information. Related links: Format String Syntax PyFormat Created by the string checker.",
    "option": {}
  },
  "E0013": {
    "description": "[Status: stable] [Name: bad-plugin-value] [Message: Plugin '%s' is impossible to load, is it installed ? ('%s')] Description: Used when a bad value is used in 'load-plugins'. Additional details: One of your pylint plugins cannot be loaded. There's nothing to change in your code, but your pylint configuration or installation has an issue. For example, there might be a typo. The following config: [MAIN] load-plugins = pylint.extensions.bad_biultin Should be: [MAIN] load-plugins = pylint.extensions.bad_builtin Or the plugin you added is not importable in your environment. Created by the main checker.",
    "option": {}
  },
  "E0111": {
    "description": "[Status: stable] [Name: bad-reversed-sequence] [Message: The first reversed() argument is not a sequence] Description: Used when the first argument to reversed() builtin isn't a sequence (does not implement __reversed__, nor __getitem__ and __len__ Problematic code: reversed({1, 2, 3, 4}) # [bad-reversed-sequence] Correct code: reversed([1, 2, 3, 4]) Created by the basic checker.",
    "option": {}
  },
  "E1310": {
    "description": "[Status: stable] [Name: bad-str-strip-call] [Message: Suspicious argument in %s.%s call] Description: The argument to a str.{l,r,}strip call contains a duplicate character, Problematic code: hello_world.py: \"Hello World\".strip(\"Hello\") # [bad-str-strip-call] # >>> ' World' remove_abc_from_both_side.py: \"abcbc def bacabc\".strip(\"abcbc \") # [bad-str-strip-call] # >>> 'def' Correct code: hello_world.py: \"Hello World\".strip(\"Helo\") # >>> ' World' remove_abc_from_both_side.py: \"abcbc def bacabc\".strip(\"abc \") # >>> 'def' Additional details: A common misconception is that str.strip('Hello') removes the substring 'Hello' from the beginning and end of the string. This is not the case. From the documentation: > The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped Duplicated characters in the str.strip call, besides not having any effect on the actual result, may indicate this misunderstanding. Related links: Documentation: str.strip([chars]) Created by the string checker.",
    "option": {}
  },
  "E1307": {
    "description": "[Status: stable] [Name: bad-string-format-type] [Message: Argument %r does not match format type %r] Description: Used when a type required by format string is not suitable for actual argument type Problematic code: print(\"%d\" % \"1\") # [bad-string-format-type] Correct code: print(\"%d\" % 1) Additional details: This check is currently only active for \"old-style\" string formatting as seen in the examples. See Issue #6085 for more information. Related links: Format String Syntax PyFormat Created by the string checker.",
    "option": {}
  },
  "E1003": {
    "description": "[Status: stable] [Name: bad-super-call] [Message: Bad first argument %r given to super()] Description: Used when another argument than the current class is given as first argument of the super builtin. Problematic code: class Animal: pass class Tree: pass class Cat(Animal): def __init__(self): super(Tree, self).__init__() # [bad-super-call] super(Animal, self).__init__() Correct code: class Animal: pass class Tree: pass class Cat(Animal): def __init__(self): super(Animal, self).__init__() Additional details: In Python 2.7, super() has to be called with its own class and self as arguments (super(Cat, self)), which can lead to a mix up of parent and child class in the code. In Python 3 the recommended way is to call super() without arguments (see also super-with-arguments). One exception is calling super() on a non-direct parent class. This can be used to get a method other than the default method returned by the mro(). Related links: Documentation for super() Created by the newstyle checker.",
    "option": {}
  },
  "E1901": {
    "description": "[Status: stable] [Name: bare-name-capture-pattern] [Message: The name capture `case %s` makes the remaining patterns unreachable. Use a dotted name (for example an enum) to fix this.] Description: Emitted when a name capture pattern is used in a match statement and there are case statements below it. Problematic code: red = 0 green = 1 blue = 2 def func(color): match color: case red: # [bare-name-capture-pattern] print(\"I see red!\") case green: # [bare-name-capture-pattern] print(\"Grass is green\") case blue: print(\"I'm feeling the blues :(\") Correct code: from enum import Enum class Color(Enum): RED = 0 GREEN = 1 BLUE = 2 def func(color: Color) -> None: match color: case Color.RED: print(\"I see red!\") case Color.GREEN: print(\"Grass is green\") case Color.BLUE: print(\"I'm feeling the blues :(\") Related links: PEP 636 Created by the match_statements checker.",
    "option": {}
  },
  "E2502": {
    "description": "[Status: stable] [Name: bidirectional-unicode] [Message: Contains control characters that can permit obfuscated code executed differently than displayed] Description: bidirectional unicode are typically not displayed characters required to display right-to-left (RTL) script (i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. So can you trust this code? Are you sure it displayed correctly in all editors? If you did not write it or your language is not RTL, remove the special characters, as they could be used to trick you into executing code, that does something else than what it looks like. More Information: https://en.wikipedia.org/wiki/Bidirectional_text https://trojansource.codes/ Problematic code: # +1: [bidirectional-unicode] example = \"x‏\" * 100 # \"‏x\" is assigned Correct code: example = \"x[U+2194]\" * 100 Created by the unicode_checker checker.",
    "option": {}
  },
  "E6005": {
    "description": "[Status: stable] [Name: broken-collections-callable] [Message: 'collections.abc.Callable' inside Optional and Union is broken in 3.9.0 / 3.9.1 (use 'typing.Callable' instead)] Description: ``collections.abc.Callable`` inside Optional and Union is broken in Python 3.9.0 and 3.9.1. Use ``typing.Callable`` for these cases instead. https://bugs.python.org/issue42965 Problematic code: from collections.abc import Callable from typing import Optional def func() -> Optional[Callable[[int], None]]: # [broken-collections-callable] ... Correct code: from typing import Callable, Optional def func() -> Optional[Callable[[int], None]]: ... Configuration file: [main] py-version=3.9 load-plugins=pylint.extensions.typing Related links: bpo-42965 Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "E6004": {
    "description": "[Status: stable] [Name: broken-noreturn] [Message: 'NoReturn' inside compound types is broken in 3.7.0 / 3.7.1] Description: ``typing.NoReturn`` inside compound types is broken in Python 3.7.0 and 3.7.1. If not dependent on runtime introspection, use string annotation instead. E.g. ``Callable[..., 'NoReturn']``. https://bugs.python.org/issue34921 Problematic code: from typing import NoReturn, Union def exploding_apple(apple) -> Union[None, NoReturn]: # [broken-noreturn] print(f\"{apple} is about to explode\") Correct code: from typing import NoReturn def exploding_apple(apple) -> NoReturn: print(f\"{apple} is about to explode\") raise Exception(\"{apple} exploded !\") Configuration file: [main] py-version=3.7 load-plugins=pylint.extensions.typing Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "E0712": {
    "description": "[Status: stable] [Name: catching-non-exception] [Message: Catching an exception which doesn't inherit from Exception: %s] Description: Used when a class which doesn't inherit from Exception is used as an exception in an except clause. Problematic code: class FooError: pass try: 1 / 0 except FooError: # [catching-non-exception] pass Correct code: class FooError(Exception): pass try: 1 / 0 except FooError: pass Created by the exceptions checker.",
    "option": {}
  },
  "E0242": {
    "description": "[Status: stable] [Name: class-variable-slots-conflict] [Message: Value %r in slots conflicts with class variable] Description: Used when a value in __slots__ conflicts with a class variable, property or method. Problematic code: class Person: # +1: [class-variable-slots-conflict, class-variable-slots-conflict, class-variable-slots-conflict] __slots__ = (\"age\", \"name\", \"say_hi\") name = None def __init__(self, age, name): self.age = age self.name = name @property def age(self): return self.age def say_hi(self): print(f\"Hi, I'm {self.name}.\") Correct code: class Person: __slots__ = (\"_age\", \"name\") def __init__(self, age, name): self._age = age self.name = name @property def age(self): return self._age def say_hi(self): print(f\"Hi, I'm {self.name}.\") Created by the classes checker.",
    "option": {}
  },
  "E0245": {
    "description": "[Status: stable] [Name: declare-non-slot] [Message: No such name %r in __slots__] Description: Raised when a type annotation on a class is absent from the list of names in __slots__, and __slots__ does not contain a __dict__ entry. Problematic code: class Student: __slots__ = (\"name\",) name: str surname: str # [declare-non-slot] Correct code: class Student: __slots__ = (\"name\", \"surname\") name: str surname: str Created by the classes checker.",
    "option": {}
  },
  "E1141": {
    "description": "[Status: stable] [Name: dict-iter-missing-items] [Message: Unpacking a dictionary in iteration without calling .items()] Description: Emitted when trying to iterate through a dict without calling .items() Problematic code: data = {\"Paris\": 2_165_423, \"New York City\": 8_804_190, \"Tokyo\": 13_988_129} for city, population in data: # [dict-iter-missing-items] print(f\"{city} has population {population}.\") Correct code: data = {\"Paris\": 2_165_423, \"New York City\": 8_804_190, \"Tokyo\": 13_988_129} for city, population in data.items(): print(f\"{city} has population {population}.\") Created by the typecheck checker.",
    "option": {}
  },
  "E0108": {
    "description": "[Status: stable] [Name: duplicate-argument-name] [Message: Duplicate argument name %r in function definition] Description: Duplicate argument names in function definitions are syntax errors. Problematic code: def get_fruits(apple, banana, apple): # [duplicate-argument-name] pass Correct code: def get_fruits(apple, banana, orange): pass Created by the basic checker.",
    "option": {}
  },
  "E0241": {
    "description": "[Status: stable] [Name: duplicate-bases] [Message: Duplicate bases for class %r] Description: Duplicate use of base classes in derived classes raise TypeErrors. Problematic code: class Animal: pass class Cat(Animal, Animal): # [duplicate-bases] pass Correct code: class Animal: pass class Bird(Animal): pass class Cat(Animal): pass Created by the classes checker.",
    "option": {}
  },
  "E1303": {
    "description": "[Status: stable] [Name: format-needs-mapping] [Message: Expected mapping for format string, not %s] Description: Used when a format string that uses named conversion specifiers is used with an argument that is not a mapping. Problematic code: print(\"%(x)d %(y)d\" % [1, 2]) # [format-needs-mapping] Correct code: print(\"%(x)d %(y)d\" % {\"x\": 1, \"y\": 2}) Created by the string checker.",
    "option": {}
  },
  "E0102": {
    "description": "[Status: stable] [Name: function-redefined] [Message: %s already defined line %s] Description: Used when a function / class / method is redefined. Problematic code: def get_email(): pass def get_email(): # [function-redefined] pass Correct code: def get_email(): pass Created by the basic checker.",
    "option": {}
  },
  "E0401": {
    "description": "[Status: stable] [Name: import-error] [Message: Unable to import %s] Description: Used when pylint has been unable to import a module. Problematic code: from patlib import Path # [import-error] Correct code: from pathlib import Path Additional details: This can happen if you're importing a package that is not installed in your environment, or if you made a typo. The solution is to install the package via pip/setup.py/wheel or fix the typo. Created by the imports checker.",
    "option": {}
  },
  "E0240": {
    "description": "[Status: stable] [Name: inconsistent-mro] [Message: Inconsistent method resolution order for class %r] Description: Used when a class has an inconsistent method resolution order. Problematic code: class A: pass class B(A): pass class C(A, B): # [inconsistent-mro] pass Correct code: class A: pass class B(A): pass class C(B): # or 'B, A' or 'A' but not 'A, B' pass Created by the classes checker.",
    "option": {}
  },
  "E0239": {
    "description": "[Status: stable] [Name: inherit-non-class] [Message: Inheriting %r, which is not a class.] Description: Used when a class inherits from something which is not a class. Problematic code: class Fruit(bool): # [inherit-non-class] pass Correct code: class Fruit: def __bool__(self): pass Created by the classes checker.",
    "option": {}
  },
  "E0100": {
    "description": "[Status: stable] [Name: init-is-generator] [Message: __init__ method is a generator] Description: Used when the special class method __init__ is turned into a generator by a yield in its body. Problematic code: class Fruit: def __init__(self, worms): # [init-is-generator] yield from worms apple = Fruit([\"Fahad\", \"Anisha\", \"Tabatha\"]) Correct code: class Fruit: def __init__(self, worms): self.__worms = worms def worms(self): yield from self.__worms apple = Fruit([\"Fahad\", \"Anisha\", \"Tabatha\"]) for worm in apple.worms(): pass Created by the basic checker.",
    "option": {}
  },
  "E0605": {
    "description": "[Status: stable] [Name: invalid-all-format] [Message: Invalid format for __all__, must be tuple or list] Description: Used when __all__ has an invalid format. Problematic code: __all__ = \"CONST\" # [invalid-all-format] CONST = 42 Correct code: __all__ = (\"CONST\",) CONST = 42 Created by the variables checker.",
    "option": {}
  },
  "E0604": {
    "description": "[Status: stable] [Name: invalid-all-object] [Message: Invalid object %r in __all__, must contain only strings] Description: Used when an invalid (non-string) object occurs in __all__. Problematic code: __all__ = ( None, # [invalid-all-object] Fruit, Worm, ) class Fruit: pass class Worm: pass Correct code: __all__ = [\"Fruit\", \"Worm\"] class Fruit: pass class Worm: pass Additional details: From The Python Language Reference – The import statement:\"The public names defined by a module are determined by checking the module's namespace for a variable named __all__; if defined, it must be a sequence of strings which are names defined or imported by that module.\" Related links: PEP 8 – Style Guide for Python Code Created by the variables checker.",
    "option": {}
  },
  "E0304": {
    "description": "[Status: stable] [Name: invalid-bool-returned] [Message: __bool__ does not return bool] Description: Used when a __bool__ method returns something which is not a bool Problematic code: class CustomBool: \"\"\"__bool__ returns an int\"\"\" def __bool__(self): # [invalid-bool-returned] return 1 Correct code: class CustomBool: \"\"\"__bool__ returns `bool`\"\"\" def __bool__(self): return True Created by the classes checker.",
    "option": {}
  },
  "E0308": {
    "description": "[Status: stable] [Name: invalid-bytes-returned] [Message: __bytes__ does not return bytes] Description: Used when a __bytes__ method returns something which is not bytes Problematic code: class CustomBytes: \"\"\"__bytes__ returns <type 'str'>\"\"\" def __bytes__(self): # [invalid-bytes-returned] return \"123\" Correct code: class CustomBytes: \"\"\"__bytes__ returns <type 'bytes'>\"\"\" def __bytes__(self): return b\"some bytes\" Created by the classes checker.",
    "option": {}
  },
  "E2510": {
    "description": "[Status: stable] [Name: invalid-character-backspace] [Message: Invalid unescaped character backspace, use \"\\b\" instead.] Description: Moves the cursor back, so the character after it will overwrite the character before. Problematic code: STRING = \"Invalid character backspace \b\" # [invalid-character-backspace] Correct code: STRING = \"Valid character backspace \\b\" Created by the unicode_checker checker.",
    "option": {}
  },
  "E2511": {
    "description": "[Status: stable] [Name: invalid-character-carriage-return] [Message: Invalid unescaped character carriage-return, use \"\\r\" instead.] Description: Moves the cursor to the start of line, subsequent characters overwrite the start of the line. Correct code: STRING = \"Valid carriage return: \\r\" Additional details: This message exists because one of our checkers is very generic, but it's never going to raise during normal use as it's a syntax-error that would prevent the python ast (and thus pylint) from constructing a code representation of the file. You could encounter it by feeding a properly constructed node directly to the checker. Created by the unicode_checker checker.",
    "option": {}
  },
  "E2513": {
    "description": "[Status: stable] [Name: invalid-character-esc] [Message: Invalid unescaped character esc, use \"\\x1B\" instead.] Description: Commonly initiates escape codes which allow arbitrary control of the terminal. Problematic code: STRING = \"Invalid escape character \u001b\" # [invalid-character-esc] Correct code: STRING = \"Valid escape character \\x1b\" Created by the unicode_checker checker.",
    "option": {}
  },
  "E2514": {
    "description": "[Status: stable] [Name: invalid-character-nul] [Message: Invalid unescaped character nul, use \"\\0\" instead.] Description: Mostly end of input for python. Additional details: There's no need to use end-of-string characters. String objects maintain their own length. Related links: Null terminator in python Created by the unicode_checker checker.",
    "option": {}
  },
  "E2512": {
    "description": "[Status: stable] [Name: invalid-character-sub] [Message: Invalid unescaped character sub, use \"\\x1A\" instead.] Description: Ctrl+Z \"End of text\" on Windows. Some programs (such as type) ignore the rest of the file after it. Problematic code: STRING = \"Invalid character sub \u001a\" # [invalid-character-sub] Correct code: STRING = \"Valid character sub x1A\" Created by the unicode_checker checker.",
    "option": {}
  },
  "E2515": {
    "description": "[Status: stable] [Name: invalid-character-zero-width-space] [Message: Invalid unescaped character zero-width-space, use \"\\u200B\" instead.] Description: Invisible space character could hide real code execution. Problematic code: STRING = \"Invalid character zero-width-space ​\" # [invalid-character-zero-width-space] Correct code: STRING = \"Valid character zero-width-space u200B\" Created by the unicode_checker checker.",
    "option": {}
  },
  "E0243": {
    "description": "[Status: stable] [Name: invalid-class-object] [Message: Invalid assignment to '__class__'. Should be a class definition but got a '%s'] Description: Used when an invalid object is assigned to a __class__ property. Only a class is permitted. Problematic code: class Apple: pass Apple.__class__ = 1 # [invalid-class-object] Correct code: class Apple: pass class RedDelicious: pass Apple.__class__ = RedDelicious Created by the classes checker.",
    "option": {}
  },
  "E0244": {
    "description": "[Status: stable] [Name: invalid-enum-extension] [Message: Extending inherited Enum class \"%s\"] Description: Used when a class tries to extend an inherited Enum class. Doing so will raise a TypeError at runtime. Problematic code: from enum import Enum class Color(Enum): ORANGE = 1 CHERRY = 2 class Fruit(Color): # [invalid-enum-extension] APPLE = 3 Correct code: from enum import Enum class Color(Enum): ORANGE = 1 CHERRY = 2 class Fruit(Enum): ORANGE = 1 CHERRY = 2 APPLE = 3 Created by the classes checker.",
    "option": {}
  },
  "E1507": {
    "description": "[Status: stable] [Name: invalid-envvar-value] [Message: %s does not support %s type argument] Description: Env manipulation functions support only string type arguments. See https://docs.python.org/3/library/os.html#os.getenv. Problematic code: import os os.getenv(1) # [invalid-envvar-value] Correct code: import os os.getenv(\"1\") Created by the stdlib checker.",
    "option": {}
  },
  "E3701": {
    "description": "[Status: stable] [Name: invalid-field-call] [Message: Invalid usage of field(), %s] Description: The dataclasses.field() specifier should only be used as the value of an assignment within a dataclass, or within the make_dataclass() function. Problematic code: from dataclasses import dataclass, field @dataclass class C: a: float b: float c: float field(init=False) # [invalid-field-call] def __post_init__(self): self.c = self.a + self.b print(field(init=False)) # [invalid-field-call] Correct code: from dataclasses import dataclass, field, make_dataclass C = make_dataclass( \"C\", [(\"x\", int), \"y\", (\"z\", int, field(default=5))], namespace={\"add_one\": lambda self: self.x + 1}, ) @dataclass class C: a: float b: float c: float = field(init=False) def __post_init__(self): self.c = self.a + self.b Created by the dataclass checker.",
    "option": {}
  },
  "E0311": {
    "description": "[Status: stable] [Name: invalid-format-returned] [Message: __format__ does not return str] Description: Used when a __format__ method returns something which is not a string Problematic code: class CustomFormat: \"\"\"__format__ returns <type 'int'>\"\"\" def __format__(self, format_spec): # [invalid-format-returned] return 1 Correct code: class CustomFormat: \"\"\"__format__ returns <type 'str'>\"\"\" def __format__(self, format_spec): return \"hello!\" Created by the classes checker.",
    "option": {}
  },
  "E0313": {
    "description": "[Status: stable] [Name: invalid-getnewargs-ex-returned] [Message: __getnewargs_ex__ does not return a tuple containing (tuple, dict)] Description: Used when a __getnewargs_ex__ method returns something which is not of the form tuple(tuple, dict) Problematic code: class CustomGetNewArgsEx: \"\"\"__getnewargs_ex__ returns tuple with incorrect arg length\"\"\" def __getnewargs_ex__(self): # [invalid-getnewargs-ex-returned] return (tuple(1), dict(x=\"y\"), 1) Correct code: class CustomGetNewArgsEx: \"\"\"__getnewargs_ex__ returns <type 'tuple'>\"\"\" def __getnewargs_ex__(self): return ((1,), {\"2\": 2}) Created by the classes checker.",
    "option": {}
  },
  "E0312": {
    "description": "[Status: stable] [Name: invalid-getnewargs-returned] [Message: __getnewargs__ does not return a tuple] Description: Used when a __getnewargs__ method returns something which is not a tuple Problematic code: class CustomGetNewArgs: \"\"\"__getnewargs__ returns an integer\"\"\" def __getnewargs__(self): # [invalid-getnewargs-returned] return 1 Correct code: class CustomGetNewArgs: \"\"\"__getnewargs__ returns <type 'tuple'>\"\"\" def __getnewargs__(self): return (1, 2) Created by the classes checker.",
    "option": {}
  },
  "E0309": {
    "description": "[Status: stable] [Name: invalid-hash-returned] [Message: __hash__ does not return int] Description: Used when a __hash__ method returns something which is not an integer Problematic code: class CustomHash: \"\"\"__hash__ returns dict\"\"\" def __hash__(self): # [invalid-hash-returned] return {} Correct code: class CustomHash: \"\"\"__hash__ returns `int`\"\"\" def __hash__(self): return 19 Created by the classes checker.",
    "option": {}
  },
  "E0305": {
    "description": "[Status: stable] [Name: invalid-index-returned] [Message: __index__ does not return int] Description: Used when an __index__ method returns something which is not an integer Problematic code: class CustomIndex: \"\"\"__index__ returns a dict\"\"\" def __index__(self): # [invalid-index-returned] return {\"19\": \"19\"} Correct code: class CustomIndex: \"\"\"__index__ returns <type 'int'>\"\"\" def __index__(self): return 19 Created by the classes checker.",
    "option": {}
  },
  "E0310": {
    "description": "[Status: stable] [Name: invalid-length-hint-returned] [Message: __length_hint__ does not return non-negative integer] Description: Used when a __length_hint__ method returns something which is not a non-negative integer Problematic code: class CustomLengthHint: \"\"\"__length_hint__ returns non-int\"\"\" def __length_hint__(self): # [invalid-length-hint-returned] return 3.0 Correct code: class CustomLengthHint: \"\"\"__length_hint__ returns <type 'int'>\"\"\" def __length_hint__(self): return 10 Created by the classes checker.",
    "option": {}
  },
  "E0303": {
    "description": "[Status: stable] [Name: invalid-length-returned] [Message: __len__ does not return non-negative integer] Description: Used when a __len__ method returns something which is not a non-negative integer Problematic code: class FruitBasket: def __init__(self, fruits): self.fruits = [\"Apple\", \"Banana\", \"Orange\"] def __len__(self): # [invalid-length-returned] return -len(self.fruits) Correct code: class FruitBasket: def __init__(self, fruits): self.fruits = [\"Apple\", \"Banana\", \"Orange\"] def __len__(self): return len(self.fruits) Created by the classes checker.",
    "option": {}
  },
  "E1902": {
    "description": "[Status: stable] [Name: invalid-match-args-definition] [Message: `__match_args__` must be a tuple of strings.] Description: Emitted if `__match_args__` isn't a tuple of strings required for match. Problematic code: class Book: __match_args__ = [\"title\", \"year\"] # [invalid-match-args-definition] def __init__(self, title, year): self.title = title self.year = year Correct code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year Related links: Python documentation Created by the match_statements checker.",
    "option": {}
  },
  "E1139": {
    "description": "[Status: stable] [Name: invalid-metaclass] [Message: Invalid metaclass %r used] Description: Emitted whenever we can detect that a class is using, as a metaclass, something which might be invalid for using as a metaclass. Problematic code: class Apple(metaclass=int): # [invalid-metaclass] pass Correct code: class Plant: pass class Apple(Plant): pass Created by the typecheck checker.",
    "option": {}
  },
  "E0306": {
    "description": "[Status: stable] [Name: invalid-repr-returned] [Message: __repr__ does not return str] Description: Used when a __repr__ method returns something which is not a string Problematic code: class CustomRepr: \"\"\"__repr__ returns <type 'int'>\"\"\" def __repr__(self): # [invalid-repr-returned] return 1 Correct code: class CustomRepr: \"\"\"__repr__ returns <type 'str'>\"\"\" def __repr__(self): return \"apples\" Created by the classes checker.",
    "option": {}
  },
  "E1126": {
    "description": "[Status: stable] [Name: invalid-sequence-index] [Message: Sequence index is not an int, slice, or instance with __index__] Description: Used when a sequence type is indexed with an invalid type. Valid types are ints, slices, and objects with an __index__ method. Problematic code: fruits = [\"apple\", \"banana\", \"orange\"] print(fruits[\"apple\"]) # [invalid-sequence-index] Correct code: fruits = [\"apple\", \"banana\", \"orange\"] print(fruits[0]) Additional details: Be careful with [True] or [False] as sequence index, since True and False will respectively be evaluated as 1 and 0 and will bring the second element of the list and the first without erroring. Created by the typecheck checker.",
    "option": {}
  },
  "E1127": {
    "description": "[Status: stable] [Name: invalid-slice-index] [Message: Slice index is not an int, None, or instance with __index__] Description: Used when a slice index is not an integer, None, or an object with an __index__ method. Problematic code: LETTERS = [\"a\", \"b\", \"c\", \"d\"] FIRST_THREE = LETTERS[:\"3\"] # [invalid-slice-index] Correct code: LETTERS = [\"a\", \"b\", \"c\", \"d\"] FIRST_THREE = LETTERS[:3] Created by the typecheck checker.",
    "option": {}
  },
  "E1144": {
    "description": "[Status: stable] [Name: invalid-slice-step] [Message: Slice step cannot be 0] Description: Used when a slice step is 0 and the object doesn't implement a custom __getitem__ method. Problematic code: LETTERS = [\"a\", \"b\", \"c\", \"d\"] LETTERS[::0] # [invalid-slice-step] Correct code: LETTERS = [\"a\", \"b\", \"c\", \"d\"] LETTERS[::2] Created by the typecheck checker.",
    "option": {}
  },
  "E0238": {
    "description": "[Status: stable] [Name: invalid-slots] [Message: Invalid __slots__ object] Description: Used when an invalid __slots__ is found in class. Only a string, an iterable or a sequence is permitted. Problematic code: class Person: # [invalid-slots] __slots__ = 42 Correct code: class Person: __slots__ = (\"name\", \"age\") Created by the classes checker.",
    "option": {}
  },
  "E0236": {
    "description": "[Status: stable] [Name: invalid-slots-object] [Message: Invalid object %r in __slots__, must contain only non empty strings] Description: Used when an invalid (non-string) object occurs in __slots__. Problematic code: class Person: __slots__ = (\"name\", 3) # [invalid-slots-object] Correct code: class Person: __slots__ = (\"name\", \"surname\") Related links: Documentation for __slots__ Created by the classes checker.",
    "option": {}
  },
  "E0113": {
    "description": "[Status: stable] [Name: invalid-star-assignment-target] [Message: Starred assignment target must be in a list or tuple] Description: Emitted when a star expression is used as a starred assignment target. Problematic code: *fruit = [\"apple\", \"banana\", \"orange\"] # [invalid-star-assignment-target] Correct code: fruit = [\"apple\", \"banana\", \"orange\"] Created by the basic checker.",
    "option": {}
  },
  "E0307": {
    "description": "[Status: stable] [Name: invalid-str-returned] [Message: __str__ does not return str] Description: Used when a __str__ method returns something which is not a string Problematic code: class CustomStr: \"\"\"__str__ returns int\"\"\" def __str__(self): # [invalid-str-returned] return 1 Correct code: class CustomStr: \"\"\"__str__ returns <type 'str'>\"\"\" def __str__(self): return \"oranges\" Created by the classes checker.",
    "option": {}
  },
  "E1130": {
    "description": "[Status: stable] [Name: invalid-unary-operand-type] [Message: %s] Description: Emitted when a unary operand is used on an object which does not support this type of operation. Problematic code: cherries = 10 eaten_cherries = int cherries = -eaten_cherries # [invalid-unary-operand-type] Correct code: cherries = 10 eaten_cherries = 2 cherries -= eaten_cherries Created by the typecheck checker.",
    "option": {}
  },
  "E2501": {
    "description": "[Status: stable] [Name: invalid-unicode-codec] [Message: UTF-16 and UTF-32 aren't backward compatible. Use UTF-8 instead] Description: For compatibility use UTF-8 instead of UTF-16/UTF-32. See also https://bugs.python.org/issue1503789 for a history of this issue. And https://softwareengineering.stackexchange.com/questions/102205/ for some possible problems when using UTF-16 for instance. Additional details: This message is a placeholder for a potential future issue with unicode codecs. Created by the unicode_checker checker.",
    "option": {}
  },
  "E1201": {
    "description": "[Status: stable] [Name: logging-format-truncated] [Message: Logging format string ends in middle of conversion specifier] Description: Used when a logging statement format string terminates before the end of a conversion specifier. Problematic code: import logging import sys logging.warning(\"Python version: %\", sys.version) # [logging-format-truncated] Correct code: import logging import sys logging.warning(\"Python version: %s\", sys.version) Created by the logging checker.",
    "option": {}
  },
  "E1206": {
    "description": "[Status: stable] [Name: logging-too-few-args] [Message: Not enough arguments for logging format string] Description: Used when a logging format string is given too few arguments. Problematic code: import logging try: function() except Exception as e: logging.error(\"%s error occurred: %s\", e) # [logging-too-few-args] raise Correct code: import logging try: function() except Exception as e: logging.error(\"%s error occurred: %s\", type(e), e) raise Created by the logging checker.",
    "option": {}
  },
  "E1205": {
    "description": "[Status: stable] [Name: logging-too-many-args] [Message: Too many arguments for logging format string] Description: Used when a logging format string is given too many arguments. Problematic code: import logging try: function() except Exception as e: logging.error(\"Error occurred: %s\", type(e), e) # [logging-too-many-args] raise Correct code: import logging try: function() except Exception as e: logging.error(\"%s error occurred: %s\", type(e), e) raise Created by the logging checker.",
    "option": {}
  },
  "E1200": {
    "description": "[Status: stable] [Name: logging-unsupported-format] [Message: Unsupported logging format character %r (%#02x) at index %d] Description: Used when an unsupported format character is used in a logging statement format string. Problematic code: import logging logging.info(\"%s %y !\", \"Hello\", \"World\") # [logging-unsupported-format] Correct code: import logging logging.info(\"%s %s !\", \"Hello\", \"World\") Created by the logging checker.",
    "option": {}
  },
  "E0202": {
    "description": "[Status: stable] [Name: method-hidden] [Message: An attribute defined in %s line %s hides this method] Description: Used when a class defines a method which is hidden by an instance attribute from an ancestor class or set by some client code. Problematic code: class Fruit: def __init__(self, vitamins): self.vitamins = vitamins def vitamins(self): # [method-hidden] pass Correct code: class Fruit: def __init__(self, vitamins): self.vitamins = vitamins def antioxidants(self): pass Created by the classes checker.",
    "option": {}
  },
  "E0704": {
    "description": "[Status: stable] [Name: misplaced-bare-raise] [Message: The raise statement is not inside an except clause] Description: Used when a bare raise is not used inside an except clause. This generates an error, since there are no active exceptions to be reraised. An exception to this rule is represented by a bare raise inside a finally clause, which might work, as long as an exception is raised inside the try block, but it is nevertheless a code smell that must not be relied upon. Problematic code: def validate_positive(x): if x <= 0: raise # [misplaced-bare-raise] Correct code: def validate_positive(x): if x <= 0: raise ValueError(f\"{x} is not positive\") Created by the exceptions checker.",
    "option": {}
  },
  "E0119": {
    "description": "[Status: stable] [Name: misplaced-format-function] [Message: format function is not called on str] Description: Emitted when format function is not called on str object. e.g doing print(\"value: {}\").format(123) instead of print(\"value: {}\".format(123)). This might not be what the user intended to do. Problematic code: print(\"Value: {}\").format(\"Car\") # [misplaced-format-function] Correct code: print(\"Value: {}\".format(\"Car\")) Created by the basic checker.",
    "option": {}
  },
  "E1304": {
    "description": "[Status: stable] [Name: missing-format-string-key] [Message: Missing key %r in format string dictionary] Description: Used when a format string that uses named conversion specifiers is used with a dictionary that doesn't contain all the keys required by the format string. Problematic code: # +1: [missing-format-string-key] fruit_prices = \"\"\" Apple: %(apple_price)d ¤ Orange: %(orange_price)d ¤ \"\"\" % { \"apple_price\": 42 } Correct code: fruit_prices = \"\"\" Apple: %(apple_price)d ¤ Orange: %(orange_price)d ¤ \"\"\" % { \"apple_price\": 42, \"orange_price\": 87, } Created by the string checker.",
    "option": {}
  },
  "E1125": {
    "description": "[Status: stable] [Name: missing-kwoa] [Message: Missing mandatory keyword argument %r in %s call] Description: Used when a function call does not pass a mandatory keyword-only argument. Problematic code: def target(pos, *, keyword): return pos + keyword def not_forwarding_kwargs(*args, **kwargs): target(*args) # [missing-kwoa] Correct code: def target(pos, *, keyword): return pos + keyword def not_forwarding_kwargs(*args, **kwargs): target(*args, **kwargs) Created by the typecheck checker.",
    "option": {}
  },
  "E1302": {
    "description": "[Status: stable] [Name: mixed-format-string] [Message: Mixing named and unnamed conversion specifiers in format string] Description: Used when a format string contains both named (e.g. '%(foo)d') and unnamed (e.g. '%d') conversion specifiers. This is also used when a named conversion specifier contains * for the minimum field width and/or precision. Problematic code: print(\"x=%(x)d, y=%d\" % (0, 1)) # [mixed-format-string] Correct code: only_named.py: print(\"x=%(x)d, y=%(y)d\" % {\"x\": 0, \"y\": 1}) only_ordered.py: print(\"x=%d, y=%d\" % (0, 1)) Created by the string checker.",
    "option": {}
  },
  "E4702": {
    "description": "[Status: stable] [Name: modified-iterating-dict] [Message: Iterated dict '%s' is being modified inside for loop body, iterate through a copy of it instead.] Description: Emitted when items are added or removed to a dict being iterated through. Doing so raises a RuntimeError. Problematic code: fruits = {\"apple\": 1, \"orange\": 2, \"mango\": 3} i = 0 for fruit in fruits: fruits[\"apple\"] = i # [modified-iterating-dict] i += 1 Correct code: fruits = {\"apple\": 1, \"orange\": 2, \"mango\": 3} i = 0 for fruit in fruits.copy(): fruits[\"apple\"] = i i += 1 Created by the modified_iteration checker.",
    "option": {}
  },
  "E4703": {
    "description": "[Status: stable] [Name: modified-iterating-set] [Message: Iterated set '%s' is being modified inside for loop body, iterate through a copy of it instead.] Description: Emitted when items are added or removed to a set being iterated through. Doing so raises a RuntimeError. Problematic code: fruits = {\"apple\", \"orange\", \"mango\"} for fruit in fruits: fruits.add(fruit + \"yum\") # [modified-iterating-set] Correct code: fruits = {\"apple\", \"orange\", \"mango\"} for fruit in fruits.copy(): fruits.add(fruit + \"yum\") Created by the modified_iteration checker.",
    "option": {}
  },
  "E1904": {
    "description": "[Status: stable] [Name: multiple-class-sub-patterns] [Message: Multiple sub-patterns for attribute %s] Description: Emitted when there is more than one sub-pattern for a specific attribute in a class pattern. Problematic code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year def func(item: Book): match item: case Book(\"abc\", title=\"abc\"): # [multiple-class-sub-patterns] ... case Book(year=2000, year=2001): # [multiple-class-sub-patterns] ... Correct code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year def func(item: Book): match item: case Book(title=\"abc\"): ... case Book(year=2000): ... Related links: Python documentation Created by the match_statements checker.",
    "option": {}
  },
  "E1101": {
    "description": "[Status: stable] [Name: no-member] [Message: %s %r has no %r member%s] Description: Used when a variable is accessed for a nonexistent member. Problematic code: from pathlib import Path directories = Path(\".\").mothers # [no-member] class Cat: def meow(self): print(\"Meow\") Cat().roar() # [no-member] Correct code: from pathlib import Path directories = Path(\".\").parents class Cat: def meow(self): print(\"Meow\") Cat().meow() Additional details: If you are getting the dreaded no-member error, there is a possibility that either: pylint found a bug in your code You're launching pylint without the dependencies installed in its environment pylint would need to lint a C extension module and is refraining to do so pylint does not understand dynamically generated code Linting C extension modules is not supported out of the box, especially since pylint has no way to get an AST object out of the extension module. But pylint actually has a mechanism which you might use in case you want to analyze C extensions. Pylint has a flag, called extension-pkg-allow-list (formerly extension-pkg-whitelist), through which you can tell it to import that module and to build an AST from that imported module: $ pylint --extension-pkg-allow-list=your_c_extension Be aware though that using this flag means that extensions are loaded into the active Python interpreter and may run arbitrary code, which you may not want. This is the reason why we disable by default loading C extensions. In case you do not want the hassle of passing C extensions module with this flag all the time, you can enable unsafe-load-any-extension in your configuration file, which will build AST objects from all the C extensions that pylint encounters: $ pylint --unsafe-load-any-extension=y Alternatively, since pylint emits a separate error for attributes that cannot be found in C extensions, c-extension-no-member, you can disable this error for your project. If something is generated dynamically, pylint won't be able to understand the code from your library (c-extension or not). You can then specify generated attributes with the generated-members option. For example if cv2.LINE_AA and sphinx.generated_member create false positives for no-member, you can do: $ pylint --generated-member=cv2.LINE_AA,sphinx.generated_member Created by the typecheck checker.",
    "option": {}
  },
  "E0211": {
    "description": "[Status: stable] [Name: no-method-argument] [Message: Method %r has no argument] Description: Used when a method which should have the bound instance as first argument has no argument defined. Problematic code: class Person: def print_greeting(): # [no-method-argument] print(\"hello\") Correct code: class Person: def print_greeting(self): print(\"hello\") Created by the classes checker.",
    "option": {}
  },
  "E0611": {
    "description": "[Status: stable] [Name: no-name-in-module] [Message: No name %r in module %r] Description: Used when a name cannot be found in a module. Problematic code: from os import pizza # [no-name-in-module] Correct code: from os import path Created by the variables checker.",
    "option": {}
  },
  "E0213": {
    "description": "[Status: stable] [Name: no-self-argument] [Message: Method %r should have \"self\" as first argument] Description: Used when a method has an attribute different the \"self\" as first argument. This is considered as an error since this is a so common convention that you shouldn't break it! Problematic code: class Fruit: def __init__(this, name): # [no-self-argument] this.name = name Correct code: class Fruit: def __init__(self, name): self.name = name Created by the classes checker.",
    "option": {}
  },
  "E1120": {
    "description": "[Status: stable] [Name: no-value-for-parameter] [Message: No value for argument %s in %s call] Description: Used when a function call passes too few arguments. Problematic code: def add(x, y): return x + y add(1) # [no-value-for-parameter] Correct code: def add(x, y): return x + y add(1, 2) Created by the typecheck checker.",
    "option": {}
  },
  "E0301": {
    "description": "[Status: stable] [Name: non-iterator-returned] [Message: __iter__ returns non-iterator] Description: Used when an __iter__ method returns something which is not an iterable (i.e. has no `__next__` method) Problematic code: import random class GenericAstrology: def __init__(self, signs, predictions): self.signs = signs self.predictions = predictions def __iter__(self): # [non-iterator-returned] self.index = 0 self.number_of_prediction = len(self.predictions) return self SIGNS = [\"Aries\", \"Taurus\", \"Gemini\", \"Cancer\", \"Leo\", \"Virgo\", \"Libra\"] PREDICTIONS = [\"good things\", \"bad thing\", \"existential dread\"] for sign, prediction in GenericAstrology(SIGNS, PREDICTIONS): print(f\"{sign} : {prediction} today\") Correct code: import random class GenericAstrology: def __init__(self, signs, predictions): self.signs = signs self.predictions = predictions def __iter__(self): self.index = 0 self.number_of_prediction = len(self.predictions) return self def __next__(self): if self.index == len(self.signs): raise StopIteration self.index += 1 prediction_index = random.randint(0, self.number_of_prediction - 1) return self.signs[self.index - 1], self.predictions[prediction_index] SIGNS = [\"Aries\", \"Taurus\", \"Gemini\", \"Cancer\", \"Leo\", \"Virgo\", \"Libra\"] PREDICTIONS = [\"good things\", \"bad thing\", \"existential dread\"] for sign, prediction in GenericAstrology(SIGNS, PREDICTIONS): print(f\"{sign} : {prediction} today\") Created by the classes checker.",
    "option": {}
  },
  "E0107": {
    "description": "[Status: stable] [Name: nonexistent-operator] [Message: Use of the non-existent %s operator] Description: Used when you attempt to use the C-style pre-increment or pre-decrement operator -- and ++, which doesn't exist in Python. Problematic code: i = 0 while i <= 10: print(i) ++i # [nonexistent-operator] Correct code: i = 0 while i <= 10: print(i) i += 1 Created by the basic checker.",
    "option": {}
  },
  "E0115": {
    "description": "[Status: stable] [Name: nonlocal-and-global] [Message: Name %r is nonlocal and global] Description: Emitted when a name is both nonlocal and global. Problematic code: NUMBER = 42 def update_number(number): # [nonlocal-and-global] global NUMBER nonlocal NUMBER NUMBER = number print(f\"New global number is: {NUMBER}\") update_number(24) Correct code: NUMBER = 42 def update_number(number): global NUMBER NUMBER = number print(f\"New global number is: {NUMBER}\") update_number(24) Created by the basic checker.",
    "option": {}
  },
  "E0117": {
    "description": "[Status: stable] [Name: nonlocal-without-binding] [Message: nonlocal name %s found without binding] Description: Emitted when a nonlocal variable does not have an attached name somewhere in the parent scopes Problematic code: class Fruit: def get_color(self): nonlocal colors # [nonlocal-without-binding] Correct code: class Fruit: colors = [\"red\", \"green\"] def get_color(self): nonlocal colors Created by the basic checker.",
    "option": {}
  },
  "E1134": {
    "description": "[Status: stable] [Name: not-a-mapping] [Message: Non-mapping value %s is used in a mapping context] Description: Used when a non-mapping value is used in place where mapping is expected Problematic code: def print_colors(**colors): print(colors) print_colors(**list(\"red\", \"black\")) # [not-a-mapping] Correct code: def print_colors(**colors): print(colors) print_colors(**dict(red=1, black=2)) Created by the typecheck checker.",
    "option": {}
  },
  "E1133": {
    "description": "[Status: stable] [Name: not-an-iterable] [Message: Non-iterable value %s is used in an iterating context] Description: Used when a non-iterable value is used in place where iterable is expected Problematic code: for i in 10: # [not-an-iterable] pass Correct code: for i in \"10\": pass Created by the typecheck checker.",
    "option": {}
  },
  "E1701": {
    "description": "[Status: stable] [Name: not-async-context-manager] [Message: Async context manager '%s' doesn't implement __aenter__ and __aexit__.] Description: Used when an async context manager is used with an object that does not implement the async context management protocol. Problematic code: class ContextManager: def __enter__(self): pass def __exit__(self, *exc): pass async def foo(): async with ContextManager(): # [not-async-context-manager] pass Correct code: class AsyncContextManager: def __aenter__(self): pass def __aexit__(self, *exc): pass async def foo(): async with AsyncContextManager(): pass Additional details: Async context manager doesn't implement __aenter__ and __aexit__. It can't be emitted when using Python < 3.5. Created by the async checker.",
    "option": {}
  },
  "E1102": {
    "description": "[Status: stable] [Name: not-callable] [Message: %s is not callable] Description: Used when an object being called has been inferred to a non callable object. Problematic code: NUMBER = 42 print(NUMBER()) # [not-callable] Correct code: NUMBER = 42 print(NUMBER) Created by the typecheck checker.",
    "option": {}
  },
  "E1129": {
    "description": "[Status: stable] [Name: not-context-manager] [Message: Context manager '%s' doesn't implement __enter__ and __exit__.] Description: Used when an instance in a with statement doesn't implement the context manager protocol(__enter__/__exit__). Problematic code: class MyContextManager: def __enter__(self): pass with MyContextManager() as c: # [not-context-manager] pass Correct code: class MyContextManager: def __enter__(self): pass def __exit__(self, *exc): pass with MyContextManager() as c: pass Created by the typecheck checker.",
    "option": {}
  },
  "E0103": {
    "description": "[Status: stable] [Name: not-in-loop] [Message: %r not properly in loop] Description: Used when break or continue keywords are used outside a loop. Problematic code: def print_even_numbers(): for i in range(100): if i % 2 == 0: print(i) else: continue # [not-in-loop] Correct code: def print_even_numbers(): for i in range(100): if i % 2: continue print(i) Created by the basic checker.",
    "option": {}
  },
  "E0711": {
    "description": "[Status: stable] [Name: notimplemented-raised] [Message: NotImplemented raised - should raise NotImplementedError] Description: Used when NotImplemented is raised instead of NotImplementedError Problematic code: class Worm: def bore(self): raise NotImplemented # [notimplemented-raised] Correct code: class Worm: def bore(self): raise NotImplementedError Created by the exceptions checker.",
    "option": {}
  },
  "E3102": {
    "description": "[Status: stable] [Name: positional-only-arguments-expected] [Message: `%s()` got some positional-only arguments passed as keyword arguments: %s] Description: Emitted when positional-only arguments have been passed as keyword arguments. Remove the keywords for the affected arguments in the function call. Problematic code: def cube(n, /): \"\"\"Takes in a number n, returns the cube of n\"\"\" return n**3 cube(n=2) # [positional-only-arguments-expected] Correct code: def cube(n, /): \"\"\"Takes in a number n, returns the cube of n\"\"\" return n**3 cube(2) Related links: PEP 570 Created by the method_args checker.",
    "option": {}
  },
  "E0606": {
    "description": "[Status: stable] [Name: possibly-used-before-assignment] [Message: Possibly using variable %r before assignment] Description: Emitted when a local variable is accessed before its assignment took place in both branches of an if/else switch. Problematic code: def check_lunchbox(items: list[str]): if not items: empty = True print(empty) # [possibly-used-before-assignment] Correct code: def check_lunchbox(items: list[str]): empty = False if not items: empty = True print(empty) Additional details: You can use assert_never to mark exhaustive choices: from typing import assert_never def handle_date_suffix(suffix): if suffix == \"d\": ... elif suffix == \"m\": ... elif suffix == \"y\": ... else: assert_never(suffix) if suffix in \"dmy\": handle_date_suffix(suffix) Or, instead of assert_never(), you can call a function with a return annotation of Never or NoReturn. Unlike in the general case, where by design pylint ignores type annotations and does its own static analysis, here, pylint treats these special annotations like a disable comment. Pylint currently allows repeating the same test like this, even though this lets some error cases through, as pylint does not assess the intervening code: if guarded(): var = 1 # what if code here affects the result of guarded()? if guarded(): print(var) But this exception is limited to the repeating the exact same test. This warns: if guarded(): var = 1 if guarded() or other_condition: print(var) # [possibly-used-before-assignment] If you find this surprising, consider that pylint, as a static analysis tool, does not know if guarded() is deterministic or talks to a database. For variables (e.g. guarded versus guarded()), this is less of an issue, so in this case, possibly-used-before-assignment acts more like a future-proofing style preference than an error, per se. Created by the variables checker.",
    "option": {}
  },
  "E0643": {
    "description": "[Status: stable] [Name: potential-index-error] [Message: Invalid index for iterable length] Description: Emitted when an index used on an iterable goes beyond the length of that iterable. Problematic code: print([1, 2, 3][3]) # [potential-index-error] Correct code: print([1, 2, 3][2]) Created by the variables checker.",
    "option": {}
  },
  "E0702": {
    "description": "[Status: stable] [Name: raising-bad-type] [Message: Raising %s while only classes or instances are allowed] Description: Used when something which is neither a class nor an instance is raised (i.e. a `TypeError` will be raised). Problematic code: class FasterThanTheSpeedOfLightError(ZeroDivisionError): def __init__(self): super().__init__(\"You can't go faster than the speed of light !\") def calculate_speed(distance: float, time: float) -> float: try: return distance / time except ZeroDivisionError as e: raise None # [raising-bad-type] Correct code: class FasterThanTheSpeedOfLightError(ZeroDivisionError): def __init__(self): super().__init__(\"You can't go faster than the speed of light !\") def calculate_speed(distance: float, time: float) -> float: try: return distance / time except ZeroDivisionError as e: raise FasterThanTheSpeedOfLightError() from e Created by the exceptions checker.",
    "option": {}
  },
  "E0710": {
    "description": "[Status: stable] [Name: raising-non-exception] [Message: Raising a class which doesn't inherit from BaseException] Description: Used when a class which doesn't inherit from BaseException is raised. Problematic code: raise str # [raising-non-exception] Correct code: raise Exception(\"Goodbye world !\") Created by the exceptions checker.",
    "option": {}
  },
  "E1124": {
    "description": "[Status: stable] [Name: redundant-keyword-arg] [Message: Argument %r passed by position and keyword in %s call] Description: Used when a function call would result in assigning multiple values to a function parameter, one value from a positional argument and one from a keyword argument. Problematic code: def square(x): return x * x square(5, x=4) # [redundant-keyword-arg] Correct code: only_arg.py: def square(x): return x * x square(5) only_kwarg.py: def square(x): return x * x square(x=4) Created by the typecheck checker.",
    "option": {}
  },
  "E0402": {
    "description": "[Status: stable] [Name: relative-beyond-top-level] [Message: Attempted relative import beyond top-level package] Description: Used when a relative import tries to access too many levels in the current package. Problematic code: from ................antigravity import NGField # [relative-beyond-top-level] Correct code: absolute_import.py: from physic.antigravity import NGField fix_the_relative_import.py: # Right number of dots in the import: you needed 15 dots, not 16, duh. # from ...............antigravity import NGField Additional details: Absolute imports were strongly preferred, historically. Relative imports allow you to reorganize packages without changing any code, but these days refactoring tools and IDEs allow you to do that at almost no cost anyway if the imports are explicit/absolute. Therefore, absolute imports are often still preferred over relative ones. Related links: Absolute vs. explicit relative import of Python module Withdraw anti-recommendation of relative imports from documentation Created by the imports checker.",
    "option": {}
  },
  "E1132": {
    "description": "[Status: stable] [Name: repeated-keyword] [Message: Got multiple values for keyword argument %r in function call] Description: Emitted when a function call got multiple values for a keyword. Problematic code: def func(a, b, c): return a, b, c func(1, 2, c=3, **{\"c\": 4}) # [repeated-keyword] func(1, 2, **{\"c\": 3}, **{\"c\": 4}) # [repeated-keyword] Correct code: def func(a, b, c): return a, b, c func(1, 2, c=3) Created by the typecheck checker.",
    "option": {}
  },
  "E0106": {
    "description": "[Status: stable] [Name: return-arg-in-generator] [Message: Return with argument inside generator] Description: Used when a \"return\" statement with an argument is found in a generator function or method (e.g. with some \"yield\" statements). Correct code: def yield_numbers(): for number in range(10): yield number return \"I am now allowed!\" # This was not allowed in Python 3.3 and earlier. Additional details: This is a message that isn't going to be raised for python > 3.3. It was raised for code like: def interrogate_until_you_find_jack(pirates): for pirate in pirates: if pirate == \"Captain Jack Sparrow\": return \"Arrr! We've found our captain!\" yield pirate Which is now valid and equivalent to the previously expected: def interrogate_until_you_find_jack(pirates): for pirate in pirates: if pirate == \"Captain Jack Sparrow\": raise StopIteration(\"Arrr! We've found our captain!\") yield pirate Related links: PEP380 Stackoverflow explanation Created by the basic checker.",
    "option": {}
  },
  "E0101": {
    "description": "[Status: stable] [Name: return-in-init] [Message: Explicit return in __init__] Description: Used when the special class method __init__ has an explicit return value. Problematic code: class Sum: def __init__(self, a, b): # [return-in-init] return a + b Correct code: class Sum: def __init__(self, a, b) -> None: self.result = a + b Related links: __init__ method documentation Created by the basic checker.",
    "option": {}
  },
  "E0104": {
    "description": "[Status: stable] [Name: return-outside-function] [Message: Return outside function] Description: Used when a \"return\" statement is found outside a function or method. Problematic code: return 42 # [return-outside-function] Correct code: def get_the_answer(): return 42 Created by the basic checker.",
    "option": {}
  },
  "E1519": {
    "description": "[Status: stable] [Name: singledispatch-method] [Message: singledispatch decorator should not be used with methods, use singledispatchmethod instead.] Description: singledispatch should decorate functions and not class/instance methods. Use singledispatchmethod for those cases. Problematic code: from functools import singledispatch class Board: @singledispatch # [singledispatch-method] def convert_position(self, position): pass @convert_position.register # [singledispatch-method] def _(self, position: str) -> tuple: position_a, position_b = position.split(\",\") return (int(position_a), int(position_b)) @convert_position.register # [singledispatch-method] def _(self, position: tuple) -> str: return f\"{position[0]},{position[1]}\" Correct code: from functools import singledispatch @singledispatch def convert_position(position): print(position) @convert_position.register def _(position: str) -> tuple: position_a, position_b = position.split(\",\") return (int(position_a), int(position_b)) @convert_position.register def _(position: tuple) -> str: return f\"{position[0]},{position[1]}\" Created by the stdlib checker.",
    "option": {}
  },
  "E1520": {
    "description": "[Status: stable] [Name: singledispatchmethod-function] [Message: singledispatchmethod decorator should not be used with functions, use singledispatch instead.] Description: singledispatchmethod should decorate class/instance methods and not functions. Use singledispatch for those cases. Problematic code: from functools import singledispatchmethod @singledispatchmethod # [singledispatchmethod-function] def convert_position(position): print(position) @convert_position.register # [singledispatchmethod-function] def _(position: str) -> tuple: position_a, position_b = position.split(\",\") return (int(position_a), int(position_b)) @convert_position.register # [singledispatchmethod-function] def _(position: tuple) -> str: return f\"{position[0]},{position[1]}\" Correct code: from functools import singledispatchmethod class Board: @singledispatchmethod def convert_position(cls, position): pass @singledispatchmethod @classmethod def _(cls, position: str) -> tuple: position_a, position_b = position.split(\",\") return (int(position_a), int(position_b)) @singledispatchmethod @classmethod def _(cls, position: tuple) -> str: return f\"{position[0]},{position[1]}\" Created by the stdlib checker.",
    "option": {}
  },
  "E0114": {
    "description": "[Status: stable] [Name: star-needs-assignment-target] [Message: Can use starred expression only in assignment target] Description: Emitted when a star expression is not used in an assignment target. Problematic code: stars = *[\"Sirius\", \"Arcturus\", \"Vega\"] # [star-needs-assignment-target] Correct code: sirius, *arcturus_and_vega = [\"Sirius\", \"Arcturus\", \"Vega\"] Created by the basic checker.",
    "option": {}
  },
  "E0001": {
    "description": "[Status: stable] [Name: syntax-error] [Message: %s] Description: Used when a syntax error is raised for a module. Problematic code: fruit_stock = { 'apple': 42, 'orange': 21 # [syntax-error] 'banana': 12 } Correct code: fruit_stock = {\"apple\": 42, \"orange\": 21, \"banana\": 12} Additional details: The python's ast builtin module cannot parse your code if there's a syntax error, so if there's a syntax error other messages won't be available at all. Related links: Why can't pylint recover from a syntax error ? Created by the main checker.",
    "option": {}
  },
  "E1306": {
    "description": "[Status: stable] [Name: too-few-format-args] [Message: Not enough arguments for format string] Description: Used when a format string that uses unnamed conversion specifiers is given too few arguments Problematic code: print(\"Today is {0}, so tomorrow will be {1}\".format(\"Monday\")) # [too-few-format-args] Correct code: print(\"Today is {0}, so tomorrow will be {1}\".format(\"Monday\", \"Tuesday\")) Related links: String Formatting Created by the string checker.",
    "option": {}
  },
  "E1305": {
    "description": "[Status: stable] [Name: too-many-format-args] [Message: Too many arguments for format string] Description: Used when a format string that uses unnamed conversion specifiers is given too many arguments. Problematic code: # +1: [too-many-format-args] print(\"Today is {0}, so tomorrow will be {1}\".format(\"Monday\", \"Tuesday\", \"Wednesday\")) Correct code: print(\"Today is {0}, so tomorrow will be {1}\".format(\"Monday\", \"Tuesday\")) Related links: String Formatting Created by the string checker.",
    "option": {}
  },
  "E1121": {
    "description": "[Status: stable] [Name: too-many-function-args] [Message: Too many positional arguments for %s call] Description: Used when a function call passes too many positional arguments. Problematic code: class Fruit: def __init__(self, color): self.color = color apple = Fruit(\"red\", \"apple\", [1, 2, 3]) # [too-many-function-args] Correct code: class Fruit: def __init__(self, color, name): self.color = color self.name = name apple = Fruit(\"red\", \"apple\") Created by the typecheck checker.",
    "option": {}
  },
  "E1903": {
    "description": "[Status: stable] [Name: too-many-positional-sub-patterns] [Message: %s expects %d positional sub-patterns (given %d)] Description: Emitted when the number of allowed positional sub-patterns exceeds the number of allowed sub-patterns specified in `__match_args__`. Problematic code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year, author): self.title = title self.year = year self.author = author def func(item: Book): match item: case Book(\"title\", 2000, \"author\"): # [too-many-positional-sub-patterns] ... Correct code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year, author): self.title = title self.year = year self.author = author def func(item: Book): match item: case Book(\"title\", 2000, author=\"author\"): ... Related links: Python documentation Created by the match_statements checker.",
    "option": {}
  },
  "E0112": {
    "description": "[Status: stable] [Name: too-many-star-expressions] [Message: More than one starred expression in assignment] Description: Emitted when there are more than one starred expressions (`*x`) in an assignment. This is a SyntaxError. Problematic code: *stars, *constellations = [\"Sirius\", \"Arcturus\", \"Vega\"] # [too-many-star-expressions] Correct code: *sirius_and_arcturus, vega = [\"Sirius\", \"Arcturus\", \"Vega\"] Created by the basic checker.",
    "option": {}
  },
  "E1301": {
    "description": "[Status: stable] [Name: truncated-format-string] [Message: Format string ends in middle of conversion specifier] Description: Used when a format string terminates before the end of a conversion specifier. Problematic code: PARG_2 = 1 print(\"strange format %2\" % PARG_2) # [truncated-format-string] Correct code: PARG_2 = 1 print(f\"strange format {PARG_2}\") Created by the string checker.",
    "option": {}
  },
  "E0603": {
    "description": "[Status: stable] [Name: undefined-all-variable] [Message: Undefined variable name %r in __all__] Description: Used when an undefined variable name is referenced in __all__. Problematic code: __all__ = [\"get_fruit_colour\"] # [undefined-all-variable] def get_fruit_color(): pass Correct code: __all__ = [\"get_fruit_color\"] def get_fruit_color(): pass Related links: Importing * From a Package Created by the variables checker.",
    "option": {}
  },
  "E0602": {
    "description": "[Status: stable] [Name: undefined-variable] [Message: Undefined variable %r] Description: Used when an undefined variable is accessed. Problematic code: print(number + 2) # [undefined-variable] Correct code: number = 3 print(number + 2) Created by the variables checker.",
    "option": {}
  },
  "E1123": {
    "description": "[Status: stable] [Name: unexpected-keyword-arg] [Message: Unexpected keyword argument %r in %s call] Description: Used when a function call passes a keyword argument that doesn't correspond to one of the function's parameter names. Problematic code: def print_coordinates(x=0, y=0): print(f\"{x=}, {y=}\") print_coordinates(x=1, y=2, z=3) # [unexpected-keyword-arg] Correct code: def print_coordinates(x=0, y=0): print(f\"{x=}, {y=}\") print_coordinates(x=1, y=2) Created by the typecheck checker.",
    "option": {}
  },
  "E0302": {
    "description": "[Status: stable] [Name: unexpected-special-method-signature] [Message: The special method %r expects %s param(s), %d %s given] Description: Emitted when a special method was defined with an invalid number of parameters. If it has too few or too many, it might not work at all. Problematic code: class ContextManager: def __enter__(self, context): # [unexpected-special-method-signature] pass def __exit__(self, type): # [unexpected-special-method-signature] pass Correct code: class ContextManager: def __enter__(self): pass def __exit__(self, type, value, traceback): pass Created by the classes checker.",
    "option": {}
  },
  "E1143": {
    "description": "[Status: stable] [Name: unhashable-member] [Message: '%s' is unhashable and can't be used as a %s in a %s] Description: Emitted when a dict key or set member is not hashable (i.e. doesn't define __hash__ method). Problematic code: # Print the number of apples: print({\"apple\": 42}[[\"apple\"]]) # [unhashable-member] Correct code: # Print the number of apples: print({\"apple\": 42}[\"apple\"]) Created by the typecheck checker.",
    "option": {}
  },
  "E0633": {
    "description": "[Status: stable] [Name: unpacking-non-sequence] [Message: Attempting to unpack a non-sequence%s] Description: Used when something which is not a sequence is used in an unpack assignment Problematic code: a, b, c = 1 # [unpacking-non-sequence] Correct code: a, b, c = 1, 2, 3 Created by the variables checker.",
    "option": {}
  },
  "E0011": {
    "description": "[Status: stable] [Name: unrecognized-inline-option] [Message: Unrecognized file option %r] Description: Used when an unknown inline option is encountered. Problematic code: # +1: [unrecognized-inline-option] # pylint:applesoranges=1 Correct code: # pylint: enable=too-many-public-methods Created by the main checker.",
    "option": {}
  },
  "E0015": {
    "description": "[Status: stable] [Name: unrecognized-option] [Message: Unrecognized option found: %s] Description: Used when we detect an option that we do not recognize. Additional details: One of your options is not recognized. There's nothing to change in your code, but your pylint configuration or the way you launch pylint needs to be modified. For example, this message would be raised when invoking pylint with pylint --unknown-option=yes test.py. Or you might be launching pylint with the following toml configuration: [tool.pylint] jars = \"10\" When the following should be used: [tool.pylint] jobs = \"10\" This warning was released in pylint 2.14: bad options were silently failing before. Created by the main checker.",
    "option": {}
  },
  "E1136": {
    "description": "[Status: stable] [Name: unsubscriptable-object] [Message: Value '%s' is unsubscriptable] Description: Emitted when a subscripted value doesn't support subscription (i.e. doesn't define __getitem__ method or __class_getitem__ for a class). Problematic code: class Fruit: pass Fruit()[1] # [unsubscriptable-object] Correct code: class Fruit: def __init__(self): self.colors = [\"red\", \"orange\", \"yellow\"] def __getitem__(self, idx): return self.colors[idx] Fruit()[1] Created by the typecheck checker.",
    "option": {}
  },
  "E1137": {
    "description": "[Status: stable] [Name: unsupported-assignment-operation] [Message: %r does not support item assignment] Description: Emitted when an object does not support item assignment (i.e. doesn't define __setitem__ method). Problematic code: def pick_fruits(fruits): for fruit in fruits: print(fruit) pick_fruits([\"apple\"])[0] = \"orange\" # [unsupported-assignment-operation] Correct code: def pick_fruits(fruits): for fruit in fruits: print(fruit) return [] pick_fruits([\"apple\"])[0] = \"orange\" Created by the typecheck checker.",
    "option": {}
  },
  "E1131": {
    "description": "[Status: stable] [Name: unsupported-binary-operation] [Message: %s] Description: Emitted when a binary arithmetic operation between two operands is not supported. Problematic code: drink = \"water\" | None # [unsupported-binary-operation] result = [] | None # [unsupported-binary-operation] Correct code: masked = 0b111111 & 0b001100 result = 0xAEFF | 0x0B99 Configuration file: [main] py-version=3.9 Created by the typecheck checker.",
    "option": {}
  },
  "E1138": {
    "description": "[Status: stable] [Name: unsupported-delete-operation] [Message: %r does not support item deletion] Description: Emitted when an object does not support item deletion (i.e. doesn't define __delitem__ method). Problematic code: FRUITS = (\"apple\", \"orange\", \"berry\") del FRUITS[0] # [unsupported-delete-operation] Correct code: FRUITS = [\"apple\", \"orange\", \"berry\"] del FRUITS[0] Created by the typecheck checker.",
    "option": {}
  },
  "E1135": {
    "description": "[Status: stable] [Name: unsupported-membership-test] [Message: Value '%s' doesn't support membership test] Description: Emitted when an instance in membership test expression doesn't implement membership protocol (__contains__/__iter__/__getitem__). Problematic code: class Fruit: pass apple = \"apple\" in Fruit() # [unsupported-membership-test] Correct code: class Fruit: FRUITS = [\"apple\", \"orange\"] def __contains__(self, name): return name in self.FRUITS apple = \"apple\" in Fruit() Created by the typecheck checker.",
    "option": {}
  },
  "E0601": {
    "description": "[Status: stable] [Name: used-before-assignment] [Message: Using variable %r before assignment] Description: Emitted when a local variable is accessed before its assignment took place. Assignments in try blocks are assumed not to have occurred when evaluating associated except/finally blocks. Assignments in except blocks are assumed not to have occurred when evaluating statements outside the block, except when the associated try block contains a return statement. Problematic code: print(hello) # [used-before-assignment] hello = \"Hello World !\" Correct code: hello = \"Hello World !\" print(hello) Created by the variables checker.",
    "option": {}
  },
  "E0118": {
    "description": "[Status: stable] [Name: used-prior-global-declaration] [Message: Name %r is used prior to global declaration] Description: Emitted when a name is used prior a global declaration, which results in an error since Python 3.6. Problematic code: TOMATO = \"black cherry\" def update_tomato(): print(TOMATO) # [used-prior-global-declaration] global TOMATO TOMATO = \"cherry tomato\" Correct code: TOMATO = \"black cherry\" def update_tomato(): global TOMATO TOMATO = \"moneymaker\" Created by the basic checker.",
    "option": {}
  },
  "E1700": {
    "description": "[Status: stable] [Name: yield-inside-async-function] [Message: Yield inside async function] Description: Used when an `yield` or `yield from` statement is found inside an async function. Problematic code: async def foo(): yield from [1, 2, 3] # [yield-inside-async-function] Correct code: async def foo(): def _inner_foo(): yield from [1, 2, 3] async def foo(): yield 42 Additional details: The message can't be emitted when using Python < 3.5. Related links: PEP 525 Created by the async checker.",
    "option": {}
  },
  "E0105": {
    "description": "[Status: stable] [Name: yield-outside-function] [Message: Yield outside function] Description: Used when a \"yield\" statement is found outside a function or method. Problematic code: for i in range(10): yield i # [yield-outside-function] Correct code: def one_to_ten(): for i in range(10): yield i Created by the basic checker.",
    "option": {}
  },
  "E0235": {
    "description": "[Status: stable] [Name: bad-context-manager]",
    "option": {}
  },
  "E0703": {
    "description": "[Status: stable] [Name: bad-exception-context]",
    "option": {}
  },
  "E0012": {
    "description": "[Status: stable] [Name: bad-option-value]",
    "option": {}
  },
  "E1103": {
    "description": "[Status: stable] [Name: maybe-no-member]",
    "option": {}
  },
  "E1140": {
    "description": "[Status: stable] [Name: unhashable-dict-key]",
    "option": {}
  },
  "W0223": {
    "description": "[Status: stable] [Name: abstract-method] [Message: Method %r is abstract in class %r but is not overridden in child class %r] Description: Used when an abstract method (i.e. raise NotImplementedError) is not overridden in concrete class. Problematic code: abstract_method.py: import abc class WildAnimal: @abc.abstractmethod def make_sound(self): pass class Panther(WildAnimal): # [abstract-method] pass function_raising_not_implemented_error.py: class Pet: def make_sound(self): raise NotImplementedError class Cat(Pet): # [abstract-method] pass Correct code: abstract_method.py: import abc class WildAnimal: @abc.abstractmethod def make_sound(self): pass class Panther(WildAnimal): def make_sound(self): print(\"MEEEOW\") function_raising_not_implemented_error.py: class Pet: def make_sound(self): raise NotImplementedError class Cat(Pet): def make_sound(self): print(\"Meeeow\") Created by the classes checker.",
    "option": {}
  },
  "W1401": {
    "description": "[Status: stable] [Name: anomalous-backslash-in-string] [Message: Anomalous backslash in string: '%s'. String constant might be missing an r prefix.] Description: Used when a backslash is in a literal string but not as an escape. Problematic code: string = \"\\z\" # [syntax-error] Correct code: double_escape.py: string = \"\\\\z\" existing_escape_sequence.py: string = \"\\t\" r_prefix.py: string = r\"\\z\" Additional details: \\z is same as \\\\z because there's no escape sequence for z. But it is not clear for the reader of the code. The only reason this is demonstrated to raise syntax-error is because pylint's CI now runs on Python 3.12, where this truly raises a SyntaxError. We hope to address this discrepancy in the documentation in the future. Related links: String and Bytes literals Long form stackoverflow explanation Created by the string checker.",
    "option": {}
  },
  "W1402": {
    "description": "[Status: stable] [Name: anomalous-unicode-escape-in-string] [Message: Anomalous Unicode escape in byte string: '%s'. String constant might be missing an r or u prefix.] Description: Used when an escape like u is encountered in a byte string where it has no effect. Problematic code: print(b\"\\u%b\" % b\"0394\") # [syntax-error] Correct code: print(b\"\\\\u%b\" % b\"0394\") Created by the string checker.",
    "option": {}
  },
  "W0221": {
    "description": "[Status: stable] [Name: arguments-differ] [Message: %s %s %r method] Description: Used when a method has a different number of arguments than in the implemented interface or in an overridden method. Extra arguments with default values are ignored. Problematic code: class Drink: def mix(self, fluid_one, fluid_two): return fluid_one + fluid_two class Cocktail(Drink): def mix(self, fluid_one, fluid_two, alcoholic_fluid): # [arguments-differ] return fluid_one + fluid_two + alcoholic_fluid Correct code: add_option_in_base_class.py: \"\"\" Here we assume that drink and cocktail are the same thing and should actually inherit from each over. We also assume that 'Drink' are 'Cocktail' without alcohol (we added the alcohol option in the base class). This permit to not have to modify the cocktails calls downstream but the case where an alcohol is mixed in a soft drink will need to be handled. \"\"\" class Drink: def mix(self, fluid_one, fluid_two, alcoholic_fluid=None): # if alcoholic_fluid is not None: # raise Exception(f\"This soft drink has {alcoholic_fluid} in it !\") return fluid_one + fluid_two class Cocktail(Drink): def mix(self, fluid_one, fluid_two, alcoholic_fluid): return fluid_one + fluid_two + alcoholic_fluid default_value.py: \"\"\" Here we assume that drink and cocktail are the same thing and should actually inherit from each over. We also assume that any Cocktail can be treated like a Drink (if you add beer to it). This permit to not have to modify the calls downstream and causes the least amount of disturbance at the cost of making cocktails beer-based implicitly. \"\"\" class Drink: def mix(self, fluid_one, fluid_two): return fluid_one + fluid_two class Cocktail(Drink): def mix(self, fluid_one, fluid_two, alcoholic_fluid=\"Beer\"): return fluid_one + fluid_two + alcoholic_fluid no_inheritance.py: \"\"\" Here we assume that 'Drink' and 'Cocktail' are different things and should not be treated together like if they were the same thing. This will force some downstream changes and force the API user to make a conscious decision about the alcoholic content of its drink when using the API. For example, it's impossible to create a mojito with beer without explicitly wanting to, or to add an alcohol to a soft-drink. \"\"\" class Drink: def mix(self, fluid_one, fluid_two): return fluid_one + fluid_two class Cocktail: def mix(self, fluid_one, fluid_two, alcoholic_fluid): return fluid_one + fluid_two + alcoholic_fluid Additional details: argument-differ denotes an issue with the Liskov Substitution Principle. This means that the code in question violates an important design principle which does not have one single solution. We recommend to search online for the best solution in your case. To give some examples of potential solutions: Add the argument to the parent class Remove the inheritance completely Add default arguments to the child class Related links: Liskov Substitution Principle Created by the classes checker.",
    "option": {}
  },
  "W1114": {
    "description": "[Status: stable] [Name: arguments-out-of-order] [Message: Positional arguments appear to be out of order] Description: Emitted when the caller's argument names fully match the parameter names in the function signature but do not have the same order. Problematic code: def function_3_args(first_argument, second_argument, third_argument): \"\"\"Three arguments function\"\"\" return first_argument, second_argument, third_argument def args_out_of_order(): first_argument = 1 second_argument = 2 third_argument = 3 function_3_args( # [arguments-out-of-order] first_argument, third_argument, second_argument ) Correct code: def function_3_args(first_argument, second_argument, third_argument): \"\"\"Three arguments function\"\"\" return first_argument, second_argument, third_argument def args_out_of_order(): first_argument = 1 second_argument = 2 third_argument = 3 function_3_args(first_argument, second_argument, third_argument) Created by the typecheck checker.",
    "option": {}
  },
  "W0237": {
    "description": "[Status: stable] [Name: arguments-renamed] [Message: %s %s %r method] Description: Used when a method parameter has a different name than in the implemented interface or in an overridden method. Problematic code: class Fruit: def brew(self, ingredient_name: str): print(f\"Brewing a {type(self)} with {ingredient_name}\") class Apple(Fruit): ... class Orange(Fruit): def brew(self, flavor: str): # [arguments-renamed] print(f\"Brewing an orange with {flavor}\") for fruit, ingredient_name in [[Orange(), \"thyme\"], [Apple(), \"cinnamon\"]]: fruit.brew(ingredient_name=ingredient_name) Correct code: class Fruit: def brew(self, ingredient_name: str): print(f\"Brewing a {type(self)} with {ingredient_name}\") class Apple(Fruit): ... class Orange(Fruit): def brew(self, ingredient_name: str): print(f\"Brewing an orange with {ingredient_name}\") for fruit, ingredient_name in [[Orange(), \"thyme\"], [Apple(), \"cinnamon\"]]: fruit.brew(ingredient_name=ingredient_name) Created by the classes checker.",
    "option": {}
  },
  "W0129": {
    "description": "[Status: stable] [Name: assert-on-string-literal] [Message: Assert statement has a string literal as its first argument. The assert will %s fail.] Description: Used when an assert statement has a string literal as its first argument, which will cause the assert to always pass. Problematic code: def test_division(): a = 9 / 3 assert \"No ZeroDivisionError were raised\" # [assert-on-string-literal] Correct code: def test_division(): a = 9 / 3 assert a == 3 Additional details: Directly asserting a string literal will always pass. The solution is to test something that could fail, or not assert at all. For unittest assertions there is the similar redundant-unittest-assert / W1503 message. Related links: Tests without assertion Testing that there is no error raised Parametrizing conditional raising Created by the basic checker.",
    "option": {}
  },
  "W0199": {
    "description": "[Status: stable] [Name: assert-on-tuple] [Message: Assert called on a populated tuple. Did you mean 'assert x,y'?] Description: A call of assert on a tuple will always evaluate to true if the tuple is not empty, and will always evaluate to false if it is. Problematic code: assert (1, None) # [assert-on-tuple] Correct code: x, y = (1, None) assert x assert y Additional details: Directly asserting a non-empty tuple will always pass. The solution is totest something that could fail, or not assert at all. For unittest assertions there is the similar redundant-unittest-assert / W1503 message. Created by the basic checker.",
    "option": {}
  },
  "W0201": {
    "description": "[Status: stable] [Name: attribute-defined-outside-init] [Message: Attribute %r defined outside __init__] Description: Used when an instance attribute is defined outside the __init__ method. Problematic code: class Student: def register(self): self.is_registered = True # [attribute-defined-outside-init] Correct code: class Student: def __init__(self): self.is_registered = False def register(self): self.is_registered = True Created by the classes checker.",
    "option": {}
  },
  "W0141": {
    "description": "[Status: stable] [Name: bad-builtin] [Message: Used builtin function %s] Description: Used when a disallowed builtin function is used (see the bad-function option). Usual disallowed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension. Problematic code: numbers = list(map(lambda x: 2 * x, [1, 2, 3])) # [bad-builtin] print(numbers) Correct code: numbers = [2 * x for x in [1, 2, 3]] print(numbers) Configuration file: [MAIN] load-plugins = pylint.extensions.bad_builtin Note This message is emitted by the optional 'deprecated_builtins' checker, which requires the pylint.extensions.bad_builtin plugin to be loaded. Created by the deprecated_builtins checker.",
    "option": {}
  },
  "W3601": {
    "description": "[Status: stable] [Name: bad-chained-comparison] [Message: Suspicious %s-part chained comparison using semantically incompatible operators (%s)] Description: Used when there is a chained comparison where one expression is part of two comparisons that belong to different semantic groups (\"<\" does not mean the same thing as \"is\", chaining them in \"0 < x is None\" is probably a mistake). Problematic code: parrot.py: shop = { # animal: (specie, descriptions) \"parrot\": (\"Norvegian blue\", (\"restin'\", \"remarkable\", \"beautiful plumage\")), } if \"parrot\" in shop is \"restin'\": # [bad-chained-comparison] print(\"Hellooooo, Pooolllllyyy ! WAAAAKEEY, WAKKEEEY !\") xor.py: def xor_check(*, left=None, right=None): if left is None != right is None: # [bad-chained-comparison] raise ValueError( \"Either both left= and right= need to be provided or none should.\" ) Correct code: parrot.py: shop = { # animal: (specie, descriptions) \"parrot\": (\"Norvegian blue\", (\"restin'\", \"remarkable\", \"beautiful plumage\")), } if \"parrot\" in shop and \"restin'\" in shop[\"parrot\"][1]: print(\"Hellooooo, Pooolllllyyy ! WAAAAKEEY, WAKKEEEY !\") xor.py: def xor_check(*, left=None, right=None): if (left is None) != (right is None): raise ValueError( \"Either both left= and right= need to be provided or none should.\" ) Related links: Comparison Chaining Created by the bad-chained-comparison checker.",
    "option": {}
  },
  "W3201": {
    "description": "[Status: stable] [Name: bad-dunder-name] [Message: Bad or misspelled dunder method name %s.] Description: Used when a dunder method is misspelled or defined with a name not within the predefined list of dunder names. Problematic code: class Apples: def _init_(self): # [bad-dunder-name] pass def __hello__(self): # [bad-dunder-name] print(\"hello\") Correct code: class Apples: def __init__(self): pass def hello(self): print(\"hello\") Configuration file: [MAIN] load-plugins=pylint.extensions.dunder Note This message is emitted by the optional 'dunder' checker, which requires the pylint.extensions.dunder plugin to be loaded. Created by the dunder checker.",
    "option": {}
  },
  "W1302": {
    "description": "[Status: stable] [Name: bad-format-string] [Message: Invalid format string] Description: Used when a PEP 3101 format string is invalid. Problematic code: print(\"{a[0] + a[1]}\".format(a=[0, 1])) # [bad-format-string] Correct code: print(\"{a[0]} + {a[1]}\".format(a=[0, 1])) Related links: Format String Syntax PyFormat Created by the string checker.",
    "option": {}
  },
  "W1300": {
    "description": "[Status: stable] [Name: bad-format-string-key] [Message: Format string dictionary key should be a string, not %s] Description: Used when a format string that uses named conversion specifiers is used with a dictionary whose keys are not all strings. Problematic code: print(\"%(one)d\" % {\"one\": 1, 2: 2}) # [bad-format-string-key] Correct code: print(\"%(one)d, %(two)d\" % {\"one\": 1, \"two\": 2}) Additional details: This check only works for old-style string formatting using the '%' operator. This check only works if the dictionary with the values to be formatted is defined inline. Passing a variable will not trigger the check as the other keys in this dictionary may be used in other contexts, while an inline defined dictionary is clearly only intended to hold the values that should be formatted. Created by the string checker.",
    "option": {}
  },
  "W0311": {
    "description": "[Status: stable] [Name: bad-indentation] [Message: Bad indentation. Found %s %s, expected %s] Description: Used when an unexpected number of indentation's tabulations or spaces has been found. Problematic code: if input(): print('yes') # [bad-indentation] Correct code: if input(): print(\"yes\") Additional details: The option --indent-string can be used to set the indentation unit for this check. Created by the format checker.",
    "option": {}
  },
  "W1501": {
    "description": "[Status: stable] [Name: bad-open-mode] [Message: \"%s\" is not a valid mode for open.] Description: Python supports: r, w, a[, x] modes with b, +, and U (only with r) options. See https://docs.python.org/3/library/functions.html#open Problematic code: def open_and_get_content(file_path): with open(file_path, \"rwx\") as file: # [bad-open-mode] return file.read() Correct code: def open_and_get_content(file_path): with open(file_path, \"r\") as file: return file.read() Created by the stdlib checker.",
    "option": {}
  },
  "W0211": {
    "description": "[Status: stable] [Name: bad-staticmethod-argument] [Message: Static method with %r as first argument] Description: Used when a static method has \"self\" or a value specified in valid-classmethod-first-arg option or valid-metaclass-classmethod-first-arg option as first argument. Problematic code: class Wolf: @staticmethod def eat(self): # [bad-staticmethod-argument] pass Correct code: class Wolf: @staticmethod def eat(sheep): pass Created by the classes checker.",
    "option": {}
  },
  "W1506": {
    "description": "[Status: stable] [Name: bad-thread-instantiation] [Message: threading.Thread needs the target function] Description: The warning is emitted when a threading.Thread class is instantiated without the target function being passed as a kwarg or as a second argument. By default, the first parameter is the group param, not the target param. Problematic code: import threading def thread_target(n): print(n**2) thread = threading.Thread(lambda: None) # [bad-thread-instantiation] thread.start() Correct code: import threading def thread_target(n): print(n**2) thread = threading.Thread(target=thread_target, args=(10,)) thread.start() Created by the stdlib checker.",
    "option": {}
  },
  "W0702": {
    "description": "[Status: stable] [Name: bare-except] [Message: No exception type(s) specified] Description: A bare ``except:`` clause will catch ``SystemExit`` and ``KeyboardInterrupt`` exceptions, making it harder to interrupt a program with ``Control-C``, and can disguise other problems. If you want to catch all exceptions that signal program errors, use ``except Exception:`` (bare except is equivalent to ``except BaseException:``). Problematic code: try: import platform_specific_module except: # [bare-except] platform_specific_module = None Correct code: try: import platform_specific_module except ImportError: platform_specific_module = None Additional details: A good rule of thumb is to limit use of bare ‘except’ clauses to two cases: - If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred. - If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise. try...finally can be a better way to handle this case. Related links: Programming recommendation in PEP8 PEP 760 – No More Bare Excepts (Rejected) Discussion about PEP 760 Created by the exceptions checker.",
    "option": {}
  },
  "W0711": {
    "description": "[Status: stable] [Name: binary-op-exception] [Message: Exception to catch is the result of a binary \"%s\" operation] Description: Used when the exception to catch is of the form \"except A or B:\". If intending to catch multiple, rewrite as \"except (A, B):\" Problematic code: try: 1 / 0 except ZeroDivisionError or ValueError: # [binary-op-exception] pass Correct code: try: 1 / 0 except (ZeroDivisionError, ValueError): pass Created by the exceptions checker.",
    "option": {}
  },
  "W1502": {
    "description": "[Status: stable] [Name: boolean-datetime] [Message: Using datetime.time in a boolean context.] Description: Using datetime.time in a boolean context can hide subtle bugs when the time they represent matches midnight UTC. This behaviour was fixed in Python 3.5. See https://bugs.python.org/issue13936 for reference. Problematic code: import datetime if datetime.time(): # [boolean-datetime] print(\"It is time.\") if datetime.datetime.now().time(): # [boolean-datetime] print(\"Now or never.\") Correct code: import datetime time_now_utc = datetime.datetime.now(tz=datetime.UTC).time() if time_now_utc > datetime.time(6, 0): print(\"Daytime!\") if time_now_utc < datetime.time(6, 0): print(\"Nighttime!\") Configuration file: [main] py-version=3.4 Related links: Python bug tracker Created by the stdlib checker.",
    "option": {}
  },
  "W0137": {
    "description": "[Status: stable] [Name: break-in-finally] [Message: 'break' discouraged inside 'finally' clause] Description: Emitted when the `break` keyword is found inside a finally clause. This will raise a SyntaxWarning starting in Python 3.14. Problematic code: while True: try: pass finally: break # [break-in-finally] Correct code: while True: try: pass except ValueError: pass else: break Related links: Python 3 docs 'finally' clause PEP 765 - Disallow return/break/continue that exit a finally block Created by the basic checker.",
    "option": {}
  },
  "W0718": {
    "description": "[Status: stable] [Name: broad-exception-caught] [Message: Catching too general exception %s] Description: If you use a naked ``except Exception:`` clause, you might end up catching exceptions other than the ones you expect to catch. This can hide bugs or make it harder to debug programs when unrelated errors are hidden. Problematic code: try: import platform_specific_module except Exception: # [broad-exception-caught] platform_specific_module = None Correct code: try: import platform_specific_module except ImportError: platform_specific_module = None Additional details: For example, you're trying to import a library with required system dependencies and you catch everything instead of only import errors, you will miss the error message telling you, that your code could work if you had installed the system dependencies. Related links: Should I always specify an exception type in 'except' statements? Created by the exceptions checker.",
    "option": {}
  },
  "W0719": {
    "description": "[Status: stable] [Name: broad-exception-raised] [Message: Raising too general exception: %s] Description: Raising exceptions that are too generic force you to catch exceptions generically too. It will force you to use a naked ``except Exception:`` clause. You might then end up catching exceptions other than the ones you expect to catch. This can hide bugs or make it harder to debug programs when unrelated errors are hidden. Problematic code: def small_apple(apple, length): if len(apple) < length: raise Exception(\"Apple is too small!\") # [broad-exception-raised] print(f\"{apple} is proper size.\") Correct code: def small_apple(apple, length): if len(apple) < length: raise ValueError(\"Apple is too small!\") print(f\"{apple} is proper size.\") Related links: Programming recommendation in PEP8 Created by the exceptions checker.",
    "option": {}
  },
  "W0640": {
    "description": "[Status: stable] [Name: cell-var-from-loop] [Message: Cell variable %s defined in loop] Description: A variable used in a closure is defined in a loop. This will result in all closures using the same value for the closed-over variable. Problematic code: def teacher_greeting(names): greetings = [] for name in names: def greet(): # do something print(f\"Hello, {name}!\") # [cell-var-from-loop] if name.isalpha(): greetings.append(greet) for greet in greetings: # the \"name\" variable is evaluated when the function is called here, # which is the last value it had in the loop - \"Not-A-Name\" greet() teacher_greeting([\"Graham\", \"John\", \"Terry\", \"Eric\", \"Terry\", \"Michael\"]) # \"Hello, Michael!\" # \"Hello, Michael!\" # \"Hello, Michael!\" # \"Hello, Michael!\" # \"Hello, Michael!\" Correct code: functools.partial.py: import functools def teacher_greeting(names): greetings = [] for name in names: if name.isalpha(): # \"name\" is evaluated when the partial is created here, so this # does not do lazy evaluation greetings.append(functools.partial(print, f\"Hello, {name}!\")) for greet in greetings: # `partial`s are called like functions, but you've already passed the # arguments to them greet() teacher_greeting([\"Graham\", \"John\", \"Terry\", \"Eric\", \"Terry\", \"Michael\"]) # \"Hello, Graham!\" # \"Hello, John!\" # \"Hello, Eric!\" # \"Hello, Terry!\" # \"Hello, Michael!\" new_function.py: def teacher_greeting(names): def greet(name): # do something print(f\"Hello, {name}!\") for name in names: if name.isalpha(): # we're passing the value of \"name\" to the function here greet(name) teacher_greeting([\"Graham\", \"John\", \"Terry\", \"Eric\", \"Terry\", \"Michael\"]) # \"Hello, Graham!\" # \"Hello, John!\" # \"Hello, Eric!\" # \"Hello, Terry!\" # \"Hello, Michael!\" Related links: Stackoverflow discussion Created by the variables checker.",
    "option": {}
  },
  "W0143": {
    "description": "[Status: stable] [Name: comparison-with-callable] [Message: Comparing against a callable, did you omit the parenthesis?] Description: This message is emitted when pylint detects that a comparison with a callable was made, which might suggest that some parenthesis were omitted, resulting in potential unwanted behaviour. Problematic code: def function_returning_a_fruit() -> str: return \"orange\" def is_an_orange(fruit: str = \"apple\"): # apple == <function function_returning_a_fruit at 0x7f343ff0a1f0> return fruit == function_returning_a_fruit # [comparison-with-callable] Correct code: def function_returning_a_fruit() -> str: return \"orange\" def is_an_orange(fruit: str = \"apple\"): # apple == orange return fruit == function_returning_a_fruit() Created by the basic checker.",
    "option": {}
  },
  "W0124": {
    "description": "[Status: stable] [Name: confusing-with-statement] [Message: Following \"as\" with another context manager looks like a tuple.] Description: Emitted when a `with` statement component returns multiple values and uses name binding with `as` only for a part of those values, as in with ctx() as a, b. This can be misleading, since it's not clear if the context manager returns a tuple or if the node without a name binding is another context manager. Problematic code: with open(\"file.txt\", \"w\") as fh1, fh2: # [confusing-with-statement] pass Correct code: with open(\"file.txt\", \"w\", encoding=\"utf8\") as fh1: with open(\"file.txt\", \"w\", encoding=\"utf8\") as fh2: pass Created by the basic checker.",
    "option": {}
  },
  "W0160": {
    "description": "[Status: stable] [Name: consider-ternary-expression] [Message: Consider rewriting as a ternary expression] Description: Multiple assign statements spread across if/else blocks can be rewritten with a single assignment and ternary expression Problematic code: x, y = input(), input() if x >= y: # [consider-ternary-expression] maximum = x else: maximum = y Correct code: x, y = input(), input() maximum = x if x >= y else y Configuration file: [MAIN] load-plugins=pylint.extensions.consider_ternary_expression Note This message is emitted by the optional 'consider_ternary_expression' checker, which requires the pylint.extensions.consider_ternary_expression plugin to be loaded. Created by the consider_ternary_expression checker.",
    "option": {}
  },
  "W0135": {
    "description": "[Status: stable] [Name: contextmanager-generator-missing-cleanup] [Message: The context used in function %r will not be exited.] Description: Used when a contextmanager is used inside a generator function and the cleanup is not handled. Problematic code: import contextlib @contextlib.contextmanager def cm(): contextvar = \"acquired context\" print(\"cm enter\") yield contextvar print(\"cm exit\") def genfunc_with_cm(): with cm() as context: # [contextmanager-generator-missing-cleanup] yield context * 2 Correct code: import contextlib @contextlib.contextmanager def good_cm_except(): contextvar = \"acquired context\" print(\"good cm enter\") try: yield contextvar except GeneratorExit: print(\"good cm exit\") def genfunc_with_cm(): with good_cm_except() as context: yield context * 2 def genfunc_with_discard(): with good_cm_except(): yield \"discarded\" @contextlib.contextmanager def good_cm_yield_none(): print(\"good cm enter\") yield print(\"good cm exit\") def genfunc_with_none_yield(): with good_cm_yield_none() as var: print(var) yield \"constant yield\" @contextlib.contextmanager def good_cm_finally(): contextvar = \"acquired context\" print(\"good cm enter\") try: yield contextvar finally: print(\"good cm exit\") def good_cm_finally_genfunc(): with good_cm_finally() as context: yield context * 2 @contextlib.contextmanager def good_cm_no_cleanup(): contextvar = \"acquired context\" print(\"cm enter\") yield contextvar def good_cm_no_cleanup_genfunc(): with good_cm_no_cleanup() as context: yield context * 2 Additional details: Instantiating and using a contextmanager inside a generator function can result in unexpected behavior if there is an expectation that the context is only available for the generator function. In the case that the generator is not closed or destroyed then the context manager is held suspended as is. This message warns on the generator function instead of the contextmanager function because the ways to use a contextmanager are many. A contextmanager can be used as a decorator (which immediately has __enter__/__exit__ applied) and the use of as ... or discard of the return value also implies whether the context needs cleanup or not. So for this message, warning the invoker of the contextmanager is important. The check can create false positives if yield is used inside an if-else block without custom cleanup. Use pylint: disable for these. from contextlib import contextmanager @contextmanager def good_cm_no_cleanup(): contextvar = \"acquired context\" print(\"cm enter\") if some_condition: yield contextvar else: yield contextvar def good_cm_no_cleanup_genfunc(): # pylint: disable-next=contextmanager-generator-missing-cleanup with good_cm_no_cleanup() as context: yield context * 2 Related links: Rationale CPython Issue Created by the basic checker.",
    "option": {}
  },
  "W0136": {
    "description": "[Status: stable] [Name: continue-in-finally] [Message: 'continue' discouraged inside 'finally' clause] Description: Emitted when the `continue` keyword is found inside a finally clause. This will raise a SyntaxWarning starting in Python 3.14. Problematic code: while True: try: pass finally: continue # [continue-in-finally] Correct code: while True: try: pass except ValueError: pass else: continue Related links: Python 3 docs 'finally' clause PEP 765 - Disallow return/break/continue that exit a finally block Created by the basic checker.",
    "option": {}
  },
  "W0102": {
    "description": "[Status: stable] [Name: dangerous-default-value] [Message: Dangerous default value %s as argument] Description: Used when a mutable value as list or dictionary is detected in a default value for an argument. Problematic code: def whats_on_the_telly(penguin=[]): # [dangerous-default-value] penguin.append(\"property of the zoo\") return penguin Correct code: def whats_on_the_telly(penguin=None): if penguin is None: penguin = [] penguin.append(\"property of the zoo\") return penguin Additional details: With a mutable default value, with each call the default value is modified, i.e.: whats_on_the_telly() # [\"property of the zoo\"] whats_on_the_telly() # [\"property of the zoo\", \"property of the zoo\"] whats_on_the_telly() # [\"property of the zoo\", \"property of the zoo\", \"property of the zoo\"] Created by the basic checker.",
    "option": {}
  },
  "W4903": {
    "description": "[Status: stable] [Name: deprecated-argument] [Message: Using deprecated argument %s of method %s()] Description: The argument is marked as deprecated and will be removed in the future. Problematic code: int(x=1) # [deprecated-argument] Correct code: int(1) Configuration file: Additional details: The actual replacement needs to be studied on a case by case basis by reading the deprecation warning or the release notes. Created by the stdlib checker.",
    "option": {}
  },
  "W4906": {
    "description": "[Status: stable] [Name: deprecated-attribute] [Message: Using deprecated attribute %r] Description: The attribute is marked as deprecated and will be removed in the future. Problematic code: from configparser import ParsingError err = ParsingError(\"filename\") source = err.filename # [deprecated-attribute] Correct code: from configparser import ParsingError err = ParsingError(\"filename\") source = err.source Additional details: The actual replacement needs to be studied on a case by case basis by reading the deprecation warning or the release notes. Created by the stdlib checker.",
    "option": {}
  },
  "W4904": {
    "description": "[Status: stable] [Name: deprecated-class] [Message: Using deprecated class %s of module %s] Description: The class is marked as deprecated and will be removed in the future. Problematic code: from collections import Iterable # [deprecated-class] Correct code: from collections.abc import Iterable Additional details: The actual replacement needs to be studied on a case by case basis by reading the deprecation warning or the release notes. Created by the stdlib checker.",
    "option": {}
  },
  "W4905": {
    "description": "[Status: stable] [Name: deprecated-decorator] [Message: Using deprecated decorator %s()] Description: The decorator is marked as deprecated and will be removed in the future. Problematic code: import abc class Animal: @abc.abstractclassmethod # [deprecated-decorator] def breath(cls): pass Correct code: import abc class Animal: @abc.classmethod @abc.abstractmethod def breath(cls): pass Configuration file: [main] py-version = 3.3 Additional details: The actual replacement needs to be studied on a case by case basis by reading the deprecation warning or the release notes. Created by the stdlib checker.",
    "option": {}
  },
  "W4902": {
    "description": "[Status: stable] [Name: deprecated-method] [Message: Using deprecated method %s()] Description: The method is marked as deprecated and will be removed in the future. Problematic code: import logging logging.warn(\"I'm coming, world !\") # [deprecated-method] Correct code: import logging logging.warning(\"I'm coming, world !\") Additional details: The actual replacement needs to be studied on a case by case basis by reading the deprecation warning or the release notes. Created by the stdlib checker.",
    "option": {}
  },
  "W4901": {
    "description": "[Status: stable] [Name: deprecated-module] [Message: Deprecated module %r] Description: A module marked as deprecated is imported. Problematic code: import distutils # [deprecated-module] import whatever_you_want # [deprecated-module] Correct code: import setuptools import whatever_replacement_you_want Configuration file: [main] py-version=3.7 deprecated-modules=whatever_you_want Additional details: The actual replacement needs to be studied on a case by case basis by reading the deprecation warning or the release notes. Created by the imports checker.",
    "option": {}
  },
  "W6001": {
    "description": "[Status: stable] [Name: deprecated-typing-alias] [Message: '%s' is deprecated, use '%s' instead] Description: Emitted when a deprecated typing alias is used. Problematic code: import typing item_to_number_of_item: typing.Dict[str, int] # [deprecated-typing-alias] Correct code: item_to_number_of_item: dict[str, int] Configuration file: [main] load-plugins = pylint.extensions.typing Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "W9017": {
    "description": "[Status: stable] [Name: differing-param-doc] [Message: \"%s\" differing in parameter documentation] Description: Please check parameter names in declarations. Problematic code: def add(x, y): # [differing-param-doc] \"\"\"Add two numbers. :param int x: x value. :param int z: z value. \"\"\" return x + y Correct code: def add(x, y): \"\"\"Add two numbers. :param int x: x value. :param int y: y value. \"\"\" return x + y Configuration file: [MAIN] load-plugins = pylint.extensions.docparams Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W9018": {
    "description": "[Status: stable] [Name: differing-type-doc] [Message: \"%s\" differing in parameter type documentation] Description: Please check parameter names in type declarations. Problematic code: def add(x: int, y: int): # [differing-type-doc] \"\"\"Add two numbers. :param int xy: x value. :param str y: y value. \"\"\" return x + y Correct code: def add(x, y): \"\"\"Add two numbers. :param int x: x value. :param int y: y value. \"\"\" return x + y Configuration file: [MAIN] load-plugins = pylint.extensions.docparams Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W0705": {
    "description": "[Status: stable] [Name: duplicate-except] [Message: Catching previously caught exception type %s] Description: Used when an except catches a type that was already caught by a previous handler. Problematic code: try: 1 / 0 except ZeroDivisionError: pass except ZeroDivisionError: # [duplicate-except] pass Correct code: try: 1 / 0 except ZeroDivisionError: pass Created by the exceptions checker.",
    "option": {}
  },
  "W0109": {
    "description": "[Status: stable] [Name: duplicate-key] [Message: Duplicate key %r in dictionary] Description: Used when a dictionary expression binds the same key multiple times. Problematic code: test_score = {\"Mathematics\": 85, \"Biology\": 90, \"Mathematics\": 75} # [duplicate-key] Correct code: test_score = {\"Mathematics\": 85, \"Biology\": 90, \"History\": 75} Related links: Python Dictionaries Mapping Types — dict Created by the basic checker.",
    "option": {}
  },
  "W1308": {
    "description": "[Status: stable] [Name: duplicate-string-formatting-argument] [Message: Duplicate string formatting argument %r, consider passing as named argument] Description: Used when we detect that a string formatting is repeating an argument instead of using named string arguments Problematic code: # pylint: disable=missing-docstring, consider-using-f-string SEE = \"see 👀\" SEA = \"sea 🌊\" # +1: [duplicate-string-formatting-argument,duplicate-string-formatting-argument] CONST = \"\"\" A sailor went to {}, {}, {} To {} what he could {}, {}, {} But all that he could {}, {}, {} Was the bottom of the deep blue {}, {}, {}! \"\"\".format( SEA, SEA, SEA, SEE, SEE, SEE, SEE, SEE, SEE, SEE, SEA, SEA, SEA, ) Correct code: # pylint: disable=missing-docstring, consider-using-f-string SEE = \"see 👀\" SEA = \"sea 🌊\" CONST = \"\"\" A sailor went to {sea}, {sea}, {sea} To {see} what he could {see}, {see}, {see} But all that he could {see}, {see}, {see} Was the bottom of the deep blue {sea}, {sea}, {sea}! \"\"\".format( sea=SEA, see=SEE ) Created by the string checker.",
    "option": {}
  },
  "W0130": {
    "description": "[Status: stable] [Name: duplicate-value] [Message: Duplicate value %r in set] Description: This message is emitted when a set contains the same value two or more times. Problematic code: incorrect_set = {\"value1\", 23, 5, \"value1\"} # [duplicate-value] Correct code: correct_set = {\"value1\", 23, 5} Created by the basic checker.",
    "option": {}
  },
  "W1641": {
    "description": "[Status: stable] [Name: eq-without-hash] [Message: Implementing __eq__ without also implementing __hash__] Description: Used when a class implements __eq__ but not __hash__. Objects get None as their default __hash__ implementation if they also implement __eq__. Problematic code: class Fruit: # [eq-without-hash] def __init__(self) -> None: self.name = \"apple\" def __eq__(self, other: object) -> bool: return isinstance(other, Fruit) and other.name == self.name Correct code: class Fruit: def __init__(self) -> None: self.name = \"apple\" def __eq__(self, other: object) -> bool: return isinstance(other, Fruit) and other.name == self.name def __hash__(self) -> int: return hash(self.name) Configuration file: [MAIN] load-plugins=pylint.extensions.eq_without_hash, Note This message is emitted by the optional 'eq-without-hash' checker, which requires the pylint.extensions.eq_without_hash plugin to be loaded. Created by the eq-without-hash checker.",
    "option": {}
  },
  "W0123": {
    "description": "[Status: stable] [Name: eval-used] [Message: Use of eval] Description: Used when you use the \"eval\" function, to discourage its usage. Consider using `ast.literal_eval` for safely evaluating strings containing Python expressions from untrusted sources. Problematic code: eval(\"[1, 2, 3]\") # [eval-used] Correct code: from ast import literal_eval literal_eval(\"[1, 2, 3]\") Created by the basic checker.",
    "option": {}
  },
  "W0122": {
    "description": "[Status: stable] [Name: exec-used] [Message: Use of exec] Description: Raised when the 'exec' statement is used. It's dangerous to use this function for a user input, and it's also slower than actual code in general. This doesn't mean you should never use it, but you should consider alternatives first and restrict the functions available. Problematic code: username = \"Ada\" code_to_execute = f\"\"\"input('Enter code to be executed please, {username}: ')\"\"\" program = exec(code_to_execute) # [exec-used] exec(program) # [exec-used] Correct code: def get_user_code(name): return input(f\"Enter code to be executed please, {name}: \") username = \"Ada\" # If the globals dictionary does not contain a value for the key __builtins__, # all builtins are allowed. You need to be explicit about it being disallowed. allowed_globals = {\"__builtins__\": {}} allowed_locals = {} # pylint: disable-next=exec-used exec(get_user_code(username), allowed_globals, allowed_locals) Additional details: The available methods and variables used in exec() may introduce a security hole. You can restrict the use of these variables and methods by passing optional globals and locals parameters (dictionaries) to the exec() method. However, use of exec() is still insecure if you allow some functions like __import__ or open. For example, consider the following call that writes a file to the user's system and then execute code unrestrained by the allowed_globals, or allowed_locals parameters: import textwrap def forbid_print(*args): raise ValueError(\"This is raised when a print is used\") allowed_globals = { \"__builtins__\": { \"__import__\": __builtins__.__import__, \"open\": __builtins__.open, \"print\": forbid_print, } } exec( textwrap.dedent( \"\"\" import textwrap with open(\"nefarious.py\", \"w\") as f: f.write(textwrap.dedent(''' def connive(): print(\"Here's some code as nefarious as imaginable\") ''')) import nefarious nefarious.connive() # This will NOT raise a ValueError \"\"\" ), allowed_globals, ) The import is used only for readability of the example in this case but it could import a dangerous functions: subprocess.run('echo \"print(\\\"Hello, World!\\\")\" > nefarious.py' pathlib.Path(\"nefarious.py\").write_file(\"print(\\\"Hello, World!\\\")\") os.system('echo \"print(\\\"Hello, World!\\\")\" > nefarious.py') logging.basicConfig(filename='nefarious.py'); logging.error('print(\"Hello, World!\")') etc. Related links: Be careful with exec and eval in Python Python documentation Created by the basic checker.",
    "option": {}
  },
  "W0106": {
    "description": "[Status: stable] [Name: expression-not-assigned] [Message: Expression \"%s\" is assigned to nothing] Description: Used when an expression that is not a function call is assigned to nothing. Probably something else was intended. Problematic code: str(42) == \"42\" # [expression-not-assigned] Correct code: are_equal: bool = str(42) == \"42\" Created by the basic checker.",
    "option": {}
  },
  "W1309": {
    "description": "[Status: stable] [Name: f-string-without-interpolation] [Message: Using an f-string that does not have any interpolated variables] Description: Used when we detect an f-string that does not use any interpolation variables, in which case it can be either a normal string or a bug in the code. Problematic code: x = 1 y = 2 print(f\"x + y = x + y\") # [f-string-without-interpolation] Correct code: x = 1 y = 2 print(f\"{x} + {y} = {x + y}\") Created by the string checker.",
    "option": {}
  },
  "W0511": {
    "description": "[Status: stable] [Name: fixme] [Message: %s] Description: Used when a warning note as FIXME or XXX is detected. Problematic code: # TODO: We should fix this at some point # [fixme] Correct code: bug_tracker.py: # The issue was added to the bug tracker: no longer need the comment fixed.py: # The issue was fixed: no longer need the comment no_fix.py: # We no longer want to fix this: no longer need the comment Additional details: You can use regular expressions and the notes-rgx option to create some constraints for this message. See the following issue for some examples. Created by the miscellaneous checker.",
    "option": {}
  },
  "W1515": {
    "description": "[Status: stable] [Name: forgotten-debug-statement] [Message: Leaving functions creating breakpoints in production code is not recommended] Description: Calls to breakpoint(), sys.breakpointhook() and pdb.set_trace() should be removed from code that is not actively being debugged. Problematic code: import pdb def find_the_treasure(clues): for clue in clues: pdb.set_trace() # [forgotten-debug-statement] if \"treasure\" in clue: return True return False treasure_hunt = [ \"Dead Man's Chest\", \"X marks the spot\", \"The treasure is buried near the palm tree\", ] find_the_treasure(treasure_hunt) Correct code: def find_the_treasure(clues): for clue in clues: if \"treasure\" in clue: return True return False treasure_hunt = [ \"Dead Man's Chest\", \"X marks the spot\", \"The treasure is buried near the palm tree\", ] find_the_treasure(treasure_hunt) Created by the stdlib checker.",
    "option": {}
  },
  "W1305": {
    "description": "[Status: stable] [Name: format-combined-specification] [Message: Format string contains both automatic field numbering and manual field specification] Description: Used when a PEP 3101 format string contains both automatic field numbering (e.g. '{}') and manual field specification (e.g. '{0}'). Problematic code: print(\"{} {1}\".format(\"hello\", \"world\")) # [format-combined-specification] Correct code: index_formatting.py: print(\"{0} {1}\".format(\"hello\", \"world\")) order_formatting.py: print(\"{} {}\".format(\"hello\", \"world\")) Created by the string checker.",
    "option": {}
  },
  "W1310": {
    "description": "[Status: stable] [Name: format-string-without-interpolation] [Message: Using formatting for a string that does not have any interpolated variables] Description: Used when we detect a string that does not have any interpolation variables, in which case it can be either a normal string without formatting or a bug in the code. Problematic code: print(\"number\".format(1)) # [format-string-without-interpolation] Correct code: print(\"number: {}\".format(1)) Created by the string checker.",
    "option": {}
  },
  "W0604": {
    "description": "[Status: stable] [Name: global-at-module-level] [Message: Using the global statement at the module level] Description: Used when you use the \"global\" statement at the module level since it has no effect. Problematic code: price = 25 global price # [global-at-module-level] Correct code: price = 25 Related links: Official Python FAQ - global and local PEP 3104 - Access to Names in Outer Scopes Python global statement Created by the variables checker.",
    "option": {}
  },
  "W0603": {
    "description": "[Status: stable] [Name: global-statement] [Message: Using the global statement] Description: Used when you use the \"global\" statement to update a global variable. Pylint discourages its usage. That doesn't mean you cannot use it! Problematic code: var = 1 def foo(): global var # [global-statement] var = 10 print(var) foo() print(var) Correct code: var = 1 def foo(): print(var) return 10 var = foo() print(var) Created by the variables checker.",
    "option": {}
  },
  "W0602": {
    "description": "[Status: stable] [Name: global-variable-not-assigned] [Message: Using global for %r but no assignment is done] Description: When a variable defined in the global scope is modified in an inner scope, the 'global' keyword is required in the inner scope only if there is an assignment operation done in the inner scope. Problematic code: TOMATO = \"black cherry\" def update_tomato(): global TOMATO # [global-variable-not-assigned] print(TOMATO) Correct code: TOMATO = \"black cherry\" def update_tomato(): global TOMATO TOMATO = \"moneymaker\" Created by the variables checker.",
    "option": {}
  },
  "W0601": {
    "description": "[Status: stable] [Name: global-variable-undefined] [Message: Global variable %r undefined at the module level] Description: Used when a variable is defined through the \"global\" statement but the variable is not defined in the module scope. Problematic code: def update_tomato(): global TOMATO # [global-variable-undefined] TOMATO = \"moneymaker\" Correct code: TOMATO = \"black cherry\" def update_tomato(): global TOMATO TOMATO = \"moneymaker\" Created by the variables checker.",
    "option": {}
  },
  "W0213": {
    "description": "[Status: stable] [Name: implicit-flag-alias] [Message: Flag member %(overlap)s shares bit positions with %(sources)s] Description: Used when multiple integer values declared within an enum.IntFlag class share a common bit position. Problematic code: from enum import IntFlag class FilePermissions(IntFlag): READ = 1 WRITE = 2 EXECUTE = 3 # [implicit-flag-alias] Correct code: from enum import IntFlag class FilePermissions(IntFlag): READ = 1 WRITE = 2 EXECUTE = 4 Created by the classes checker.",
    "option": {}
  },
  "W1404": {
    "description": "[Status: stable] [Name: implicit-str-concat] [Message: Implicit string concatenation found in %s] Description: String literals are implicitly concatenated in a literal iterable definition : maybe a comma is missing ? Problematic code: list.py: x = [\"a\" \"b\"] # [implicit-str-concat] open.py: with open(\"hello.txt\" \"r\") as f: # [implicit-str-concat] print(f.read()) Correct code: list.py: x = [\"a\", \"b\"] open.py: with open(\"hello.txt\", \"r\") as f: print(f.read()) Additional details: By default, detection of implicit string concatenation of line jumps is disabled. Hence the following code will not trigger this rule: SEQ = ('a', 'b' 'c') In order to detect this case, you must enable check-str-concat-over-line-jumps: [STRING_CONSTANT] check-str-concat-over-line-jumps = true However, the drawback of this setting is that it will trigger false positive for string parameters passed on multiple lines in function calls: warnings.warn( \"rotate() is deprecated and will be removed in a future release. \" \"Use the rotation() context manager instead.\", DeprecationWarning, stacklevel=3, ) No message will be emitted, though, if you clarify the wanted concatenation with parentheses: warnings.warn( ( \"rotate() is deprecated and will be removed in a future release. \" \"Use the rotation() context manager instead.\" ), DeprecationWarning, stacklevel=3, ) Created by the string checker.",
    "option": {}
  },
  "W0406": {
    "description": "[Status: stable] [Name: import-self] [Message: Module import itself] Description: Used when a module is importing itself. Additional details: Say you have a file called my_file.py. import-self would be raised on the following code: from my_file import a_function # [import-self] def a_function(): pass The solution would be to remove the import: def a_function(): pass Created by the imports checker.",
    "option": {}
  },
  "W1405": {
    "description": "[Status: stable] [Name: inconsistent-quotes] [Message: Quote delimiter %s is inconsistent with the rest of the file] Description: Quote delimiters are not used consistently throughout a module (with allowances made for avoiding unnecessary escaping). Problematic code: import datetime print('Current year: ', datetime.date.today().strftime(\"%Y\")) # [inconsistent-quotes] Correct code: import datetime print(\"Current year: \", datetime.date.today().strftime(\"%Y\")) Configuration file: [main] check-quote-consistency=yes Created by the string checker.",
    "option": {}
  },
  "W1508": {
    "description": "[Status: stable] [Name: invalid-envvar-default] [Message: %s default type is %s. Expected str or None.] Description: Env manipulation functions return None or str values. Supplying anything different as a default may cause bugs. See https://docs.python.org/3/library/os.html#os.getenv. Problematic code: import os env = os.getenv(\"SECRET_KEY\", 1) # [invalid-envvar-default] Correct code: import os env = os.getenv(\"SECRET_KEY\", \"1\") Created by the stdlib checker.",
    "option": {}
  },
  "W1307": {
    "description": "[Status: stable] [Name: invalid-format-index] [Message: Using invalid lookup key %r in format specifier %r] Description: Used when a PEP 3101 format string uses a lookup specifier ({a[1]}), but the argument passed for formatting doesn't contain or doesn't have that key as an attribute. Problematic code: not_enough_fruits = [\"apple\"] print('The second fruit is a {fruits[1]}'.format(fruits=not_enough_fruits)) # [invalid-format-index] Correct code: enough_fruits = [\"apple\", \"banana\"] print(\"The second fruit is a {fruits[1]}\".format(fruits=enough_fruits)) Created by the string checker.",
    "option": {}
  },
  "W0236": {
    "description": "[Status: stable] [Name: invalid-overridden-method] [Message: Method %r was expected to be %r, found it instead as %r] Description: Used when we detect that a method was overridden in a way that does not match its base class which could result in potential bugs at runtime. Problematic code: class Fruit: async def bore(self, insect): insect.eat(self) class Apple(Fruit): def bore(self, insect): # [invalid-overridden-method] insect.eat(self) Correct code: class Fruit: async def bore(self, insect): insect.eat(self) class Apple(Fruit): async def bore(self, insect): insect.eat(self) Created by the classes checker.",
    "option": {}
  },
  "W1116": {
    "description": "[Status: stable] [Name: isinstance-second-argument-not-valid-type] [Message: Second argument of isinstance is not a type] Description: Emitted when the second argument of an isinstance call is not a type. Problematic code: isinstance(\"apples and oranges\", hex) # [isinstance-second-argument-not-valid-type] Correct code: isinstance(\"apples and oranges\", str) Created by the typecheck checker.",
    "option": {}
  },
  "W1113": {
    "description": "[Status: stable] [Name: keyword-arg-before-vararg] [Message: Keyword argument before variable positional arguments list in the definition of %s function] Description: When defining a keyword argument before variable positional arguments, one can end up in having multiple values passed for the aforementioned parameter in case the method is called with keyword arguments. Problematic code: def func(x=None, *args): # [keyword-arg-before-vararg] return [x, *args] Correct code: def func(*args, x=None): return [*args, x] Created by the typecheck checker.",
    "option": {}
  },
  "W1117": {
    "description": "[Status: stable] [Name: kwarg-superseded-by-positional-arg] [Message: %r will be included in %r since a positional-only parameter with this name already exists] Description: Emitted when a function is called with a keyword argument that has the same name as a positional-only parameter and the function contains a keyword variadic parameter dict. Problematic code: def print_name(name=\"Sarah\", /, **kwds): print(name) print_name(name=\"Jacob\") # [kwarg-superseded-by-positional-arg] # Will print \"Sarah\" Correct code: def print_name(name=\"Sarah\", /, **kwds): print(name) print_name(\"Jacob\") # Will print \"Jacob\" Created by the typecheck checker.",
    "option": {}
  },
  "W1202": {
    "description": "[Status: stable] [Name: logging-format-interpolation] [Message: Use %s formatting in logging functions] Description: Used when a logging statement has a call form of \"logging.<logging method>(format_string.format(format_args...))\". Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-fstring-interpolation is disabled then you can use fstring formatting. If logging-not-lazy is disabled then you can use % formatting as normal. Problematic code: import logging import sys # +1: [logging-format-interpolation] logging.error(\"Python version: {}\".format(sys.version)) Correct code: import logging import sys logging.error(\"Python version: %s\", sys.version) Additional details: Another reasonable option is to use f-string. If you want to do that, you need to enable logging-format-interpolation and disable logging-fstring-interpolation. Related links: logging variable data Rationale for the message on stackoverflow Created by the logging checker.",
    "option": {}
  },
  "W1203": {
    "description": "[Status: stable] [Name: logging-fstring-interpolation] [Message: Use %s formatting in logging functions] Description: Used when a logging statement has a call form of \"logging.<logging method>(f\"...\")\".Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-format-interpolation is disabled then you can use str.format. If logging-not-lazy is disabled then you can use % formatting as normal. Problematic code: import logging import sys logging.error(f\"Python version: {sys.version}\") # [logging-fstring-interpolation] Correct code: import logging import sys logging.error(\"Python version: %s\", sys.version) Additional details: This message permits to allow f-string in logging and still be warned of logging-format-interpolation. Related links: logging variable data Rationale Created by the logging checker.",
    "option": {}
  },
  "W1201": {
    "description": "[Status: stable] [Name: logging-not-lazy] [Message: Use %s formatting in logging functions] Description: Used when a logging statement has a call form of \"logging.<logging method>(format_string % (format_args...))\". Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-fstring-interpolation is disabled then you can use fstring formatting. If logging-format-interpolation is disabled then you can use str.format. Problematic code: import logging try: function() except Exception as e: logging.error(\"Error occurred: %s\" % e) # [logging-not-lazy] raise Correct code: import logging try: function() except Exception as e: logging.error(\"Error occurred: %s\", e) raise Additional details: Another reasonable option is to use f-strings. If you want to do that, you need to enable logging-not-lazy and disable logging-fstring-interpolation. Related links: Logging variable data Rationale for the message on stackoverflow Created by the logging checker.",
    "option": {}
  },
  "W0150": {
    "description": "[Status: stable] [Name: lost-exception] [Message: %s statement in finally block may swallow exception] Description: Used when a break or a return statement is found inside the finally clause of a try...finally block: the exceptions raised in the try clause will be silently swallowed instead of being re-raised. Problematic code: class FasterThanTheSpeedOfLightError(ZeroDivisionError): def __init__(self): super().__init__(\"You can't go faster than the speed of light !\") def calculate_speed(distance: float, time: float) -> float: try: return distance / time except ZeroDivisionError as e: raise FasterThanTheSpeedOfLightError() from e finally: return 299792458 # [lost-exception] Correct code: class FasterThanTheSpeedOfLightError(ZeroDivisionError): def __init__(self): super().__init__(\"You can't go faster than the speed of light !\") def calculate_speed(distance: float, time: float) -> float: try: return distance / time except ZeroDivisionError as e: raise FasterThanTheSpeedOfLightError() from e Created by the basic checker.",
    "option": {}
  },
  "W1518": {
    "description": "[Status: stable] [Name: method-cache-max-size-none] [Message: 'lru_cache(maxsize=None)' or 'cache' will keep all method args alive indefinitely, including 'self'] Description: By decorating a method with lru_cache or cache the 'self' argument will be linked to the function and therefore never garbage collected. Unless your instance will never need to be garbage collected (singleton) it is recommended to refactor code to avoid this pattern or add a maxsize to the cache. The default value for maxsize is 128. Problematic code: import functools class Fibonnaci: def __init__(self): self.result = [] @functools.lru_cache(maxsize=None) # [method-cache-max-size-none] def fibonacci(self, n): if n in {0, 1}: self.result.append(n) self.result.append(self.fibonacci(n - 1) + self.fibonacci(n - 2)) Correct code: import functools @functools.cache def cached_fibonacci(n): if n in {0, 1}: return n return cached_fibonacci(n - 1) + cached_fibonacci(n - 2) class Fibonnaci: def __init__(self): self.result = [] def fibonacci(self, n): self.result.append(cached_fibonacci(n)) Created by the stdlib checker.",
    "option": {}
  },
  "W0410": {
    "description": "[Status: stable] [Name: misplaced-future] [Message: __future__ import is not the first non docstring statement] Description: Python 2.5 and greater require __future__ import to be the first non docstring statement in the module. Problematic code: import sys from __future__ import print_function # [misplaced-future] Correct code: from __future__ import print_function import sys Additional details: A bare raise statement will re-raise the last active exception in the current scope. If the raise statement is not in an except or finally block, a RuntimeError will be raised instead. Created by the imports checker.",
    "option": {}
  },
  "W9021": {
    "description": "[Status: stable] [Name: missing-any-param-doc] [Message: Missing any documentation in \"%s\"] Description: Please add parameter and/or type documentation. Problematic code: def puppies(head, tail): # [missing-any-param-doc] \"\"\"Print puppy's details.\"\"\" print(head, tail) Correct code: def puppies(head: str, tail: str): \"\"\"Print puppy's details. :param head: description of the head of the dog :param tail: description of the tail of the dog \"\"\" print(head, tail) Configuration file: [main] load-plugins = pylint.extensions.docparams accept-no-param-doc = false Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W1303": {
    "description": "[Status: stable] [Name: missing-format-argument-key] [Message: Missing keyword argument %r for format string] Description: Used when a PEP 3101 format string that uses named fields doesn't receive one or more required keywords. Problematic code: print(\"My name is {first} {last}\".format(first=\"John\")) # [missing-format-argument-key] Correct code: print(\"My name is {first} {last}\".format(first=\"John\", last=\"Wick\")) Related links: PEP 3101 Custom String Formatting Created by the string checker.",
    "option": {}
  },
  "W1306": {
    "description": "[Status: stable] [Name: missing-format-attribute] [Message: Missing format attribute %r in format specifier %r] Description: Used when a PEP 3101 format string uses an attribute specifier ({0.length}), but the argument passed for formatting doesn't have that attribute. Problematic code: print(\"{0.real}\".format(\"1\")) # [missing-format-attribute] Correct code: print(\"{0.real}\".format(1)) Created by the string checker.",
    "option": {}
  },
  "W9015": {
    "description": "[Status: stable] [Name: missing-param-doc] [Message: \"%s\" missing in parameter documentation] Description: Please add parameter declarations for all parameters. Problematic code: def integer_sum(a: int, b): # [missing-param-doc] \"\"\"Returns sum of two integers :param a: first integer \"\"\" return a + b Correct code: def integer_sum(a: int, b: int): \"\"\"Returns sum of two integers :param a: first integer :param b: second integer \"\"\" return a + b Configuration file: [MAIN] load-plugins = pylint.extensions.docparams Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W0126": {
    "description": "[Status: stable] [Name: missing-parentheses-for-call-in-test] [Message: Using a conditional statement with potentially wrong function or method call due to missing parentheses] Description: Emitted when a conditional statement (If or ternary if) seems to wrongly call a function due to missing parentheses Problematic code: import random def is_it_a_good_day(): return random.choice([True, False]) if is_it_a_good_day: # [missing-parentheses-for-call-in-test] print(\"Today is a good day!\") Correct code: import random def is_it_a_good_day(): return random.choice([True, False]) if is_it_a_good_day(): print(\"Today is a good day!\") Created by the basic checker.",
    "option": {}
  },
  "W9006": {
    "description": "[Status: stable] [Name: missing-raises-doc] [Message: \"%s\" not documented as being raised] Description: Please document exceptions for all raised exception types. Problematic code: def integer_sum(a: int, b: int): # [missing-raises-doc] \"\"\"Returns sum of two integers :param a: first integer :param b: second integer \"\"\" if not (isinstance(a, int) and isinstance(b, int)): raise ValueError(\"Function supports only integer parameters.\") return a + b Correct code: def integer_sum(a: int, b: int): \"\"\"Returns sum of two integers :param a: first integer :param b: second integer :raises ValueError: One of the parameters is not an integer. \"\"\" if not (isinstance(a, int) and isinstance(b, int)): raise ValueError(\"Function supports only integer parameters.\") return a + b Configuration file: [MAIN] load-plugins = pylint.extensions.docparams [BASIC] accept-no-raise-doc = no Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W9011": {
    "description": "[Status: stable] [Name: missing-return-doc] [Message: Missing return documentation] Description: Please add documentation about what this method returns. Problematic code: def integer_sum(a: int, b: int): # [missing-return-doc] \"\"\"Returns sum of two integers :param a: first integer :param b: second integer \"\"\" return a + b Correct code: def integer_sum(a: int, b: int) -> int: \"\"\"Returns sum of two integers :param a: first integer :param b: second integer :return: sum of parameters a and b \"\"\" return a + b Configuration file: [main] load-plugins=pylint.extensions.docparams [Parameter_documentation] accept-no-return-doc=no Additional details: This message is raised only when parameter accept-no-return-doc is set to no. Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W9012": {
    "description": "[Status: stable] [Name: missing-return-type-doc] [Message: Missing return type documentation] Description: Please document the type returned by this method. Problematic code: def integer_sum(a: int, b: int): # [missing-return-type-doc] \"\"\"Returns sum of two integers :param a: first integer :param b: second integer :return: sum of parameters a and b \"\"\" return a + b Correct code: def integer_sum(a: int, b: int) -> int: \"\"\"Returns sum of two integers :param a: first integer :param b: second integer :return: sum of parameters a and b \"\"\" return a + b Configuration file: [main] load-plugins=pylint.extensions.docparams [Parameter_documentation] accept-no-return-doc=no Additional details: This message is raised only when parameter accept-no-return-doc is set to no. Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W3101": {
    "description": "[Status: stable] [Name: missing-timeout] [Message: Missing timeout argument for method '%s' can cause your program to hang indefinitely] Description: Used when a method needs a 'timeout' parameter in order to avoid waiting for a long time. If no timeout is specified explicitly the default value is used. For example for 'requests' the program will never time out (i.e. hang indefinitely). Problematic code: import requests requests.post(\"http://localhost\") # [missing-timeout] Correct code: import requests requests.post(\"http://localhost\", timeout=10) Additional details: You can add new methods that should have a defined `timeout argument as qualified names in the timeout-methods option, for example: requests.api.get requests.api.head requests.api.options requests.api.patch requests.api.post requests.api.put requests.api.request Created by the method_args checker.",
    "option": {}
  },
  "W9016": {
    "description": "[Status: stable] [Name: missing-type-doc] [Message: \"%s\" missing in parameter type documentation] Description: Please add parameter type declarations for all parameters. Problematic code: def integer_sum(a: int, b): # [missing-type-doc] \"\"\"Returns sum of two integers :param a: first integer :param b: second integer \"\"\" return a + b Correct code: def integer_sum(a: int, b: int): \"\"\"Returns sum of two integers :param a: first integer :param b: second integer \"\"\" return a + b Configuration file: [MAIN] load-plugins = pylint.extensions.docparams Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W9013": {
    "description": "[Status: stable] [Name: missing-yield-doc] [Message: Missing yield documentation] Description: Please add documentation about what this generator yields. Problematic code: def even_number_under(n: int): # [missing-yield-doc] \"\"\"Prints even numbers smaller than n. Args: n: Upper limit of even numbers. \"\"\" for i in range(n): if i % 2 == 1: continue yield i Correct code: from typing import Iterator def even_number_under(n: int) -> Iterator[int]: \"\"\"Prints even numbers smaller than n. Args: n: Upper limit of even numbers. Yields: even numbers \"\"\" for i in range(n): if i % 2 == 1: continue yield i Configuration file: [main] load-plugins=pylint.extensions.docparams [Parameter_documentation] accept-no-yields-doc=no Additional details: This message is raised only when parameter accept-no-yields-doc is set to no. Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W9014": {
    "description": "[Status: stable] [Name: missing-yield-type-doc] [Message: Missing yield type documentation] Description: Please document the type yielded by this method. Problematic code: def even_number_under(n: int): # [missing-yield-type-doc] \"\"\"Prints even numbers smaller than n. Args: n: Upper limit of even numbers. Yields: even numbers \"\"\" for i in range(n): if i % 2 == 1: continue yield i Correct code: from typing import Iterator def even_number_under(n: int) -> Iterator[int]: \"\"\"Prints even numbers smaller than n. Args: n: Upper limit of even numbers. Yields: even numbers \"\"\" for i in range(n): if i % 2 == 1: continue yield i Configuration file: [main] load-plugins=pylint.extensions.docparams [Parameter_documentation] accept-no-yields-doc=no Additional details: This message is raised only when parameter accept-no-yields-doc is set to no. Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W4701": {
    "description": "[Status: stable] [Name: modified-iterating-list] [Message: Iterated list '%s' is being modified inside for loop body, consider iterating through a copy of it instead.] Description: Emitted when items are added or removed to a list being iterated through. Doing so can result in unexpected behaviour, that is why it is preferred to use a copy of the list. Problematic code: fruits = [\"apple\", \"orange\", \"mango\"] for fruit in fruits: fruits.append(\"pineapple\") # [modified-iterating-list] Correct code: fruits = [\"apple\", \"orange\", \"mango\"] for fruit in fruits.copy(): fruits.append(\"pineapple\") Created by the modified_iteration checker.",
    "option": {}
  },
  "W9005": {
    "description": "[Status: stable] [Name: multiple-constructor-doc] [Message: \"%s\" has constructor parameters documented in class and __init__] Description: Please remove parameter declarations in the class or constructor. Problematic code: class Point: # [multiple-constructor-doc] \"\"\"Represents a point in the xy-coordinate plane. :param x: coordinate :param y: coordinate \"\"\" def __init__(self, x, y): \"\"\"Represents a point in the xy-coordinate plane. :param x: coordinate :param y: coordinate \"\"\" self.x = x self.y = y Correct code: class Point: def __init__(self, x, y): \"\"\"Represents a point in the xy-coordinate plane. :param x: x coordinate :param y: y coordinate \"\"\" self.x = x self.y = y Configuration file: [main] load-plugins=pylint.extensions.docparams [Parameter_documentation] no-docstring-rgx=^(?!__init__$)_ Additional details: Both docstrings are acceptable but not both at the same time. Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W0131": {
    "description": "[Status: stable] [Name: named-expr-without-context] [Message: Named expression used without context] Description: Emitted if named expression is used to do a regular assignment outside a context like if, for, while, or a comprehension. Problematic code: (a := 42) # [named-expr-without-context] Correct code: if a := 42: print(\"Success\") Created by the basic checker.",
    "option": {}
  },
  "W0177": {
    "description": "[Status: stable] [Name: nan-comparison] [Message: Comparison %s should be %s] Description: Used when an expression is compared to NaN values like numpy.NaN and float('nan'). Problematic code: import numpy as np def both_nan(x, y) -> bool: return x == np.NaN and y == float(\"nan\") # [nan-comparison, nan-comparison] Correct code: import numpy as np def both_nan(x, y) -> bool: return np.isnan(x) and np.isnan(y) Created by the basic checker.",
    "option": {}
  },
  "W3301": {
    "description": "[Status: stable] [Name: nested-min-max] [Message: Do not use nested call of '%s'; it's possible to do '%s' instead] Description: Nested calls ``min(1, min(2, 3))`` can be rewritten as ``min(1, 2, 3)``. Problematic code: print(min(1, min(2, 3))) # [nested-min-max] Correct code: print(min(1, 2, 3)) Created by the nested_min_max checker.",
    "option": {}
  },
  "W2402": {
    "description": "[Status: stable] [Name: non-ascii-file-name] [Message: %s name \"%s\" contains a non-ASCII character.] Description: Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.Since Python 3.5, even though Python supports UTF-8 files, some editors or tools don't. Problematic code: bàd.py: # [non-ascii-file-name] not_bétter.py: # [non-ascii-file-name] Correct code: __init__.py: bad.py: not_better.py: Related links: PEP 489 PEP 672 Python issue 20485 Created by the nonascii-checker checker.",
    "option": {}
  },
  "W0233": {
    "description": "[Status: stable] [Name: non-parent-init-called] [Message: __init__ method from a non direct base class %r is called] Description: Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class. Problematic code: class Animal: def __init__(self): self.is_multicellular = True class Vertebrate(Animal): def __init__(self): super().__init__() self.has_vertebrae = True class Cat(Vertebrate): def __init__(self): Animal.__init__(self) # [non-parent-init-called] self.is_adorable = True Correct code: class Animal: def __init__(self): self.is_multicellular = True class Vertebrate(Animal): def __init__(self): super().__init__() self.has_vertebrae = True class Cat(Vertebrate): def __init__(self): super().__init__() self.is_adorable = True Created by the classes checker.",
    "option": {}
  },
  "W1115": {
    "description": "[Status: stable] [Name: non-str-assignment-to-dunder-name] [Message: Non-string value assigned to __name__] Description: Emitted when a non-string value is assigned to __name__ Problematic code: class Fruit: pass Fruit.__name__ = 1 # [non-str-assignment-to-dunder-name] Correct code: class Fruit: pass Fruit.__name__ = \"FRUIT\" Created by the typecheck checker.",
    "option": {}
  },
  "W0714": {
    "description": "[Status: stable] [Name: overlapping-except] [Message: Overlapping exceptions (%s)] Description: Used when exceptions in handler overlap or are identical Problematic code: def divide_x_by_y(x: float, y: float): try: print(x / y) except (ArithmeticError, FloatingPointError) as e: # [overlapping-except] print(f\"There was an issue: {e}\") Correct code: less_generic_first.py: def divide_x_by_y(x: float, y: float): try: print(x / y) except FloatingPointError as e: print(f\"There was a FloatingPointError: {e}\") except ArithmeticError as e: # FloatingPointError were already caught at this point print(f\"There was an OverflowError or a ZeroDivisionError: {e}\") only_generic.py: def divide_x_by_y(x: float, y: float): try: print(x / y) except ArithmeticError as e: print( f\"There was an OverflowError, a ZeroDivisionError or a FloatingPointError: {e}\" ) Configuration file: [MAIN] load-plugins=pylint.extensions.overlapping_exceptions, Related links: Exception hierarchy Note This message is emitted by the optional 'overlap-except' checker, which requires the pylint.extensions.overlapping_exceptions plugin to be loaded. Created by the overlap-except checker.",
    "option": {}
  },
  "W0239": {
    "description": "[Status: stable] [Name: overridden-final-method] [Message: Method %r overrides a method decorated with typing.final which is defined in class %r] Description: Used when a method decorated with typing.final has been overridden. Problematic code: from typing import final class Animal: @final def can_breathe(self): return True class Cat(Animal): def can_breathe(self): # [overridden-final-method] pass Correct code: from typing import final class Animal: @final def can_breathe(self): return True class Cat(Animal): def can_purr(self): return True Configuration file: [MAIN] py-version=3.8 Additional details: The message can't be emitted when using Python < 3.8. Related links: PEP 591 Created by the classes checker.",
    "option": {}
  },
  "W0133": {
    "description": "[Status: stable] [Name: pointless-exception-statement] [Message: Exception statement has no effect] Description: Used when an exception is created without being assigned, raised or returned for subsequent use elsewhere. Problematic code: Exception(\"This exception is a statement.\") # [pointless-exception-statement] Correct code: raise Exception(\"This will raise.\") Created by the basic checker.",
    "option": {}
  },
  "W0104": {
    "description": "[Status: stable] [Name: pointless-statement] [Message: Statement seems to have no effect] Description: Used when a statement doesn't have (or at least seems to) any effect. Problematic code: [1, 2, 3] # [pointless-statement] Correct code: NUMBERS = [1, 2, 3] print(NUMBERS) Created by the basic checker.",
    "option": {}
  },
  "W0105": {
    "description": "[Status: stable] [Name: pointless-string-statement] [Message: String statement has no effect] Description: Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments. Problematic code: \"\"\"This is a docstring which describes the module\"\"\" \"\"\"This is not a docstring\"\"\" # [pointless-string-statement] Correct code: \"\"\"This is a docstring which describes the module\"\"\" # This is comment which describes a particular part of the module. Related links: Discussion thread re: docstrings on assignments Created by the basic checker.",
    "option": {}
  },
  "W0641": {
    "description": "[Status: stable] [Name: possibly-unused-variable] [Message: Possibly unused variable %r] Description: Used when a variable is defined but might not be used. The possibility comes from the fact that locals() might be used, which could consume or not the said variable Problematic code: def choose_fruits(fruits): print(fruits) color = \"red\" # [possibly-unused-variable] return locals() Correct code: def choose_fruits(fruits): current_locals = locals() print(fruits) color = \"red\" print(color) return current_locals Created by the variables checker.",
    "option": {}
  },
  "W0407": {
    "description": "[Status: stable] [Name: preferred-module] [Message: Prefer importing %r instead of %r] Description: Used when a module imported has a preferred replacement module. Problematic code: import urllib # [preferred-module] Correct code: import requests Configuration file: [IMPORTS] preferred-modules=urllib:requests, Created by the imports checker.",
    "option": {}
  },
  "W0212": {
    "description": "[Status: stable] [Name: protected-access] [Message: Access to a protected member %s of a client class] Description: Used when a protected member (i.e. class member with a name beginning with an underscore) is accessed outside the class or a descendant of the class where it's defined. Problematic code: class Worm: def __swallow(self): pass jim = Worm() jim.__swallow() # [protected-access] Correct code: class Worm: def __swallow(self): pass def eat(self): return self.__swallow() jim = Worm() jim.eat() Created by the classes checker.",
    "option": {}
  },
  "W0707": {
    "description": "[Status: stable] [Name: raise-missing-from] [Message: Consider explicitly re-raising using %s'%s from %s'] Description: Python's exception chaining shows the traceback of the current exception, but also of the original exception. When you raise a new exception after another exception was caught it's likely that the second exception is a friendly re-wrapping of the first exception. In such cases `raise from` provides a better link between the two tracebacks in the final error. Problematic code: try: 1 / 0 except ZeroDivisionError as e: raise ValueError(\"Rectangle Area cannot be zero\") # [raise-missing-from] Correct code: try: 1 / 0 except ZeroDivisionError as e: raise ValueError(\"Rectangle Area cannot be zero\") from e Related links: PEP 3134 Created by the exceptions checker.",
    "option": {}
  },
  "W0715": {
    "description": "[Status: stable] [Name: raising-format-tuple] [Message: Exception arguments suggest string formatting might be intended] Description: Used when passing multiple arguments to an exception constructor, the first of them a string literal containing what appears to be placeholders intended for formatting Problematic code: raise RuntimeError(\"This looks wrong %s %s\", (\"a\", \"b\")) # [raising-format-tuple] Correct code: raise RuntimeError(\"This looks wrong %s %s\" % (\"a\", \"b\")) Created by the exceptions checker.",
    "option": {}
  },
  "W0128": {
    "description": "[Status: stable] [Name: redeclared-assigned-name] [Message: Redeclared variable %r in assignment] Description: Emitted when we detect that a variable was redeclared in the same assignment. Problematic code: FIRST, FIRST = (1, 2) # [redeclared-assigned-name] Correct code: FIRST, SECOND = (1, 2) Created by the basic checker.",
    "option": {}
  },
  "W0622": {
    "description": "[Status: stable] [Name: redefined-builtin] [Message: Redefining built-in %r] Description: Used when a variable or function override a built-in. Problematic code: def map(): # [redefined-builtin] pass Correct code: def map_iterable(): pass Additional details: The allowed-redefined-builtins option lets you specify names that are permitted to shadow built-ins. However, this option is not effective for redefinitions at the module level or for global variables. For example: Module-Level Redefinitions: # module_level_redefine.py id = 1 # Shadows the built-in `id` Global Variable Redefinitions: # global_variable_redefine.py def my_func(): global len len = 1 # Shadows the built-in `len` Rationale: Shadowing built-ins at the global scope is discouraged because it obscures their behavior throughout the entire module, increasing the risk of subtle bugs when the built-in is needed elsewhere. In contrast, local redefinitions are acceptable as their impact is confined to a specific scope, reducing unintended side effects and simplifying debugging. Created by the variables checker.",
    "option": {}
  },
  "W2901": {
    "description": "[Status: stable] [Name: redefined-loop-name] [Message: Redefining %r from loop (line %s)] Description: Used when a loop variable is overwritten in the loop body. Problematic code: def normalize_names(names): for name in names: name = name.lower() # [redefined-loop-name] Correct code: def normalize_names(names): for name in names: lowercased_name = name.lower() Configuration file: [MAIN] load-plugins=pylint.extensions.redefined_loop_name, Note This message is emitted by the optional 'redefined-loop-name' checker, which requires the pylint.extensions.redefined_loop_name plugin to be loaded. Created by the redefined-loop-name checker.",
    "option": {}
  },
  "W0621": {
    "description": "[Status: stable] [Name: redefined-outer-name] [Message: Redefining name %r from outer scope (line %s)] Description: Used when a variable's name hides a name defined in an outer scope or except handler. Problematic code: count = 10 def count_it(count): # [redefined-outer-name] for i in range(count): print(i) Correct code: count = 10 def count_it(limit): for i in range(limit): print(i) Additional details: A common issue is that this message is triggered when using pytest fixtures: import pytest @pytest.fixture def setup(): ... def test_something(setup): # [redefined-outer-name] ... One solution to this problem is to explicitly name the fixture: @pytest.fixture(name=\"setup\") def setup_fixture(): ... Alternatively pylint plugins like pylint-pytest can be used. Created by the variables checker.",
    "option": {}
  },
  "W0244": {
    "description": "[Status: stable] [Name: redefined-slots-in-subclass] [Message: Redefined slots %r in subclass] Description: Used when a slot is re-defined in a subclass. Problematic code: class Base: __slots__ = (\"a\", \"b\") class Subclass(Base): __slots__ = (\"a\", \"d\") # [redefined-slots-in-subclass] Correct code: class Base: __slots__ = (\"a\", \"b\") class Subclass(Base): __slots__ = (\"d\",) Created by the classes checker.",
    "option": {}
  },
  "W9008": {
    "description": "[Status: stable] [Name: redundant-returns-doc] [Message: Redundant returns documentation] Description: Please remove the return/rtype documentation from this method. Problematic code: def print_fruits(fruits): # [redundant-returns-doc] \"\"\"Print list of fruits Returns ------- str \"\"\" print(fruits) return None Correct code: def print_fruits(fruits): \"\"\"Print list of fruits Returns ------- str \"\"\" print(fruits) return \",\".join(fruits) Configuration file: [MAIN] load-plugins = pylint.extensions.docparams Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W1406": {
    "description": "[Status: stable] [Name: redundant-u-string-prefix] [Message: The u prefix for strings is no longer necessary in Python >=3.0] Description: Used when we detect a string with a u prefix. These prefixes were necessary in Python 2 to indicate a string was Unicode, but since Python 3.0 strings are Unicode by default. Problematic code: def print_fruit(): print(u\"Apple\") # [redundant-u-string-prefix] Correct code: def print_fruit(): print(\"Apple\") Created by the string checker.",
    "option": {}
  },
  "W1503": {
    "description": "[Status: stable] [Name: redundant-unittest-assert] [Message: Redundant use of %s with constant value %r] Description: The first argument of assertTrue and assertFalse is a condition. If a constant is passed as parameter, that condition will be always true. In this case a warning should be emitted. Problematic code: import unittest class DummyTestCase(unittest.TestCase): def test_dummy(self): self.assertTrue(\"foo\") # [redundant-unittest-assert] Correct code: import unittest class DummyTestCase(unittest.TestCase): def test_dummy(self): actual = \"test_result\" self.assertEqual(actual, \"expected\") Additional details: Directly asserting a string literal will always pass. The solution is to test something that could fail, or not assert at all. For assertions using assert there are similar messages: assert-on-string-literal / W0129 and assert-on-tuple / W0199. Related links: Tests without assertion Testing that there is no error raised Parametrizing conditional raising Created by the stdlib checker.",
    "option": {}
  },
  "W9010": {
    "description": "[Status: stable] [Name: redundant-yields-doc] [Message: Redundant yields documentation] Description: Please remove the yields documentation from this method. Problematic code: def give_fruits(fruits): # [redundant-yields-doc] \"\"\"Something about fruits Yields ------- list fruits \"\"\" return fruits Correct code: def give_fruits(fruits): \"\"\"Something about fruits Yields ------- str fruit \"\"\" for fruit in fruits: yield fruit Configuration file: [MAIN] load-plugins = pylint.extensions.docparams Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W0404": {
    "description": "[Status: stable] [Name: reimported] [Message: Reimport %r (imported line %s)] Description: Used when a module is imported more than once. Problematic code: import re import re # [reimported] Correct code: import re Created by the imports checker.",
    "option": {}
  },
  "W0134": {
    "description": "[Status: stable] [Name: return-in-finally] [Message: 'return' shadowed by the 'finally' clause.] Description: Emitted when a 'return' statement is found in a 'finally' block. This will overwrite the return value of a function and should be avoided. Problematic code: def second_favorite(): fruits = [\"kiwi\", \"pineapple\"] try: return fruits[1] finally: # because of this `return` statement, this function will always return \"kiwi\" return fruits[0] # [return-in-finally] Correct code: def second_favorite(): fruits = [\"kiwi\", \"pineapple\"] try: return fruits[1] except KeyError: ... return fruits[0] Related links: Python 3 docs 'finally' clause PEP 765 - Disallow return/break/continue that exit a finally block Created by the basic checker.",
    "option": {}
  },
  "W0127": {
    "description": "[Status: stable] [Name: self-assigning-variable] [Message: Assigning the same variable %r to itself] Description: Emitted when we detect that a variable is assigned to itself Problematic code: year = 2000 year = year # [self-assigning-variable] Correct code: year = 2000 Related links: Python assignment statement Created by the basic checker.",
    "option": {}
  },
  "W0642": {
    "description": "[Status: stable] [Name: self-cls-assignment] [Message: Invalid assignment to %s in method] Description: Invalid assignment to self or cls in instance or class method respectively. Problematic code: class Fruit: @classmethod def list_fruits(cls): cls = \"apple\" # [self-cls-assignment] def print_color(self, *colors): self = \"red\" # [self-cls-assignment] color = colors[1] print(color) Correct code: class Fruit: @classmethod def list_fruits(cls): fruit = \"apple\" print(fruit) def print_color(self, *colors): color = colors[1] print(color) Created by the variables checker.",
    "option": {}
  },
  "W0416": {
    "description": "[Status: stable] [Name: shadowed-import] [Message: Shadowed %r (imported line %s)] Description: Used when a module is aliased with a name that shadows another import. Problematic code: from pathlib import Path import FastAPI.Path as Path # [shadowed-import] Correct code: from pathlib import Path import FastAPI.Path as FastApiPath Created by the imports checker.",
    "option": {}
  },
  "W1507": {
    "description": "[Status: stable] [Name: shallow-copy-environ] [Message: Using copy.copy(os.environ). Use os.environ.copy() instead.] Description: os.environ is not a dict object but proxy object, so shallow copy has still effects on original object. See https://bugs.python.org/issue15373 for reference. Problematic code: import copy import os copied_env = copy.copy(os.environ) # [shallow-copy-environ] Correct code: import os copied_env = os.environ.copy() Created by the stdlib checker.",
    "option": {}
  },
  "W0222": {
    "description": "[Status: stable] [Name: signature-differs] [Message: Signature differs from %s %r method] Description: Used when a method signature is different than in the implemented interface or in an overridden method. Problematic code: class Animal: def run(self, distance=0): print(f\"Ran {distance} km!\") class Dog(Animal): def run(self, distance): # [signature-differs] super(Animal, self).run(distance) print(\"Fetched that stick, wuff !\") Correct code: class Animal: def run(self, distance=0): print(f\"Ran {distance} km!\") class Dog(Animal): def run(self, distance=0): super(Animal, self).run(distance) print(\"Fetched that stick, wuff !\") Created by the classes checker.",
    "option": {}
  },
  "W0240": {
    "description": "[Status: stable] [Name: subclassed-final-class] [Message: Class %r is a subclass of a class decorated with typing.final: %r] Description: Used when a class decorated with typing.final has been subclassed. Problematic code: from typing import final @final class PlatypusData: \"\"\"General Platypus data.\"\"\" average_length = 46 average_body_temperature = 32 class FluorescentPlaytipus(PlatypusData): # [subclassed-final-class] \"\"\"Playtipus with fluorescent fur.\"\"\" Correct code: from typing import final @final class PlatypusData: \"\"\"General Platypus data.\"\"\" average_length = 46 average_body_temperature = 32 def print_average_length_platypus(): output = f\"The average length of a platypus is: {PlatypusData.average_length}cm\" print(output) Configuration file: [MAIN] py-version=3.8 Additional details: This message is emitted when a class which is decorated with final is subclassed; the decorator indicates that the class is not intended to be extended. Note this message can't be emitted when using Python < 3.8. Related links: PEP 591 Created by the classes checker.",
    "option": {}
  },
  "W1509": {
    "description": "[Status: stable] [Name: subprocess-popen-preexec-fn] [Message: Using preexec_fn keyword which may be unsafe in the presence of threads] Description: The preexec_fn parameter is not safe to use in the presence of threads in your application. The child process could deadlock before exec is called. If you must use it, keep it trivial! Minimize the number of libraries you call into. See https://docs.python.org/3/library/subprocess.html#popen-constructor Problematic code: import subprocess def foo(): pass subprocess.Popen(preexec_fn=foo) # [subprocess-popen-preexec-fn] Correct code: import subprocess subprocess.Popen() Created by the stdlib checker.",
    "option": {}
  },
  "W1510": {
    "description": "[Status: stable] [Name: subprocess-run-check] [Message: 'subprocess.run' used without explicitly defining the value for 'check'.] Description: The ``check`` keyword is set to False by default. It means the process launched by ``subprocess.run`` can exit with a non-zero exit code and fail silently. It's better to set it explicitly to make clear what the error-handling behavior is. Problematic code: import subprocess proc = subprocess.run([\"ls\"]) # [subprocess-run-check] Correct code: import subprocess proc = subprocess.run([\"ls\"], check=False) Related links: subprocess.run documentation Created by the stdlib checker.",
    "option": {}
  },
  "W0231": {
    "description": "[Status: stable] [Name: super-init-not-called] [Message: __init__ method from base class %r is not called] Description: Used when an ancestor class method has an __init__ method which is not called by a derived class. Problematic code: class Fruit: def __init__(self, name=\"fruit\"): self.name = name print(\"Creating a {self.name}\") class Apple(Fruit): def __init__(self): # [super-init-not-called] print(\"Creating an apple\") Correct code: class Fruit: def __init__(self, name=\"fruit\"): self.name = name print(\"Creating a {self.name}\") class Apple(Fruit): def __init__(self): super().__init__(\"apple\") Created by the classes checker.",
    "option": {}
  },
  "W0245": {
    "description": "[Status: stable] [Name: super-without-brackets] [Message: Super call without brackets] Description: Used when a call to super does not have brackets and thus is not an actual call and does not work as expected. Problematic code: class Soup: @staticmethod def temp(): print(\"Soup is hot!\") class TomatoSoup(Soup): @staticmethod def temp(): super.temp() # [super-without-brackets] print(\"But tomato soup is even hotter!\") Correct code: class Soup: @staticmethod def temp(): print(\"Soup is hot!\") class TomatoSoup(Soup): @staticmethod def temp(): super().temp() print(\"But tomato soup is even hotter!\") Created by the classes checker.",
    "option": {}
  },
  "W0717": {
    "description": "[Status: stable] [Name: too-many-try-statements] [Message: %s] Description: Try clause contains too many statements. Problematic code: FRUITS = {\"apple\": 1, \"orange\": 10} def pick_fruit(name): try: # [too-many-try-statements] count = FRUITS[name] count += 1 print(f\"Got fruit count {count}\") except KeyError: return Correct code: FRUITS = {\"apple\": 1, \"orange\": 10} def pick_fruit(name): try: count = FRUITS[name] except KeyError: return count += 1 print(f\"Got fruit count {count}\") Configuration file: [MAIN] load-plugins=pylint.extensions.broad_try_clause, Note This message is emitted by the optional 'broad_try_clause' checker, which requires the pylint.extensions.broad_try_clause plugin to be loaded. Created by the broad_try_clause checker.",
    "option": {}
  },
  "W0706": {
    "description": "[Status: stable] [Name: try-except-raise] [Message: The except handler raises immediately] Description: Used when an except handler uses raise as its first or only operator. This is useless because it raises back the exception immediately. Remove the raise operator or the entire try-except-raise block! Problematic code: try: 1 / 0 except ZeroDivisionError as e: # [try-except-raise] raise Correct code: remove_try_except.py: # The try except might be removed entirely: 1 / 0 specialized_exception.py: # Another more detailed exception can be raised: try: 1 / 0 except ZeroDivisionError as e: raise ValueError(\"The area of the rectangle cannot be zero\") from e Additional details: There is a legitimate use case for re-raising immediately. E.g. with the following inheritance tree: +-- ArithmeticError +-- FloatingPointError +-- OverflowError +-- ZeroDivisionError The following code shows valid case for re-raising exception immediately: def execute_calculation(a, b): try: return some_calculation(a, b) except ZeroDivisionError: raise except ArithmeticError: return float('nan') The pylint is able to detect this case and does not produce error. Created by the exceptions checker.",
    "option": {}
  },
  "W0644": {
    "description": "[Status: stable] [Name: unbalanced-dict-unpacking] [Message: Possible unbalanced dict unpacking with %s: left side has %d label%s, right side has %d value%s] Description: Used when there is an unbalanced dict unpacking in assignment or for loop Problematic code: FRUITS = {\"apple\": 2, \"orange\": 3, \"mellon\": 10} for fruit, price in FRUITS.values(): # [unbalanced-dict-unpacking] print(fruit) Correct code: FRUITS = {\"apple\": 2, \"orange\": 3, \"mellon\": 10} for fruit, price in FRUITS.items(): print(fruit) Created by the variables checker.",
    "option": {}
  },
  "W0632": {
    "description": "[Status: stable] [Name: unbalanced-tuple-unpacking] [Message: Possible unbalanced tuple unpacking with sequence %s: left side has %d label%s, right side has %d value%s] Description: Used when there is an unbalanced tuple unpacking in assignment Problematic code: fruits = (\"orange\", \"apple\", \"strawberry\", \"peer\") orange, apple, strawberry = fruits # [unbalanced-tuple-unpacking] Correct code: fruits = (\"orange\", \"apple\", \"strawberry\", \"peer\") orange, apple, *remaining_fruits = fruits Related links: PEP 3132 - Extended Iterable Unpacking Created by the variables checker.",
    "option": {}
  },
  "W0631": {
    "description": "[Status: stable] [Name: undefined-loop-variable] [Message: Using possibly undefined loop variable %r] Description: Used when a loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop. Problematic code: def find_even_number(numbers): for x in numbers: if x % 2 == 0: break return x # [undefined-loop-variable] Correct code: def find_even_number(numbers): for x in numbers: if x % 2: return x return None Created by the variables checker.",
    "option": {}
  },
  "W0012": {
    "description": "[Status: stable] [Name: unknown-option-value] [Message: Unknown option value for '%s', expected a valid pylint message and got '%s'] Description: Used when an unknown value is encountered for an option. Problematic code: # pylint: disable=missnig-docstring # [unknown-option-value] Correct code: # pylint: disable=missing-docstring Created by the main checker.",
    "option": {}
  },
  "W2301": {
    "description": "[Status: stable] [Name: unnecessary-ellipsis] [Message: Unnecessary ellipsis constant] Description: Used when the ellipsis constant is encountered and can be avoided. A line of code consisting of an ellipsis is unnecessary if there is a docstring on the preceding line or if there is a statement in the same scope. Problematic code: def my_function(): \"\"\"My docstring\"\"\" ... # [unnecessary-ellipsis] Correct code: def my_function(): \"\"\"My docstring\"\"\" Created by the unnecessary_ellipsis checker.",
    "option": {}
  },
  "W0108": {
    "description": "[Status: stable] [Name: unnecessary-lambda] [Message: Lambda may not be necessary] Description: Used when the body of a lambda expression is a function call on the same argument list as the lambda itself; such lambda expressions are in all but a few cases replaceable with the function being called in the body of the lambda. Problematic code: pandas.py: df.apply(lambda x: str(x)) # [unnecessary-lambda] print.py: function = lambda x: print(x) # [unnecessary-lambda] function(\"Hello world !\") Correct code: pandas.py: df.apply(str) print.py: print(\"Hello world !\") Created by the basic checker.",
    "option": {}
  },
  "W0107": {
    "description": "[Status: stable] [Name: unnecessary-pass] [Message: Unnecessary pass statement] Description: Used when a \"pass\" statement can be removed without affecting the behaviour of the code. Problematic code: class DataEntryError(Exception): \"\"\"This exception is raised when a user has provided incorrect data.\"\"\" pass # [unnecessary-pass] Correct code: class DataEntryError(Exception): \"\"\"This exception is raised when a user has provided incorrect data.\"\"\" Created by the basic checker.",
    "option": {}
  },
  "W0301": {
    "description": "[Status: stable] [Name: unnecessary-semicolon] [Message: Unnecessary semicolon] Description: Used when a statement is ended by a semi-colon (\";\"), which isn't necessary (that's python, not C ;). Problematic code: print(\"Hello World!\"); # [unnecessary-semicolon] Correct code: print(\"Hello World!\") Created by the format checker.",
    "option": {}
  },
  "W0101": {
    "description": "[Status: stable] [Name: unreachable] [Message: Unreachable code] Description: Used when there is some code behind a \"return\" or \"raise\" statement, which will never be accessed. Problematic code: def say_hello(): return True print(\"Hello World!, Outside function.\") # [unreachable] Correct code: def say_hello(): print(\"Hello World!, Inside function.\") return True Created by the basic checker.",
    "option": {}
  },
  "W1514": {
    "description": "[Status: stable] [Name: unspecified-encoding] [Message: Using open without explicitly specifying an encoding] Description: It is better to specify an encoding when opening documents. Using the system default implicitly can create problems on other operating systems. See https://peps.python.org/pep-0597/ Problematic code: def foo(file_path): with open(file_path) as file: # [unspecified-encoding] contents = file.read() Correct code: def foo(file_path): with open(file_path, encoding=\"utf-8\") as file: contents = file.read() Created by the stdlib checker.",
    "option": {}
  },
  "W0613": {
    "description": "[Status: stable] [Name: unused-argument] [Message: Unused argument %r] Description: Used when a function or method argument is not used. Problematic code: def print_point(x, y): # [unused-argument] print(f\"Point is located at {x},{x}\") Correct code: def print_point(x, y): print(f\"Point is located at {x},{y}\") Created by the variables checker.",
    "option": {}
  },
  "W1304": {
    "description": "[Status: stable] [Name: unused-format-string-argument] [Message: Unused format argument %r] Description: Used when a PEP 3101 format string that uses named fields is used with an argument that is not required by the format string. Problematic code: print(\"{x} {y}\".format(x=1, y=2, z=3)) # [unused-format-string-argument] Correct code: add_format_target.py: print(\"{x} {y} {z}\".format(x=1, y=2, z=3)) remove_unused_args.py: print(\"{x} {y}\".format(x=1, y=2)) Created by the string checker.",
    "option": {}
  },
  "W1301": {
    "description": "[Status: stable] [Name: unused-format-string-key] [Message: Unused key %r in format string dictionary] Description: Used when a format string that uses named conversion specifiers is used with a dictionary that contains keys not required by the format string. Problematic code: \"The quick %(color)s fox jumps over the lazy dog.\" % { \"color\": \"brown\", \"action\": \"hops\", } # -4: [unused-format-string-key] Correct code: \"The quick %(color)s fox %(action)s over the lazy dog.\" % { \"color\": \"brown\", \"action\": \"hops\", } Created by the string checker.",
    "option": {}
  },
  "W0611": {
    "description": "[Status: stable] [Name: unused-import] [Message: Unused %s] Description: Used when an imported module or variable is not used. Problematic code: from logging import getLogger from pathlib import Path # [unused-import] LOGGER = getLogger(__name__) Correct code: from logging import getLogger LOGGER = getLogger(__name__) Additional details: By default, this check is skipped for __init__.py files, as they often contain imports from submodules for the convenience of end users. While these imports are not used within __init__.py, they serve the purpose of providing intuitive import paths for the module's important classes and constants. Related links: --init-import Created by the variables checker.",
    "option": {}
  },
  "W0238": {
    "description": "[Status: stable] [Name: unused-private-member] [Message: Unused private member `%s.%s`] Description: Emitted when a private member of a class is defined but not used. Problematic code: class Fruit: FRUITS = {\"apple\": \"red\", \"orange\": \"orange\"} def __print_color(self): # [unused-private-member] pass Correct code: class Fruit: FRUITS = {\"apple\": \"red\", \"orange\": \"orange\"} def __print_color(self, name, color): print(f\"{name}: {color}\") def print(self): for fruit, color in self.FRUITS.items(): self.__print_color(fruit, color) Created by the classes checker.",
    "option": {}
  },
  "W0612": {
    "description": "[Status: stable] [Name: unused-variable] [Message: Unused variable %r] Description: Used when a variable is defined but not used. Problematic code: def print_fruits(): fruit1 = \"orange\" fruit2 = \"apple\" # [unused-variable] print(fruit1) Correct code: def print_fruits(): fruit1 = \"orange\" fruit2 = \"apple\" print(fruit1, fruit2) Created by the variables checker.",
    "option": {}
  },
  "W0614": {
    "description": "[Status: stable] [Name: unused-wildcard-import] [Message: Unused import(s) %s from wildcard import of %s] Description: Used when an imported module or variable is not used from a `'from X import *'` style import. Problematic code: from abc import * # [unused-wildcard-import] class Animal(ABC): ... Correct code: from abc import ABC class Animal(ABC): ... Created by the variables checker.",
    "option": {}
  },
  "W0120": {
    "description": "[Status: stable] [Name: useless-else-on-loop] [Message: Else clause on loop without a break statement, remove the else and de-indent all the code inside it] Description: Loops should only have an else clause if they can exit early with a break statement, otherwise the statements under else should be on the same scope as the loop itself. Problematic code: def find_even_number(numbers): for x in numbers: if x % 2 == 0: return x else: # [useless-else-on-loop] print(\"Did not find an even number\") Correct code: def find_even_number(numbers): for x in numbers: if x % 2 == 0: return x print(\"Did not find an even number\") Created by the basic checker.",
    "option": {}
  },
  "W9019": {
    "description": "[Status: stable] [Name: useless-param-doc] [Message: \"%s\" useless ignored parameter documentation] Description: Please remove the ignored parameter documentation. Problematic code: def say_hello(_new: str) -> str: # [useless-param-doc] \"\"\"say hello! :param _new: :return: comment \"\"\" return \"hello\" Correct code: def say_hello(_new: str) -> str: \"\"\"say hello! :return: comment \"\"\" return \"hello\" Configuration file: [MAIN] load-plugins=pylint.extensions.docparams, Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W0246": {
    "description": "[Status: stable] [Name: useless-parent-delegation] [Message: Useless parent or super() delegation in method %r] Description: Used whenever we can detect that an overridden method is useless, relying on parent or super() delegation to do the same thing as another method from the MRO. Problematic code: class Animal: def eat(self, food): print(f\"Eating {food}\") class Human(Animal): def eat(self, food): # [useless-parent-delegation] super(Human, self).eat(food) Correct code: class Animal: def eat(self, food): print(f\"Eating {food}\") class Human(Animal): \"\"\"There is no need to override 'eat' it has the same signature as the implementation in Animal.\"\"\" Related links: Stackoverflow explanation for 'useless-super-delegation' Created by the classes checker.",
    "option": {}
  },
  "W9020": {
    "description": "[Status: stable] [Name: useless-type-doc] [Message: \"%s\" useless ignored parameter type documentation] Description: Please remove the ignored parameter type documentation. Problematic code: def print_fruit(fruit, _): # [useless-type-doc] \"\"\"docstring ... Args: fruit (str): A fruit. _ (float): Another argument. \"\"\" print(fruit) Correct code: def print_fruit(fruit): \"\"\"docstring ... Args: fruit (str): A fruit. \"\"\" print(fruit) Configuration file: [MAIN] load-plugins=pylint.extensions.docparams, Note This message is emitted by the optional 'parameter_documentation' checker, which requires the pylint.extensions.docparams plugin to be loaded. Created by the parameter_documentation checker.",
    "option": {}
  },
  "W2101": {
    "description": "[Status: stable] [Name: useless-with-lock] [Message: '%s()' directly created in 'with' has no effect] Description: Used when a new lock instance is created by using with statement which has no effect. Instead, an existing instance should be used to acquire lock. Problematic code: import threading with threading.Lock(): # [useless-with-lock] print(\"Make your bed.\") with threading.Lock(): # [useless-with-lock] print(\"Sleep in it\") Correct code: import threading lock = threading.Lock() with lock: print(\"Make your bed.\") with lock: print(\"Sleep in it.\") Created by the threading checker.",
    "option": {}
  },
  "W2605": {
    "description": "[Status: stable] [Name: using-assignment-expression-in-unsupported-version] [Message: Assignment expression is not supported by all versions included in the py-version setting] Description: Used when the py-version set by the user is lower than 3.8 and pylint encounters an assignment expression (walrus) operator. Problematic code: import random # +1: [using-assignment-expression-in-unsupported-version] if zero_or_one := random.randint(0, 1): assert zero_or_one == 1 Correct code: import random zero_or_one = random.randint(0, 1) if zero_or_one: assert zero_or_one == 1 Configuration file: [main] py-version=3.7 Additional details: The assignment expression (walrus) operator (:=) was introduced in Python 3.8; to use it, please use a more recent version of Python. Created by the unsupported_version checker.",
    "option": {}
  },
  "W0125": {
    "description": "[Status: stable] [Name: using-constant-test] [Message: Using a conditional statement with a constant value] Description: Emitted when a conditional statement (If or ternary if) uses a constant value for its test. This might not be what the user intended to do. Problematic code: if 0: # [using-constant-test] print(\"This code is never executed.\") if 1: # [using-constant-test] print(\"This code is always executed.\") Correct code: print(\"This code is always executed.\") Created by the basic checker.",
    "option": {}
  },
  "W2603": {
    "description": "[Status: stable] [Name: using-exception-groups-in-unsupported-version] [Message: Exception groups are not supported by all versions included in the py-version setting] Description: Used when the py-version set by the user is lower than 3.11 and pylint encounters ``except*`` or `ExceptionGroup``. Problematic code: def f(): excs = [OSError(\"error 1\"), SystemError(\"error 2\")] # +1: [using-exception-groups-in-unsupported-version] raise ExceptionGroup(\"there were problems\", excs) try: # [using-exception-groups-in-unsupported-version] f() except* OSError as e: print(\"There were OSErrors\") except* SystemError as e: print(\"There were SystemErrors\") Correct code: def f(): raise OSError(\"error 1\") try: f() except OSError as e: print(\"There were OSErrors\") except SystemError as e: print(\"There were SystemErrors\") Configuration file: [main] py-version=3.10 Additional details: Exception groups were introduced in Python 3.11; to use it, please use a more recent version of Python. Created by the unsupported_version checker.",
    "option": {}
  },
  "W2601": {
    "description": "[Status: stable] [Name: using-f-string-in-unsupported-version] [Message: F-strings are not supported by all versions included in the py-version setting] Description: Used when the py-version set by the user is lower than 3.6 and pylint encounters an f-string. Problematic code: f\"python {3.5} is past end of life\" # [using-f-string-in-unsupported-version] Correct code: \"python {} is past end of life\".format(3.5) Configuration file: [main] py-version=3.5 Additional details: f-strings were introduced in Python version 3.6; to use them, please use a more recent version of Python. Created by the unsupported_version checker.",
    "option": {}
  },
  "W2602": {
    "description": "[Status: stable] [Name: using-final-decorator-in-unsupported-version] [Message: typing.final is not supported by all versions included in the py-version setting] Description: Used when the py-version set by the user is lower than 3.8 and pylint encounters a ``typing.final`` decorator. Problematic code: from typing import final @final # [using-final-decorator-in-unsupported-version] class Playtypus(Animal): @final # [using-final-decorator-in-unsupported-version] def lay_egg(self): ... Correct code: class Playtypus(Animal): def lay_egg(self): ... Configuration file: [main] py-version=3.7 Additional details: The message is emitted when the final decorator is used with a Python version less than 3.8. The final decorator was introduced in Python version 3.8. Related links: PEP 591 Created by the unsupported_version checker.",
    "option": {}
  },
  "W2604": {
    "description": "[Status: stable] [Name: using-generic-type-syntax-in-unsupported-version] [Message: Generic type syntax (PEP 695) is not supported by all versions included in the py-version setting] Description: Used when the py-version set by the user is lower than 3.12 and pylint encounters generic type syntax. Problematic code: type Vector = list[float] # [using-generic-type-syntax-in-unsupported-version] Correct code: from typing import TypeAlias Vector: TypeAlias = list[float] Configuration file: [main] py-version=3.11 Additional details: Generic type syntax was introduced in Python 3.12; to use it, please use a more recent version of Python. Created by the unsupported_version checker.",
    "option": {}
  },
  "W2606": {
    "description": "[Status: stable] [Name: using-positional-only-args-in-unsupported-version] [Message: Positional-only arguments are not supported by all versions included in the py-version setting] Description: Used when the py-version set by the user is lower than 3.8 and pylint encounters positional-only arguments. Problematic code: def add(x, y, /): # [using-positional-only-args-in-unsupported-version] return x + y Correct code: # pylint: disable=missing-function-docstring, missing-module-docstring def add(x, y): return x + y Configuration file: [main] py-version=3.7 Additional details: Positional-only arguments were introduced in Python 3.8; to use them, please use a more recent version of Python. Created by the unsupported_version checker.",
    "option": {}
  },
  "W0149": {
    "description": "[Status: stable] [Name: while-used] [Message: Used `while` loop] Description: Unbounded `while` loops can often be rewritten as bounded `for` loops. Exceptions can be made for cases such as event loops, listeners, etc. Problematic code: import requests def fetch_data(): i = 1 while i < 6: # [while-used] print(f\"Attempt {i}...\") try: return requests.get(\"https://example.com/data\") except requests.exceptions.RequestException: pass i += 1 Correct code: import requests def fetch_data(): for i in range(1, 6): print(f\"Attempt {i}...\") try: return requests.get(\"https://example.com/data\") except requests.exceptions.RequestException: pass Configuration file: [main] load-plugins=pylint.extensions.while_used Related links: Stackoverflow discussion Note This message is emitted by the optional 'while_used' checker, which requires the pylint.extensions.while_used plugin to be loaded. Created by the while_used checker.",
    "option": {}
  },
  "W0401": {
    "description": "[Status: stable] [Name: wildcard-import] [Message: Wildcard import %s] Description: Used when `from module import *` is detected. Problematic code: from abc import * # [wildcard-import] Correct code: # Either import module or # only import required objects from module. import abc from abc import ABC, abstractmethod Created by the imports checker.",
    "option": {}
  },
  "W0716": {
    "description": "[Status: stable] [Name: wrong-exception-operation] [Message: Invalid exception operation. %s] Description: Used when an operation is done against an exception, but the operation is not valid for the exception in question. Usually emitted when having binary operations between exceptions in except handlers. Problematic code: try: 1 / 0 except ValueError + TypeError: # [wrong-exception-operation] pass Correct code: try: 1 / 0 except (ValueError, TypeError): pass Created by the exceptions checker.",
    "option": {}
  },
  "W0703": {
    "description": "[Status: stable] [Name: broad-except]",
    "option": {}
  },
  "W1517": {
    "description": "[Status: stable] [Name: cache-max-size-none]",
    "option": {}
  },
  "W1403": {
    "description": "[Status: stable] [Name: implicit-str-concat-in-sequence]",
    "option": {}
  },
  "W1516": {
    "description": "[Status: stable] [Name: lru-cache-decorating-method]",
    "option": {}
  },
  "W0235": {
    "description": "[Status: stable] [Name: useless-super-delegation]",
    "option": {}
  },
  "C0202": {
    "description": "[Status: stable] [Name: bad-classmethod-argument] [Message: Class method %s should have %s as first argument] Description: Used when a class method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to \"cls\"), recommended to easily differentiate them from regular instance methods. Problematic code: class Klass: @classmethod def get_instance(self): # [bad-classmethod-argument] return self() Correct code: class Klass: @classmethod def get_instance(cls): return cls() Created by the classes checker.",
    "option": {}
  },
  "C0198": {
    "description": "[Status: stable] [Name: bad-docstring-quotes] [Message: Bad docstring quotes in %s, expected \"\"\", given %s] Description: Used when a docstring does not have triple double quotes. Problematic code: def foo(): # [bad-docstring-quotes] \"Docstring.\" return Correct code: def foo(): \"\"\"Docstring.\"\"\" return Configuration file: [main] load-plugins=pylint.extensions.docstyle Additional details: From PEP 257:\"For consistency, always use \"\"\"triple double quotes\"\"\" around docstrings.\" Related links: PEP 257 – Docstring Conventions Note This message is emitted by the optional 'docstyle' checker, which requires the pylint.extensions.docstyle plugin to be loaded. Created by the docstyle checker.",
    "option": {}
  },
  "C2503": {
    "description": "[Status: stable] [Name: bad-file-encoding] [Message: PEP8 recommends UTF-8 as encoding for Python files] Description: PEP8 recommends UTF-8 default encoding for Python files. See https://peps.python.org/pep-0008/#source-file-encoding Problematic code: # coding: latin_1 # [bad-file-encoding] Correct code: Created by the unicode_checker checker.",
    "option": {}
  },
  "C0204": {
    "description": "[Status: stable] [Name: bad-mcs-classmethod-argument] [Message: Metaclass class method %s should have %s as first argument] Description: Used when a metaclass class method has a first argument named differently than the value specified in valid-metaclass-classmethod-first-arg option (default to \"mcs\"), recommended to easily differentiate them from regular instance methods. Problematic code: class Meta(type): @classmethod def foo(some): # [bad-mcs-classmethod-argument] pass Correct code: class Meta(type): @classmethod def foo(mcs): pass Created by the classes checker.",
    "option": {}
  },
  "C0203": {
    "description": "[Status: stable] [Name: bad-mcs-method-argument] [Message: Metaclass method %s should have %s as first argument] Description: Used when a metaclass method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to \"cls\"), recommended to easily differentiate them from regular instance methods. Problematic code: class Meta(type): def func(some): # [bad-mcs-method-argument] pass Correct code: class Meta(type): def func(cls): pass Created by the classes checker.",
    "option": {}
  },
  "C0201": {
    "description": "[Status: stable] [Name: consider-iterating-dictionary] [Message: Consider iterating the dictionary directly instead of calling .keys()] Description: Emitted when the keys of a dictionary are iterated through the ``.keys()`` method or when ``.keys()`` is used for a membership check. It is enough to iterate through the dictionary itself, ``for key in dictionary``. For membership checks, ``if key in dictionary`` is faster. Problematic code: FRUITS = {\"apple\": 1, \"pear\": 5, \"peach\": 10} for fruit in FRUITS.keys(): # [consider-iterating-dictionary] print(fruit) Correct code: FRUITS = {\"apple\": 1, \"pear\": 5, \"peach\": 10} for fruit in FRUITS: print(fruit) Created by the refactoring checker.",
    "option": {}
  },
  "C0501": {
    "description": "[Status: stable] [Name: consider-using-any-or-all] [Message: `for` loop could be `%s`] Description: A for loop that checks for a condition and return a bool can be replaced with any or all. Problematic code: all_even.py: def all_even(items): \"\"\"Return True if the list contains all even numbers\"\"\" for item in items: # [consider-using-any-or-all] if not item % 2 == 0: return False return True any_even.py: def any_even(items): \"\"\"Return True if the list contains any even numbers\"\"\" for item in items: # [consider-using-any-or-all] if item % 2 == 0: return True return False Correct code: all_even.py: def all_even(items): \"\"\"Return True if the list contains all even numbers\"\"\" return all(item % 2 == 0 for item in items) any_even.py: def any_even(items): \"\"\"Return True if the list contains any even numbers\"\"\" return any(item % 2 == 0 for item in items) Configuration file: [MAIN] load-plugins=pylint.extensions.for_any_all Note This message is emitted by the optional 'consider-using-any-or-all' checker, which requires the pylint.extensions.for_any_all plugin to be loaded. Created by the consider-using-any-or-all checker.",
    "option": {}
  },
  "C0206": {
    "description": "[Status: stable] [Name: consider-using-dict-items] [Message: Consider iterating with .items()] Description: Emitted when iterating over the keys of a dictionary and accessing the value by index lookup. Both the key and value can be accessed by iterating using the .items() method of the dictionary instead. Problematic code: ORCHESTRA = { \"violin\": \"strings\", \"oboe\": \"woodwind\", \"tuba\": \"brass\", \"gong\": \"percussion\", } for instrument in ORCHESTRA: # [consider-using-dict-items] print(f\"{instrument}: {ORCHESTRA[instrument]}\") Correct code: ORCHESTRA = { \"violin\": \"strings\", \"oboe\": \"woodwind\", \"tuba\": \"brass\", \"gong\": \"percussion\", } for instrument, section in ORCHESTRA.items(): print(f\"{instrument}: {section}\") Created by the refactoring checker.",
    "option": {}
  },
  "C0200": {
    "description": "[Status: stable] [Name: consider-using-enumerate] [Message: Consider using enumerate instead of iterating with range and len] Description: Emitted when code that iterates with range and len is encountered. Such code can be simplified by using the enumerate builtin. Problematic code: seasons = [\"Spring\", \"Summer\", \"Fall\", \"Winter\"] for i in range(len(seasons)): # [consider-using-enumerate] print(i, seasons[i]) Correct code: seasons = [\"Spring\", \"Summer\", \"Fall\", \"Winter\"] for i, season in enumerate(seasons): print(i, season) Created by the refactoring checker.",
    "option": {}
  },
  "C0209": {
    "description": "[Status: stable] [Name: consider-using-f-string] [Message: Formatting a regular string which could be an f-string] Description: Used when we detect a string that is being formatted with format() or % which could potentially be an f-string. The use of f-strings is preferred. Requires Python 3.6 and ``py-version >= 3.6``. Problematic code: from string import Template menu = (\"eggs\", \"spam\", 42.4) old_order = \"%s and %s: %.2f ¤\" % menu # [consider-using-f-string] beginner_order = menu[0] + \" and \" + menu[1] + \": \" + str(menu[2]) + \" ¤\" joined_order = \" and \".join(menu[:2]) # +1: [consider-using-f-string] format_order = \"{} and {}: {:0.2f} ¤\".format(menu[0], menu[1], menu[2]) # +1: [consider-using-f-string] named_format_order = \"{eggs} and {spam}: {price:0.2f} ¤\".format( eggs=menu[0], spam=menu[1], price=menu[2] ) template_order = Template(\"$eggs and $spam: $price ¤\").substitute( eggs=menu[0], spam=menu[1], price=menu[2] ) Correct code: menu = (\"eggs\", \"spam\", 42.4) f_string_order = f\"{menu[0]} and {menu[1]}: {menu[2]:0.2f} ¤\" Additional details: Formatted string literals (f-strings) give a concise, consistent syntax that can replace most use cases for the % formatting operator, str.format() and string.Template. F-strings also perform better than alternatives; see this tweet for a simple example. Created by the refactoring checker.",
    "option": {}
  },
  "C3401": {
    "description": "[Status: stable] [Name: dict-init-mutate] [Message: Declare all known key/values when initializing the dictionary.] Description: Dictionaries can be initialized with a single statement using dictionary literal syntax. Problematic code: fruit_prices = {} # [dict-init-mutate] fruit_prices[\"apple\"] = 1 fruit_prices[\"banana\"] = 10 Correct code: fruit_prices = {\"apple\": 1, \"banana\": 10} Configuration file: [MAIN] load-plugins=pylint.extensions.dict_init_mutate, Note This message is emitted by the optional 'dict-init-mutate' checker, which requires the pylint.extensions.dict_init_mutate plugin to be loaded. Created by the dict-init-mutate checker.",
    "option": {}
  },
  "C0104": {
    "description": "[Status: stable] [Name: disallowed-name] [Message: Disallowed name \"%s\"] Description: Used when the name matches bad-names or bad-names-rgxs- (unauthorized names). Problematic code: def foo(): # [disallowed-name] print(\"apples\") Correct code: def print_fruit(): print(\"apples\") Configuration file: [MAIN] bad-names=foo,bar,baz Created by the basic checker.",
    "option": {}
  },
  "C0199": {
    "description": "[Status: stable] [Name: docstring-first-line-empty] [Message: First line empty in %s docstring] Description: Used when a blank line is found at the beginning of a docstring. Problematic code: def foo(): # [docstring-first-line-empty] \"\"\" Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book \"\"\" Correct code: def foo(): \"\"\"Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book \"\"\" Configuration file: [MAIN] load-plugins = pylint.extensions.docstyle Note This message is emitted by the optional 'docstyle' checker, which requires the pylint.extensions.docstyle plugin to be loaded. Created by the docstyle checker.",
    "option": {}
  },
  "C0112": {
    "description": "[Status: stable] [Name: empty-docstring] [Message: Empty %s docstring] Description: Used when a module, function, class or method has an empty docstring (it would be too easy ;). Problematic code: def foo(): # [empty-docstring] \"\"\"\"\"\" Correct code: def foo(): \"\"\"A dummy description.\"\"\" Created by the basic checker.",
    "option": {}
  },
  "C0415": {
    "description": "[Status: stable] [Name: import-outside-toplevel] [Message: Import outside toplevel (%s)] Description: Used when an import statement is used anywhere other than the module toplevel. Move this import to the top of the file. Problematic code: def print_python_version(): import sys # [import-outside-toplevel] print(sys.version_info) Correct code: import sys def print_python_version(): print(sys.version_info) Created by the imports checker.",
    "option": {}
  },
  "C2701": {
    "description": "[Status: stable] [Name: import-private-name] [Message: Imported private %s (%s)] Description: Used when a private module or object prefixed with _ is imported. PEP8 guidance on Naming Conventions states that public attributes with leading underscores should be considered private. Problematic code: from argparse import _AttributeHolder, _SubParsersAction # [import-private-name] attr_holder = _AttributeHolder() def add_sub_parser(sub_parsers: _SubParsersAction): sub_parsers.add_parser(\"my_subparser\") # ... Correct code: \"\"\"Private import can be used as type annotations.\"\"\" from argparse import _SubParsersAction def add_sub_parser(sub_parsers: _SubParsersAction): sub_parsers.add_parser(\"my_subparser\") # ... Configuration file: [main] load-plugins = pylint.extensions.private_import Additional details: Using private imports expose you to unexpected breaking changes for any version bump of your dependencies, even in patch versions. Note This message is emitted by the optional 'import-private-name' checker, which requires the pylint.extensions.private_import plugin to be loaded. Created by the import-private-name checker.",
    "option": {}
  },
  "C0403": {
    "description": "[Status: stable] [Name: invalid-characters-in-docstring] [Message: Invalid characters %r in a docstring] Description: Used when a word in docstring cannot be checked by enchant. Additional details: This is a message linked to an internal problem in enchant. There's nothing to change in your code, but maybe in pylint's configuration or the way you installed the 'enchant' system library. Created by the spelling checker.",
    "option": {}
  },
  "C0103": {
    "description": "[Status: stable] [Name: invalid-name] [Message: %s name \"%s\" doesn't conform to %s] Description: Used when the name doesn't conform to naming rules associated to its type (constant, variable, class...). Problematic code: class cat: # [invalid-name] def Meow(self, NUMBER_OF_MEOW): # [invalid-name, invalid-name] print(\"Meow\" * NUMBER_OF_MEOW) return NUMBER_OF_MEOW Cat = cat().Meow(42) # [invalid-name] Correct code: class Cat: def meow(self, number_of_meow): print(\"Meow\" * number_of_meow) return number_of_meow CAT = Cat().meow(42) Additional details: Pylint recognizes a number of different name types internally. With a few exceptions, the type of the name is governed by the location the assignment to a name is found in, and not the type of object assigned. Name Type Description module Module and package names, same as the file names. const Module-level constants: any name defined at module level that is not bound to a class object nor reassigned. class Names in class statements, as well as names bound to class objects at module level. function Functions, toplevel or nested in functions or methods. method Methods, functions defined in class bodies. Includes static and class methods. attr Attributes created on class instances inside methods. argument Arguments to any function type, including lambdas. variable Local variables in function scopes or module-level names that are assigned multiple times. class-attribute Attributes defined in class bodies. class-const Enum constants and class variables annotated with Final inlinevar Loop variables in list comprehensions and generator expressions. typevar Type variable declared with TypeVar. paramspec Parameter specification variable declared with ParamSpec. typevartuple Type variable tuple declared with TypeVarTuple. typealias Type alias declared with TypeAlias or assignments of Union. Default behavior¶ By default, Pylint will enforce PEP8-suggested names. Predefined Naming Styles¶ Pylint provides set of predefined naming styles. Those predefined naming styles may be used to adjust Pylint configuration to coding style used in linted project. Following predefined naming styles are available: snake_case camelCase PascalCase UPPER_CASE any - fake style which does not enforce any limitations The following options are exposed: --module-naming-style=<style>¶ --const-naming-style=<style>¶ --class-naming-style=<style>¶ --function-naming-style=<style>¶ --method-naming-style=<style>¶ --attr-naming-style=<style>¶ --argument-naming-style=<style>¶ --variable-naming-style=<style>¶ --class-attribute-naming-style=<style>¶ --class-const-naming-style=<style>¶ --inlinevar-naming-style=<style>¶ Predefined Naming Patterns¶ Pylint provides predefined naming patterns for some names. These patterns are often based on a Naming Style but there is no option to choose one of the styles mentioned above. The pattern can be overwritten with the options discussed below. The following types of names are checked with a predefined pattern: Name type Good names Bad names typevar T, _CallableT, _T_co, AnyStr, DeviceTypeT, IPAddressT DICT_T, CALLABLE_T, ENUM_T, DeviceType, _StrType paramspec P, _P CALLABLE_P typevartuple Ts, _Ts TUPLE_TS typealias GoodName, _GoodName, IPAddressType,GoodName2 and other PascalCase variants that don't start with T or Type. This is to distinguish them from typevars. Note that TopName is allowed but TTopName isn't. BadNameT, badName, TBadName, TypeBadName,_1BadName Before pylint 3.0, most predefined patterns also enforced a minimum length of three characters. If this behavior is desired in versions 3.0 and following, it can be had by providing custom regular expressions as described next. (Or, if the disallowed-name check is sufficient instead of invalid-name, providing the single option bad-names-rgxs=\"^..?$\" will suffice to fail 1-2 character names. Custom regular expressions¶ If predefined naming styles are too limited, checker behavior may be further customized. For each name type, a separate regular expression matching valid names of this type can be defined. If any of custom regular expressions are defined, it overrides *-naming-style option value. Regular expressions for the names are anchored at the beginning, any anchor for the end must be supplied explicitly. Any name not matching the regular expression will lead to an instance of invalid-name. --module-rgx=<regex>¶ --const-rgx=<regex>¶ --class-rgx=<regex>¶ --function-rgx=<regex>¶ --method-rgx=<regex>¶ --attr-rgx=<regex>¶ --argument-rgx=<regex>¶ --variable-rgx=<regex>¶ --class-attribute-rgx=<regex>¶ --class-const-rgx=<regex>¶ --inlinevar-rgx=<regex>¶ --typevar-rgx=<regex>¶ --paramspec-rgx=<regex>¶ --typevartuple-rgx=<regex>¶ --typealias-rgx=<regex>¶ Multiple naming styles for custom regular expressions¶ Large code bases that have been worked on for multiple years often exhibit an evolution in style as well. In some cases, modules can be in the same package, but still have different naming style based on the stratum they belong to. However, intra-module consistency should still be required, to make changes inside a single file easier. For this case, Pylint supports regular expression with several named capturing group. Rather than emitting name warnings immediately, Pylint will determine the prevalent naming style inside each module and enforce it on all names. Consider the following (simplified) example: pylint --function-rgx='(?:(?P<snake>[a-z_]+)|(?P<camel>[a-z]+([A-Z][a-z]*)*))$' sample.py The regular expression defines two naming styles, snake for snake-case names, and camel for camel-case names. In sample.py, the function name on line 1 and 7 will mark the module and enforce the match of named group snake for the remaining names in the module: def valid_snake_case(arg): ... def InvalidCamelCase(arg): ... def more_valid_snake_case(arg): ... Because of this, the name on line 4 will trigger an invalid-name warning, even though the name matches the given regex. Matches named exempt or ignore can be used for non-tainting names, to prevent built-in or interface-dictated names to trigger certain naming styles. --name-group=<name1:name2:...,...>¶ Default value: empty Format: comma-separated groups of colon-separated names. This option can be used to combine name styles. For example, function:method enforces that functions and methods use the same style, and a style triggered by either name type carries over to the other. This requires that the regular expression for the combined name types use the same group names. Name Hints¶ --include-naming-hint=y|n¶ Default: off Include a hint (regular expression used) for the correct name format with every invalid-name warning. Created by the basic checker.",
    "option": {}
  },
  "C0301": {
    "description": "[Status: stable] [Name: line-too-long] [Message: Line too long (%s/%s)] Description: Used when a line is longer than a given number of characters. Problematic code: # +1: [line-too-long] FRUIT = [\"apricot\", \"blackcurrant\", \"cantaloupe\", \"dragon fruit\", \"elderberry\", \"fig\", \"grapefruit\", ] Correct code: FRUIT = [ \"apricot\", \"blackcurrant\", \"cantaloupe\", \"dragon fruit\", \"elderberry\", \"fig\", \"grapefruit\", ] Configuration file: [MAIN] max-line-length=100 Additional details: Pragma controls such as # pylint: disable=all are not counted toward line length for the purposes of this message. If you attempt to disable this message via # pylint: disable=line-too-long in a module with no code, you may receive a message for useless-suppression. This is a false positive of useless-suppression we can't easily fix. See https://github.com/pylint-dev/pylint/issues/3368 for more information. Created by the format checker.",
    "option": {}
  },
  "C2201": {
    "description": "[Status: stable] [Name: misplaced-comparison-constant] [Message: Comparison should be %s] Description: Used when the constant is placed on the left side of a comparison. It is usually clearer in intent to place it in the right hand side of the comparison. Problematic code: def compare_apples(apples=20): for i in range(10): if 5 <= i: # [misplaced-comparison-constant] pass if 1 == i: # [misplaced-comparison-constant] pass if 20 < len(apples): # [misplaced-comparison-constant] pass Correct code: def compare_apples(apples=20): for i in range(10): if i >= 5: pass if i == 1: pass if len(apples) > 20: pass Configuration file: [MAIN] load-plugins=pylint.extensions.comparison_placement Note This message is emitted by the optional 'comparison-placement' checker, which requires the pylint.extensions.comparison_placement plugin to be loaded. Created by the comparison-placement checker.",
    "option": {}
  },
  "C0115": {
    "description": "[Status: stable] [Name: missing-class-docstring] [Message: Missing class docstring] Description: Used when a class has no docstring. Even an empty class must have a docstring. Problematic code: class Person: # [missing-class-docstring] def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name Correct code: class Person: \"\"\"Class representing a person\"\"\" def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name Created by the basic checker.",
    "option": {}
  },
  "C0304": {
    "description": "[Status: stable] [Name: missing-final-newline] [Message: Final newline missing] Description: Used when the last line in a file is missing a newline. Problematic code: crlf.py: print(\"Hello\") # CRLF (\\r\\n) print(\"world\") # End-of-file (EOF) # [missing-final-newline] lf.py: print(\"Hello\") # LF (\\n) print(\"world\") # End-of-file (EOF) # [missing-final-newline] Correct code: crlf.py: print(\"Hello\") # CRLF (\\r\\n) print(\"world\") # CRLF (\\r\\n) # End-of-file (EOF) lf.py: print(\"Hello\") # LF (\\n) print(\"world\") # LF (\\n) # End-of-file (EOF) Additional details: The POSIX standard defines a line as:\"A sequence of zero or more non- <newline> characters plus a terminating <newline> character.\" Related links: POSIX Standard POSIX Standard Chapter 3.206 Line Created by the format checker.",
    "option": {}
  },
  "C0116": {
    "description": "[Status: stable] [Name: missing-function-docstring] [Message: Missing function or method docstring] Description: Used when a function or method has no docstring. Some special methods like __init__ do not require a docstring. Problematic code: import sys def print_python_version(): # [missing-function-docstring] print(sys.version) Correct code: import sys def print_python_version(): \"\"\"Function printing python version.\"\"\" print(sys.version) Created by the basic checker.",
    "option": {}
  },
  "C0114": {
    "description": "[Status: stable] [Name: missing-module-docstring] [Message: Missing module docstring] Description: Used when a module has no docstring. Empty modules do not require a docstring. Problematic code: import sys # [missing-module-docstring] def print_python_version(): print(sys.version) Correct code: \"\"\"Module providing a function printing python version.\"\"\" import sys def print_python_version(): print(sys.version) Created by the basic checker.",
    "option": {}
  },
  "C0327": {
    "description": "[Status: stable] [Name: mixed-line-endings] [Message: Mixed line endings LF and CRLF] Description: Used when there are mixed (LF and CRLF) newline signs in a file. Problematic code: print(\"Hello\") # CRLF (\\r\\n) print(\"World\") # LF (\\n) # [mixed-line-endings] Correct code: full_crlf.py: print(\"Hello\") # CRLF (\\r\\n) print(\"World\") # CRLF (\\r\\n) full_lf.py: print(\"Hello\") # LF (\\n) print(\"World\") # LF (\\n) Related links: History of CRLF and LF Dealing with line endings in Git A Collection of Useful .gitattributes Templates Created by the format checker.",
    "option": {}
  },
  "C0410": {
    "description": "[Status: stable] [Name: multiple-imports] [Message: Multiple imports on one line (%s)] Description: Used when import statement importing multiple modules is detected. Problematic code: import os, sys # [multiple-imports] Correct code: import os import sys Created by the imports checker.",
    "option": {}
  },
  "C0321": {
    "description": "[Status: stable] [Name: multiple-statements] [Message: More than one statement on a single line] Description: Used when more than on statement are found on the same line. Problematic code: fruits = [\"apple\", \"orange\", \"mango\"] if \"apple\" in fruits: pass # [multiple-statements] else: print(\"no apples!\") Correct code: fruits = [\"apple\", \"orange\", \"mango\"] if \"apple\" in fruits: pass else: print(\"no apples!\") Created by the format checker.",
    "option": {}
  },
  "C2403": {
    "description": "[Status: stable] [Name: non-ascii-module-import] [Message: %s name \"%s\" contains a non-ASCII character, use an ASCII-only alias for import.] Description: Used when the name contains at least one non-ASCII unicode character. See https://peps.python.org/pep-0672/#confusing-features for a background why this could be bad. If your programming guideline defines that you are programming in English, then there should be no need for non ASCII characters in Python Names. If not you can simply disable this check. Problematic code: from os.path import join as łos # [non-ascii-module-import] foo = łos(\"a\", \"b\") Correct code: from os.path import join as os_join foo = os_join(\"a\", \"b\") Created by the nonascii-checker checker.",
    "option": {}
  },
  "C2401": {
    "description": "[Status: stable] [Name: non-ascii-name] [Message: %s name \"%s\" contains a non-ASCII character, consider renaming it.] Description: Used when the name contains at least one non-ASCII unicode character. See https://peps.python.org/pep-0672/#confusing-features for a background why this could be bad. If your programming guideline defines that you are programming in English, then there should be no need for non ASCII characters in Python Names. If not you can simply disable this check. Problematic code: ápple_count = 4444 # [non-ascii-name] Correct code: apple_count = 4444 Created by the nonascii-checker checker.",
    "option": {}
  },
  "C0205": {
    "description": "[Status: stable] [Name: single-string-used-for-slots] [Message: Class __slots__ should be a non-string iterable] Description: Used when a class __slots__ is a simple string, rather than an iterable. Problematic code: class Fruit: # [single-string-used-for-slots] __slots__ = \"name\" def __init__(self, name): self.name = name Correct code: class Fruit: __slots__ = (\"name\",) def __init__(self, name): self.name = name Created by the classes checker.",
    "option": {}
  },
  "C0121": {
    "description": "[Status: stable] [Name: singleton-comparison] [Message: Comparison %s should be %s] Description: Used when an expression is compared to singleton values like True, False or None. Problematic code: game_won = True if game_won == True: # [singleton-comparison] print(\"Game won !\") Correct code: game_won = True if game_won: print(\"Game won !\") Related links: PEP 285 – Adding a bool type Created by the basic checker.",
    "option": {}
  },
  "C0325": {
    "description": "[Status: stable] [Name: superfluous-parens] [Message: Unnecessary parens after %r keyword] Description: Used when a single item in parentheses follows an if, for, or other keyword. Problematic code: example_1.py: x = input() y = input() if (x == y): # [superfluous-parens] pass example_2.py: i = 0 exclude = [] if (i - 0) in exclude: # [superfluous-parens] pass Correct code: example_1.py: x = input() y = input() if x == y: pass example_2.py: i = 0 exclude = [] if i - 0 in exclude: pass Created by the format checker.",
    "option": {}
  },
  "C0302": {
    "description": "[Status: stable] [Name: too-many-lines] [Message: Too many lines in module (%s/%s)] Description: Used when a module has too many lines, reducing its readability. Problematic code: def is_palindrome(string): # [too-many-lines] left_pos = 0 right_pos = len(string) - 1 while right_pos >= left_pos: if not string[left_pos] == string[right_pos]: return False left_pos += 1 right_pos -= 1 return True def main(): print(is_palindrome(\"aza\")) print(is_palindrome(\"racecar\")) print(is_palindrome(\"trigger\")) print(is_palindrome(\"ogre\")) Correct code: __init__.py: __all__ = [\"is_palindrome\", \"main\"] from is_palindrome import is_palindrome from main import main is_palindrome.py: def is_palindrome(string): return string == string[::-1] main.py: from is_palindrome import is_palindrome def main(): for string in [\"aza\", \"racecar\", \"trigger\", \"ogre\"]: print(is_palindrome(string)) Configuration file: [main] max-module-lines=15 Additional details: When a module has too many lines it can make it difficult to read and understand. There might be performance issue while editing the file because the IDE must parse more code. You need more expertise to navigate the file properly (go to a particular line when debugging, or search for a specific code construct, instead of navigating by clicking and scrolling) This measure is a proxy for higher cyclomatic complexity that you might not be calculating if you're not using load-plugins=pylint.extensions.mccabe,. Cyclomatic complexity is slower to compute, but also a more fine grained measure than raw SLOC. In particular, you can't make the code less readable by making a very complex one liner if you're using cyclomatic complexity. The example simplify the code, but it's not always possible. Most of the time bursting the file by creating a package with the same API is the only solution. Anticipating and creating the file from the get go will permit to have the same end result with a better version control history. Created by the format checker.",
    "option": {}
  },
  "C0305": {
    "description": "[Status: stable] [Name: trailing-newlines] [Message: Trailing newlines] Description: Used when there are trailing blank lines in a file. Problematic code: print(\"apple\") # The file ends with 2 lines that are empty # +1: [trailing-newlines] Correct code: print(\"apple\") Created by the format checker.",
    "option": {}
  },
  "C0303": {
    "description": "[Status: stable] [Name: trailing-whitespace] [Message: Trailing whitespace] Description: Used when there is whitespace between the end of a line and the newline. Problematic code: print(\"Hello\") # [trailing-whitespace] # ^^^ trailing whitespaces Correct code: print(\"Hello\") Created by the format checker.",
    "option": {}
  },
  "C0131": {
    "description": "[Status: stable] [Name: typevar-double-variance] [Message: TypeVar cannot be both covariant and contravariant] Description: Emitted when both the \"covariant\" and \"contravariant\" keyword arguments are set to \"True\" in a TypeVar. Problematic code: from typing import TypeVar T = TypeVar(\"T\", covariant=True, contravariant=True) # [typevar-double-variance] Correct code: from typing import TypeVar T_co = TypeVar(\"T_co\", covariant=True) T_contra = TypeVar(\"T_contra\", contravariant=True) Created by the basic checker.",
    "option": {}
  },
  "C0105": {
    "description": "[Status: stable] [Name: typevar-name-incorrect-variance] [Message: Type variable name does not reflect variance%s] Description: Emitted when a TypeVar name doesn't reflect its type variance. According to PEP8, it is recommended to add suffixes '_co' and '_contra' to the variables used to declare covariant or contravariant behaviour respectively. Invariant (default) variables do not require a suffix. The message is also emitted when invariant variables do have a suffix. Problematic code: from typing import TypeVar T_co = TypeVar(\"T_co\") # [typevar-name-incorrect-variance] Correct code: from typing import TypeVar T = TypeVar(\"T\") Additional details: When naming type vars, only use a _co suffix when indicating covariance or _contra when indicating contravariance. Created by the basic checker.",
    "option": {}
  },
  "C0132": {
    "description": "[Status: stable] [Name: typevar-name-mismatch] [Message: TypeVar name \"%s\" does not match assigned variable name \"%s\"] Description: Emitted when a TypeVar is assigned to a variable that does not match its name argument. Problematic code: from typing import TypeVar X = TypeVar(\"T\") # [typevar-name-mismatch] Correct code: from typing import TypeVar T = TypeVar(\"T\") Created by the basic checker.",
    "option": {}
  },
  "C0328": {
    "description": "[Status: stable] [Name: unexpected-line-ending-format] [Message: Unexpected line ending format. There is '%s' while it should be '%s'.] Description: Used when there is different newline than expected. Problematic code: print(\"I'm drinking tea!\") # CRLF (\\r\\n) # [unexpected-line-ending-format] print(\"I'm drinking water!\") # CRLF (\\r\\n) # [unexpected-line-ending-format] Correct code: print(\"I'm drinking tea!\") # LF (\\n) print(\"I'm drinking water!\") # LF (\\n) Configuration file: [FORMAT] expected-line-ending-format=LF Related links: History of CRLF and LF Dealing with line endings in Git A Collection of Useful .gitattributes Templates Created by the format checker.",
    "option": {}
  },
  "C0412": {
    "description": "[Status: stable] [Name: ungrouped-imports] [Message: Imports from package %s are not grouped] Description: Used when imports are not grouped by packages. Problematic code: import logging import os import sys import logging.config # [ungrouped-imports] from logging.handlers import WatchedFileHandler Correct code: import logging import logging.config import os import sys from logging.handlers import FileHandler Created by the imports checker.",
    "option": {}
  },
  "C0123": {
    "description": "[Status: stable] [Name: unidiomatic-typecheck] [Message: Use isinstance() rather than type() for a typecheck.] Description: The idiomatic way to perform an explicit typecheck in Python is to use isinstance(x, Y) rather than type(x) == Y, type(x) is Y. Though there are unusual situations where these give different results. Problematic code: test_score = {\"Biology\": 95, \"History\": 80} if type(test_score) is dict: # [unidiomatic-typecheck] pass Correct code: test_score = {\"Biology\": 95, \"History\": 80} if isinstance(test_score, dict): pass Related links: Builtin function type() Builtin function isinstance() Created by the basic checker.",
    "option": {}
  },
  "C3002": {
    "description": "[Status: stable] [Name: unnecessary-direct-lambda-call] [Message: Lambda expression called directly. Execute the expression inline instead.] Description: Used when a lambda expression is directly called rather than executing its contents inline. Problematic code: y = (lambda x: x**2 + 2 * x + 1)(a) # [unnecessary-direct-lambda-call] Correct code: y = a**2 + 2 * a + 1 Created by the lambda-expressions checker.",
    "option": {}
  },
  "C2801": {
    "description": "[Status: stable] [Name: unnecessary-dunder-call] [Message: Unnecessarily calls dunder method %s. %s.] Description: Used when a dunder method is manually called instead of using the corresponding function/method/operator. Problematic code: three = (3.0).__str__() # [unnecessary-dunder-call] twelve = \"1\".__add__(\"2\") # [unnecessary-dunder-call] def is_bigger_than_two(x): return x.__gt__(2) # [unnecessary-dunder-call] Correct code: three = str(3.0) twelve = \"1\" + \"2\" def is_bigger_than_two(x): return x > 2 Related links: Define dunder methods but don't call them directly Created by the unnecessary-dunder-call checker.",
    "option": {}
  },
  "C3001": {
    "description": "[Status: stable] [Name: unnecessary-lambda-assignment] [Message: Lambda expression assigned to a variable. Define a function using the \"def\" keyword instead.] Description: Used when a lambda expression is assigned to variable rather than defining a standard function with the \"def\" keyword. Problematic code: foo = lambda x: x**2 + 2 * x + 1 # [unnecessary-lambda-assignment] Correct code: def foo(x): return x**2 + 2 * x + 1 Created by the lambda-expressions checker.",
    "option": {}
  },
  "C0117": {
    "description": "[Status: stable] [Name: unnecessary-negation] [Message: Consider changing \"%s\" to \"%s\"] Description: Used when a boolean expression contains an unneeded negation, e.g. when two negation operators cancel each other out. Problematic code: double_not.py: if not not input(): # [unnecessary-negation] pass equivalent_comparator_exists.py: a = 3 b = 10 if not a > b: # [unnecessary-negation] pass Correct code: double_not.py: if input(): pass equivalent_comparator_exists.py: a = 3 b = 10 if a <= b: pass Created by the refactoring checker.",
    "option": {}
  },
  "C1803": {
    "description": "[Status: stable] [Name: use-implicit-booleaness-not-comparison] [Message: \"%s\" can be simplified to \"%s\", if it is strictly a sequence, as an empty %s is falsey] Description: Empty sequences are considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not a sequence (for example ``None``, an empty string, or ``0``) the code will not be equivalent. Problematic code: z = [] if z != []: # [use-implicit-booleaness-not-comparison] print(\"z is not an empty sequence\") Correct code: z = [] if z: print(\"z is not an empty sequence\") Created by the refactoring checker.",
    "option": {}
  },
  "C1804": {
    "description": "[Status: stable] [Name: use-implicit-booleaness-not-comparison-to-string] [Message: \"%s\" can be simplified to \"%s\", if it is strictly a string, as an empty string is falsey] Description: Empty string are considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not a string (for example ``None``, an empty sequence, or ``0``) the code will not be equivalent. Caution This message is disabled by default. To enable it, add use-implicit-booleaness-not-comparison-to-string to the enable option. Problematic code: def important_string_manipulation(x: str, y: str) -> None: if x == \"\": # [use-implicit-booleaness-not-comparison-to-string] print(\"x is an empty string\") if y != \"\": # [use-implicit-booleaness-not-comparison-to-string] print(\"y is not an empty string\") Correct code: def important_string_manipulation(x: str, y: str) -> None: if not x: print(\"x is an empty string\") if y: print(\"y is not an empty string\") Configuration file: [main] enable=use-implicit-booleaness-not-comparison-to-string Created by the refactoring checker.",
    "option": {}
  },
  "C1805": {
    "description": "[Status: stable] [Name: use-implicit-booleaness-not-comparison-to-zero] [Message: \"%s\" can be simplified to \"%s\", if it is strictly an int, as 0 is falsey] Description: 0 is considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not an int (for example ``None``, an empty string, or an empty sequence) the code will not be equivalent. Caution This message is disabled by default. To enable it, add use-implicit-booleaness-not-comparison-to-zero to the enable option. Problematic code: def important_math(x: int, y: int) -> None: if x == 0: # [use-implicit-booleaness-not-comparison-to-zero] print(\"x is equal to zero\") if y != 0: # [use-implicit-booleaness-not-comparison-to-zero] print(\"y is not equal to zero\") Correct code: def important_math(x: int, y: int) -> None: if not x: print(\"x is equal to zero\") if y: print(\"y is not equal to zero\") Configuration file: [main] enable=use-implicit-booleaness-not-comparison-to-zero Created by the refactoring checker.",
    "option": {}
  },
  "C1802": {
    "description": "[Status: stable] [Name: use-implicit-booleaness-not-len] [Message: Do not use `len(SEQUENCE)` without comparison to determine if a sequence is empty] Description: Empty sequences are considered false in a boolean context. You can either remove the call to 'len' (``if not x``) or compare the length against a scalar (``if len(x) > 1``). Problematic code: fruits = [\"orange\", \"apple\"] if len(fruits): # [use-implicit-booleaness-not-len] print(fruits) Correct code: fruits = [\"orange\", \"apple\"] if fruits: print(fruits) Created by the refactoring checker.",
    "option": {}
  },
  "C0207": {
    "description": "[Status: stable] [Name: use-maxsplit-arg] [Message: Use %s instead] Description: Emitted when accessing only the first or last element of str.split(). The first and last element can be accessed by using str.split(sep, maxsplit=1)[0] or str.rsplit(sep, maxsplit=1)[-1] instead. Problematic code: url = \"www.example.com\" suffix = url.split(\".\")[-1] # [use-maxsplit-arg] Correct code: url = \"www.example.com\" suffix = url.rsplit(\".\", maxsplit=1)[-1] Additional details: Be aware that the performance improvement from not splitting the string so many times will only be realized in cases presenting more instances of the splitting character than the minimal example here. Created by the refactoring checker.",
    "option": {}
  },
  "C0208": {
    "description": "[Status: stable] [Name: use-sequence-for-iteration] [Message: Use a sequence type when iterating over values] Description: When iterating over values, sequence types (e.g., ``lists``, ``tuples``, ``ranges``) are more efficient than ``sets``. Problematic code: for food in {\"apples\", \"lemons\", \"water\"}: # [use-sequence-for-iteration] print(f\"I like {food}.\") Correct code: list.py: for food in [\"apples\", \"lemons\", \"water\"]: print(f\"I like {food}.\") tuple.py: for food in (\"apples\", \"lemons\", \"water\"): print(f\"I like {food}.\") Additional details: https://gist.github.com/hofrob/8b1c1e205a0d4c66a680b1fe4bfeba11 This example script shows a significant increase in performance when using a list, tuple or range over a set in python version 3.11.1. Created by the refactoring checker.",
    "option": {}
  },
  "C0414": {
    "description": "[Status: stable] [Name: useless-import-alias] [Message: Import alias does not rename original package] Description: Used when an import alias is same as original package, e.g., using import numpy as numpy instead of import numpy as np. Problematic code: import pandas as pandas # [useless-import-alias] Correct code: import pandas as pd Additional details: Known issue¶ If you prefer to use \"from-as\" to explicitly reexport in API (from fruit import orange as orange) instead of using __all__ this message will be a false positive. Use --allow-reexport-from-package to allow explicit reexports by alias in package __init__ files. Related links: --allow-reexport-from-package PEP 8, Import Guideline Pylint block-disable mypy --no-implicit-reexport Created by the imports checker.",
    "option": {}
  },
  "C0411": {
    "description": "[Status: stable] [Name: wrong-import-order] [Message: %s should be placed before %s] Description: Used when PEP8 import order is not respected (standard imports first, then third-party libraries, then local imports). Problematic code: import os from . import utils import pylint # [wrong-import-order] import sys # [wrong-import-order] Correct code: import os import sys import pylint from . import utils Created by the imports checker.",
    "option": {}
  },
  "C0413": {
    "description": "[Status: stable] [Name: wrong-import-position] [Message: Import \"%s\" should be placed at the top of the module] Description: Used when code and imports are mixed. Problematic code: import os home = os.environ[\"HOME\"] import sys # [wrong-import-position] print(f\"Home directory is {home}\", file=sys.stderr) Correct code: import os import sys home = os.environ[\"HOME\"] print(f\"Home directory is {home}\", file=sys.stderr) Created by the imports checker.",
    "option": {}
  },
  "C0401": {
    "description": "[Status: stable] [Name: wrong-spelling-in-comment] [Message: Wrong spelling of a word '%s' in a comment: %s %s Did you mean: '%s'?] Description: Used when a word in comment is not spelled correctly. Problematic code: # There's a mistkae in this string # [wrong-spelling-in-comment] Correct code: # There's no mistake in this string Configuration file: [main] # This might not run in your env if you don't have the en_US dict installed. spelling-dict=en_US Created by the spelling checker.",
    "option": {}
  },
  "C0402": {
    "description": "[Status: stable] [Name: wrong-spelling-in-docstring] [Message: Wrong spelling of a word '%s' in a docstring: %s %s Did you mean: '%s'?] Description: Used when a word in docstring is not spelled correctly. Problematic code: \"\"\"There's a mistkae in this string\"\"\" # [wrong-spelling-in-docstring] Correct code: \"\"\"There's no mistake in this string\"\"\" Configuration file: [main] # This might not run in your env if you don't have the en_US dict installed. spelling-dict=en_US Created by the spelling checker.",
    "option": {}
  },
  "C0102": {
    "description": "[Status: stable] [Name: blacklisted-name]",
    "option": {}
  },
  "C1901": {
    "description": "[Status: stable] [Name: compare-to-empty-string]",
    "option": {}
  },
  "C2001": {
    "description": "[Status: stable] [Name: compare-to-zero]",
    "option": {}
  },
  "C1801": {
    "description": "[Status: stable] [Name: len-as-condition]",
    "option": {}
  },
  "C0111": {
    "description": "[Status: stable] [Name: missing-docstring]",
    "option": {}
  },
  "C0113": {
    "description": "[Status: stable] [Name: unneeded-not]",
    "option": {}
  },
  "R1716": {
    "description": "[Status: stable] [Name: chained-comparison] [Message: Simplify chained comparison between the operands] Description: This message is emitted when pylint encounters boolean operation like \"a < b and b < c\", suggesting instead to refactor it to \"a < b < c\" Problematic code: a = int(input()) b = int(input()) c = int(input()) if a < b and b < c: # [chained-comparison] pass Correct code: a = int(input()) b = int(input()) c = int(input()) if a < b < c: pass Created by the refactoring checker.",
    "option": {}
  },
  "R0133": {
    "description": "[Status: stable] [Name: comparison-of-constants] [Message: Comparison between constants: \"%s %s %s\" has a constant value] Description: When two literals are compared with each other the result is a constant. Using the constant directly is both easier to read and more performant. Initializing 'True' and 'False' this way is not required since Python 2.3. Problematic code: def is_the_answer() -> bool: return 42 == 42 # [comparison-of-constants] Correct code: def is_the_answer(meaning_of_life: int) -> bool: return meaning_of_life == 42 Created by the basic checker.",
    "option": {}
  },
  "R0124": {
    "description": "[Status: stable] [Name: comparison-with-itself] [Message: Redundant comparison - %s] Description: Used when something is compared against itself. Problematic code: def is_an_orange(fruit): an_orange = \"orange\" return fruit == fruit # [comparison-with-itself] Correct code: def is_an_orange(fruit): an_orange = \"orange\" return an_orange == fruit Created by the basic checker.",
    "option": {}
  },
  "R1727": {
    "description": "[Status: stable] [Name: condition-evals-to-constant] [Message: Boolean condition '%s' will always evaluate to '%s'] Description: Emitted when a boolean condition can be simplified to a constant value. Problematic code: def is_a_fruit(fruit): return bool(fruit in {\"apple\", \"orange\"} or True) # [condition-evals-to-constant] Correct code: def is_a_fruit(fruit): return fruit in {\"apple\", \"orange\"} Created by the refactoring checker.",
    "option": {}
  },
  "R5601": {
    "description": "[Status: stable] [Name: confusing-consecutive-elif] [Message: Consecutive elif with differing indentation level, consider creating a function to separate the inner elif] Description: Used when an elif statement follows right after an indented block which itself ends with if or elif. It may not be obvious if the elif statement was willingly or mistakenly unindented. Extracting the indented if statement into a separate function might avoid confusion and prevent errors. Problematic code: def myfunc(shall_continue: bool, shall_exit: bool): if shall_continue: if input(\"Are you sure?\") == \"y\": print(\"Moving on.\") elif shall_exit: # [confusing-consecutive-elif] print(\"Exiting.\") Correct code: # Option 1: add explicit 'else' def myfunc(shall_continue: bool, shall_exit: bool): if shall_continue: if input(\"Are you sure?\") == \"y\": print(\"Moving on.\") else: pass elif shall_exit: print(\"Exiting.\") # Option 2: extract function def user_confirmation(): if input(\"Are you sure?\") == \"y\": print(\"Moving on.\") def myfunc2(shall_continue: bool, shall_exit: bool): if shall_continue: user_confirmation() elif shall_exit: print(\"Exiting.\") Configuration file: [MAIN] load-plugins=pylint.extensions.confusing_elif Additional details: Creating a function for the nested conditional, or adding an explicit else in the indented if statement, even if it only contains a pass statement, can help clarify the code. Note This message is emitted by the optional 'confusing_elif' checker, which requires the pylint.extensions.confusing_elif plugin to be loaded. Created by the confusing_elif checker.",
    "option": {}
  },
  "R6003": {
    "description": "[Status: stable] [Name: consider-alternative-union-syntax] [Message: Consider using alternative union syntax instead of '%s'%s] Description: Emitted when ``typing.Union`` or ``typing.Optional`` is used instead of the shorthand union syntax. For example, ``Union[int, float]`` instead of ``int | float``. Using the shorthand for unions aligns with Python typing recommendations, removes the need for imports, and avoids confusion in function signatures. Problematic code: from typing import Optional, Union def forecast( temp: Union[int, float], # [consider-alternative-union-syntax] unit: Optional[str], # [consider-alternative-union-syntax] ) -> None: print(f'Temperature: {temp}{unit or \"\"}') Correct code: def forecast(temp: int | float, unit: str | None) -> None: print(f'Temperature: {temp}{unit or \"\"}') Configuration file: [MAIN] load-plugins = pylint.extensions.typing Additional details: Using the shorthand syntax for union types is recommended over the typing module. This is consistent with the broader recommendation to prefer built-in types over imports (for example, using list instead of the now-deprecated typing.List). typing.Optional can also cause confusion in annotated function arguments, since an argument annotated as Optional is still a required argument when a default value is not set. Explicitly annotating such arguments with type | None makes the intention clear. Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "R6106": {
    "description": "[Status: stable] [Name: consider-math-not-float] [Message: Consider %smath.%s instead of %s] Description: Using math.inf or math.nan permits to benefit from typing and it is up to 4 times faster than a float call (after the initial import of math). This check also catches typos in float calls as a side effect. Problematic code: swag = float(\"inf\") # [consider-math-not-float] Correct code: import math swag = math.inf Configuration file: [MAIN] load-plugins=pylint.extensions.code_style Additional details: This is an extension check because the typing advantage could be fixed. Regarding performance, float(\"nan\") and float(\"inf\") are slower than their counterpart math.inf and math.nan by a factor of 4 after the initial import of math. import math import timeit time_math_inf = timeit.timeit('math.nan', globals=globals(), number=10**8) print(f'math.nan: {time_math_inf:.2f} seconds') import timeit time_inf_str = timeit.timeit('float(\"nan\")', number=10**8) print(f'float(\"nan\"): {time_inf_str:.2f} seconds') Result: math.nan: 1.24 seconds float(\"nan\"): 5.15 seconds But if we take the initial import into account it's worse. import timeit time_math_inf = timeit.timeit('import math;math.nan', globals=globals(), number=10**8) print(f'math.nan: {time_math_inf:.2f} seconds') import timeit time_inf_str = timeit.timeit('float(\"nan\")', number=10**8) print(f'float(\"nan\"): {time_inf_str:.2f} seconds') Result: math.nan: 9.08 seconds float(\"nan\"): 5.33 seconds So the decision depends on how and how often you need to use it and what matter to you. Note This message is emitted by the optional 'code_style' checker, which requires the pylint.extensions.code_style plugin to be loaded. Created by the code_style checker.",
    "option": {}
  },
  "R1701": {
    "description": "[Status: stable] [Name: consider-merging-isinstance] [Message: Consider merging these isinstance calls to isinstance(%s, (%s))] Description: Used when multiple consecutive isinstance calls can be merged into one. Problematic code: from typing import Any def is_number(value: Any) -> bool: # +1: [consider-merging-isinstance] return isinstance(value, int) or isinstance(value, float) Correct code: from typing import Any def is_number(value: Any) -> bool: return isinstance(value, (int, float)) Created by the refactoring checker.",
    "option": {}
  },
  "R3501": {
    "description": "[Status: stable] [Name: consider-refactoring-into-while-condition] [Message: Consider using 'while %s' instead of 'while %s:' an 'if', and a 'break'] Description: Emitted when `while True:` loop is used and the first statement is a break condition. The ``if / break`` construct can be removed if the check is inverted and moved to the ``while`` statement. Problematic code: fruit_basket = [\"apple\", \"orange\", \"banana\", \"cherry\", \"guava\"] while True: # [consider-refactoring-into-while-condition] if len(fruit_basket) == 0: break fruit = fruit_basket.pop() print(f\"We removed {fruit} from the basket\") Correct code: fruit_basket = [\"apple\", \"orange\", \"banana\", \"cherry\", \"guava\"] while len(fruit_basket) != 0: fruit = fruit_basket.pop() print(f\"We removed {fruit} from the basket\") Configuration file: [MAIN] load-plugins=pylint.extensions.consider_refactoring_into_while_condition Note This message is emitted by the optional 'consider_refactoring_into_while' checker, which requires the pylint.extensions.consider_refactoring_into_while_condition plugin to be loaded. Created by the consider_refactoring_into_while checker.",
    "option": {}
  },
  "R1712": {
    "description": "[Status: stable] [Name: consider-swap-variables] [Message: Consider using tuple unpacking for swapping variables] Description: You do not have to use a temporary variable in order to swap variables. Using \"tuple unpacking\" to directly swap variables makes the intention more clear. Problematic code: a = 1 b = 2 temp = a # [consider-swap-variables] a = b b = temp Correct code: a = 1 b = 2 a, b = b, a Created by the refactoring checker.",
    "option": {}
  },
  "R6002": {
    "description": "[Status: stable] [Name: consider-using-alias] [Message: '%s' will be deprecated with PY39, consider using '%s' instead%s] Description: Only emitted if 'runtime-typing=no' and a deprecated typing alias is used in a type annotation context in Python 3.7 or 3.8. Problematic code: import typing cats: typing.Dict[str, int] # [consider-using-alias] Correct code: import typing cats: typing.cast(dict[str, int], \"string\") Configuration file: [main] load-plugins = pylint.extensions.typing py-version = 3.7 runtime-typing=no Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "R6103": {
    "description": "[Status: stable] [Name: consider-using-assignment-expr] [Message: Use '%s' instead] Description: Emitted when an if assignment is directly followed by an if statement and both can be combined by using an assignment expression ``:=``. Requires Python 3.8 and ``py-version >= 3.8``. Problematic code: apples = 2 if apples: # [consider-using-assignment-expr] print(\"God apples!\") Correct code: if apples := 2: print(\"God apples!\") Configuration file: [MAIN] py-version=3.8 load-plugins=pylint.extensions.code_style Note This message is emitted by the optional 'code_style' checker, which requires the pylint.extensions.code_style plugin to be loaded. Created by the code_style checker.",
    "option": {}
  },
  "R6104": {
    "description": "[Status: stable] [Name: consider-using-augmented-assign] [Message: Use '%s' to do an augmented assign directly] Description: Emitted when an assignment is referring to the object that it is assigning to. This can be changed to be an augmented assign. Disabled by default! Caution This message is disabled by default. To enable it, add consider-using-augmented-assign to the enable option. Problematic code: x = 1 x = x + 1 # [consider-using-augmented-assign] Correct code: x = 1 x += 1 Configuration file: [MAIN] load-plugins=pylint.extensions.code_style enable=consider-using-augmented-assign Note This message is emitted by the optional 'code_style' checker, which requires the pylint.extensions.code_style plugin to be loaded. Created by the code_style checker.",
    "option": {}
  },
  "R1717": {
    "description": "[Status: stable] [Name: consider-using-dict-comprehension] [Message: Consider using a dictionary comprehension] Description: Emitted when we detect the creation of a dictionary using the dict() callable and a transient list. Although there is nothing syntactically wrong with this code, it is hard to read and can be simplified to a dict comprehension. Also it is faster since you don't need to create another transient list Problematic code: NUMBERS = [1, 2, 3] # +1: [consider-using-dict-comprehension] DOUBLED_NUMBERS = dict([(number, number * 2) for number in NUMBERS]) Correct code: NUMBERS = [1, 2, 3] DOUBLED_NUMBERS = {number: number * 2 for number in NUMBERS} Additional details: pyupgrade or ruff can fix this issue automatically. Created by the refactoring checker.",
    "option": {}
  },
  "R0402": {
    "description": "[Status: stable] [Name: consider-using-from-import] [Message: Use 'from %s import %s' instead] Description: Emitted when a submodule of a package is imported and aliased with the same name, e.g., instead of ``import concurrent.futures as futures`` use ``from concurrent import futures``. Problematic code: import os.path as path # [consider-using-from-import] Correct code: from os import path Created by the imports checker.",
    "option": {}
  },
  "R1728": {
    "description": "[Status: stable] [Name: consider-using-generator] [Message: Consider using a generator instead '%s(%s)'] Description: If your container can be large using a generator will bring better performance. Problematic code: list([0 for y in list(range(10))]) # [consider-using-generator] tuple([0 for y in list(range(10))]) # [consider-using-generator] sum([y**2 for y in list(range(10))]) # [consider-using-generator] max([y**2 for y in list(range(10))]) # [consider-using-generator] min([y**2 for y in list(range(10))]) # [consider-using-generator] Correct code: list(0 for y in list(range(10))) tuple(0 for y in list(range(10))) sum(y**2 for y in list(range(10))) max(y**2 for y in list(range(10))) min(y**2 for y in list(range(10))) Additional details: Removing [] inside calls that can use containers or generators should be considered for performance reasons since a generator will have an upfront cost to pay. The performance will be better if you are working with long lists or sets. For max, min and sum using a generator is also recommended by pep289. Related links: PEP 289 Benchmark and discussion for any/all/list/tuple Benchmark and discussion for sum/max/min Created by the refactoring checker.",
    "option": {}
  },
  "R1715": {
    "description": "[Status: stable] [Name: consider-using-get] [Message: Consider using dict.get for getting values from a dict if a key is present or a default if not] Description: Using the builtin dict.get for getting a value from a dictionary if a key is present or a default if not, is simpler and considered more idiomatic, although sometimes a bit slower Problematic code: knights = {\"Gallahad\": \"the pure\", \"Robin\": \"the brave\"} if \"Gallahad\" in knights: # [consider-using-get] DESCRIPTION = knights[\"Gallahad\"] else: DESCRIPTION = \"\" Correct code: knights = {\"Gallahad\": \"the pure\", \"Robin\": \"the brave\"} description = knights.get(\"Gallahad\", \"\") Created by the refactoring checker.",
    "option": {}
  },
  "R1714": {
    "description": "[Status: stable] [Name: consider-using-in] [Message: Consider merging these comparisons with 'in' by using '%s %sin (%s)'. Use a set instead if elements are hashable.] Description: To check if a variable is equal to one of many values, combine the values into a set or tuple and check if the variable is contained \"in\" it instead of checking for equality against each of the values. This is faster and less verbose. Problematic code: def fruit_is_round(fruit): # +1: [consider-using-in] return fruit == \"apple\" or fruit == \"orange\" or fruit == \"melon\" Correct code: def fruit_is_round(fruit): return fruit in {\"apple\", \"orange\", \"melon\"} Created by the refactoring checker.",
    "option": {}
  },
  "R1713": {
    "description": "[Status: stable] [Name: consider-using-join] [Message: Consider using str.join(sequence) for concatenating strings from an iterable] Description: Using str.join(sequence) is faster, uses less memory and increases readability compared to for-loop iteration. Problematic code: def fruits_to_string(fruits): formatted_fruit = \"\" for fruit in fruits: formatted_fruit += fruit # [consider-using-join] return formatted_fruit print(fruits_to_string([\"apple\", \"pear\", \"peach\"])) Correct code: print(\"\".join([\"apple\", \"pear\", \"peach\"])) Created by the refactoring checker.",
    "option": {}
  },
  "R1731": {
    "description": "[Status: stable] [Name: consider-using-max-builtin] [Message: Consider using '%s' instead of unnecessary if block] Description: Using the max builtin instead of a conditional improves readability and conciseness. Problematic code: def get_max(value1, value2): if value1 < value2: # [consider-using-max-builtin] value1 = value2 return value1 print(get_max(1, 2)) Correct code: print(max(1, 2)) Created by the refactoring checker.",
    "option": {}
  },
  "R1730": {
    "description": "[Status: stable] [Name: consider-using-min-builtin] [Message: Consider using '%s' instead of unnecessary if block] Description: Using the min builtin instead of a conditional improves readability and conciseness. Problematic code: def get_min(value1, value2): if value1 > value2: # [consider-using-min-builtin] value1 = value2 return value1 print(get_min(1, 2)) Correct code: print(min(1, 2)) Created by the refactoring checker.",
    "option": {}
  },
  "R6101": {
    "description": "[Status: stable] [Name: consider-using-namedtuple-or-dataclass] [Message: Consider using namedtuple or dataclass for dictionary values] Description: Emitted when dictionary values can be replaced by namedtuples or dataclass instances. Problematic code: FELIDAES = { # [consider-using-namedtuple-or-dataclass] \"The queen's cymric, fragile furry friend\": { \"tail_length_cm\": 1, \"paws\": 4, \"eyes\": 2, \"Elizabethan collar\": 1, }, \"Rackat the red, terror of the sea\": { \"tail_length_cm\": 13, \"paws\": 3, \"eyes\": 1, \"Red Hat\": 1, }, } Correct code: from typing import NamedTuple class FelidaeCharacteristics(NamedTuple): tail_length_cm: int paws: int eyes: int hat: str | None FELIDAES = { \"The queen's cymric, fragile furry friend\": FelidaeCharacteristics( tail_length_cm=1, paws=4, eyes=2, hat=\"Elizabethan collar\" ), \"Rackat the red, terror of the sea\": FelidaeCharacteristics( tail_length_cm=21, paws=3, eyes=1, hat=\"Red Hat\" ), } Configuration file: [MAIN] load-plugins=pylint.extensions.code_style Note This message is emitted by the optional 'code_style' checker, which requires the pylint.extensions.code_style plugin to be loaded. Created by the code_style checker.",
    "option": {}
  },
  "R1718": {
    "description": "[Status: stable] [Name: consider-using-set-comprehension] [Message: Consider using a set comprehension] Description: Although there is nothing syntactically wrong with this code, it is hard to read and can be simplified to a set comprehension. Also it is faster since you don't need to create another transient list Problematic code: NUMBERS = [1, 2, 2, 3, 4, 4] # +1: [consider-using-set-comprehension] UNIQUE_EVEN_NUMBERS = set([number for number in NUMBERS if number % 2 == 0]) Correct code: NUMBERS = [1, 2, 2, 3, 4, 4] UNIQUE_EVEN_NUMBERS = {number for number in NUMBERS if number % 2 == 0} Additional details: pyupgrade or ruff can fix this issue automatically. Created by the refactoring checker.",
    "option": {}
  },
  "R1722": {
    "description": "[Status: stable] [Name: consider-using-sys-exit] [Message: Consider using 'sys.exit' instead] Description: Contrary to 'exit()' or 'quit()', 'sys.exit' does not rely on the site module being available (as the 'sys' module is always available). Problematic code: if __name__ == \"__main__\": user = input(\"Enter user name: \") print(f\"Hello, {user}\") exit(0) # [consider-using-sys-exit] Correct code: import sys if __name__ == \"__main__\": user = input(\"Enter user name: \") print(f\"Hello, {user}\") sys.exit(0) Created by the refactoring checker.",
    "option": {}
  },
  "R1706": {
    "description": "[Status: stable] [Name: consider-using-ternary] [Message: Consider using ternary (%s)] Description: Used when one of known pre-python 2.5 ternary syntax is used. Problematic code: x, y = 1, 2 maximum = x >= y and x or y # [consider-using-ternary] Correct code: x, y = 1, 2 maximum = x if x >= y else y Created by the refactoring checker.",
    "option": {}
  },
  "R6102": {
    "description": "[Status: stable] [Name: consider-using-tuple] [Message: Consider using an in-place tuple instead of list] Description: Only for style consistency! Emitted where an in-place defined ``list`` can be replaced by a ``tuple``. Due to optimizations by CPython, there is no performance benefit from it. Problematic code: for i in [1, 2, 3]: # [consider-using-tuple] print(i) Correct code: for i in (1, 2, 3): print(i) Configuration file: [MAIN] load-plugins=pylint.extensions.code_style Note This message is emitted by the optional 'code_style' checker, which requires the pylint.extensions.code_style plugin to be loaded. Created by the code_style checker.",
    "option": {}
  },
  "R1732": {
    "description": "[Status: stable] [Name: consider-using-with] [Message: Consider using 'with' for resource-allocating operations] Description: Emitted if a resource-allocating assignment or call may be replaced by a 'with' block. By using 'with' the release of the allocated resources is ensured even in the case of an exception. Problematic code: close.py: file = open(\"apple.txt\", \"r\", encoding=\"utf8\") # [consider-using-with] contents = file.read() file.close() not_even_close.py: contents = open(\"apple.txt\", \"r\", encoding=\"utf8\").read() # [consider-using-with] Correct code: with open(\"apple.txt\", \"r\", encoding=\"utf8\") as file: contents = file.read() Additional details: Calling write() without using the with keyword or calling close() might result in the arguments of write() not being completely written to the disk, even if the program exits successfully. This message applies to callables of Python's stdlib which can be replaced by a with statement. It is suppressed in the following cases: the call is located inside a context manager the call result is returned from the enclosing function the call result is used in a with statement itself Related links: Python doc: Reading and writing files PEP 343 Context managers in Python by John Lekberg Rationale Created by the refactoring checker.",
    "option": {}
  },
  "R0401": {
    "description": "[Status: stable] [Name: cyclic-import] [Message: Cyclic import (%s)] Description: Used when a cyclic import between two or more modules is detected. Problematic code: __init__.py: bad.py: def count_to_one(): return 1 def count_to_three(): from .bad2 import count_to_two return count_to_two() + 1 bad2.py: from .bad import count_to_one # [cyclic-import] def count_to_two(): return count_to_one() + 1 Correct code: def count_to_one(): return 1 def count_to_two(): return count_to_one() + 1 def count_to_three(): return count_to_two() + 1 Additional details: The good code is just an example. There are various strategies to resolving cyclic imports and the best choice relies heavily on the context of the code and the affected modules. Created by the imports checker.",
    "option": {}
  },
  "R0801": {
    "description": "[Status: stable] [Name: duplicate-code] [Message: Similar lines in %s files %s] Description: Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication. Problematic code: __init__.py: apple.py: class Apple: def __init__(self): self.remaining_bites = 3 def take_bite(self): if self.remaining_bites > 0: print(\"You take a bite of the apple.\") self.remaining_bites -= 1 else: print(\"The apple is already eaten up!\") def eaten_by_animal(self, animal): self.remaining_bites = 0 print(\"The apple has been eaten by an animal.\") orange.py: class Orange: # [duplicate-code] def __init__(self): self.remaining_bites = 3 def take_bite(self): if self.remaining_bites > 0: print(\"You take a bite of the apple.\") self.remaining_bites -= 1 else: print(\"The orange is already eaten up!\") def eaten_by_animal(self, animal): if animal == \"cat\": raise ValueError(\"A cat would never do that !\") self.remaining_bites = 0 print(\"The orange has been eaten by an animal.\") Correct code: __init__.py: apple.py: from fruit import Fruit class Apple(Fruit): ... fruit.py: class Fruit: def __init__(self): self.remaining_bites = 3 def take_bite(self): if self.remaining_bites > 0: print(f\"You take a bite of the {self.__class__.__name__.lower()}.\") self.remaining_bites -= 1 else: print(f\"The {self.__class__.__name__.lower()} is already eaten up!\") def eaten_by_animal(self, animal): self.remaining_bites = 0 print(f\"The {self.__class__.__name__.lower()} has been eaten by an animal.\") orange.py: from fruit import Fruit class Orange(Fruit): def eaten_by_animal(self, animal): if animal == \"cat\": raise ValueError(\"A cat would never do that !\") super().eaten_by_animal(animal) Additional details: If you need to make a change to the logic or functionality of the duplicated code, you will need to identify all the places that need to be changed, which can be time-consuming and error-prone. If there are multiple copies of the same code, then you will also need to test each copy to ensure that the functionality is correct. Duplicate code can be confusing for someone who is trying to understand the logic and flow of the code if they come across multiple identical or nearly identical blocks of code. The reader can then skim and think something is identical when it actually isn't. This is particularly true during review. Created by the similarities checker.",
    "option": {}
  },
  "R5501": {
    "description": "[Status: stable] [Name: else-if-used] [Message: Consider using \"elif\" instead of \"else\" then \"if\" to remove one indentation level] Description: Used when an else statement is immediately followed by an if statement and does not contain statements that would be unrelated to it. Problematic code: if input(): pass else: if len(input()) >= 10: # [else-if-used] pass else: pass Correct code: if input(): pass elif len(input()) >= 10: pass else: pass Configuration file: [MAIN] load-plugins=pylint.extensions.check_elif Note This message is emitted by the optional 'else_if_used' checker, which requires the pylint.extensions.check_elif plugin to be loaded. Created by the else_if_used checker.",
    "option": {}
  },
  "R2044": {
    "description": "[Status: stable] [Name: empty-comment] [Message: Line with empty comment] Description: Used when a # symbol appears on a line not followed by an actual comment Problematic code: # +1:[empty-comment] # # +1:[empty-comment] x = 0 # Correct code: # comment x = 0 # comment Configuration file: [main] load-plugins=pylint.extensions.empty_comment Note This message is emitted by the optional 'empty-comment' checker, which requires the pylint.extensions.empty_comment plugin to be loaded. Created by the empty-comment checker.",
    "option": {}
  },
  "R1710": {
    "description": "[Status: stable] [Name: inconsistent-return-statements] [Message: Either all return statements in a function should return an expression, or none of them should.] Description: According to PEP8, if any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable) Problematic code: def get_the_answer(value: str) -> str | None: # [inconsistent-return-statements] if value: return value Correct code: def get_the_answer(value: str) -> str | None: if value: return value return None Created by the refactoring checker.",
    "option": {}
  },
  "R0123": {
    "description": "[Status: stable] [Name: literal-comparison] [Message: In '%s', use '%s' when comparing constant literals not '%s' ('%s')] Description: Used when comparing an object to a literal, which is usually what you do not want to do, since you can compare to a different literal than what was expected altogether. Problematic code: def is_an_orange(fruit): return fruit is \"orange\" # [literal-comparison] Correct code: def is_an_orange(fruit): return fruit == \"orange\" Related links: Comparison operations in Python Created by the basic checker.",
    "option": {}
  },
  "R2004": {
    "description": "[Status: stable] [Name: magic-value-comparison] [Message: Consider using a named constant or an enum instead of '%s'.] Description: Using named constants instead of magic values helps improve readability and maintainability of your code, try to avoid them in comparisons. Problematic code: import random measurement = random.randint(0, 200) above_threshold = False i = 0 while i < 5: # [magic-value-comparison] above_threshold = measurement > 100 # [magic-value-comparison] if above_threshold: break measurement = random.randint(0, 200) Correct code: import random MAX_NUM_OF_ITERATIONS = 5 THRESHOLD_VAL = 100 MIN_MEASUREMENT_VAL = 0 MAX_MEASUREMENT_VAL = 200 measurement = random.randint(MIN_MEASUREMENT_VAL, MAX_MEASUREMENT_VAL) above_threshold = False i = 0 while i < MAX_NUM_OF_ITERATIONS: above_threshold = measurement > THRESHOLD_VAL if above_threshold: break measurement = random.randint(MIN_MEASUREMENT_VAL, MAX_MEASUREMENT_VAL) Configuration file: [main] load-plugins=pylint.extensions.magic_value Note This message is emitted by the optional 'magic-value' checker, which requires the pylint.extensions.magic_value plugin to be loaded. Created by the magic-value checker.",
    "option": {}
  },
  "R1905": {
    "description": "[Status: stable] [Name: match-class-bind-self] [Message: Use '%s() as %s' instead] Description: Match class patterns are faster if the name binding happens for the whole pattern and any lookup for `__match_args__` can be avoided. Problematic code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year def func(item: Book): match item: case Book(title=str(title)): # [match-class-bind-self] ... case Book(year=int(year)): # [match-class-bind-self] ... Correct code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year def func(item: Book): match item: case Book(title=str() as title): ... case Book(year=int() as year): ... Related links: Python documentation Created by the match_statements checker.",
    "option": {}
  },
  "R1906": {
    "description": "[Status: stable] [Name: match-class-positional-attributes] [Message: Use keyword attributes instead of positional ones (%s)] Description: Keyword attributes are more explicit and slightly faster since CPython can skip the `__match_args__` lookup. Problematic code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year def func(item: Book): match item: case Book(\"abc\", 2000): # [match-class-positional-attributes] ... Correct code: class Book: __match_args__ = (\"title\", \"year\") def __init__(self, title, year): self.title = title self.year = year def func(item: Book): match item: case Book(title=\"abc\", year=2000): ... Related links: Python documentation Created by the match_statements checker.",
    "option": {}
  },
  "R0202": {
    "description": "[Status: stable] [Name: no-classmethod-decorator] [Message: Consider using a decorator instead of calling classmethod] Description: Used when a class method is defined without using the decorator syntax. Problematic code: class Fruit: COLORS = [] def __init__(self, color): self.color = color def pick_colors(cls, *args): \"\"\"classmethod to pick fruit colors\"\"\" cls.COLORS = args pick_colors = classmethod(pick_colors) # [no-classmethod-decorator] Correct code: class Fruit: COLORS = [] def __init__(self, color): self.color = color @classmethod def pick_colors(cls, *args): \"\"\"classmethod to pick fruit colors\"\"\" cls.COLORS = args Created by the classes checker.",
    "option": {}
  },
  "R1723": {
    "description": "[Status: stable] [Name: no-else-break] [Message: Unnecessary \"%s\" after \"break\", %s] Description: Used in order to highlight an unnecessary block of code following an if containing a break statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a break statement. Problematic code: def next_seven_elements(iterator): for i, item in enumerate(iterator): if i == 7: # [no-else-break] break else: yield item Correct code: def next_seven_elements(iterator): for i, item in enumerate(iterator): if i == 7: break yield item Created by the refactoring checker.",
    "option": {}
  },
  "R1724": {
    "description": "[Status: stable] [Name: no-else-continue] [Message: Unnecessary \"%s\" after \"continue\", %s] Description: Used in order to highlight an unnecessary block of code following an if containing a continue statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a continue statement. Problematic code: def even_number_under(n: int): for i in range(n): if i % 2 == 1: # [no-else-continue] continue else: yield i Correct code: def even_number_under(n: int): for i in range(n): if i % 2 == 1: continue yield i Created by the refactoring checker.",
    "option": {}
  },
  "R1720": {
    "description": "[Status: stable] [Name: no-else-raise] [Message: Unnecessary \"%s\" after \"raise\", %s] Description: Used in order to highlight an unnecessary block of code following an if, or a try/except containing a raise statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a raise statement. Problematic code: def integer_sum(a: int, b: int) -> int: if not (isinstance(a, int) and isinstance(b, int)): # [no-else-raise] raise ValueError(\"Function supports only integer parameters.\") else: return a + b Correct code: def integer_sum(a: int, b: int) -> int: if not (isinstance(a, int) and isinstance(b, int)): raise ValueError(\"Function supports only integer parameters.\") return a + b Created by the refactoring checker.",
    "option": {}
  },
  "R1705": {
    "description": "[Status: stable] [Name: no-else-return] [Message: Unnecessary \"%s\" after \"return\", %s] Description: Used in order to highlight an unnecessary block of code following an if, or a try/except containing a return statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a return statement. Problematic code: def compare_numbers(a: int, b: int) -> int: if a == b: # [no-else-return] return 0 elif a < b: return -1 else: return 1 Correct code: def compare_numbers(a: int, b: int) -> int: if a == b: return 0 if a < b: return -1 return 1 Created by the refactoring checker.",
    "option": {}
  },
  "R6301": {
    "description": "[Status: stable] [Name: no-self-use] [Message: Method could be a function] Description: Used when a method doesn't use its bound instance, and so could be written as a function. Problematic code: class Person: def greeting(self): # [no-self-use] print(\"Greetings pythonista!\") Correct code: function.py: def greeting(): print(\"Greetings pythonista!\") staticmethod.py: class Person: @staticmethod def greeting(): print(\"Greetings pythonista!\") use_self.py: class Person: name: str = \"Amelia\" def greeting(self): print(f\"Greetings {self.name} the pythonista!\") Configuration file: [MAIN] load-plugins=pylint.extensions.no_self_use, Additional details: If a function is not using any class attribute it can be a @staticmethod, or a function outside the class. Note This message is emitted by the optional 'no_self_use' checker, which requires the pylint.extensions.no_self_use plugin to be loaded. Created by the no_self_use checker.",
    "option": {}
  },
  "R0203": {
    "description": "[Status: stable] [Name: no-staticmethod-decorator] [Message: Consider using a decorator instead of calling staticmethod] Description: Used when a static method is defined without using the decorator syntax. Problematic code: class Worm: def bore(self): pass bore = staticmethod(bore) # [no-staticmethod-decorator] Correct code: class Worm: @staticmethod def bore(self): pass Created by the classes checker.",
    "option": {}
  },
  "R6105": {
    "description": "[Status: stable] [Name: prefer-typing-namedtuple] [Message: Prefer 'typing.NamedTuple' over 'collections.namedtuple'] Description: 'typing.NamedTuple' uses the well-known 'class' keyword with type-hints for readability (it's also faster as it avoids an internal exec call). Disabled by default! Caution This message is disabled by default. To enable it, add prefer-typing-namedtuple to the enable option. Problematic code: from collections import namedtuple Philosophy = namedtuple( # [prefer-typing-namedtuple] \"Philosophy\", (\"goodness\", \"truth\", \"beauty\") ) Correct code: from typing import NamedTuple class Philosophy(NamedTuple): goodness: str truth: bool beauty: float Configuration file: [MAIN] load-plugins = pylint.extensions.code_style Related links: typing.NamedTuple Note This message is emitted by the optional 'code_style' checker, which requires the pylint.extensions.code_style plugin to be loaded. Created by the code_style checker.",
    "option": {}
  },
  "R0206": {
    "description": "[Status: stable] [Name: property-with-parameters] [Message: Cannot have defined parameters for properties] Description: Used when we detect that a property also has parameters, which are useless, given that properties cannot be called with additional arguments. Problematic code: class Worm: @property def bore(self, depth): # [property-with-parameters] pass Correct code: class Worm: @property def bore(self): \"\"\"Property accessed with '.bore'.\"\"\" pass def bore_with_depth(depth): \"\"\"Function called with .bore_with_depth(depth).\"\"\" pass Created by the classes checker.",
    "option": {}
  },
  "R1704": {
    "description": "[Status: stable] [Name: redefined-argument-from-local] [Message: Redefining argument with the local name %r] Description: Used when a local name is redefining an argument, which might suggest a potential error. This is taken in account only for a handful of name binding operations, such as for iteration, with statement assignment and exception handler assignment. Problematic code: def show(host_id=10.11): # +1: [redefined-argument-from-local] for host_id, host in [[12.13, \"Venus\"], [14.15, \"Mars\"]]: print(host_id, host) Correct code: def show(host_id=10.11): for inner_host_id, host in [[12.13, \"Venus\"], [14.15, \"Mars\"]]: print(host_id, inner_host_id, host) Created by the refactoring checker.",
    "option": {}
  },
  "R0204": {
    "description": "[Status: stable] [Name: redefined-variable-type] [Message: Redefinition of %s type from %s to %s] Description: Used when the type of a variable changes inside a method or a function. Problematic code: x = 1 x = \"2\" # [redefined-variable-type] Correct code: x = 1 x = 2 Configuration file: [MAIN] load-plugins=pylint.extensions.redefined_variable_type, Note This message is emitted by the optional 'multiple_types' checker, which requires the pylint.extensions.redefined_variable_type plugin to be loaded. Created by the multiple_types checker.",
    "option": {}
  },
  "R6006": {
    "description": "[Status: stable] [Name: redundant-typehint-argument] [Message: Type `%s` is used more than once in union type annotation. Remove redundant typehints.] Description: Duplicated type arguments will be skipped by `mypy` tool, therefore should be removed to avoid confusion. Problematic code: from typing import Union sweet_count: Union[int, str, int] = 42 # [redundant-typehint-argument] Correct code: from typing import Union sweet_count: Union[str, int] = 42 Configuration file: [main] load-plugins=pylint.extensions.typing Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "R1726": {
    "description": "[Status: stable] [Name: simplifiable-condition] [Message: Boolean condition \"%s\" may be simplified to \"%s\"] Description: Emitted when a boolean condition is able to be simplified. Problematic code: def has_apples(apples) -> bool: return bool(apples or False) # [simplifiable-condition] Correct code: def has_apples(apples) -> bool: return bool(apples) Created by the refactoring checker.",
    "option": {}
  },
  "R1719": {
    "description": "[Status: stable] [Name: simplifiable-if-expression] [Message: The if expression can be replaced with %s] Description: Used when an if expression can be replaced with 'bool(test)' or simply 'test' if the boolean cast is implicit. Problematic code: FLYING_THINGS = [\"bird\", \"plane\", \"superman\", \"this example\"] def is_flying_thing(an_object): return True if an_object in FLYING_THINGS else False # [simplifiable-if-expression] def is_not_flying_thing(an_object): return False if an_object in FLYING_THINGS else True # [simplifiable-if-expression] Correct code: FLYING_THINGS = [\"bird\", \"plane\", \"superman\", \"this example\"] def is_flying_thing(an_object): return an_object in FLYING_THINGS def is_not_flying_thing(an_object): return an_object not in FLYING_THINGS Related links: Simplifying an 'if' statement with bool() Created by the refactoring checker.",
    "option": {}
  },
  "R1703": {
    "description": "[Status: stable] [Name: simplifiable-if-statement] [Message: The if statement can be replaced with %s] Description: Used when an if statement can be replaced with 'bool(test)'. Problematic code: FLYING_THINGS = [\"bird\", \"plane\", \"superman\", \"this example\"] def is_flying_animal(an_object): # +1: [simplifiable-if-statement] if isinstance(an_object, Animal) and an_object in FLYING_THINGS: is_flying = True else: is_flying = False return is_flying Correct code: FLYING_THINGS = [\"bird\", \"plane\", \"superman\", \"this example\"] def is_flying_animal(an_object): is_flying = isinstance(an_object, Animal) and an_object.name in FLYING_THINGS return is_flying Created by the refactoring checker.",
    "option": {}
  },
  "R1709": {
    "description": "[Status: stable] [Name: simplify-boolean-expression] [Message: Boolean expression may be simplified to %s] Description: Emitted when redundant pre-python 2.5 ternary syntax is used. Problematic code: def has_oranges(oranges, apples=None) -> bool: return apples and False or oranges # [simplify-boolean-expression] Correct code: def has_oranges(oranges, apples=None) -> bool: return oranges Created by the refactoring checker.",
    "option": {}
  },
  "R1708": {
    "description": "[Status: stable] [Name: stop-iteration-return] [Message: Do not raise StopIteration in generator, use return statement instead] Description: According to PEP479, the raise of StopIteration to end the loop of a generator may lead to hard to find bugs. This PEP specify that raise StopIteration has to be replaced by a simple return statement Problematic code: fruit_generator.py: def fruit_generator(): for fruit in [\"apple\", \"banana\"]: yield fruit raise StopIteration # [stop-iteration-return] two_fruit_generator.py: def two_fruits_generator(fruits): for fruit in fruits: yield fruit, next(fruits) # [stop-iteration-return] two_good_fruit_generator.py: def two_good_fruits_generator(fruits): for fruit in fruits: if not fruit.is_tasty(): continue while True: next_fruit = next(fruits) # [stop-iteration-return] if next_fruit.is_tasty(): yield fruit, next_fruit break Correct code: fruit_generator.py: def fruit_generator(): \"\"\"The example is simple enough you don't need an explicit return.\"\"\" for fruit in [\"apple\", \"banana\"]: yield fruit two_fruit_generator.py: def two_fruits_generator(fruits): \"\"\"Catching the StopIteration.\"\"\" for fruit in fruits: try: yield fruit, next(fruits) except StopIteration: print(\"Sorry there is only one fruit left.\") yield fruit, None two_good_fruit_generator.py: def two_good_fruits_generator(fruits): \"\"\"A return can be used to end the iterator early, but not a StopIteration.\"\"\" for fruit in fruits: if not fruit.is_tasty(): continue while True: next_fruit = next(fruits, None) if next_fruit is None: print(\"Sorry there is only one fruit left.\") yield fruit, None # We reached the end of the 'fruits' generator but raising a # StopIteration instead of returning would create a RuntimeError return if next_fruit.is_tasty(): yield fruit, next_fruit break Additional details: It's possible to give a default value to next or catch the StopIteration, or return directly. A StopIteration cannot be propagated from a generator. Related links: PEP 479 Created by the refactoring checker.",
    "option": {}
  },
  "R1725": {
    "description": "[Status: stable] [Name: super-with-arguments] [Message: Consider using Python 3 style super() without arguments] Description: Emitted when calling the super() builtin with the current class and instance. On Python 3 these arguments are the default and they can be omitted. Problematic code: class Fruit: pass class Orange(Fruit): def __init__(self): super(Orange, self).__init__() # [super-with-arguments] Correct code: class Fruit: pass class Orange(Fruit): def __init__(self): super().__init__() Created by the refactoring checker.",
    "option": {}
  },
  "R1260": {
    "description": "[Status: stable] [Name: too-complex] [Message: %s is too complex. The McCabe rating is %d] Description: Used when a method or function is too complex based on McCabe Complexity Cyclomatic Problematic code: def fifty_percent_off(whole): return (float(whole)) * 50 / 100 def calculate_sum_and_display_price_of_fruits(*fruits): # [too-complex] # McCabe rating is 13 here (by default 10) shopping_list = [] if \"apple\" in fruits: v = fifty_percent_off(1.1) shopping_list.append(v) if \"pear\" in fruits: shopping_list.append(0.8) if \"banana\" in fruits: shopping_list.append(1.2) if \"mango\" in fruits: shopping_list.append(3.5) if \"peach\" in fruits: shopping_list.append(0.5) if \"melon\" in fruits: shopping_list.append(4.9) if \"orange\" in fruits: shopping_list.append(2.0) if \"strawberry\" in fruits: shopping_list.append(2.5) if \"mandarin\" in fruits: shopping_list.append(2.3) if \"plum\" in fruits: shopping_list.append(0.5) if \"watermelon\" in fruits: v = fifty_percent_off(6.4) shopping_list.append(v) combine = zip(fruits, shopping_list) for i in combine: print(f\"{i[0]} ${i[1]:.2f}\") total = sum(shopping_list) print(f\"Total price is ${total:.2f}\") fruits_to_buy = [\"apple\", \"orange\", \"watermelon\"] calculate_sum_and_display_price_of_fruits(*fruits_to_buy) Correct code: FRUIT_PRICES = { \"apple\": 1.1, \"pear\": 0.8, \"banana\": 1.2, \"mango\": 3.5, \"peach\": 0.5, \"melon\": 4.9, \"orange\": 2.0, \"strawberry\": 2.5, \"mandarin\": 2.3, \"plum\": 0.5, \"watermelon\": 6.4, } DISCOUNTED_FRUITS = [\"apple\", \"watermelon\"] def fifty_percent_off(whole): return (float(whole)) * 50 / 100 def get_price(fruit): full_price = FRUIT_PRICES.get(fruit) if fruit in DISCOUNTED_FRUITS: return fifty_percent_off(full_price) else: return full_price def display_fruit_and_price(fruits): for fruit in fruits: print(f\"{fruit} ${get_price(fruit) :.2f}\") def get_total(fruits): return sum(get_price(f) for f in fruits) fruits_to_buy = [\"apple\", \"orange\", \"watermelon\"] display_fruit_and_price(fruits_to_buy) print(f\"Total price is ${get_total(fruits_to_buy):.2f}\") Configuration file: [main] load-plugins=pylint.extensions.mccabe Note This message is emitted by the optional 'design' checker, which requires the pylint.extensions.mccabe plugin to be loaded. Created by the design checker.",
    "option": {}
  },
  "R0903": {
    "description": "[Status: stable] [Name: too-few-public-methods] [Message: Too few public methods (%s/%s)] Description: Used when class has too few public methods, so be sure it's really worth it. Problematic code: class Worm: # [too-few-public-methods] def __init__(self, name: str, fruit_of_residence: Fruit): self.name = name self.fruit_of_residence = fruit_of_residence def bore(self): print(f\"{self.name} is boring into {self.fruit_of_residence}\") Correct code: dataclass_and_function.py: import dataclasses @dataclasses.dataclass class Worm: name: str fruit_of_residence: Fruit def bore(worm: Worm): print(f\"{worm.name} is boring into {worm.fruit_of_residence}\") function.py: def bore(fruit: Fruit, worm_name: str): print(f\"{worm_name} is boring into {fruit}\") larger_api.py: class Worm: def __init__(self, name: str, fruit_of_residence: Fruit): self.name = name self.fruit_of_residence = fruit_of_residence def bore(self): print(f\"{self.name} is boring into {self.fruit_of_residence}\") def wiggle(self): print(f\"{self.name} wiggle around wormily.\") Created by the design checker.",
    "option": {}
  },
  "R0901": {
    "description": "[Status: stable] [Name: too-many-ancestors] [Message: Too many ancestors (%s/%s)] Description: Used when class has too many parent classes, try to reduce this to get a simpler (and so easier to use) class. Problematic code: class Animal: ... class BeakyAnimal(Animal): ... class FurryAnimal(Animal): ... class Swimmer(Animal): ... class EggLayer(Animal): ... class VenomousAnimal(Animal): ... class ProtectedSpecie(Animal): ... class BeaverTailedAnimal(Animal): ... class Vertebrate(Animal): ... # max of 7 by default, can be configured # each edge of a diamond inheritance counts class Playtypus( # [too-many-ancestors] BeakyAnimal, FurryAnimal, Swimmer, EggLayer, VenomousAnimal, ProtectedSpecie, BeaverTailedAnimal, Vertebrate, ): pass Correct code: class Animal: beaver_tailed: bool can_swim: bool has_beak: bool has_fur: bool has_vertebrae: bool lays_egg: bool protected_specie: bool venomous: bool class Invertebrate(Animal): has_vertebrae = False class Vertebrate(Animal): has_vertebrae = True class Mammal(Vertebrate): has_beak = False has_fur = True lays_egg = False venomous = False class Playtypus(Mammal): beaver_tailed = True can_swim = True has_beak = True lays_egg = True protected_specie = True venomous = True Created by the design checker.",
    "option": {}
  },
  "R0913": {
    "description": "[Status: stable] [Name: too-many-arguments] [Message: Too many arguments (%s/%s)] Description: Used when a function or method takes too many arguments. Problematic code: def three_d_chess_move( # [too-many-arguments] x_white, y_white, z_white, piece_white, x_black, y_black, z_black, piece_black, x_blue, y_blue, z_blue, piece_blue, current_player, ): pass Correct code: from dataclasses import dataclass @dataclass class ThreeDChessPiece: x: int y: int z: int type: str def three_d_chess_move( white: ThreeDChessPiece, black: ThreeDChessPiece, blue: ThreeDChessPiece, current_player, ): pass Created by the design checker.",
    "option": {}
  },
  "R0916": {
    "description": "[Status: stable] [Name: too-many-boolean-expressions] [Message: Too many boolean expressions in if statement (%s/%s)] Description: Used when an if statement contains too many boolean expressions. Problematic code: def can_be_divided_by_two_and_are_not_zero(x, y, z): # Maximum number of boolean expressions in an if statement (by default 5) # +1: [too-many-boolean-expressions] if (x and y and z) and (x % 2 == 0 and y % 2 == 0 and z % 2 == 0): pass Correct code: def can_be_divided_by_two_and_are_not_zero(x, y, z): if all(i and i % 2 == 0 for i in [x, y, z]): pass Created by the design checker.",
    "option": {}
  },
  "R0912": {
    "description": "[Status: stable] [Name: too-many-branches] [Message: Too many branches (%s/%s)] Description: Used when a function or method has too many branches, making it hard to follow. Problematic code: def num_to_word(x): # [too-many-branches] if x == 0: return \"zero\" elif x == 1: return \"one\" elif x == 2: return \"two\" elif x == 3: return \"three\" elif x == 4: return \"four\" elif x == 5: return \"five\" elif x == 6: return \"six\" elif x == 7: return \"seven\" elif x == 8: return \"eight\" elif x == 9: return \"nine\" else: return None Correct code: def num_to_word(x): return { 0: \"zero\", 1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\", }.get(x) Configuration file: [main] max-branches=10 Created by the design checker.",
    "option": {}
  },
  "R0902": {
    "description": "[Status: stable] [Name: too-many-instance-attributes] [Message: Too many instance attributes (%s/%s)] Description: Used when class has too many instance attributes, try to reduce this to get a simpler (and so easier to use) class. Problematic code: class Fruit: # [too-many-instance-attributes] def __init__(self): # max of 7 attributes by default, can be configured self.worm_name = \"Jimmy\" self.worm_type = \"Codling Moths\" self.worm_color = \"light brown\" self.fruit_name = \"Little Apple\" self.fruit_color = \"Bright red\" self.fruit_vitamins = [\"A\", \"B1\"] self.fruit_antioxidants = None self.secondary_worm_name = \"Kim\" self.secondary_worm_type = \"Apple maggot\" self.secondary_worm_color = \"Whitish\" Correct code: import dataclasses @dataclasses.dataclass class Worm: name: str type: str color: str class Fruit: def __init__(self): self.name = \"Little Apple\" self.color = \"Bright red\" self.vitamins = [\"A\", \"B1\"] self.antioxidants = None self.worms = [ Worm(name=\"Jimmy\", type=\"Codling Moths\", color=\"light brown\"), Worm(name=\"Kim\", type=\"Apple maggot\", color=\"Whitish\"), ] Created by the design checker.",
    "option": {}
  },
  "R0914": {
    "description": "[Status: stable] [Name: too-many-locals] [Message: Too many local variables (%s/%s)] Description: Used when a function or method has too many local variables. Problematic code: from childhood import Child, Sweet def handle_sweets(infos): # [too-many-locals] # Create children children = [Child(info) for info in infos] number_of_sweets = 87 sweets = [Sweet() * number_of_sweets] number_of_sweet_per_child = 5 money = 45.0 sweets_given = 0 time_to_eat_sweet = 54 price_of_sweet = 0.42 # distribute sweet for child in children: sweets_given += number_of_sweet_per_child child.give(sweets[number_of_sweet_per_child:]) # calculate prices cost_of_children = sweets_given * price_of_sweet # Calculate remaining money remaining_money = money - cost_of_children # Calculate time it took time_it_took_assuming_parallel_eating = ( time_to_eat_sweet * number_of_sweet_per_child ) print( f\"{children} ate {cost_of_children}¤ of sweets in {time_it_took_assuming_parallel_eating}, \" f\"you still have {remaining_money}\" ) Correct code: from typing import NamedTuple from childhood import Child, Sweet class SweetDistrubutionCharacteristics(NamedTuple): number_of_sweets: int number_of_sweet_per_child: int number_of_children: int @property def sweets_given(self): return self.number_of_sweet_per_child * self.number_of_children def handle_sweets(infos): children = [Child(info) for info in infos] characteristics = SweetDistrubutionCharacteristics(87, 5, len(children)) _allocate_sweets_to_children(children, characteristics) financial_impact = _assess_financial_impact(characteristics) print(f\"{children} ate {financial_impact}\") def _allocate_sweets_to_children( children, characteristics: SweetDistrubutionCharacteristics ) -> None: sweets = [Sweet() * characteristics.number_of_sweets] for child in children: child.give(sweets[characteristics.number_of_sweet_per_child :]) def _assess_financial_impact(characteristics: SweetDistrubutionCharacteristics) -> str: time_to_eat_sweet = 54 money = 45.0 price_of_sweet = 0.42 cost_of_children = characteristics.sweets_given * price_of_sweet remaining_money = money - cost_of_children time_it_took_assuming_parallel_eating = ( time_to_eat_sweet * characteristics.number_of_sweet_per_child ) return ( f\"{cost_of_children}¤ of sweets in \" f\"{time_it_took_assuming_parallel_eating}, you still have {remaining_money}\" ) Configuration file: [design] max-locals = 11 Additional details: Having too many locals may indicate that you're doing too much in a function and that classes regrouping some attributes could be created. Maybe operations could be separated in multiple functions. Are all your variables really closely related ? Created by the design checker.",
    "option": {}
  },
  "R1702": {
    "description": "[Status: stable] [Name: too-many-nested-blocks] [Message: Too many nested blocks (%s/%s)] Description: Used when a function or a method has too many nested blocks. This makes the code less understandable and maintainable. Problematic code: def correct_fruits(fruits): if len(fruits) > 1: # [too-many-nested-blocks] if \"apple\" in fruits: if \"orange\" in fruits: count = fruits[\"orange\"] if count % 2: if \"kiwi\" in fruits: if count == 2: return True return False Correct code: def correct_fruits(fruits): if len(fruits) > 1 and \"apple\" in fruits and \"orange\" in fruits: count = fruits[\"orange\"] if count % 2 and \"kiwi\" in fruits and count == 2: return True return False Created by the refactoring checker.",
    "option": {}
  },
  "R0917": {
    "description": "[Status: stable] [Name: too-many-positional-arguments] [Message: Too many positional arguments (%s/%s)] Description: Used when a function has too many positional arguments. Problematic code: # +1: [too-many-positional-arguments] def calculate_drag_force(velocity, area, density, drag_coefficient): \"\"\"Each argument is positional-or-keyword unless a `/` or `*` is present.\"\"\" return 0.5 * drag_coefficient * density * area * velocity**2 drag_force = calculate_drag_force(30, 2.5, 1.225, 0.47) Correct code: def calculate_drag_force(*, velocity, area, density, drag_coefficient): \"\"\"This function is 'Keyword only' for all args due to the '*'.\"\"\" return 0.5 * drag_coefficient * density * area * velocity**2 # This is now impossible to do and will raise a TypeError: # drag_force = calculate_drag_force(30, 2.5, 1.225, 0.47) # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # TypeError: calculate_drag_force() takes 0 positional arguments but 4 were given # And this is the only way to call 'calculate_drag_force' drag_force = calculate_drag_force( velocity=30, area=2.5, density=1.225, drag_coefficient=0.47 ) Configuration file: [DESIGN] max-positional-arguments=3 Additional details: Good function signatures don’t have many positional parameters. For almost all interfaces, comprehensibility suffers beyond a handful of arguments. Positional arguments work well for cases where the use cases are self-evident, such as unittest's assertEqual(first, second, \"assert msg\") or zip(fruits, vegetables). There are a few exceptions where four or more positional parameters make sense, for example rgba(1.0, 0.5, 0.3, 1.0), because it uses a very well-known and well-established convention, and using keywords all the time would be a waste of time. Related links: Special parameters in python Created by the design checker.",
    "option": {}
  },
  "R0904": {
    "description": "[Status: stable] [Name: too-many-public-methods] [Message: Too many public methods (%s/%s)] Description: Used when class has too many public methods, try to reduce this to get a simpler (and so easier to use) class. Problematic code: class SpaceInvaders: # [too-many-public-methods] def __init__(self): pass def fire_laser_beam(self): pass def deploy_shield(self): pass def launch_missile(self): pass def activate_super_laser(self): pass def summon_mothership(self): pass def destroy_planet(self): pass def teleport(self): pass def invoke_aliens(self): pass def invade_earth(self): pass def takeover_galaxy(self): pass Correct code: class LaserBeam: def __init__(self): pass def fire(self): pass def activate_super(self): pass def destroy_planet(self): pass class Shield: def deploy(self): pass class Missile: def launch(self): pass class SpaceInvaders: def __init__(self): self.laser = LaserBeam() self.shield = Shield() self.missile = Missile() def summon_mothership(self): pass def destroy_planet(self): pass def teleport(self): pass def invoke_aliens(self): pass def invade_earth(self): pass def takeover_galaxy(self): pass Configuration file: [main] max-public-methods=7 Additional details: Having too many public methods is an indication that you might not be respecting the Single-responsibility principle (S of SOLID). The class should have only one reason to change, but in the example the spaceship has at least 4 persons that could ask for change to it (laser manager, shield manager, missile manager, teleportation officer...). Related links: Single-responsibility principle Created by the design checker.",
    "option": {}
  },
  "R0911": {
    "description": "[Status: stable] [Name: too-many-return-statements] [Message: Too many return statements (%s/%s)] Description: Used when a function or method has too many return statement, making it hard to follow. Problematic code: def to_string(x): # [too-many-return-statements] # max of 6 by default, can be configured if x == 1: return \"This is one.\" if x == 2: return \"This is two.\" if x == 3: return \"This is three.\" if x == 4: return \"This is four.\" if x == 5: return \"This is five.\" if x == 6: return \"This is six.\" if x == 7: return \"This is seven.\" Correct code: NUMBERS_TO_STRINGS = { 1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", } def to_string(x): return f\"This is {NUMBERS_TO_STRINGS.get(x)}.\" Created by the design checker.",
    "option": {}
  },
  "R0915": {
    "description": "[Status: stable] [Name: too-many-statements] [Message: Too many statements (%s/%s)] Description: Used when a function or method has too many statements. You should then split it in smaller functions / methods. Problematic code: import random def distribute_candies( # [too-many-statements] children: list[Child], candies_per_child: int ): # This function is a masterpiece of code that embodies the epitome of efficiency # it's also an essential part of a high-priority project with extremely tight deadlines # and there is absolutely no time to refactor it to make it more concise. # The lead developer on the project, who has decades of experience, # has personally reviewed this implementation and deemed it good enough as it is. # The person writing this code has a demanding job and multiple responsibilities, # and simply does not have the luxury of spending time making this code more readable. total_candies = len(children) * candies_per_child eaten_candies = 0 # Counting candies given to each child for child in children: # If a child eat more than 1 candies they're going to eat all # the candies for sure eaten_for_child = random.choices([0, 1, candies_per_child]) print( f\"Child {child} gets {candies_per_child} candies and eat {eaten_for_child}\" ) remaining_candies_for_children = child.eat_candies(eaten_for_child) if remaining_candies_for_children == 0: print(f\"All the candies have been devoured by {child.name}!\") else: print( f\"{child.name} still have {remaining_candies_for_children} candies left.\" ) eaten_candies += eaten_for_child return eaten_candies, total_candies Correct code: import random def distribute_candies(children: list[Child], candies_per_child: int): total_candies = len(children) * candies_per_child eaten_candies = 0 for child in children: eaten_candies += _distribute_candies_to_child(candies_per_child, child) return eaten_candies, total_candies def _distribute_candies_to_child(candies_per_child: int, child: Child): # If a child eat more than 1 candies they're going to eat all # the candies for sure eaten_for_child = random.choices([0, 1, candies_per_child]) print(f\"Child {child} gets {candies_per_child} candies and eat {eaten_for_child}\") remaining_candies_for_children = child.eat_candies(eaten_for_child) if remaining_candies_for_children == 0: print(f\"All the candies have been devoured by {child.name}!\") else: print(f\"{child.name} still have {remaining_candies_for_children} candies left.\") return eaten_for_child Configuration file: [DESIGN] max-statements=7 Created by the design checker.",
    "option": {}
  },
  "R1707": {
    "description": "[Status: stable] [Name: trailing-comma-tuple] [Message: Disallow trailing comma tuple] Description: In Python, a tuple is actually created by the comma symbol, not by the parentheses. Unfortunately, one can actually create a tuple by misplacing a trailing comma, which can lead to potential weird bugs in your code. You should always use parentheses explicitly for creating a tuple. Problematic code: COMPASS = \"north\", \"south\", \"east\", \"west\", # [trailing-comma-tuple] Correct code: COMPASS = (\"north\", \"south\", \"east\", \"west\") Created by the refactoring checker.",
    "option": {}
  },
  "R1721": {
    "description": "[Status: stable] [Name: unnecessary-comprehension] [Message: Unnecessary use of a comprehension, use %s instead.] Description: Instead of using an identity comprehension, consider using the list, dict or set constructor. It is faster and simpler. Problematic code: NUMBERS = [1, 1, 2, 2, 3, 3] UNIQUE_NUMBERS = {number for number in NUMBERS} # [unnecessary-comprehension] Correct code: NUMBERS = [1, 1, 2, 2, 3, 3] UNIQUE_NUMBERS = set(NUMBERS) Created by the refactoring checker.",
    "option": {}
  },
  "R6007": {
    "description": "[Status: stable] [Name: unnecessary-default-type-args] [Message: Type `%s` has unnecessary default type args. Change it to `%s`.] Description: Emitted when types have default type args which can be omitted. Mainly used for `typing.Generator` and `typing.AsyncGenerator`. Problematic code: from collections.abc import AsyncGenerator, Generator a1: AsyncGenerator[int, None] # [unnecessary-default-type-args] b1: Generator[int, None, None] # [unnecessary-default-type-args] Correct code: from collections.abc import AsyncGenerator, Generator a1: AsyncGenerator[int] b1: Generator[int] Configuration file: [main] load-plugins=pylint.extensions.typing Additional details: At the moment, this check only works for Generator and AsyncGenerator. Starting with Python 3.13, the SendType and ReturnType default to None. As such it's no longer necessary to specify them. The collections.abc variants don't validate the number of type arguments. Therefore the defaults for these can be used in earlier versions as well. Related links: Python documentation for AsyncGenerator Python documentation for Generator Note This message is emitted by the optional 'typing' checker, which requires the pylint.extensions.typing plugin to be loaded. Created by the typing checker.",
    "option": {}
  },
  "R1733": {
    "description": "[Status: stable] [Name: unnecessary-dict-index-lookup] [Message: Unnecessary dictionary index lookup, use '%s' instead] Description: Emitted when iterating over the dictionary items (key-item pairs) and accessing the value by index lookup. The value can be accessed directly instead. Problematic code: FRUITS = {\"apple\": 1, \"orange\": 10, \"berry\": 22} for fruit_name, fruit_count in FRUITS.items(): print(FRUITS[fruit_name]) # [unnecessary-dict-index-lookup] Correct code: FRUITS = {\"apple\": 1, \"orange\": 10, \"berry\": 22} for fruit_name, fruit_count in FRUITS.items(): print(fruit_count) Created by the refactoring checker.",
    "option": {}
  },
  "R1736": {
    "description": "[Status: stable] [Name: unnecessary-list-index-lookup] [Message: Unnecessary list index lookup, use '%s' instead] Description: Emitted when iterating over an enumeration and accessing the value by index lookup. The value can be accessed directly instead. Problematic code: letters = [\"a\", \"b\", \"c\"] for index, letter in enumerate(letters): print(letters[index]) # [unnecessary-list-index-lookup] Correct code: letters = [\"a\", \"b\", \"c\"] for index, letter in enumerate(letters): print(letter) Created by the refactoring checker.",
    "option": {}
  },
  "R1729": {
    "description": "[Status: stable] [Name: use-a-generator] [Message: Use a generator instead '%s(%s)'] Description: Comprehension inside of 'any', 'all', 'max', 'min' or 'sum' is unnecessary. A generator would be sufficient and faster. Problematic code: from random import randint all([randint(-5, 5) > 0 for _ in range(10)]) # [use-a-generator] any([randint(-5, 5) > 0 for _ in range(10)]) # [use-a-generator] Correct code: from random import randint all(randint(-5, 5) > 0 for _ in range(10)) any(randint(-5, 5) > 0 for _ in range(10)) Additional details: By using a generator you can cut the execution tree and exit directly at the first element that is False for all or True for any instead of calculating all the elements. Except in the worst possible case where you still need to evaluate everything (all values are True for all or all values are false for any) performance will be better. Related links: PEP 289 – Generator Expressions Benchmark and discussion during initial implementation Created by the refactoring checker.",
    "option": {}
  },
  "R1735": {
    "description": "[Status: stable] [Name: use-dict-literal] [Message: Consider using '%s' instead of a call to 'dict'.] Description: Emitted when using dict() to create a dictionary instead of a literal '{ ... }'. The literal is faster as it avoids an additional function call. Problematic code: empty_dict.py: empty_dict = dict() # [use-dict-literal] init_dict_from_another.py: original_dict = {\"name\": \"Sunny\", \"age\": 10, \"favorite_color\": \"yellow\"} copied_dict = dict(**original_dict) # [use-dict-literal] init_with_keyword.py: response_dict = dict(answer=\"No\") # [use-dict-literal] Correct code: empty_dict.py: empty_dict = {} init_dict_from_another.py: original_dict = {\"name\": \"Sunny\", \"age\": 10, \"favorite_color\": \"yellow\"} # shallow copy a dict copied_dict = {**original_dict} init_with_literal.py: response_dict = {\"answer\": \"No\"} Additional details: https://gist.github.com/hofrob/ad143aaa84c096f42489c2520a3875f9 This example script shows an 18% increase in performance when using a literal over the constructor in python version 3.10.6. Related links: Performance Analysis of Python’s dict() vs dict literal Created by the refactoring checker.",
    "option": {}
  },
  "R1734": {
    "description": "[Status: stable] [Name: use-list-literal] [Message: Consider using [] instead of list()] Description: Emitted when using list() to create an empty list instead of the literal []. The literal is faster as it avoids an additional function call. Problematic code: empty_list = list() # [use-list-literal] Correct code: empty_list = [] Created by the refactoring checker.",
    "option": {}
  },
  "R6201": {
    "description": "[Status: stable] [Name: use-set-for-membership] [Message: Consider using set for membership test] Description: Membership tests are more efficient when performed on a lookup optimized datatype like ``sets``. Problematic code: def fruit_is_dangerous_for_cat(fruit: str) -> bool: \"\"\"This list is only a silly example, don't make decision regarding your cat diet based on it.\"\"\" return fruit in [\"cherry\", \"grapes\"] # [use-set-for-membership] Correct code: def fruit_is_dangerous_for_cat(fruit: str) -> bool: \"\"\"This list is only a silly example, don't make decision regarding your cat diet based on it.\"\"\" return fruit in {\"cherry\", \"grapes\"} Configuration file: [MAIN] load-plugins=pylint.extensions.set_membership Note This message is emitted by the optional 'set_membership' checker, which requires the pylint.extensions.set_membership plugin to be loaded. Created by the set_membership checker.",
    "option": {}
  },
  "R1737": {
    "description": "[Status: stable] [Name: use-yield-from] [Message: Use 'yield from' directly instead of yielding each element one by one] Description: Yielding directly from the iterator is faster and arguably cleaner code than yielding each element one by one in the loop. Problematic code: def bad_yield_from(generator): for item in generator: # [use-yield-from] yield item Correct code: def good_yield_from(generator): yield from generator Additional details: yield from can be thought of as removing the intermediary (your for loop) between the function caller and the requested generator. This enables the caller to directly communicate with the generator (e.g. using send()). This communication is not possible when manually yielding each element one by one in a loop. PEP 380 describes the possibility of adding optimizations specific to yield from. It looks like they have not been implemented as of the time of writing. Even without said optimizations, the following snippet shows that yield from is marginally faster. $ python3 -m timeit \"def yield_from(): yield from range(100)\" \"for _ in yield_from(): pass\" 100000 loops, best of 5: 2.44 usec per loop $ python3 -m timeit \"def yield_loop():\" \" for item in range(100): yield item\" \"for _ in yield_loop(): pass\" 100000 loops, best of 5: 2.49 usec per loop Related links: PEP 380 Created by the refactoring checker.",
    "option": {}
  },
  "R0205": {
    "description": "[Status: stable] [Name: useless-object-inheritance] [Message: Class %r inherits from object, can be safely removed from bases in python3] Description: Used when a class inherit from object, which under python3 is implicit, hence can be safely removed from bases. Problematic code: class Banana(object): # [useless-object-inheritance] ... Correct code: class Banana: ... Created by the classes checker.",
    "option": {}
  },
  "R0022": {
    "description": "[Status: stable] [Name: useless-option-value] [Message: Useless option value for '%s', %s] Description: Used when a value for an option that is now deleted from pylint is encountered. Problematic code: \"\"\"'bad-continuation' was removed from pylint in https://github.com/pylint-dev/pylint/pull/3571\"\"\" # pylint: disable=bad-continuation # [useless-option-value] Correct code: \"\"\"'bad-continuation' was removed from pylint in https://github.com/pylint-dev/pylint/pull/3571\"\"\" Additional details: You can disable this check if you don't want to cleanup your configuration of old messages. Created by the main checker.",
    "option": {}
  },
  "R1711": {
    "description": "[Status: stable] [Name: useless-return] [Message: Useless return at end of function or method] Description: Emitted when a single \"return\" or \"return None\" statement is found at the end of function or method definition. This statement can safely be removed because Python will implicitly return None Problematic code: import sys def print_python_version(): # [useless-return] print(sys.version) return None Correct code: import sys def print_python_version(): print(sys.version) Created by the refactoring checker.",
    "option": {}
  },
  "I0010": {
    "description": "[Status: stable] [Name: bad-inline-option] [Message: Unable to consider inline option %r] Description: Used when an inline option is either badly formatted or can't be used inside modules. Caution This message is disabled by default. To enable it, add bad-inline-option to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0010 option or --fail-on=I to fail on all enabled informational messages. Problematic code: # 2:[bad-inline-option] # pylint: disable line-too-long Correct code: # pylint: disable=line-too-long Created by the main checker.",
    "option": {}
  },
  "I1101": {
    "description": "[Status: stable] [Name: c-extension-no-member] [Message: %s %r has no %r member%s, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects.] Description: Used when a variable is accessed for non-existent member of C extension. Due to unavailability of source static analysis is impossible, but it may be performed by introspecting living objects in run-time. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I1101 option or --fail-on=I to fail on all enabled informational messages. Additional details: c-extension-no-member is an informational variant of no-member to encourage allowing introspection of C extensions as described in the page for no-member. Created by the typecheck checker.",
    "option": {}
  },
  "I0022": {
    "description": "[Status: stable] [Name: deprecated-pragma] [Message: Pragma \"%s\" is deprecated, use \"%s\" instead] Description: Some inline pylint options have been renamed or reworked, only the most recent form should be used. NOTE:skip-all is only available with pylint >= 0.26 Caution This message is disabled by default. To enable it, add deprecated-pragma to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0022 option or --fail-on=I to fail on all enabled informational messages. Problematic code: # pylint: disable-msg=eval-used # [deprecated-pragma] Correct code: # pylint: disable = eval-used Created by the main checker.",
    "option": {}
  },
  "I0013": {
    "description": "[Status: stable] [Name: file-ignored] [Message: Ignoring entire file] Description: Used to inform that the file will not be checked Caution This message is disabled by default. To enable it, add file-ignored to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0013 option or --fail-on=I to fail on all enabled informational messages. Problematic code: # pylint: skip-file # -1: [file-ignored] Correct code: Additional details: There's no checks at all for a file if it starts by # pylint: skip-file. Created by the main checker.",
    "option": {}
  },
  "I0011": {
    "description": "[Status: stable] [Name: locally-disabled] [Message: Locally disabling %s (%s)] Description: Used when an inline option disables a message or a messages category. Caution This message is disabled by default. To enable it, add locally-disabled to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0011 option or --fail-on=I to fail on all enabled informational messages. Problematic code: def wizard_spells(spell_book): # pylint: disable=maybe-no-member # [locally-disabled] for spell in spell_book: print(f\"Abracadabra! {spell}.\") spell_list = [\"Levitation\", \"Invisibility\", \"Fireball\", \"Teleportation\"] wizard_spells(spell_list) Correct code: def wizard_spells(spell_book): for spell in spell_book: print(f\"Abracadabra! {spell}.\") spell_list = [\"Levitation\", \"Invisibility\", \"Fireball\", \"Teleportation\"] wizard_spells(spell_list) Created by the main checker.",
    "option": {}
  },
  "I0001": {
    "description": "[Status: stable] [Name: raw-checker-failed] [Message: Unable to run raw checkers on built-in module %s] Description: Used to inform that a built-in module has not been checked using the raw checkers. Caution This message is disabled by default. To enable it, add raw-checker-failed to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0001 option or --fail-on=I to fail on all enabled informational messages. Additional details: This warns you that a builtin module was impossible to analyse (an ast node is not pure python). There's nothing to change in your code, this is a warning about astroid and pylint's limitations. Created by the main checker.",
    "option": {}
  },
  "I0020": {
    "description": "[Status: stable] [Name: suppressed-message] [Message: Suppressed %s (from line %d)] Description: A message was triggered on a line, but suppressed explicitly by a disable= comment in the file. This message is not generated for messages that are ignored due to configuration settings. Caution This message is disabled by default. To enable it, add suppressed-message to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0020 option or --fail-on=I to fail on all enabled informational messages. Problematic code: ### This is a contrived example, to show how suppressed-message works. ### First we enable all messages # pylint: enable=all ### Here we disable two messages so we get two warnings # pylint: disable=locally-disabled, useless-suppression # [suppressed-message, suppressed-message] ### Here we disable a message, so we get a warning for suppressed-message again. \"A\" # pylint: disable=pointless-statement # [suppressed-message, suppressed-message] Correct code: \"\"\"Instead of a single string somewhere in the file, write a module docstring!\"\"\" Additional details: suppressed-message is simply a way to see messages that would be raised without the disable in your codebase. It should not be activated most of the time. See also useless-suppression if you want to see the message that are disabled for no reasons. Created by the main checker.",
    "option": {}
  },
  "I0023": {
    "description": "[Status: stable] [Name: use-symbolic-message-instead] [Message: %s] Description: Used when a message is enabled or disabled by id. Caution This message is disabled by default. To enable it, add use-symbolic-message-instead to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0023 option or --fail-on=I to fail on all enabled informational messages. Problematic code: fruit_name = \"plum\" # pylint: disable-next=W0621 def eat(fruit_name: str): # [use-symbolic-message-instead] ... Correct code: fruit_name = \"plum\" # pylint: disable-next=redefined-outer-name def eat(fruit_name: str): ... Created by the miscellaneous checker.",
    "option": {}
  },
  "I0021": {
    "description": "[Status: stable] [Name: useless-suppression] [Message: Useless suppression of %s] Description: Reported when a message is explicitly disabled for a line or a block of code, but never triggered. Caution This message is disabled by default. To enable it, add useless-suppression to the enable option. Caution By default, this message will not fail the execution (pylint will return 0). To make pylint fail for this message use the --fail-on=I0021 option or --fail-on=I to fail on all enabled informational messages. Problematic code: fruit_counter = 0 # pylint: disable-next=redefined-outer-name def eat(fruit_name: str): # [useless-suppression] ... Correct code: fruit_counter = 0 def eat(fruit_name: str): ... Created by the main checker.",
    "option": {}
  },
  "I0014": {
    "description": "[Status: stable] [Name: deprecated-disable-all]",
    "option": {}
  }
}