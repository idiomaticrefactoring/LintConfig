{
    "portability-simd-intrinsics": {
        "description": "Description\n\nFinds SIMD intrinsics calls and suggests\nstd::experimental::simd\n(\nP0214\n)\nalternatives.\n\nIf the option\nSuggest\nis set to\ntrue\n, for\n\n_mm_add_epi32\n(\na\n,\nb\n);\n// x86\nvec_add\n(\na\n,\nb\n);\n// Power\n\nthe check suggests an alternative:\noperator+\non\nstd::experimental::simd\nobjects.\n\nOtherwise, it just complains the intrinsics are non-portable (and there are\nP0214\nalternatives).\n\nMany architectures provide SIMD operations (e.g. x86 SSE/AVX, Power\nAltiVec/VSX, ARM NEON). It is common that SIMD code implementing the same\nalgorithm, is written in multiple target-dispatching pieces to optimize for\ndifferent architectures or micro-architectures.\n\nThe C++ standard proposal\nP0214\nand its extensions cover many common SIMD\noperations. By migrating from target-dependent intrinsics to\nP0214\noperations, the SIMD code can be simplified and pieces for different targets\ncan be unified.\n\nRefer to\nP0214\nfor introduction and motivation for the data-parallel\nstandard library.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nSuggest\nIf this option is set to\ntrue\n(default is\nfalse\n), the check will suggest\nP0214\nalternatives, otherwise it only points out the intrinsic function is\nnon-portable.\nStd\nThe namespace used to suggest\nP0214\nalternatives. If not specified,\nstd::\nfor\n-std=c++20\nand\nstd::experimental::\nfor\n-std=c++11\n."
    }
}