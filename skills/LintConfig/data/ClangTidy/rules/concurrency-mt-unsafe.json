{
    "concurrency-mt-unsafe": {
        "description": "Description\n\nChecks for some thread-unsafe functions against a black list of\nknown-to-be-unsafe functions. Usually they access static variables without\nsynchronization (e.g. gmtime(3)) or utilize signals in a racy way.\nThe set of functions to check is specified with the\nFunctionSet\noption.\n\nNote that using some thread-unsafe functions may be still valid in\nconcurrent programming if only a single thread is used (e.g. setenv(3)),\nhowever, some functions may track a state in global variables which\nwould be clobbered by subsequent (non-parallel, but concurrent) calls to\na related function. E.g. the following code suffers from unprotected\naccesses to a global state:\n\n// getnetent(3) maintains global state with DB connection, etc.\n// If a concurrent green thread calls getnetent(3), the global state is corrupted.\nnetent\n=\ngetnetent\n();\nyield\n();\nnetent\n=\ngetnetent\n();\n\nExamples:\n\ntm\n=\ngmtime\n(\ntimep\n);\n// uses a global buffer\nsleep\n(\n1\n);\n// implementation may use SIGALRM",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nFunctionSet\nSpecifies which functions in libc should be considered thread-safe,\npossible values are\nposix\n,\nglibc\n, or\nany\n.\nposix\nmeans POSIX defined thread-unsafe functions. POSIX.1-2001\nin “2.9.1 Thread-Safety” defines that all functions specified in the\nstandard are thread-safe except a predefined list of thread-unsafe\nfunctions.\nGlibc defines some of them as thread-safe (e.g. dirname(3)), but adds\nnon-POSIX thread-unsafe ones (e.g. getopt_long(3)). Glibc’s list is\ncompiled from GNU web documentation with a search for MT-Safe tag:\nhttps://www.gnu.org/software/libc/manual/html_node/POSIX-Safety-Concepts.html\nIf you want to identify thread-unsafe API for at least one libc or\nunsure which libc will be used, use\nany\n(default)."
    }
}