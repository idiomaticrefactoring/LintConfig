{
    "bugprone-use-after-move": {
        "description": "Description\n\nWarns if an object is used after it has been moved, for example:\n\nstd\n::\nstring\nstr\n=\n\"Hello, world!\n\\n\n\"\n;\nstd\n::\nvector\n<\nstd\n::\nstring\n>\nmessages\n;\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\nstd\n::\ncout\n<<\nstr\n;\n\nThe last line will trigger a warning that\nstr\nis used after it has been\nmoved.\n\nThe check does not trigger a warning if the object is reinitialized after the\nmove and before the use. For example, no warning will be output for this code:\n\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\nstr\n=\n\"Greetings, stranger!\n\\n\n\"\n;\nstd\n::\ncout\n<<\nstr\n;\n\nSubsections below explain more precisely what exactly the check considers to be\na move, use, and reinitialization.\n\nThe check takes control flow into account. A warning is only emitted if the use\ncan be reached from the move. This means that the following code does not\nproduce a warning:\n\nif\n(\ncondition\n)\n{\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n}\nelse\n{\nstd\n::\ncout\n<<\nstr\n;\n}\n\nOn the other hand, the following code does produce a warning:\n\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n10\n;\n++\ni\n)\n{\nstd\n::\ncout\n<<\nstr\n;\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n}\n\n(The use-after-move happens on the second iteration of the loop.)\n\nIn some cases, the check may not be able to detect that two branches are\nmutually exclusive. For example (assuming that\ni\nis an int):\n\nif\n(\ni\n==\n1\n)\n{\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n}\nif\n(\ni\n==\n2\n)\n{\nstd\n::\ncout\n<<\nstr\n;\n}\n\nIn this case, the check will erroneously produce a warning, even though it is\nnot possible for both the move and the use to be executed. More formally, the\nanalysis is\nflow-sensitive but not path-sensitive\n.\n\nSilencing erroneous warnings\nAn erroneous warning can be silenced by reinitializing the object after the\nmove:\nif\n(\ni\n==\n1\n)\n{\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\nstr\n=\n\"\"\n;\n}\nif\n(\ni\n==\n2\n)\n{\nstd\n::\ncout\n<<\nstr\n;\n}\nIf you want to avoid the overhead of actually reinitializing the object,\nyou can create a dummy function that causes the check to assume the object\nwas reinitialized:\ntemplate\n<\nclass\nT\n>\nvoid\nIS_INITIALIZED\n(\nT\n&\n)\n{}\nYou can use this as follows:\nif\n(\ni\n==\n1\n)\n{\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n}\nif\n(\ni\n==\n2\n)\n{\nIS_INITIALIZED\n(\nstr\n);\nstd\n::\ncout\n<<\nstr\n;\n}\nThe check will not output a warning in this case because passing the object\nto a function as a non-const pointer or reference counts as a reinitialization\n(see section\nReinitialization\nbelow).\n\nUnsequenced moves, uses, and reinitializations\nIn many cases, C++ does not make any guarantees about the order in which\nsub-expressions of a statement are evaluated. This means that in code like the\nfollowing, it is not guaranteed whether the use will happen before or after the\nmove:\nvoid\nf\n(\nint\ni\n,\nstd\n::\nvector\n<\nint\n>\nv\n);\nstd\n::\nvector\n<\nint\n>\nv\n=\n{\n1\n,\n2\n,\n3\n};\nf\n(\nv\n[\n1\n],\nstd\n::\nmove\n(\nv\n));\nIn this kind of situation, the check will note that the use and move are\nunsequenced.\nThe check will also take sequencing rules into account when reinitializations\noccur in the same statement as moves or uses. A reinitialization is only\nconsidered to reinitialize a variable if it is guaranteed to be evaluated after\nthe move and before the use.\n\nMove\nThe check currently only considers calls of\nstd::move\non local variables or\nfunction parameters. It does not check moves of member variables or global\nvariables.\nAny call of\nstd::move\non a variable is considered to cause a move of that\nvariable, even if the result of\nstd::move\nis not passed to an rvalue\nreference parameter.\nThis means that the check will flag a use-after-move even on a type that does\nnot define a move constructor or move assignment operator. This is intentional.\nDevelopers may use\nstd::move\non such a type in the expectation that the\ntype will add move semantics in the future. If such a\nstd::move\nhas the\npotential to cause a use-after-move, we want to warn about it even if the type\ndoes not implement move semantics yet.\nFurthermore, if the result of\nstd::move\nis\npassed to an rvalue reference\nparameter, this will always be considered to cause a move, even if the function\nthat consumes this parameter does not move from it, or if it does so only\nconditionally. For example, in the following situation, the check will assume\nthat a move always takes place:\nstd\n::\nvector\n<\nstd\n::\nstring\n>\nmessages\n;\nvoid\nf\n(\nstd\n::\nstring\n&&\nstr\n)\n{\n// Only remember the message if it isn't empty.\nif\n(\n!\nstr\n.\nempty\n())\n{\nmessages\n.\nemplace_back\n(\nstd\n::\nmove\n(\nstr\n));\n}\n}\nstd\n::\nstring\nstr\n=\n\"\"\n;\nf\n(\nstd\n::\nmove\n(\nstr\n));\nThe check will assume that the last line causes a move, even though, in this\nparticular case, it does not. Again, this is intentional.\nThere is one special case: A call to\nstd::move\ninside a\ntry_emplace\ncall is conservatively assumed not to move. This is to avoid spurious warnings,\nas the check has no way to reason about the\nbool\nreturned by\ntry_emplace\n.\nWhen analyzing the order in which moves, uses and reinitializations happen (see\nsection\nUnsequenced moves, uses, and reinitializations\n), the move is assumed\nto occur in whichever function the result of the\nstd::move\nis passed to.\nThe check also handles perfect-forwarding with\nstd::forward\nso the\nfollowing code will also trigger a use-after-move warning.\nvoid\nconsume\n(\nint\n);\nvoid\nf\n(\nint\n&&\ni\n)\n{\nconsume\n(\nstd\n::\nforward\n<\nint\n>\n(\ni\n));\nconsume\n(\nstd\n::\nforward\n<\nint\n>\n(\ni\n));\n// use-after-move\n}\n\nUse\nAny occurrence of the moved variable that is not a reinitialization (see below)\nis considered to be a use.\nAn exception to this are objects of type\nstd::unique_ptr\n,\nstd::shared_ptr\n,\nstd::weak_ptr\n,\nstd::optional\n, and\nstd::any\n.\nAn exception to this are objects of type\nstd::unique_ptr\n,\nstd::shared_ptr\n,\nstd::weak_ptr\n,\nstd::optional\n, and\nstd::any\n,\nwhich can be reinitialized via\nreset\n. For smart pointers specifically, the\nmoved-from objects have a well-defined state of being\nnullptr``s,\nand\nonly\n``operator*\n,\noperator->\nand\noperator[]\nare considered bad accesses as\nthey would be dereferencing a\nnullptr\n.\nIf multiple uses occur after a move, only the first of these is flagged.\n\nReinitialization\nThe check considers a variable to be reinitialized in the following cases:\nThe variable occurs on the left-hand side of an assignment.\nThe variable is passed to a function as a non-const pointer or non-const\nlvalue reference. (It is assumed that the variable may be an out-parameter\nfor the function.)\nclear()\nor\nassign()\nis called on the variable and the variable is\nof     one of the standard container types\nbasic_string\n,\nvector\n,\ndeque\n,\nforward_list\n,\nlist\n,\nset\n,\nmap\n,\nmultiset\n,\nmultimap\n,\nunordered_set\n,\nunordered_map\n,\nunordered_multiset\n,\nunordered_multimap\n.\nreset()\nis called on the variable and the variable is of type\nstd::unique_ptr\n,\nstd::shared_ptr\n,\nstd::weak_ptr\n,\nstd::optional\n, or\nstd::any\n.\nA member function marked with the\n[[clang::reinitializes]]\nattribute is\ncalled on the variable.\nIf the variable in question is a struct and an individual member variable of\nthat struct is written to, the check does not consider this to be a\nreinitialization â€“ even if, eventually, all member variables of the struct are\nwritten to. For example:\nstruct\nS\n{\nstd\n::\nstring\nstr\n;\nint\ni\n;\n};\nS\ns\n=\n{\n\"Hello, world!\n\\n\n\"\n,\n42\n};\nS\ns_other\n=\nstd\n::\nmove\n(\ns\n);\ns\n.\nstr\n=\n\"Lorem ipsum\"\n;\ns\n.\ni\n=\n99\n;\nThe check will not consider\ns\nto be reinitialized after the last line;\ninstead, the line that assigns to\ns.str\nwill be flagged as a use-after-move.\nThis is intentional as this pattern of reinitializing a struct is error-prone.\nFor example, if an additional member variable is added to\nS\n, it is easy to\nforget to add the reinitialization for this additional member. Instead, it is\nsafer to assign to the entire struct in one go, and this will also avoid the\nuse-after-move warning.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nInvalidationFunctions\nA semicolon-separated list of regular expressions matching names of functions\nthat cause their first arguments to be invalidated (e.g., closing a handle).\nFor member functions, the first argument is considered to be the implicit\nobject argument (\nthis\n). Default value is an empty string.\nReinitializationFunctions\nA semicolon-separated list of regular expressions matching names of functions\nthat reinitialize the object. For member functions, the implicit object\nargument (\n*this\n) is considered to be reinitialized. For non-member or\nstatic member functions, the first argument is considered to be\nreinitialized. Default value is an empty string."
    }
}