{
    "modernize-use-scoped-lock": {
        "description": "Description\n\nFinds uses of\nstd::lock_guard\nand suggests replacing them with C++17â€™s\nalternative\nstd::scoped_lock\n.\n\nFix-its are provided for single declarations of\nstd::lock_guard\nand warning\nis emitted for multiple declarations of\nstd::lock_guard\nthat can be\nreplaced with a single declaration of\nstd::scoped_lock\n.\n\nExamples\nSingle\nstd::lock_guard\ndeclaration:\nstd\n::\nmutex\nM\n;\nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\nL\n(\nM\n);\nTransforms to:\nstd\n::\nmutex\nM\n;\nstd\n::\nscoped_lock\nL\n(\nM\n);\nSingle\nstd::lock_guard\ndeclaration with\nstd::adopt_lock\n:\nstd\n::\nmutex\nM\n;\nstd\n::\nlock\n(\nM\n);\nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\nL\n(\nM\n,\nstd\n::\nadopt_lock\n);\nTransforms to:\nstd\n::\nmutex\nM\n;\nstd\n::\nlock\n(\nM\n);\nstd\n::\nscoped_lock\nL\n(\nstd\n::\nadopt_lock\n,\nM\n);\nMultiple\nstd::lock_guard\ndeclarations only emit warnings:\nstd\n::\nmutex\nM1\n,\nM2\n;\nstd\n::\nlock\n(\nM1\n,\nM2\n);\nstd\n::\nlock_guard\nLock1\n(\nM1\n,\nstd\n::\nadopt_lock\n);\n// warning: use single 'std::scoped_lock' instead of multiple 'std::lock_guard'\nstd\n::\nlock_guard\nLock2\n(\nM2\n,\nstd\n::\nadopt_lock\n);\n// note: additional 'std::lock_guard' declared here\n\nLimitations\nThe check will not emit warnings if\nstd::lock_guard\nis used implicitly via\ntemplate\nparameter:\ntemplate\n<\ntemplate\n<\ntypename\n>\ntypename\nLock\n>\nvoid\nTemplatedLock\n()\n{\nstd\n::\nmutex\nM\n;\nLock\n<\nstd\n::\nmutex\n>\nL\n(\nM\n);\n// no warning\n}\nvoid\ninstantiate\n()\n{\nTemplatedLock\n<\nstd\n::\nlock_guard\n>\n();\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nWarnOnSingleLocks\nWhen\ntrue\n, the check will warn on single\nstd::lock_guard\ndeclarations.\nSet this option to\nfalse\nif you want to get warnings only on multiple\nstd::lock_guard\ndeclarations that can be replaced with a single\nstd::scoped_lock\n. Default is\ntrue\n.\nWarnOnUsingAndTypedef\nWhen\ntrue\n, the check will emit warnings if\nstd::lock_guard\nis used\nin\nusing\nor\ntypedef\ncontext. Default is\ntrue\n.\ntemplate\n<\ntypename\nT\n>\nusing\nLock\n=\nstd\n::\nlock_guard\n<\nT\n>\n;\n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'\nusing\nLockMutex\n=\nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\n;\n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'\ntypedef\nstd\n::\nlock_guard\n<\nstd\n::\nmutex\n>\nLockDef\n;\n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'\nusing\nstd\n::\nlock_guard\n;\n// warning: use 'std::scoped_lock' instead of 'std::lock_guard'"
    }
}