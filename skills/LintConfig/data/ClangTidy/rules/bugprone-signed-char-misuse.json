{
    "bugprone-signed-char-misuse": {
        "description": "Description\n\ncert-str34-c\nredirects here as an alias for this check. For the CERT alias,\nthe\nDiagnoseSignedUnsignedCharComparisons\noption is set to\nfalse\n.\n\nFinds those\nsigned\nchar\n-> integer conversions which might indicate a\nprogramming error. The basic problem with the\nsigned\nchar\n, that it might\nstore the non-ASCII characters as negative values. This behavior can cause a\nmisunderstanding of the written code both when an explicit and when an\nimplicit conversion happens.\n\nWhen the code contains an explicit\nsigned\nchar\n-> integer conversion, the\nhuman programmer probably expects that the converted value matches with the\ncharacter code (a value from [0..255]), however, the actual value is in\n[-128..127] interval. To avoid this kind of misinterpretation, the desired way\nof converting from a\nsigned\nchar\nto an integer value is converting to\nunsigned\nchar\nfirst, which stores all the characters in the positive\n[0..255] interval which matches the known character codes.\n\nIn case of implicit conversion, the programmer might not actually be aware\nthat a conversion happened and char value is used as an integer. There are\nsome use cases when this unawareness might lead to a functionally imperfect\ncode. For example, checking the equality of a\nsigned\nchar\nand an\nunsigned\nchar\nvariable is something we should avoid in C++ code. During\nthis comparison, the two variables are converted to integers which have\ndifferent value ranges. For\nsigned\nchar\n, the non-ASCII characters are\nstored as a value in [-128..-1] interval, while the same characters are\nstored in the [128..255] interval for an\nunsigned\nchar\n.\n\nIt depends on the actual platform whether plain\nchar\nis handled as\nsigned\nchar\nby default and so it is caught by this check or not.\nTo change the default behavior you can use\n-funsigned-char\nand\n-fsigned-char\ncompilation options.\n\nCurrently, this check warns in the following cases:\n\nsigned\nchar\nis assigned to an integer variable\nsigned\nchar\nand\nunsigned\nchar\nare compared with\nequality/inequality operator\nsigned\nchar\nis converted to an integer in the array subscript\n\nSee also:\nSTR34-C. Cast characters to unsigned char before converting to larger\ninteger sizes\n\nA good example from the CERT description when a\nchar\nvariable is used to\nread from a file that might contain non-ASCII characters. The problem comes\nup when the code uses the\n-1\ninteger value as EOF, while the 255 character\ncode is also stored as\n-1\nin twoâ€™s complement form of char type.\nSee a simple example of this below. This code stops not only when it reaches\nthe end of the file, but also when it gets a character with the 255 code.\n\n#define EOF (-1)\nint\nread\n(\nvoid\n)\n{\nchar\nCChar\n;\nint\nIChar\n=\nEOF\n;\nif\n(\nreadChar\n(\nCChar\n))\n{\nIChar\n=\nCChar\n;\n}\nreturn\nIChar\n;\n}\n\nA proper way to fix the code above is converting the\nchar\nvariable to\nan\nunsigned\nchar\nvalue first.\n\n#define EOF (-1)\nint\nread\n(\nvoid\n)\n{\nchar\nCChar\n;\nint\nIChar\n=\nEOF\n;\nif\n(\nreadChar\n(\nCChar\n))\n{\nIChar\n=\nstatic_cast\n<\nunsigned\nchar\n>\n(\nCChar\n);\n}\nreturn\nIChar\n;\n}\n\nAnother use case is checking the equality of two\nchar\nvariables with\ndifferent signedness. Inside the non-ASCII value range this comparison between\na\nsigned\nchar\nand an\nunsigned\nchar\nalways returns\nfalse\n.\n\nbool\ncompare\n(\nsigned\nchar\nSChar\n,\nunsigned\nchar\nUSChar\n)\n{\nif\n(\nSChar\n==\nUSChar\n)\nreturn\ntrue\n;\nreturn\nfalse\n;\n}\n\nThe easiest way to fix this kind of comparison is casting one of the arguments,\nso both arguments will have the same type.\n\nbool\ncompare\n(\nsigned\nchar\nSChar\n,\nunsigned\nchar\nUSChar\n)\n{\nif\n(\nstatic_cast\n<\nunsigned\nchar\n>\n(\nSChar\n)\n==\nUSChar\n)\nreturn\ntrue\n;\nreturn\nfalse\n;\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nCharTypedefsToIgnore\nA semicolon-separated list of typedef names. In this list, we can list\ntypedefs for\nchar\nor\nsigned\nchar\n, which will be ignored by the\ncheck. This is useful when a typedef introduces an integer alias like\nsal_Int8\nor\nint8_t\n. In this case, human misinterpretation is not\nan issue. Default is an empty string.\nDiagnoseSignedUnsignedCharComparisons\nWhen\ntrue\n, the check will warn on\nsigned\nchar\n/\nunsigned\nchar\ncomparisons,\notherwise these comparisons are ignored. By default, this option is set to\ntrue\n."
    }
}