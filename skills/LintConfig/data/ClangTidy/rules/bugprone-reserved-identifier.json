{
    "bugprone-reserved-identifier": {
        "description": "Description\n\ncert-dcl37-c\nand\ncert-dcl51-cpp\nredirect here as an alias for this check.\n\nChecks for usages of identifiers reserved for use by the implementation.\n\nThe C and C++ standards both reserve the following names for such use:\n\nidentifiers that begin with an underscore followed by an uppercase letter;\nidentifiers in the global namespace that begin with an underscore.\n\nThe C standard additionally reserves names beginning with a double underscore,\nwhile the C++ standard strengthens this to reserve names with a double\nunderscore occurring anywhere.\n\nViolating the naming rules above results in undefined behavior.\n\nnamespace\nNS\n{\nvoid\n__f\n();\n// name is not allowed in user code\nusing\n_Int\n=\nint\n;\n// same with this\n#define cool__macro\n// also this\n}\nint\n_g\n();\n// disallowed in global namespace only\n\nThe check can also be inverted, i.e. it can be configured to flag any\nidentifier that is\nnot\na reserved identifier. This mode is for use by e.g.\nstandard library implementors, to ensure they don’t infringe on the user\nnamespace.\n\nThis check does not (yet) check for other reserved names, e.g. macro names\nidentical to language keywords, and names specifically reserved by language\nstandards, e.g. C++ ‘zombie names’ and C future library directions.\n\nThis check corresponds to CERT C Coding Standard rule\nDCL37-C. Do not declare\nor define a reserved identifier\nas well as its C++ counterpart,\nDCL51-CPP. Do not declare or define a reserved\nidentifier\n.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nInvert\nIf\ntrue\n, inverts the check, i.e. flags names that are not reserved.\nDefault is\nfalse\n.\nAllowedIdentifiers\nSemicolon-separated list of regular expressions that the check ignores. Default is an\nempty list."
    }
}