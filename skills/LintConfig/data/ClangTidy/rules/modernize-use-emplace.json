{
    "modernize-use-emplace": {
        "description": "Description\n\nThe check flags insertions to an STL-style container done by calling the\npush_back\n,\npush\n, or\npush_front\nmethods with an\nexplicitly-constructed temporary of the container element type. In this case,\nthe corresponding\nemplace\nequivalent methods result in less verbose and\npotentially more efficient code.  Right now the check doesn’t support\ninsert\n. It also doesn’t support\ninsert\nfunctions for associative\ncontainers because replacing\ninsert\nwith\nemplace\nmay result in\nspeed regression\n, but it might get support with some addition flag in the future.\n\nThe\nContainersWithPushBack\n,\nContainersWithPush\n, and\nContainersWithPushFront\noptions are used to specify the container\ntypes that support the\npush_back\n,\npush\n, and\npush_front\noperations\nrespectively. The default values for these options are as follows:\n\nContainersWithPushBack\n:\nstd::vector\n,\nstd::deque\n,\nand\nstd::list\n.\nContainersWithPush\n:\nstd::stack\n,\nstd::queue\n,\nand\nstd::priority_queue\n.\nContainersWithPushFront\n:\nstd::forward_list\n,\nstd::list\n, and\nstd::deque\n.\n\nThis check also reports when an\nemplace\n-like method is improperly used,\nfor example using\nemplace_back\nwhile also calling a constructor. This\ncreates a temporary that requires at best a move and at worst a copy. Almost\nall\nemplace\n-like functions in the STL are covered by this, with\ntry_emplace\non\nstd::map\nand\nstd::unordered_map\nbeing the\nexception as it behaves slightly differently than all the others. More\ncontainers can be added with the\nEmplacyFunctions\noption, so long\nas the container defines a\nvalue_type\ntype, and the\nemplace\n-like\nfunctions construct a\nvalue_type\nobject.\n\nBefore:\n\nstd\n::\nvector\n<\nMyClass\n>\nv\n;\nv\n.\npush_back\n(\nMyClass\n(\n21\n,\n37\n));\nv\n.\nemplace_back\n(\nMyClass\n(\n21\n,\n37\n));\nstd\n::\nvector\n<\nstd\n::\npair\n<\nint\n,\nint\n>>\nw\n;\nw\n.\npush_back\n(\nstd\n::\npair\n<\nint\n,\nint\n>\n(\n21\n,\n37\n));\nw\n.\npush_back\n(\nstd\n::\nmake_pair\n(\n21L\n,\n37L\n));\nw\n.\nemplace_back\n(\nstd\n::\nmake_pair\n(\n21L\n,\n37L\n));\n\nAfter:\n\nstd\n::\nvector\n<\nMyClass\n>\nv\n;\nv\n.\nemplace_back\n(\n21\n,\n37\n);\nv\n.\nemplace_back\n(\n21\n,\n37\n);\nstd\n::\nvector\n<\nstd\n::\npair\n<\nint\n,\nint\n>>\nw\n;\nw\n.\nemplace_back\n(\n21\n,\n37\n);\nw\n.\nemplace_back\n(\n21L\n,\n37L\n);\nw\n.\nemplace_back\n(\n21L\n,\n37L\n);\n\nBy default, the check is able to remove unnecessary\nstd::make_pair\nand\nstd::make_tuple\ncalls from\npush_back\ncalls on containers of\nstd::pair\nand\nstd::tuple\n. Custom tuple-like types can be modified by\nthe\nTupleTypes\noption; custom make functions can be modified by the\nTupleMakeFunctions\noption.\n\nThe other situation is when we pass arguments that will be converted to a type\ninside a container.\n\nBefore:\n\nstd\n::\nvector\n<\nboost\n::\noptional\n<\nstd\n::\nstring\n>\n>\nv\n;\nv\n.\npush_back\n(\n\"abc\"\n);\n\nAfter:\n\nstd\n::\nvector\n<\nboost\n::\noptional\n<\nstd\n::\nstring\n>\n>\nv\n;\nv\n.\nemplace_back\n(\n\"abc\"\n);\n\nIn some cases the transformation would be valid, but the code wouldn’t be\nexception safe. In this case the calls of\npush_back\nwon’t be replaced.\n\nstd\n::\nvector\n<\nstd\n::\nunique_ptr\n<\nint\n>>\nv\n;\nv\n.\npush_back\n(\nstd\n::\nunique_ptr\n<\nint\n>\n(\nnew\nint\n(\n0\n)));\nauto\n*\nptr\n=\nnew\nint\n(\n1\n);\nv\n.\npush_back\n(\nstd\n::\nunique_ptr\n<\nint\n>\n(\nptr\n));\n\nThis is because replacing it with\nemplace_back\ncould cause a leak of this\npointer if\nemplace_back\nwould throw exception before emplacement (e.g. not\nenough memory to add a new element).\n\nFor more info read item 42 - “Consider emplacement instead of insertion.” of\nScott Meyers “Effective Modern C++”.\n\nThe default smart pointers that are considered are\nstd::unique_ptr\n,\nstd::shared_ptr\n,\nstd::auto_ptr\n. To specify other smart pointers or\nother classes use the\nSmartPointers\noption.\n\nCheck also doesn’t fire if any argument of the constructor call would be:\n\na bit-field (bit-fields can’t bind to rvalue/universal reference)\na\nnew\nexpression (to avoid leak)\nif the argument would be converted via derived-to-base cast.\n\nThis check requires C++11 or higher to run.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nContainersWithPushBack\nSemicolon-separated list of class names of custom containers that support\npush_back\n.\nContainersWithPush\nSemicolon-separated list of class names of custom containers that support\npush\n.\nContainersWithPushFront\nSemicolon-separated list of class names of custom containers that support\npush_front\n.\nIgnoreImplicitConstructors\nWhen\ntrue\n, the check will ignore implicitly constructed arguments of\npush_back\n, e.g.\nstd\n::\nvector\n<\nstd\n::\nstring\n>\nv\n;\nv\n.\npush_back\n(\n\"a\"\n);\n// Ignored when IgnoreImplicitConstructors is `true`.\nDefault is\nfalse\n.\nSmartPointers\nSemicolon-separated list of class names of custom smart pointers.\nTupleTypes\nSemicolon-separated list of\nstd::tuple\n-like class names.\nTupleMakeFunctions\nSemicolon-separated list of\nstd::make_tuple\n-like function names. Those\nfunction calls will be removed from\npush_back\ncalls and turned into\nemplace_back\n.\nEmplacyFunctions\nSemicolon-separated list of containers without their template parameters\nand some\nemplace\n-like method of the container. Example:\nvector::emplace_back\n. Those methods will be checked for improper use and\nthe check will report when a temporary is unnecessarily created. All STL\ncontainers with such member functions are supported by default.\nExample\nstd\n::\nvector\n<\nMyTuple\n<\nint\n,\nbool\n,\nchar\n>>\nx\n;\nx\n.\npush_back\n(\nMakeMyTuple\n(\n1\n,\nfalse\n,\n'x'\n));\nx\n.\nemplace_back\n(\nMakeMyTuple\n(\n1\n,\nfalse\n,\n'x'\n));\ntransforms to:\nstd\n::\nvector\n<\nMyTuple\n<\nint\n,\nbool\n,\nchar\n>>\nx\n;\nx\n.\nemplace_back\n(\n1\n,\nfalse\n,\n'x'\n);\nx\n.\nemplace_back\n(\n1\n,\nfalse\n,\n'x'\n);\nwhen\nTupleTypes\nis set to\nMyTuple\n,\nTupleMakeFunctions\nis set to\nMakeMyTuple\n, and\nEmplacyFunctions\nis set to\nvector::emplace_back\n."
    }
}