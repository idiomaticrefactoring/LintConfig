{
    "performance-no-automatic-move": {
        "description": "Description\n\nFinds local variables that cannot be automatically moved due to constness.\n\nUnder\ncertain conditions\n,\nlocal values are automatically moved out when returning from a function. A\ncommon mistake is to declare local\nlvalue\nvariables\nconst\n, which\nprevents the move.\n\nExample\n[1]\n:\n\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\nCool\n()\n{\nstd\n::\nvector\n<\nint\n>\nobj\n=\n...;\nreturn\nobj\n;\n// calls StatusOr::StatusOr(std::vector<int>&&)\n}\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\nNotCool\n()\n{\nconst\nstd\n::\nvector\n<\nint\n>\nobj\n=\n...;\nreturn\nobj\n;\n// calls `StatusOr::StatusOr(const std::vector<int>&)`\n}\n\nThe former version (\nCool\n) should be preferred over the latter (\nNotCool\n)\nas it will avoid allocations and potentially large memory copies.\n\nSemantics\nIn the example above,\nStatusOr::StatusOr(T&&)\nhave the same semantics as\nlong as the copy and move constructors for\nT\nhave the same semantics. Note\nthat there is no guarantee that\nS::S(T&&)\nand\nS::S(const\nT&)\nhave the\nsame semantics for any single\nS\n, so weâ€™re not providing automated fixes for\nthis check, and judgement should be exerted when making the suggested changes.\n\n-Wreturn-std-move\nAnother case where the move cannot happen is the following:\nStatusOr\n<\nstd\n::\nvector\n<\nint\n>>\nUncool\n()\n{\nstd\n::\nvector\n<\nint\n>&&\nobj\n=\n...;\nreturn\nobj\n;\n// calls `StatusOr::StatusOr(const std::vector<int>&)`\n}\nIn that case the fix is more consensual: just\nreturn std::move(obj)\n.\nThis is handled by the\n-Wreturn-std-move\nwarning.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}