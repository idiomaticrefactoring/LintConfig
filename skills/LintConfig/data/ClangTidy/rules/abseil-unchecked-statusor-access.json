{
    "abseil-unchecked-statusor-access": {
        "description": "Description\n\nThis check identifies unsafe accesses to values contained in\nabsl::StatusOr<T>\nobjects. Below we will refer to this type as\nStatusOr<T>\n.\n\nAn access to the value of an\nStatusOr<T>\noccurs when one of its\nvalue\n,\noperator*\n, or\noperator->\nmember functions is invoked.\nTo align with common misconceptions, the check considers these member\nfunctions as equivalent, even though there are subtle differences\nrelated to exceptions vs. undefined behavior.\n\nAn access to the value of a\nStatusOr<T>\nis considered safe if and\nonly if code in the local scope (e.g. function body) ensures that the\nstatus of the\nStatusOr<T>\nis ok in all possible execution paths that\ncan reach the access. That should happen either through an explicit\ncheck, using the\nStatusOr<T>::ok\nmember function, or by constructing\nthe\nStatusOr<T>\nin a way that shows that its status is unambiguously\nok (e.g. by passing a value to its constructor).\n\nBelow we list some examples of safe and unsafe\nStatusOr<T>\naccess\npatterns.\n\nNote: If the check isn’t behaving as you would have expected on a code\nsnippet, please\nreport it\n.\n\nFalse negatives\nThis check generally does\nnot\ngenerate false negatives. That means that if\nan access is not marked as unsafe, it is provably safe. If it cannot prove an\naccess safe, it is assumed to be unsafe. In some cases, the static analysis\ncannot prove an access safe even though it is, for a variety of reasons (e.g.\nunmodelled invariants of functions called). In these cases, the analysis does\nproduce false positive reports.\nThat being said, there are some heuristics used that in very rare cases might\nbe incorrect:\na const method accessor (without arguments) that returns different\nvalues when called multiple times\n.\nIf you think the check generated a false negative, please\nreport\nit\n.\n\nKnown limitations\nThis is a non-exhaustive list of constructs that are currently not\nmodelled in the check and will lead to false positives:\nChecking a StatusOr and then capturing it in a lambda\nIndexing into a container with the same index\nProject specific helper-functions\n,\nFunctions with a stable return value\nAny\ncross-function reasoning\n. This is by\ndesign and will not change in the future.\n\nChecking if the status is ok, then accessing the value\nThe check recognizes all straightforward ways for checking the status\nand accessing the value contained in a\nStatusOr<T>\nobject. For\nexample:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nif\n(\nx\n.\nok\n())\n{\nuse\n(\n*\nx\n);\n}\n}\n\nChecking if the status is ok, then accessing the value from a copy\nThe criteria that the check uses is semantic, not syntactic. It\nrecognizes when a copy of the\nStatusOr<T>\nobject being accessed is\nknown to have ok status. For example:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx1\n)\n{\nif\n(\nx1\n.\nok\n())\n{\nabsl\n::\noptional\n<\nint\n>\nx2\n=\nx1\n;\nuse\n(\n*\nx2\n);\n}\n}\n\nEnsuring that the status is ok using common macros\nThe check is aware of common macros like\nABSL_CHECK\nand\nASSERT_THAT\n.\nThose can be used to ensure that the status of a\nStatusOr<T>\nobject\nis ok. For example:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nABSL_CHECK_OK\n(\nx\n);\nuse\n(\n*\nx\n);\n}\n\nEnsuring that the status is ok, then accessing the value in a correlated branch\nThe check is aware of correlated branches in the code and can figure out\nwhen a\nStatusOr<T>\nobject is ensured to have ok status on all\nexecution paths that lead to an access. For example:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nbool\nsafe\n=\nfalse\n;\nif\n(\nx\n.\nok\n()\n&&\nSomeOtherCondition\n())\n{\nsafe\n=\ntrue\n;\n}\n// ... more code...\nif\n(\nsafe\n)\n{\nuse\n(\n*\nx\n);\n}\n}\n\nAccessing the value without checking the status\nThe check flags accesses to the value that are not locally guarded by a\nstatus check:\nvoid\nf1\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nuse\n(\n*\nx\n);\n// unsafe: it is unclear whether the status of `x` is ok.\n}\nvoid\nf2\n(\nabsl\n::\nStatusOr\n<\nMyStruct\n>\nx\n)\n{\nuse\n(\nx\n->\nmember\n);\n// unsafe: it is unclear whether the status of `x` is ok.\n}\nvoid\nf3\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nuse\n(\nx\n.\nvalue\n());\n// unsafe: it is unclear whether the status of `x` is ok.\n}\nUse\nABSL_CHECK_OK\nto signal that you knowingly want to crash on\nnon-OK values.\nNOTE: Even though using\n.value()\non a non-\nok()\nStatusOr\nis defined\nto crash, it is often unintentional. That is why our checker flags those as\nwell.\n\nAccessing the value in the wrong branch\nThe check is aware of the state of a\nStatusOr<T>\nobject in different\nbranches of the code. For example:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nif\n(\nx\n.\nok\n())\n{\n}\nelse\n{\nuse\n(\n*\nx\n);\n// unsafe: it is clear that the status of `x` is *not* ok.\n}\n}\n\nAssuming a function result to be stable\nThe check is aware that function results might not be stable. That is,\nconsecutive calls to the same function might return different values.\nFor example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nfoo\n.\nx\n().\nok\n())\n{\nuse\n(\n*\nfoo\n.\nx\n());\n// unsafe: it is unclear whether the status of `foo.x()` is ok.\n}\n}\nIn such cases it is best to store the result of the function call in a\nlocal variable and use it to access the value. For example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nconst\nauto\n&\nx\n=\nfoo\n.\nx\n();\nx\n.\nok\n())\n{\nuse\n(\n*\nx\n);\n}\n}\nThe check\ndoes\nassume that\nconst\n-qualified accessor functions\nreturn a stable value if no non-const function was called between the\ntwo calls:\nclass\nFoo\n{\nconst\nabsl\n::\nStatusOr\n<\nint\n>&\nget\n()\nconst\n{\n[...];\n}\n}\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nfoo\n.\nget\n().\nok\n())\n{\nuse\n(\n*\nfoo\n.\nget\n());\n}\n}\nIf there is a call to a non-\nconst\n-qualified function, the check\nassumes the return value of the accessor was mutated.\nclass\nFoo\n{\nconst\nabsl\n::\nStatusOr\n<\nint\n>&\nget\n()\nconst\n{\n[...];\n}\nvoid\nmutate\n();\n}\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nfoo\n.\nget\n().\nok\n())\n{\nfoo\n.\nmutate\n();\nuse\n(\n*\nfoo\n.\nget\n());\n// unsafe: `mutate()` might have changed the state of the object\n}\n}\n\nRelying on invariants of uncommon APIs\nThe check is unaware of invariants of uncommon APIs. For example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nfoo\n.\nHasProperty\n(\n\"bar\"\n))\n{\nuse\n(\n*\nfoo\n.\nGetProperty\n(\n\"bar\"\n));\n// unsafe: it is unclear whether the status of `foo.GetProperty(\"bar\")` is ok.\n}\n}\nIn such cases it is best to check explicitly that the status of the\nStatusOr<T>\nobject is ok. For example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nconst\nauto\n&\nproperty\n=\nfoo\n.\nGetProperty\n(\n\"bar\"\n);\nproperty\n.\nok\n())\n{\nuse\n(\n*\nproperty\n);\n}\n}\n\nChecking if the\nStatusOr<T>\nis ok, then passing it to another function\nThe check relies on local reasoning. The check and value access must\nboth happen in the same function. An access is considered unsafe even if\nthe caller of the function performing the access ensures that the status\nof the\nStatusOr<T>\nis ok. For example:\nvoid\ng\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nuse\n(\n*\nx\n);\n// unsafe: it is unclear whether the status of `x` is ok.\n}\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nif\n(\nx\n.\nok\n())\n{\ng\n(\nx\n);\n}\n}\nIn such cases it is best to either pass the value directly when calling\na function or check that the status of the\nStatusOr<T>\nis ok in the\nlocal scope of the callee. For example:\nvoid\ng\n(\nint\nval\n)\n{\nuse\n(\nval\n);\n}\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nif\n(\nx\n.\nok\n())\n{\ng\n(\n*\nx\n);\n}\n}\n\nAliases created via\nusing\ndeclarations\nThe check is aware of aliases of\nStatusOr<T>\ntypes that are created\nvia\nusing\ndeclarations. For example:\nusing\nStatusOrInt\n=\nabsl\n::\nStatusOr\n<\nint\n>\n;\nvoid\nf\n(\nStatusOrInt\nx\n)\n{\nuse\n(\n*\nx\n);\n// unsafe: it is unclear whether the status of `x` is ok.\n}\n\nContainers\nThe check is more strict than necessary when it comes to containers of\nStatusOr<T>\nvalues. Simply checking that the status of an element of\na container is ok is not sufficient to deem accessing it safe. For\nexample:\nvoid\nf\n(\nstd\n::\nvector\n<\nabsl\n::\nStatusOr\n<\nint\n>>\nx\n)\n{\nif\n(\nx\n[\n0\n].\nok\n())\n{\nuse\n(\n*\nx\n[\n0\n]);\n// unsafe: it is unclear whether the status of `x[0]` is ok.\n}\n}\nOne needs to grab a reference to a particular object and use that\ninstead:\nvoid\nf\n(\nstd\n::\nvector\n<\nabsl\n::\nStatusOr\n<\nint\n>>\nx\n)\n{\nabsl\n::\nStatusOr\n<\nint\n>&\nx0\n=\nx\n[\n0\n];\nif\n(\nx0\n.\nok\n())\n{\nuse\n(\n*\nx0\n);\n}\n}\nA future version could improve the understanding of more safe usage\npatterns that involve containers.\n\nLambdas\nThe check is capable of reporting unsafe\nStatusOr<T>\naccesses in\nlambdas, but isn’t smart enough to propagate information from the\nsurrounding context through the lambda. This means that the following\npattern will be reported as an unsafe access:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nif\n(\nx\n.\nok\n())\n{\n[\n&\nx\n]()\n{\nuse\n(\n*\nx\n);\n// unsafe: it is unclear whether the status of `x` is ok.\n}\n}\n}\nTo avoid the issue, you should instead capture the contained object,\neither by value or by reference. An init-capture is useful for this,\nhere capturing by reference:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\nif\n(\nx\n.\nok\n())\n{\n[\n&\nx\n=\n*\nx\n]()\n{\nuse\n(\nx\n);\n}\n}\n}\nAlternatively you could add a check inside the lambda where the value is\naccessed:\nvoid\nf\n(\nabsl\n::\nStatusOr\n<\nint\n>\nx\n)\n{\n[\n&\nx\n]()\n{\nif\n(\nx\n.\nok\n())\n{\nuse\n(\n*\nx\n);\n}\n}\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}