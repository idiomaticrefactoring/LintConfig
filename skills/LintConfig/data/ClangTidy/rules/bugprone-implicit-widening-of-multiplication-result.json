{
    "bugprone-implicit-widening-of-multiplication-result": {
        "description": "Description\n\nThe check diagnoses instances where a result of a multiplication is implicitly\nwidened, and suggests (with fix-it) to either silence the code by making\nwidening explicit, or to perform the multiplication in a wider type,\nto avoid the widening afterwards.\n\nThis is mainly useful when operating on very large buffers.\nFor example, consider:\n\nvoid\nzeroinit\n(\nchar\n*\nbase\n,\nunsigned\nwidth\n,\nunsigned\nheight\n)\n{\nfor\n(\nunsigned\nrow\n=\n0\n;\nrow\n!=\nheight\n;\n++\nrow\n)\n{\nfor\n(\nunsigned\ncol\n=\n0\n;\ncol\n!=\nwidth\n;\n++\ncol\n)\n{\nchar\n*\nptr\n=\nbase\n+\nrow\n*\nwidth\n+\ncol\n;\n*\nptr\n=\n0\n;\n}\n}\n}\n\nThis is fine in general, but if\nwidth\n*\nheight\noverflows,\nyou end up wrapping back to the beginning of\nbase\ninstead of processing the entire requested buffer.\n\nIndeed, this only matters for pretty large buffers (4GB+),\nbut that can happen very easily for example in image processing,\nwhere for that to happen you “only” need a ~269MPix image.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nUseCXXStaticCastsInCppSources\nWhen suggesting fix-its for C++ code, should C++-style\nstatic_cast<>()\n’s\nbe suggested, or C-style casts. Defaults to\ntrue\n.\nUseCXXHeadersInCppSources\nWhen suggesting to include the appropriate header in C++ code,\nshould\n<cstddef>\nheader be suggested, or\n<stddef.h>\n.\nDefaults to\ntrue\n.\nIgnoreConstantIntExpr\nIf the multiplication operands are compile-time constants (like literals or\nare\nconstexpr\n) and fit within the source expression type, do not emit a\ndiagnostic or suggested fix.  Only considers expressions where the source\nexpression is a signed integer type.  Defaults to\nfalse\n.\nExamples:\nlong\nmul\n(\nint\na\n,\nint\nb\n)\n{\nreturn\na\n*\nb\n;\n// warning: performing an implicit widening conversion to type 'long' of a multiplication performed in type 'int'\n}\nchar\n*\nptr_add\n(\nchar\n*\nbase\n,\nint\na\n,\nint\nb\n)\n{\nreturn\nbase\n+\na\n*\nb\n;\n// warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n}\nchar\nptr_subscript\n(\nchar\n*\nbase\n,\nint\na\n,\nint\nb\n)\n{\nreturn\nbase\n[\na\n*\nb\n];\n// warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'\n}"
    }
}