{
    "bugprone-sizeof-expression": {
        "description": "Description\n\nThe check finds usages of\nsizeof\nexpressions which are most likely errors.\n\nThe\nsizeof\noperator yields the size (in bytes) of its operand, which may be\nan expression or the parenthesized name of a type. Misuse of this operator may\nbe leading to errors and possible software vulnerabilities.\n\nSuspicious usage of ‘sizeof(K)’\nA common mistake is to query the\nsizeof\nof an integer literal. This is\nequivalent to query the size of its type (probably\nint\n). The intent of the\nprogrammer was probably to simply get the integer and not its size.\n#define BUFLEN 42\nchar\nbuf\n[\nBUFLEN\n];\nmemset\n(\nbuf\n,\n0\n,\nsizeof\n(\nBUFLEN\n));\n// sizeof(42) ==> sizeof(int)\n\nSuspicious usage of ‘sizeof(expr)’\nIn cases, where there is an enum or integer to represent a type, a common\nmistake is to query the\nsizeof\non the integer or enum that represents the\ntype that should be used by\nsizeof\n. This results in the size of the integer\nand not of the type the integer represents:\nenum\ndata_type\n{\nFLOAT_TYPE\n,\nDOUBLE_TYPE\n};\nstruct\ndata\n{\ndata_type\ntype\n;\nvoid\n*\nbuffer\n;\ndata_type\nget_type\n()\n{\nreturn\ntype\n;\n}\n};\nvoid\nf\n(\ndata\nd\n,\nint\nnumElements\n)\n{\n// should be sizeof(float) or sizeof(double), depending on d.get_type()\nint\nnumBytes\n=\nnumElements\n*\nsizeof\n(\nd\n.\nget_type\n());\n...\n}\n\nSuspicious usage of ‘sizeof(this)’\nThe\nthis\nkeyword is evaluated to a pointer to an object of a given type.\nThe expression\nsizeof(this)\nis returning the size of a pointer. The\nprogrammer most likely wanted the size of the object and not the size of the\npointer.\nclass\nPoint\n{\n[...]\nsize_t\nsize\n()\n{\nreturn\nsizeof\n(\nthis\n);\n}\n// should probably be sizeof(*this)\n[...]\n};\n\nSuspicious usage of ‘sizeof(char*)’\nThere is a subtle difference between declaring a string literal with\nchar*\nA\n=\n\"\"\nand\nchar\nA[]\n=\n\"\"\n. The first case has the type\nchar*\ninstead of the aggregate type\nchar[]\n. Using\nsizeof\non an object\ndeclared with\nchar*\ntype is returning the size of a pointer instead of\nthe number of characters (bytes) in the string literal.\nconst\nchar\n*\nkMessage\n=\n\"Hello World!\"\n;\n// const char kMessage[] = \"...\";\nvoid\ngetMessage\n(\nchar\n*\nbuf\n)\n{\nmemcpy\n(\nbuf\n,\nkMessage\n,\nsizeof\n(\nkMessage\n));\n// sizeof(char*)\n}\n\nSuspicious usage of ‘sizeof(A*)’\nA common mistake is to compute the size of a pointer instead of its pointee.\nThese cases may occur because of explicit cast or implicit conversion.\nint\nA\n[\n10\n];\nmemset\n(\nA\n,\n0\n,\nsizeof\n(\nA\n+\n0\n));\nstruct\nPoint\npoint\n;\nmemset\n(\npoint\n,\n0\n,\nsizeof\n(\n&\npoint\n));\n\nSuspicious usage of ‘sizeof(…)/sizeof(…)’\nDividing\nsizeof\nexpressions is typically used to retrieve the number of\nelements of an aggregate. This check warns on incompatible or suspicious cases.\nIn the following example, the entity has 10-bytes and is incompatible with the\ntype\nint\nwhich has 4 bytes.\nchar\nbuf\n[]\n=\n{\n0\n,\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n};\n// sizeof(buf) => 10\nvoid\ngetMessage\n(\nchar\n*\ndst\n)\n{\nmemcpy\n(\ndst\n,\nbuf\n,\nsizeof\n(\nbuf\n)\n/\nsizeof\n(\nint\n));\n// sizeof(int) => 4  [incompatible sizes]\n}\nIn the following example, the expression\nsizeof(Values)\nis returning the\nsize of\nchar*\n. One can easily be fooled by its declaration, but in parameter\ndeclaration the size ‘10’ is ignored and the function is receiving a\nchar*\n.\nchar\nOrderedValues\n[\n10\n]\n=\n{\n0\n,\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n,\n9\n};\nreturn\nCompareArray\n(\nchar\nValues\n[\n10\n])\n{\nreturn\nmemcmp\n(\nOrderedValues\n,\nValues\n,\nsizeof\n(\nValues\n))\n==\n0\n;\n// sizeof(Values) ==> sizeof(char*) [implicit cast to char*]\n}\n\nSuspicious ‘sizeof’ by ‘sizeof’ expression\nMultiplying\nsizeof\nexpressions typically makes no sense and is probably a\nlogic error. In the following example, the programmer used\n*\ninstead of\n/\n.\nconst\nchar\nkMessage\n[]\n=\n\"Hello World!\"\n;\nvoid\ngetMessage\n(\nchar\n*\nbuf\n)\n{\nmemcpy\n(\nbuf\n,\nkMessage\n,\nsizeof\n(\nkMessage\n)\n*\nsizeof\n(\nchar\n));\n//  sizeof(kMessage) / sizeof(char)\n}\nThis check may trigger on code using the arraysize macro. The following code is\nworking correctly but should be simplified by using only the\nsizeof\noperator.\nextern\nObject\nobjects\n[\n100\n];\nvoid\nInitializeObjects\n()\n{\nmemset\n(\nobjects\n,\n0\n,\narraysize\n(\nobjects\n)\n*\nsizeof\n(\nObject\n));\n// sizeof(objects)\n}\n\nSuspicious usage of ‘sizeof(sizeof(…))’\nGetting the\nsizeof\nof a\nsizeof\nmakes no sense and is typically an error\nhidden through macros.\n#define INT_SZ sizeof(int)\nint\nbuf\n[]\n=\n{\n42\n};\nvoid\ngetInt\n(\nint\n*\ndst\n)\n{\nmemcpy\n(\ndst\n,\nbuf\n,\nsizeof\n(\nINT_SZ\n));\n// sizeof(sizeof(int)) is suspicious.\n}\n\nSuspicious usages of ‘sizeof(…)’ in pointer arithmetic\nArithmetic operators on pointers automatically scale the result with the size\nof the pointed typed.\nFurther use of\nsizeof\naround pointer arithmetic will typically result in an\nunintended result.\nScaling the result of pointer difference\nSubtracting two pointers results in an integer expression (of type\nptrdiff_t\n) which expresses the distance between the two pointed objects in\n“number of objects between”.\nA common mistake is to think that the result is “number of bytes between”, and\nscale the difference with\nsizeof\n, such as\nP1\n-\nP2\n==\nN\n*\nsizeof(T)\n(instead of\nP1\n-\nP2\n==\nN\n) or\n(P1\n-\nP2)\n/\nsizeof(T)\ninstead of\nP1\n-\nP2\n.\nvoid\nsplitFour\n(\nconst\nObj\n*\nObjs\n,\nsize_t\nN\n,\nObj\nDelimiter\n)\n{\nconst\nObj\n*\nP\n=\nObjs\n;\nwhile\n(\nP\n<\nObjs\n+\nN\n)\n{\nif\n(\n*\nP\n==\nDelimiter\n)\n{\nbreak\n;\n}\n}\nif\n(\nP\n-\nObjs\n!=\n4\n*\nsizeof\n(\nObj\n))\n{\n// Expecting a distance multiplied by sizeof is suspicious.\nerror\n();\n}\n}\nvoid\niterateIfEvenLength\n(\nint\n*\nBegin\n,\nint\n*\nEnd\n)\n{\nauto\nN\n=\n(\nBegin\n-\nEnd\n)\n/\nsizeof\n(\nint\n);\n// Dividing by sizeof() is suspicious.\nif\n(\nN\n%\n2\n)\nreturn\n;\n// ...\n}\nStepping a pointer with a scaled integer\nConversely, when performing pointer arithmetics to add or subtract from a\npointer, the arithmetic operator implicitly scales the value actually added to\nthe pointer with the size of the pointee, as\nPtr\n+\nN\nexpects\nN\nto be\n“number of objects to step”, and not “number of bytes to step”.\nSeeing the calculation of a pointer where\nsizeof\nappears is suspicious,\nand the result is typically unintended, often out of bounds.\nPtr\n+\nsizeof(T)\nwill offset the pointer by\nsizeof(T)\nelements,\neffectively exponentiating the scaling factor to the power of 2.\nSimilarly, multiplying or dividing a numeric value with the\nsizeof\nof an\nelement or the whole buffer is suspicious, because the dimensional connection\nbetween the numeric value and the actual\nsizeof\nresult can not always be\ndeduced.\nWhile scaling an integer up (multiplying) with\nsizeof\nis likely\nalways\nan issue, a scaling down (division) is not always inherently dangerous, in case\nthe developer is aware that the division happens between an appropriate number\nof _bytes_ and a\nsizeof\nvalue.\nTurning\nWarnOnOffsetDividedBySizeOf\noff will restrict the\nwarnings to the multiplication case.\nThis case also checks suspicious\nalignof\nand\noffsetof\nusages in\npointer arithmetic, as both return the “size” in bytes and not elements,\npotentially resulting in doubly-scaled offsets.\nvoid\nprintEveryEvenIndexElement\n(\nint\n*\nArray\n,\nsize_t\nN\n)\n{\nint\n*\nP\n=\nArray\n;\nwhile\n(\nP\n<=\nArray\n+\nN\n*\nsizeof\n(\nint\n))\n{\n// Suspicious pointer arithmetic using sizeof()!\nprintf\n(\n\"%d \"\n,\n*\nP\n);\nP\n+=\n2\n*\nsizeof\n(\nint\n);\n// Suspicious pointer arithmetic using sizeof()!\n}\n}\nstruct\nMessage\n{\n/* ... */\n;\nchar\nFlags\n[\n8\n];\n};\nvoid\nclearFlags\n(\nMessage\n*\nArray\n,\nsize_t\nN\n)\n{\nconst\nMessage\n*\nEnd\n=\nArray\n+\nN\n;\nwhile\n(\nArray\n<\nEnd\n)\n{\nmemset\n(\nArray\n+\noffsetof\n(\nMessage\n,\nFlags\n),\n// Suspicious pointer arithmetic using offsetof()!\n0\n,\nsizeof\n(\nMessage\n::\nFlags\n));\n++\nArray\n;\n}\n}\nFor this checked bogus pattern,\ncert-arr39-c\nredirects here as an alias of\nthis check.\nThis check corresponds to the CERT C Coding Standard rule\nARR39-C. Do not add or subtract a scaled integer to a pointer\n.\n\nLimitations\nCases where the pointee type has a size of\n1\nbyte (such as, and most\nimportantly,\nchar\n) are excluded.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nWarnOnSizeOfConstant\nWhen\ntrue\n, the check will warn on an expression like\nsizeof(CONSTANT)\n. Default is\ntrue\n.\nWarnOnSizeOfIntegerExpression\nWhen\ntrue\n, the check will warn on an expression like\nsizeof(expr)\nwhere the expression results in an integer. Default is\nfalse\n.\nWarnOnSizeOfThis\nWhen\ntrue\n, the check will warn on an expression like\nsizeof(this)\n.\nDefault is\ntrue\n.\nWarnOnSizeOfCompareToConstant\nWhen\ntrue\n, the check will warn on an expression like\nsizeof(expr)\n<=\nk\nfor a suspicious constant\nk\nwhile\nk\nis\n0\nor\ngreater than\n0x8000\n. Default is\ntrue\n.\nWarnOnSizeOfPointerToAggregate\nWhen\ntrue\n, the check will warn when the argument of\nsizeof\nis either a\npointer-to-aggregate type, an expression returning a pointer-to-aggregate\nvalue or an expression that returns a pointer from an array-to-pointer\nconversion (that may be implicit or explicit, for example\narray\n+\n2\nor\n(int\n*)array\n). Default is\ntrue\n.\nWarnOnSizeOfPointer\nWhen\ntrue\n, the check will report all expressions where the argument of\nsizeof\nis an expression that produces a pointer (except for a few\nidiomatic expressions that are probably intentional and correct).\nThis detects occurrences of CWE 467. Default is\nfalse\n.\nWarnOnOffsetDividedBySizeOf\nWhen\ntrue\n, the check will warn on pointer arithmetic where the\nelement count is obtained from a division with\nsizeof(...)\n,\ne.g.,\nPtr\n+\nBytes\n/\nsizeof(*T)\n. Default is\ntrue\n.\nWarnOnSizeOfInLoopTermination\nWhen\ntrue\n, the check will warn about incorrect use of sizeof expression\nin loop termination condition. The warning triggers if the\nsizeof\nexpression appears to be incorrectly used to determine the number of\narray/buffer elements.\ne.g,\nlong\narr[10];\nfor(int\ni\n=\n0;\ni\n<\nsizeof(arr);\ni++)\n{\n...\n}\n. Default\nis\ntrue\n."
    }
}