{
    "bugprone-misplaced-operator-in-strlen-in-alloc": {
        "description": "Description\n\nFinds cases where\n1\nis added to the string in the argument to\nstrlen()\n,\nstrnlen()\n,\nstrnlen_s()\n,\nwcslen()\n,\nwcsnlen()\n, and\nwcsnlen_s()\ninstead of the result and the value is used as an argument to a\nmemory allocation function (\nmalloc()\n,\ncalloc()\n,\nrealloc()\n,\nalloca()\n) or the\nnew[]\noperator in\nC++\n. The check detects error cases\neven if one of these functions (except the\nnew[]\noperator) is called by a\nconstant function pointer. Cases where\n1\nis added both to the parameter and\nthe result of the\nstrlen()\n-like function are ignored, as are cases where\nthe whole addition is surrounded by extra parentheses.\n\nC\nexample code:\n\nvoid\nbad_malloc\n(\nchar\n*\nstr\n)\n{\nchar\n*\nc\n=\n(\nchar\n*\n)\nmalloc\n(\nstrlen\n(\nstr\n+\n1\n));\n}\n\nThe suggested fix is to add\n1\nto the return value of\nstrlen()\nand not\nto its argument. In the example above the fix would be\n\nchar\n*\nc\n=\n(\nchar\n*\n)\nmalloc\n(\nstrlen\n(\nstr\n)\n+\n1\n);\n\nC++\nexample code:\n\nvoid\nbad_new\n(\nchar\n*\nstr\n)\n{\nchar\n*\nc\n=\nnew\nchar\n[\nstrlen\n(\nstr\n+\n1\n)];\n}\n\nAs in the\nC\ncode with the\nmalloc()\nfunction, the suggested fix is to\nadd\n1\nto the return value of\nstrlen()\nand not to its argument. In the\nexample above the fix would be\n\nchar\n*\nc\n=\nnew\nchar\n[\nstrlen\n(\nstr\n)\n+\n1\n];\n\nExample for silencing the diagnostic:\n\nvoid\nbad_malloc\n(\nchar\n*\nstr\n)\n{\nchar\n*\nc\n=\n(\nchar\n*\n)\nmalloc\n(\nstrlen\n((\nstr\n+\n1\n)));\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}