{
    "readability-identifier-naming": {
        "description": "Description\n\nChecks for identifiers naming style mismatch.\n\nThis check will try to enforce coding guidelines on the identifiers naming. It\nsupports one of the following casing types and tries to convert from one to\nanother if a mismatch is detected\n\nCasing types include:\n\nlower_case\nUPPER_CASE\ncamelBack\nCamelCase\ncamel_Snake_Back\nCamel_Snake_Case\naNy_CasE\nLeading_upper_snake_case\n\nIt also supports a fixed prefix and suffix that will be prepended or appended\nto the identifiers, regardless of the casing.\n\nMany configuration options are available, in order to be able to create\ndifferent rules for different kinds of identifiers. In general, the rules are\nfalling back to a more generic rule if the specific case is not configured.\n\nThe naming of virtual methods is reported where they occur in the base class,\nbut not where they are overridden, as it can’t be fixed locally there.\nThis also applies for pseudo-override patterns like CRTP.\n\nLeading_upper_snake_case\nis a naming convention where the first word is\ncapitalized followed by lower case word(s) separated by underscore(s) ‘_’.\nExamples include:\nCap_snake_case\n,\nCobra_case\n,\nFoo_bar_baz\n,\nand\nMaster_copy_8gb\n.\n\nHungarian notation can be customized using different\nHungarianPrefix\nsettings. The options and their corresponding values are:\n\nOff\n- the default setting\nOn\n- example:\nint\niVariable\nLowerCase\n- example:\nint\ni_Variable\nCamelCase\n- example:\nint\nIVariable\n\nThe check only enforces style on kinds of identifiers which have been\nconfigured, so an empty config effectively disables it.\nThe\nDefaultCase\noption can be used to enforce style on all kinds of\nidentifiers, then optionally overriden for specific kinds which are desired\nwith a different case.\n\nFor example using values of:\n\nDefaultCase of\nlower_case\nMacroDefinitionCase of\nUPPER_CASE\nTemplateParameterCase of\nCamelCase\n\nIdentifies and transforms names as follows:\n\nBefore:\n\n#define macroDefinition\ntemplate\n<\ntypename\ntypenameParameter\n>\nint\nfunctionDeclaration\n(\ntypenameParameter\nparamVal\n,\nint\nparamCount\n);\n\nAfter:\n\n#define MACRO_DEFINITION\ntemplate\n<\ntypename\nTypenameParameter\n>\nint\nfunction_declarations\n(\nTypenameParameter\nparam_val\n,\nint\nparam_count\n);",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions summary\nThe available options are summarized below:\nGeneral options\nAggressiveDependentMemberLookup\nCheckAnonFieldInParent\nGetConfigPerFile\nIgnoreMainLikeFunctions\nSpecific options\nDefaultCase\n,\nDefaultPrefix\n,\nDefaultSuffix\n,\nDefaultIgnoredRegexp\n,\nDefaultHungarianPrefix\nAbstractClassCase\n,\nAbstractClassPrefix\n,\nAbstractClassSuffix\n,\nAbstractClassIgnoredRegexp\n,\nAbstractClassHungarianPrefix\nClassCase\n,\nClassPrefix\n,\nClassSuffix\n,\nClassIgnoredRegexp\n,\nClassHungarianPrefix\nClassConstexprCase\n,\nClassConstexprPrefix\n,\nClassConstexprSuffix\n,\nClassConstexprIgnoredRegexp\n,\nClassConstexprHungarianPrefix\nClassConstantCase\n,\nClassConstantPrefix\n,\nClassConstantSuffix\n,\nClassConstantIgnoredRegexp\n,\nClassConstantHungarianPrefix\nClassMemberCase\n,\nClassMemberPrefix\n,\nClassMemberSuffix\n,\nClassMemberIgnoredRegexp\n,\nClassMemberHungarianPrefix\nClassMethodCase\n,\nClassMethodPrefix\n,\nClassMethodSuffix\n,\nClassMethodIgnoredRegexp\nConceptCase\n,\nConceptPrefix\n,\nConceptSuffix\n,\nConceptIgnoredRegexp\nConstantCase\n,\nConstantPrefix\n,\nConstantSuffix\n,\nConstantIgnoredRegexp\n,\nConstantHungarianPrefix\nConstantMemberCase\n,\nConstantMemberPrefix\n,\nConstantMemberSuffix\n,\nConstantMemberIgnoredRegexp\n,\nConstantMemberHungarianPrefix\nConstantParameterCase\n,\nConstantParameterPrefix\n,\nConstantParameterSuffix\n,\nConstantParameterIgnoredRegexp\n,\nConstantParameterHungarianPrefix\nConstantPointerParameterCase\n,\nConstantPointerParameterPrefix\n,\nConstantPointerParameterSuffix\n,\nConstantPointerParameterIgnoredRegexp\n,\nConstantPointerParameterHungarianPrefix\nConstexprFunctionCase\n,\nConstexprFunctionPrefix\n,\nConstexprFunctionSuffix\n,\nConstexprFunctionIgnoredRegexp\nConstexprMethodCase\n,\nConstexprMethodPrefix\n,\nConstexprMethodSuffix\n,\nConstexprMethodIgnoredRegexp\nConstexprVariableCase\n,\nConstexprVariablePrefix\n,\nConstexprVariableSuffix\n,\nConstexprVariableIgnoredRegexp\n,\nConstexprVariableHungarianPrefix\nEnumCase\n,\nEnumPrefix\n,\nEnumSuffix\n,\nEnumIgnoredRegexp\nEnumConstantCase\n,\nEnumConstantPrefix\n,\nEnumConstantSuffix\n,\nEnumConstantIgnoredRegexp\n,\nEnumConstantHungarianPrefix\nFunctionCase\n,\nFunctionPrefix\n,\nFunctionSuffix\n,\nFunctionIgnoredRegexp\nGlobalConstexprVariableCase\n,\nGlobalConstexprVariablePrefix\n,\nGlobalConstexprVariableSuffix\n,\nGlobalConstexprVariableIgnoredRegexp\n,\nGlobalConstexprVariableHungarianPrefix\nGlobalConstantCase\n,\nGlobalConstantPrefix\n,\nGlobalConstantSuffix\n,\nGlobalConstantIgnoredRegexp\n,\nGlobalConstantHungarianPrefix\nGlobalConstantPointerCase\n,\nGlobalConstantPointerPrefix\n,\nGlobalConstantPointerSuffix\n,\nGlobalConstantPointerIgnoredRegexp\n,\nGlobalConstantPointerHungarianPrefix\nGlobalFunctionCase\n,\nGlobalFunctionPrefix\n,\nGlobalFunctionSuffix\n,\nGlobalFunctionIgnoredRegexp\nGlobalPointerCase\n,\nGlobalPointerPrefix\n,\nGlobalPointerSuffix\n,\nGlobalPointerIgnoredRegexp\n,\nGlobalPointerHungarianPrefix\nGlobalVariableCase\n,\nGlobalVariablePrefix\n,\nGlobalVariableSuffix\n,\nGlobalVariableIgnoredRegexp\n,\nGlobalVariableHungarianPrefix\nInlineNamespaceCase\n,\nInlineNamespacePrefix\n,\nInlineNamespaceSuffix\n,\nInlineNamespaceIgnoredRegexp\nLocalConstexprVariableCase\n,\nLocalConstexprVariablePrefix\n,\nLocalConstexprVariableSuffix\n,\nLocalConstexprVariableIgnoredRegexp\n,\nLocalConstexprVariableHungarianPrefix\nLocalConstantCase\n,\nLocalConstantPrefix\n,\nLocalConstantSuffix\n,\nLocalConstantIgnoredRegexp\n,\nLocalConstantHungarianPrefix\nLocalConstantPointerCase\n,\nLocalConstantPointerPrefix\n,\nLocalConstantPointerSuffix\n,\nLocalConstantPointerIgnoredRegexp\n,\nLocalConstantPointerHungarianPrefix\nLocalPointerCase\n,\nLocalPointerPrefix\n,\nLocalPointerSuffix\n,\nLocalPointerIgnoredRegexp\n,\nLocalPointerHungarianPrefix\nLocalVariableCase\n,\nLocalVariablePrefix\n,\nLocalVariableSuffix\n,\nLocalVariableIgnoredRegexp\n,\nLocalVariableHungarianPrefix\nMacroDefinitionCase\n,\nMacroDefinitionPrefix\n,\nMacroDefinitionSuffix\n,\nMacroDefinitionIgnoredRegexp\nMemberCase\n,\nMemberPrefix\n,\nMemberSuffix\n,\nMemberIgnoredRegexp\n,\nMemberHungarianPrefix\nMethodCase\n,\nMethodPrefix\n,\nMethodSuffix\n,\nMethodIgnoredRegexp\nNamespaceCase\n,\nNamespacePrefix\n,\nNamespaceSuffix\n,\nNamespaceIgnoredRegexp\nParameterCase\n,\nParameterPrefix\n,\nParameterSuffix\n,\nParameterIgnoredRegexp\n,\nParameterHungarianPrefix\nParameterPackCase\n,\nParameterPackPrefix\n,\nParameterPackSuffix\n,\nParameterPackIgnoredRegexp\nPointerParameterCase\n,\nPointerParameterPrefix\n,\nPointerParameterSuffix\n,\nPointerParameterIgnoredRegexp\n,\nPointerParameterHungarianPrefix\nPrivateMemberCase\n,\nPrivateMemberPrefix\n,\nPrivateMemberSuffix\n,\nPrivateMemberIgnoredRegexp\n,\nPrivateMemberHungarianPrefix\nPrivateMethodCase\n,\nPrivateMethodPrefix\n,\nPrivateMethodSuffix\n,\nPrivateMethodIgnoredRegexp\nProtectedMemberCase\n,\nProtectedMemberPrefix\n,\nProtectedMemberSuffix\n,\nProtectedMemberIgnoredRegexp\n,\nProtectedMemberHungarianPrefix\nProtectedMethodCase\n,\nProtectedMethodPrefix\n,\nProtectedMethodSuffix\n,\nProtectedMethodIgnoredRegexp\nPublicMemberCase\n,\nPublicMemberPrefix\n,\nPublicMemberSuffix\n,\nPublicMemberIgnoredRegexp\n,\nPublicMemberHungarianPrefix\nPublicMethodCase\n,\nPublicMethodPrefix\n,\nPublicMethodSuffix\n,\nPublicMethodIgnoredRegexp\nScopedEnumConstantCase\n,\nScopedEnumConstantPrefix\n,\nScopedEnumConstantSuffix\n,\nScopedEnumConstantIgnoredRegexp\nStaticConstexprVariableCase\n,\nStaticConstexprVariablePrefix\n,\nStaticConstexprVariableSuffix\n,\nStaticConstexprVariableIgnoredRegexp\n,\nStaticConstexprVariableHungarianPrefix\nStaticConstantCase\n,\nStaticConstantPrefix\n,\nStaticConstantSuffix\n,\nStaticConstantIgnoredRegexp\n,\nStaticConstantHungarianPrefix\nStaticVariableCase\n,\nStaticVariablePrefix\n,\nStaticVariableSuffix\n,\nStaticVariableIgnoredRegexp\n,\nStaticVariableHungarianPrefix\nStructCase\n,\nStructPrefix\n,\nStructSuffix\n,\nStructIgnoredRegexp\nTemplateParameterCase\n,\nTemplateParameterPrefix\n,\nTemplateParameterSuffix\n,\nTemplateParameterIgnoredRegexp\nTemplateTemplateParameterCase\n,\nTemplateTemplateParameterPrefix\n,\nTemplateTemplateParameterSuffix\n,\nTemplateTemplateParameterIgnoredRegexp\nTypeAliasCase\n,\nTypeAliasPrefix\n,\nTypeAliasSuffix\n,\nTypeAliasIgnoredRegexp\nTypedefCase\n,\nTypedefPrefix\n,\nTypedefSuffix\n,\nTypedefIgnoredRegexp\nTypeTemplateParameterCase\n,\nTypeTemplateParameterPrefix\n,\nTypeTemplateParameterSuffix\n,\nTypeTemplateParameterIgnoredRegexp\nUnionCase\n,\nUnionPrefix\n,\nUnionSuffix\n,\nUnionIgnoredRegexp\nValueTemplateParameterCase\n,\nValueTemplateParameterPrefix\n,\nValueTemplateParameterSuffix\n,\nValueTemplateParameterIgnoredRegexp\nVariableCase\n,\nVariablePrefix\n,\nVariableSuffix\n,\nVariableIgnoredRegexp\n,\nVariableHungarianPrefix\nVirtualMethodCase\n,\nVirtualMethodPrefix\n,\nVirtualMethodSuffix\n,\nVirtualMethodIgnoredRegexp\n\nOptions description\nA detailed description of each option is presented below:\nDefaultCase\nWhen defined, the check will ensure all names by default conform to the\nselected casing.\nDefaultPrefix\nWhen defined, the check will ensure all names by default will add the\nprefix with the given value (regardless of casing).\nDefaultIgnoredRegexp\nIdentifier naming checks won’t be enforced for all names by default\nmatching this regular expression.\nDefaultSuffix\nWhen defined, the check will ensure all names by default will add the\nsuffix with the given value (regardless of casing).\nDefaultHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nAbstractClassCase\nWhen defined, the check will ensure abstract class names conform to the\nselected casing.\nAbstractClassPrefix\nWhen defined, the check will ensure abstract class names will add the\nprefix with the given value (regardless of casing).\nAbstractClassIgnoredRegexp\nIdentifier naming checks won’t be enforced for abstract class names\nmatching this regular expression.\nAbstractClassSuffix\nWhen defined, the check will ensure abstract class names will add the\nsuffix with the given value (regardless of casing).\nAbstractClassHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nAbstractClassCase of\nlower_case\nAbstractClassPrefix of\npre_\nAbstractClassSuffix of\n_post\nAbstractClassHungarianPrefix of\nOn\nIdentifies and/or transforms abstract class names as follows:\nBefore:\nclass\nABSTRACT_CLASS\n{\npublic\n:\nABSTRACT_CLASS\n();\n};\nAfter:\nclass\npre_abstract_class_post\n{\npublic\n:\npre_abstract_class_post\n();\n};\nAggressiveDependentMemberLookup\nWhen set to\ntrue\nthe check will look in dependent base classes for dependent\nmember references that need changing. This can lead to errors with template\nspecializations so the default value is\nfalse\n.\nFor example using values of:\nClassMemberCase of\nlower_case\nBefore:\ntemplate\n<\ntypename\nT\n>\nstruct\nBase\n{\nT\nBadNamedMember\n;\n};\ntemplate\n<\ntypename\nT\n>\nstruct\nDerived\n:\nBase\n<\nT\n>\n{\nvoid\nreset\n()\n{\nthis\n->\nBadNamedMember\n=\n0\n;\n}\n};\nAfter if AggressiveDependentMemberLookup is\nfalse\n:\ntemplate\n<\ntypename\nT\n>\nstruct\nBase\n{\nT\nbad_named_member\n;\n};\ntemplate\n<\ntypename\nT\n>\nstruct\nDerived\n:\nBase\n<\nT\n>\n{\nvoid\nreset\n()\n{\nthis\n->\nBadNamedMember\n=\n0\n;\n}\n};\nAfter if AggressiveDependentMemberLookup is\ntrue\n:\ntemplate\n<\ntypename\nT\n>\nstruct\nBase\n{\nT\nbad_named_member\n;\n};\ntemplate\n<\ntypename\nT\n>\nstruct\nDerived\n:\nBase\n<\nT\n>\n{\nvoid\nreset\n()\n{\nthis\n->\nbad_named_member\n=\n0\n;\n}\n};\nCheckAnonFieldInParent\nWhen set to\ntrue\n, fields in anonymous records (i.e. anonymous\nunions and structs) will be treated as names in the enclosing scope\nrather than public members of the anonymous record for the purpose\nof name checking.\nFor example:\nclass\nFoo\n{\nprivate\n:\nunion\n{\nint\niv_\n;\nfloat\nfv_\n;\n};\n};\nIf\nCheckAnonFieldInParent\nis\nfalse\n, you may get warnings\nthat\niv_\nand\nfv_\nare not coherent to public member names, because\niv_\nand\nfv_\nare public members of the anonymous union. When\nCheckAnonFieldInParent\nis\ntrue\n,\niv_\nand\nfv_\nwill be\ntreated as private data members of\nFoo\nfor the purpose of name checking\nand thus no warnings will be emitted.\nClassCase\nWhen defined, the check will ensure class names conform to the\nselected casing.\nClassPrefix\nWhen defined, the check will ensure class names will add the\nprefix with the given value (regardless of casing).\nClassIgnoredRegexp\nIdentifier naming checks won’t be enforced for class names matching\nthis regular expression.\nClassSuffix\nWhen defined, the check will ensure class names will add the\nsuffix with the given value (regardless of casing).\nClassHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nClassCase of\nlower_case\nClassPrefix of\npre_\nClassSuffix of\n_post\nClassHungarianPrefix of\nOn\nIdentifies and/or transforms class names as follows:\nBefore:\nclass\nFOO\n{\npublic\n:\nFOO\n();\n~\nFOO\n();\n};\nAfter:\nclass\npre_foo_post\n{\npublic\n:\npre_foo_post\n();\n~\npre_foo_post\n();\n};\nClassConstexprCase\nWhen defined, the check will ensure class\nconstexpr\nnames conform to\nthe selected casing.\nClassConstexprPrefix\nWhen defined, the check will ensure class\nconstexpr\nnames will add the\nprefix with the given value (regardless of casing).\nClassConstexprIgnoredRegexp\nIdentifier naming checks won’t be enforced for class\nconstexpr\nnames\nmatching this regular expression.\nClassConstexprSuffix\nWhen defined, the check will ensure class\nconstexpr\nnames will add the\nsuffix with the given value (regardless of casing).\nClassConstexprHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\nFor example using values of:\nClassConstexprCase of\nlower_case\nClassConstexprPrefix of\npre_\nClassConstexprSuffix of\n_post\nClassConstexprHungarianPrefix of\nOn\nIdentifies and/or transforms class\nconstexpr\nvariable names as follows:\nBefore:\nclass\nFOO\n{\npublic\n:\nstatic\nconstexpr\nint\nCLASS_CONSTEXPR\n;\n};\nAfter:\nclass\nFOO\n{\npublic\n:\nstatic\nconst\nint\npre_class_constexpr_post\n;\n};\nClassConstantCase\nWhen defined, the check will ensure class constant names conform to the\nselected casing.\nClassConstantPrefix\nWhen defined, the check will ensure class constant names will add the\nprefix with the given value (regardless of casing).\nClassConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for class constant names\nmatching this regular expression.\nClassConstantSuffix\nWhen defined, the check will ensure class constant names will add the\nsuffix with the given value (regardless of casing).\nClassConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nClassConstantCase of\nlower_case\nClassConstantPrefix of\npre_\nClassConstantSuffix of\n_post\nClassConstantHungarianPrefix of\nOn\nIdentifies and/or transforms class constant names as follows:\nBefore:\nclass\nFOO\n{\npublic\n:\nstatic\nconst\nint\nCLASS_CONSTANT\n;\n};\nAfter:\nclass\nFOO\n{\npublic\n:\nstatic\nconst\nint\npre_class_constant_post\n;\n};\nClassMemberCase\nWhen defined, the check will ensure class member names conform to the\nselected casing.\nClassMemberPrefix\nWhen defined, the check will ensure class member names will add the\nprefix with the given value (regardless of casing).\nClassMemberIgnoredRegexp\nIdentifier naming checks won’t be enforced for class member names\nmatching this regular expression.\nClassMemberSuffix\nWhen defined, the check will ensure class member names will add the\nsuffix with the given value (regardless of casing).\nClassMemberHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nClassMemberCase of\nlower_case\nClassMemberPrefix of\npre_\nClassMemberSuffix of\n_post\nClassMemberHungarianPrefix of\nOn\nIdentifies and/or transforms class member names as follows:\nBefore:\nclass\nFOO\n{\npublic\n:\nstatic\nint\nCLASS_CONSTANT\n;\n};\nAfter:\nclass\nFOO\n{\npublic\n:\nstatic\nint\npre_class_constant_post\n;\n};\nClassMethodCase\nWhen defined, the check will ensure class method names conform to the\nselected casing.\nClassMethodPrefix\nWhen defined, the check will ensure class method names will add the\nprefix with the given value (regardless of casing).\nClassMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for class method names\nmatching this regular expression.\nClassMethodSuffix\nWhen defined, the check will ensure class method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nClassMethodCase of\nlower_case\nClassMethodPrefix of\npre_\nClassMethodSuffix of\n_post\nIdentifies and/or transforms class method names as follows:\nBefore:\nclass\nFOO\n{\npublic\n:\nint\nCLASS_MEMBER\n();\n};\nAfter:\nclass\nFOO\n{\npublic\n:\nint\npre_class_member_post\n();\n};\nConceptCase\nWhen defined, the check will ensure concept names conform to the\nselected casing.\nConceptPrefix\nWhen defined, the check will ensure concept names will add the\nprefix with the given value (regardless of casing).\nConceptIgnoredRegexp\nIdentifier naming checks won’t be enforced for concept names\nmatching this regular expression.\nConceptSuffix\nWhen defined, the check will ensure concept names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nConceptCase of\nCamelCase\nConceptPrefix of\nPre\nConceptSuffix of\nPost\nIdentifies and/or transforms concept names as follows:\nBefore:\ntemplate\n<\ntypename\nT\n>\nconcept\nmy_concept\n=\nrequires\n(\nT\nt\n)\n{\n{\nt\n++\n};\n};\nAfter:\ntemplate\n<\ntypename\nT\n>\nconcept\nPreMyConceptPost\n=\nrequires\n(\nT\nt\n)\n{\n{\nt\n++\n};\n};\nConstantCase\nWhen defined, the check will ensure constant names conform to the\nselected casing.\nConstantPrefix\nWhen defined, the check will ensure constant names will add the\nprefix with the given value (regardless of casing).\nConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for constant names\nmatching this regular expression.\nConstantSuffix\nWhen defined, the check will ensure constant names will add the\nsuffix with the given value (regardless of casing).\nConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nConstantCase of\nlower_case\nConstantPrefix of\npre_\nConstantSuffix of\n_post\nConstantHungarianPrefix of\nOn\nIdentifies and/or transforms constant names as follows:\nBefore:\nvoid\nfunction\n()\n{\nunsigned\nconst\nMyConst_array\n[]\n=\n{\n1\n,\n2\n,\n3\n};\n}\nAfter:\nvoid\nfunction\n()\n{\nunsigned\nconst\npre_myconst_array_post\n[]\n=\n{\n1\n,\n2\n,\n3\n};\n}\nConstantMemberCase\nWhen defined, the check will ensure constant member names conform to the\nselected casing.\nConstantMemberPrefix\nWhen defined, the check will ensure constant member names will add the\nprefix with the given value (regardless of casing).\nConstantMemberIgnoredRegexp\nIdentifier naming checks won’t be enforced for constant member names\nmatching this regular expression.\nConstantMemberSuffix\nWhen defined, the check will ensure constant member names will add the\nsuffix with the given value (regardless of casing).\nConstantMemberHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nConstantMemberCase of\nlower_case\nConstantMemberPrefix of\npre_\nConstantMemberSuffix of\n_post\nConstantMemberHungarianPrefix of\nOn\nIdentifies and/or transforms constant member names as follows:\nBefore:\nclass\nFoo\n{\nchar\nconst\nMY_ConstMember_string\n[\n4\n]\n=\n\"123\"\n;\n}\nAfter:\nclass\nFoo\n{\nchar\nconst\npre_my_constmember_string_post\n[\n4\n]\n=\n\"123\"\n;\n}\nConstantParameterCase\nWhen defined, the check will ensure constant parameter names conform to the\nselected casing.\nConstantParameterPrefix\nWhen defined, the check will ensure constant parameter names will add the\nprefix with the given value (regardless of casing).\nConstantParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for constant parameter names\nmatching this regular expression.\nConstantParameterSuffix\nWhen defined, the check will ensure constant parameter names will add the\nsuffix with the given value (regardless of casing).\nConstantParameterHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nConstantParameterCase of\nlower_case\nConstantParameterPrefix of\npre_\nConstantParameterSuffix of\n_post\nConstantParameterHungarianPrefix of\nOn\nIdentifies and/or transforms constant parameter names as follows:\nBefore:\nvoid\nGLOBAL_FUNCTION\n(\nint\nPARAMETER_1\n,\nint\nconst\nCONST_parameter\n);\nAfter:\nvoid\nGLOBAL_FUNCTION\n(\nint\nPARAMETER_1\n,\nint\nconst\npre_const_parameter_post\n);\nConstantPointerParameterCase\nWhen defined, the check will ensure constant pointer parameter names conform to the\nselected casing.\nConstantPointerParameterPrefix\nWhen defined, the check will ensure constant pointer parameter names will add the\nprefix with the given value (regardless of casing).\nConstantPointerParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for constant pointer parameter\nnames matching this regular expression.\nConstantPointerParameterSuffix\nWhen defined, the check will ensure constant pointer parameter names will add the\nsuffix with the given value (regardless of casing).\nConstantPointerParameterHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nConstantPointerParameterCase of\nlower_case\nConstantPointerParameterPrefix of\npre_\nConstantPointerParameterSuffix of\n_post\nConstantPointerParameterHungarianPrefix of\nOn\nIdentifies and/or transforms constant pointer parameter names as follows:\nBefore:\nvoid\nGLOBAL_FUNCTION\n(\nint\nconst\n*\nCONST_parameter\n);\nAfter:\nvoid\nGLOBAL_FUNCTION\n(\nint\nconst\n*\npre_const_parameter_post\n);\nConstexprFunctionCase\nWhen defined, the check will ensure constexpr function names conform to the\nselected casing.\nConstexprFunctionPrefix\nWhen defined, the check will ensure constexpr function names will add the\nprefix with the given value (regardless of casing).\nConstexprFunctionIgnoredRegexp\nIdentifier naming checks won’t be enforced for constexpr function names\nmatching this regular expression.\nConstexprFunctionSuffix\nWhen defined, the check will ensure constexpr function names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nConstexprFunctionCase of\nlower_case\nConstexprFunctionPrefix of\npre_\nConstexprFunctionSuffix of\n_post\nIdentifies and/or transforms constexpr function names as follows:\nBefore:\nconstexpr\nint\nCE_function\n()\n{\nreturn\n3\n;\n}\nAfter:\nconstexpr\nint\npre_ce_function_post\n()\n{\nreturn\n3\n;\n}\nConstexprMethodCase\nWhen defined, the check will ensure constexpr method names conform to the\nselected casing.\nConstexprMethodPrefix\nWhen defined, the check will ensure constexpr method names will add the\nprefix with the given value (regardless of casing).\nConstexprMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for constexpr method names\nmatching this regular expression.\nConstexprMethodSuffix\nWhen defined, the check will ensure constexpr method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nConstexprMethodCase of\nlower_case\nConstexprMethodPrefix of\npre_\nConstexprMethodSuffix of\n_post\nIdentifies and/or transforms constexpr method names as follows:\nBefore:\nclass\nFoo\n{\npublic\n:\nconstexpr\nint\nCST_expr_Method\n()\n{\nreturn\n2\n;\n}\n}\nAfter:\nclass\nFoo\n{\npublic\n:\nconstexpr\nint\npre_cst_expr_method_post\n()\n{\nreturn\n2\n;\n}\n}\nConstexprVariableCase\nWhen defined, the check will ensure constexpr variable names conform to the\nselected casing.\nConstexprVariablePrefix\nWhen defined, the check will ensure constexpr variable names will add the\nprefix with the given value (regardless of casing).\nConstexprVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for constexpr variable names\nmatching this regular expression.\nConstexprVariableSuffix\nWhen defined, the check will ensure constexpr variable names will add the\nsuffix with the given value (regardless of casing).\nConstexprVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nConstexprVariableCase of\nlower_case\nConstexprVariablePrefix of\npre_\nConstexprVariableSuffix of\n_post\nConstexprVariableHungarianPrefix of\nOn\nIdentifies and/or transforms constexpr variable names as follows:\nBefore:\nconstexpr\nint\nConstExpr_variable\n=\nMyConstant\n;\nAfter:\nconstexpr\nint\npre_constexpr_variable_post\n=\nMyConstant\n;\nEnumCase\nWhen defined, the check will ensure enumeration names conform to the\nselected casing.\nEnumPrefix\nWhen defined, the check will ensure enumeration names will add the\nprefix with the given value (regardless of casing).\nEnumIgnoredRegexp\nIdentifier naming checks won’t be enforced for enumeration names\nmatching this regular expression.\nEnumSuffix\nWhen defined, the check will ensure enumeration names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nEnumCase of\nlower_case\nEnumPrefix of\npre_\nEnumSuffix of\n_post\nIdentifies and/or transforms enumeration names as follows:\nBefore:\nenum\nFOO\n{\nOne\n,\nTwo\n,\nThree\n};\nAfter:\nenum\npre_foo_post\n{\nOne\n,\nTwo\n,\nThree\n};\nEnumConstantCase\nWhen defined, the check will ensure enumeration constant names conform to the\nselected casing.\nEnumConstantPrefix\nWhen defined, the check will ensure enumeration constant names will add the\nprefix with the given value (regardless of casing).\nEnumConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for enumeration constant names\nmatching this regular expression.\nEnumConstantSuffix\nWhen defined, the check will ensure enumeration constant names will add the\nsuffix with the given value (regardless of casing).\nEnumConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nEnumConstantCase of\nlower_case\nEnumConstantPrefix of\npre_\nEnumConstantSuffix of\n_post\nEnumConstantHungarianPrefix of\nOn\nIdentifies and/or transforms enumeration constant names as follows:\nBefore:\nenum\nFOO\n{\nOne\n,\nTwo\n,\nThree\n};\nAfter:\nenum\nFOO\n{\npre_One_post\n,\npre_Two_post\n,\npre_Three_post\n};\nFunctionCase\nWhen defined, the check will ensure function names conform to the\nselected casing.\nFunctionPrefix\nWhen defined, the check will ensure function names will add the\nprefix with the given value (regardless of casing).\nFunctionIgnoredRegexp\nIdentifier naming checks won’t be enforced for function names\nmatching this regular expression.\nFunctionSuffix\nWhen defined, the check will ensure function names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nFunctionCase of\nlower_case\nFunctionPrefix of\npre_\nFunctionSuffix of\n_post\nIdentifies and/or transforms function names as follows:\nBefore:\nchar\nMY_Function_string\n();\nAfter:\nchar\npre_my_function_string_post\n();\nGetConfigPerFile\nWhen\ntrue\nthe check will look for the configuration for where an\nidentifier is declared. Useful for when included header files use a\ndifferent style.\nDefault value is\ntrue\n.\nGlobalConstexprVariableCase\nWhen defined, the check will ensure global\nconstexpr\nvariable names\nconform to the selected casing.\nGlobalConstexprVariablePrefix\nWhen defined, the check will ensure global\nconstexpr\nvariable names\nwill add the prefixed with the given value (regardless of casing).\nGlobalConstexprVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for global\nconstexpr\nvariable names matching this regular expression.\nGlobalConstexprVariableSuffix\nWhen defined, the check will ensure global\nconstexpr\nvariable names\nwill add the suffix with the given value (regardless of casing).\nGlobalConstexprVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\nFor example using values of:\nGlobalConstexprVariableCase of\nlower_case\nGlobalConstexprVariablePrefix of\npre_\nGlobalConstexprVariableSuffix of\n_post\nGlobalConstexprVariableHungarianPrefix of\nOn\nIdentifies and/or transforms global\nconstexpr\nvariable names as follows:\nBefore:\nconstexpr\nunsigned\nImportantValue\n=\n69\n;\nAfter:\nconstexpr\nunsigned\npre_important_value_post\n=\n69\n;\nGlobalConstantCase\nWhen defined, the check will ensure global constant names conform to the\nselected casing.\nGlobalConstantPrefix\nWhen defined, the check will ensure global constant names will add the\nprefix with the given value (regardless of casing).\nGlobalConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for global constant names\nmatching this regular expression.\nGlobalConstantSuffix\nWhen defined, the check will ensure global constant names will add the\nsuffix with the given value (regardless of casing).\nGlobalConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nGlobalConstantCase of\nlower_case\nGlobalConstantPrefix of\npre_\nGlobalConstantSuffix of\n_post\nGlobalConstantHungarianPrefix of\nOn\nIdentifies and/or transforms global constant names as follows:\nBefore:\nunsigned\nconst\nMyConstGlobal_array\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nAfter:\nunsigned\nconst\npre_myconstglobal_array_post\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nGlobalConstantPointerCase\nWhen defined, the check will ensure global constant pointer names conform to the\nselected casing.\nGlobalConstantPointerPrefix\nWhen defined, the check will ensure global constant pointer names will add the\nprefix with the given value (regardless of casing).\nGlobalConstantPointerIgnoredRegexp\nIdentifier naming checks won’t be enforced for global constant pointer\nnames matching this regular expression.\nGlobalConstantPointerSuffix\nWhen defined, the check will ensure global constant pointer names will add the\nsuffix with the given value (regardless of casing).\nGlobalConstantPointerHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nGlobalConstantPointerCase of\nlower_case\nGlobalConstantPointerPrefix of\npre_\nGlobalConstantPointerSuffix of\n_post\nGlobalConstantPointerHungarianPrefix of\nOn\nIdentifies and/or transforms global constant pointer names as follows:\nBefore:\nint\n*\nconst\nMyConstantGlobalPointer\n=\nnullptr\n;\nAfter:\nint\n*\nconst\npre_myconstantglobalpointer_post\n=\nnullptr\n;\nGlobalFunctionCase\nWhen defined, the check will ensure global function names conform to the\nselected casing.\nGlobalFunctionPrefix\nWhen defined, the check will ensure global function names will add the\nprefix with the given value (regardless of casing).\nGlobalFunctionIgnoredRegexp\nIdentifier naming checks won’t be enforced for global function names\nmatching this regular expression.\nGlobalFunctionSuffix\nWhen defined, the check will ensure global function names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nGlobalFunctionCase of\nlower_case\nGlobalFunctionPrefix of\npre_\nGlobalFunctionSuffix of\n_post\nIdentifies and/or transforms global function names as follows:\nBefore:\nvoid\nGLOBAL_FUNCTION\n(\nint\nPARAMETER_1\n,\nint\nconst\nCONST_parameter\n);\nAfter:\nvoid\npre_global_function_post\n(\nint\nPARAMETER_1\n,\nint\nconst\nCONST_parameter\n);\nGlobalPointerCase\nWhen defined, the check will ensure global pointer names conform to the\nselected casing.\nGlobalPointerPrefix\nWhen defined, the check will ensure global pointer names will add the\nprefix with the given value (regardless of casing).\nGlobalPointerIgnoredRegexp\nIdentifier naming checks won’t be enforced for global pointer names\nmatching this regular expression.\nGlobalPointerSuffix\nWhen defined, the check will ensure global pointer names will add the\nsuffix with the given value (regardless of casing).\nGlobalPointerHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nGlobalPointerCase of\nlower_case\nGlobalPointerPrefix of\npre_\nGlobalPointerSuffix of\n_post\nGlobalPointerHungarianPrefix of\nOn\nIdentifies and/or transforms global pointer names as follows:\nBefore:\nint\n*\nGLOBAL3\n;\nAfter:\nint\n*\npre_global3_post\n;\nGlobalVariableCase\nWhen defined, the check will ensure global variable names conform to the\nselected casing.\nGlobalVariablePrefix\nWhen defined, the check will ensure global variable names will add the\nprefix with the given value (regardless of casing).\nGlobalVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for global variable names\nmatching this regular expression.\nGlobalVariableSuffix\nWhen defined, the check will ensure global variable names will add the\nsuffix with the given value (regardless of casing).\nGlobalVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nGlobalVariableCase of\nlower_case\nGlobalVariablePrefix of\npre_\nGlobalVariableSuffix of\n_post\nGlobalVariableHungarianPrefix of\nOn\nIdentifies and/or transforms global variable names as follows:\nBefore:\nint\nGLOBAL3\n;\nAfter:\nint\npre_global3_post\n;\nIgnoreMainLikeFunctions\nWhen set to\ntrue\nfunctions that have a similar signature to\nmain\nor\nwmain\nwon’t enforce checks on the names of their parameters.\nDefault value is\nfalse\n.\nInlineNamespaceCase\nWhen defined, the check will ensure inline namespaces names conform to the\nselected casing.\nInlineNamespacePrefix\nWhen defined, the check will ensure inline namespaces names will add the\nprefix with the given value (regardless of casing).\nInlineNamespaceIgnoredRegexp\nIdentifier naming checks won’t be enforced for inline namespaces names\nmatching this regular expression.\nInlineNamespaceSuffix\nWhen defined, the check will ensure inline namespaces names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nInlineNamespaceCase of\nlower_case\nInlineNamespacePrefix of\npre_\nInlineNamespaceSuffix of\n_post\nIdentifies and/or transforms inline namespaces names as follows:\nBefore:\nnamespace\nFOO_NS\n{\ninline\nnamespace\nInlineNamespace\n{\n...\n}\n}\n// namespace FOO_NS\nAfter:\nnamespace\nFOO_NS\n{\ninline\nnamespace\npre_inlinenamespace_post\n{\n...\n}\n}\n// namespace FOO_NS\nLocalConstexprVariableCase\nWhen defined, the check will ensure local\nconstexpr\nvariable names\nconform to the selected casing.\nLocalConstexprVariablePrefix\nWhen defined, the check will ensure local\nconstexpr\nvariable names will\nadd the prefixed with the given value (regardless of casing).\nLocalConstexprVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for local\nconstexpr\nvariable\nnames matching this regular expression.\nLocalConstexprVariableSuffix\nWhen defined, the check will ensure local\nconstexpr\nvariable names will\nadd the suffix with the given value (regardless of casing).\nLocalConstexprVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\nFor example using values of:\nLocalConstexprVariableCase of\nlower_case\nLocalConstexprVariablePrefix of\npre_\nLocalConstexprVariableSuffix of\n_post\nLocalConstexprVariableHungarianPrefix of\nOn\nIdentifies and/or transforms local\nconstexpr\nvariable names as follows:\nBefore:\nvoid\nfoo\n()\n{\nint\nconst\nlocal_Constexpr\n=\n420\n;\n}\nAfter:\nvoid\nfoo\n()\n{\nint\nconst\npre_local_constexpr_post\n=\n420\n;\n}\nLocalConstantCase\nWhen defined, the check will ensure local constant names conform to the\nselected casing.\nLocalConstantPrefix\nWhen defined, the check will ensure local constant names will add the\nprefix with the given value (regardless of casing).\nLocalConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for local constant names\nmatching this regular expression.\nLocalConstantSuffix\nWhen defined, the check will ensure local constant names will add the\nsuffix with the given value (regardless of casing).\nLocalConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nLocalConstantCase of\nlower_case\nLocalConstantPrefix of\npre_\nLocalConstantSuffix of\n_post\nLocalConstantHungarianPrefix of\nOn\nIdentifies and/or transforms local constant names as follows:\nBefore:\nvoid\nfoo\n()\n{\nint\nconst\nlocal_Constant\n=\n3\n;\n}\nAfter:\nvoid\nfoo\n()\n{\nint\nconst\npre_local_constant_post\n=\n3\n;\n}\nLocalConstantPointerCase\nWhen defined, the check will ensure local constant pointer names conform to the\nselected casing.\nLocalConstantPointerPrefix\nWhen defined, the check will ensure local constant pointer names will add the\nprefix with the given value (regardless of casing).\nLocalConstantPointerIgnoredRegexp\nIdentifier naming checks won’t be enforced for local constant pointer names\nmatching this regular expression.\nLocalConstantPointerSuffix\nWhen defined, the check will ensure local constant pointer names will add the\nsuffix with the given value (regardless of casing).\nLocalConstantPointerHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nLocalConstantPointerCase of\nlower_case\nLocalConstantPointerPrefix of\npre_\nLocalConstantPointerSuffix of\n_post\nLocalConstantPointerHungarianPrefix of\nOn\nIdentifies and/or transforms local constant pointer names as follows:\nBefore:\nvoid\nfoo\n()\n{\nint\nconst\n*\nlocal_Constant\n=\n3\n;\n}\nAfter:\nvoid\nfoo\n()\n{\nint\nconst\n*\npre_local_constant_post\n=\n3\n;\n}\nLocalPointerCase\nWhen defined, the check will ensure local pointer names conform to the\nselected casing.\nLocalPointerPrefix\nWhen defined, the check will ensure local pointer names will add the\nprefix with the given value (regardless of casing).\nLocalPointerIgnoredRegexp\nIdentifier naming checks won’t be enforced for local pointer names\nmatching this regular expression.\nLocalPointerSuffix\nWhen defined, the check will ensure local pointer names will add the\nsuffix with the given value (regardless of casing).\nLocalPointerHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nLocalPointerCase of\nlower_case\nLocalPointerPrefix of\npre_\nLocalPointerSuffix of\n_post\nLocalPointerHungarianPrefix of\nOn\nIdentifies and/or transforms local pointer names as follows:\nBefore:\nvoid\nfoo\n()\n{\nint\n*\nlocal_Constant\n;\n}\nAfter:\nvoid\nfoo\n()\n{\nint\n*\npre_local_constant_post\n;\n}\nLocalVariableCase\nWhen defined, the check will ensure local variable names conform to the\nselected casing.\nLocalVariablePrefix\nWhen defined, the check will ensure local variable names will add the\nprefix with the given value (regardless of casing).\nLocalVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for local variable names\nmatching this regular expression.\nFor example using values of:\nLocalVariableCase of\nCamelCase\nLocalVariableIgnoredRegexp of\n\\w{1,2}\nWill exclude variables with a length less than or equal to 2 from the\ncamel case check applied to other variables.\nLocalVariableSuffix\nWhen defined, the check will ensure local variable names will add the\nsuffix with the given value (regardless of casing).\nLocalVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nLocalVariableCase of\nlower_case\nLocalVariablePrefix of\npre_\nLocalVariableSuffix of\n_post\nLocalVariableHungarianPrefix of\nOn\nIdentifies and/or transforms local variable names as follows:\nBefore:\nvoid\nfoo\n()\n{\nint\nlocal_Constant\n;\n}\nAfter:\nvoid\nfoo\n()\n{\nint\npre_local_constant_post\n;\n}\nMacroDefinitionCase\nWhen defined, the check will ensure macro definitions conform to the\nselected casing.\nMacroDefinitionPrefix\nWhen defined, the check will ensure macro definitions will add the\nprefix with the given value (regardless of casing).\nMacroDefinitionIgnoredRegexp\nIdentifier naming checks won’t be enforced for macro definitions\nmatching this regular expression.\nMacroDefinitionSuffix\nWhen defined, the check will ensure macro definitions will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nMacroDefinitionCase of\nlower_case\nMacroDefinitionPrefix of\npre_\nMacroDefinitionSuffix of\n_post\nIdentifies and/or transforms macro definitions as follows:\nBefore:\n#define MY_MacroDefinition\nAfter:\n#define pre_my_macro_definition_post\nNote: This will not warn on builtin macros or macros defined on the\ncommand line using the\n-D\nflag.\nMemberCase\nWhen defined, the check will ensure member names conform to the\nselected casing.\nMemberPrefix\nWhen defined, the check will ensure member names will add the\nprefix with the given value (regardless of casing).\nMemberIgnoredRegexp\nIdentifier naming checks won’t be enforced for member names\nmatching this regular expression.\nMemberSuffix\nWhen defined, the check will ensure member names will add the\nsuffix with the given value (regardless of casing).\nMemberHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nMemberCase of\nlower_case\nMemberPrefix of\npre_\nMemberSuffix of\n_post\nMemberHungarianPrefix of\nOn\nIdentifies and/or transforms member names as follows:\nBefore:\nclass\nFoo\n{\nchar\nMY_ConstMember_string\n[\n4\n];\n}\nAfter:\nclass\nFoo\n{\nchar\npre_my_constmember_string_post\n[\n4\n];\n}\nMethodCase\nWhen defined, the check will ensure method names conform to the\nselected casing.\nMethodPrefix\nWhen defined, the check will ensure method names will add the\nprefix with the given value (regardless of casing).\nMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for method names\nmatching this regular expression.\nMethodSuffix\nWhen defined, the check will ensure method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nMethodCase of\nlower_case\nMethodPrefix of\npre_\nMethodSuffix of\n_post\nIdentifies and/or transforms method names as follows:\nBefore:\nclass\nFoo\n{\nchar\nMY_Method_string\n();\n}\nAfter:\nclass\nFoo\n{\nchar\npre_my_method_string_post\n();\n}\nNamespaceCase\nWhen defined, the check will ensure namespace names conform to the\nselected casing.\nNamespacePrefix\nWhen defined, the check will ensure namespace names will add the\nprefix with the given value (regardless of casing).\nNamespaceIgnoredRegexp\nIdentifier naming checks won’t be enforced for namespace names\nmatching this regular expression.\nNamespaceSuffix\nWhen defined, the check will ensure namespace names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nNamespaceCase of\nlower_case\nNamespacePrefix of\npre_\nNamespaceSuffix of\n_post\nIdentifies and/or transforms namespace names as follows:\nBefore:\nnamespace\nFOO_NS\n{\n...\n}\nAfter:\nnamespace\npre_foo_ns_post\n{\n...\n}\nParameterCase\nWhen defined, the check will ensure parameter names conform to the\nselected casing.\nParameterPrefix\nWhen defined, the check will ensure parameter names will add the\nprefix with the given value (regardless of casing).\nParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for parameter names\nmatching this regular expression.\nParameterSuffix\nWhen defined, the check will ensure parameter names will add the\nsuffix with the given value (regardless of casing).\nParameterHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nParameterCase of\nlower_case\nParameterPrefix of\npre_\nParameterSuffix of\n_post\nParameterHungarianPrefix of\nOn\nIdentifies and/or transforms parameter names as follows:\nBefore:\nvoid\nGLOBAL_FUNCTION\n(\nint\nPARAMETER_1\n,\nint\nconst\nCONST_parameter\n);\nAfter:\nvoid\nGLOBAL_FUNCTION\n(\nint\npre_parameter_post\n,\nint\nconst\nCONST_parameter\n);\nParameterPackCase\nWhen defined, the check will ensure parameter pack names conform to the\nselected casing.\nParameterPackPrefix\nWhen defined, the check will ensure parameter pack names will add the\nprefix with the given value (regardless of casing).\nParameterPackIgnoredRegexp\nIdentifier naming checks won’t be enforced for parameter pack names\nmatching this regular expression.\nParameterPackSuffix\nWhen defined, the check will ensure parameter pack names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nParameterPackCase of\nlower_case\nParameterPackPrefix of\npre_\nParameterPackSuffix of\n_post\nIdentifies and/or transforms parameter pack names as follows:\nBefore:\ntemplate\n<\ntypename\n...\nTYPE_parameters\n>\n{\nvoid\nFUNCTION\n(\nint\n...\nTYPE_parameters\n);\n}\nAfter:\ntemplate\n<\ntypename\n...\nTYPE_parameters\n>\n{\nvoid\nFUNCTION\n(\nint\n...\npre_type_parameters_post\n);\n}\nPointerParameterCase\nWhen defined, the check will ensure pointer parameter names conform to the\nselected casing.\nPointerParameterPrefix\nWhen defined, the check will ensure pointer parameter names will add the\nprefix with the given value (regardless of casing).\nPointerParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for pointer parameter names\nmatching this regular expression.\nPointerParameterSuffix\nWhen defined, the check will ensure pointer parameter names will add the\nsuffix with the given value (regardless of casing).\nPointerParameterHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nPointerParameterCase of\nlower_case\nPointerParameterPrefix of\npre_\nPointerParameterSuffix of\n_post\nPointerParameterHungarianPrefix of\nOn\nIdentifies and/or transforms pointer parameter names as follows:\nBefore:\nvoid\nFUNCTION\n(\nint\n*\nPARAMETER\n);\nAfter:\nvoid\nFUNCTION\n(\nint\n*\npre_parameter_post\n);\nPrivateMemberCase\nWhen defined, the check will ensure private member names conform to the\nselected casing.\nPrivateMemberPrefix\nWhen defined, the check will ensure private member names will add the\nprefix with the given value (regardless of casing).\nPrivateMemberIgnoredRegexp\nIdentifier naming checks won’t be enforced for private member names\nmatching this regular expression.\nPrivateMemberSuffix\nWhen defined, the check will ensure private member names will add the\nsuffix with the given value (regardless of casing).\nPrivateMemberHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nPrivateMemberCase of\nlower_case\nPrivateMemberPrefix of\npre_\nPrivateMemberSuffix of\n_post\nPrivateMemberHungarianPrefix of\nOn\nIdentifies and/or transforms private member names as follows:\nBefore:\nclass\nFoo\n{\nprivate\n:\nint\nMember_Variable\n;\n}\nAfter:\nclass\nFoo\n{\nprivate\n:\nint\npre_member_variable_post\n;\n}\nPrivateMethodCase\nWhen defined, the check will ensure private method names conform to the\nselected casing.\nPrivateMethodPrefix\nWhen defined, the check will ensure private method names will add the\nprefix with the given value (regardless of casing).\nPrivateMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for private method names\nmatching this regular expression.\nPrivateMethodSuffix\nWhen defined, the check will ensure private method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nPrivateMethodCase of\nlower_case\nPrivateMethodPrefix of\npre_\nPrivateMethodSuffix of\n_post\nIdentifies and/or transforms private method names as follows:\nBefore:\nclass\nFoo\n{\nprivate\n:\nint\nMember_Method\n();\n}\nAfter:\nclass\nFoo\n{\nprivate\n:\nint\npre_member_method_post\n();\n}\nProtectedMemberCase\nWhen defined, the check will ensure protected member names conform to the\nselected casing.\nProtectedMemberPrefix\nWhen defined, the check will ensure protected member names will add the\nprefix with the given value (regardless of casing).\nProtectedMemberIgnoredRegexp\nIdentifier naming checks won’t be enforced for protected member names\nmatching this regular expression.\nProtectedMemberSuffix\nWhen defined, the check will ensure protected member names will add the\nsuffix with the given value (regardless of casing).\nProtectedMemberHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nProtectedMemberCase of\nlower_case\nProtectedMemberPrefix of\npre_\nProtectedMemberSuffix of\n_post\nProtectedMemberHungarianPrefix of\nOn\nIdentifies and/or transforms protected member names as follows:\nBefore:\nclass\nFoo\n{\nprotected\n:\nint\nMember_Variable\n;\n}\nAfter:\nclass\nFoo\n{\nprotected\n:\nint\npre_member_variable_post\n;\n}\nProtectedMethodCase\nWhen defined, the check will ensure protected method names conform to the\nselected casing.\nProtectedMethodPrefix\nWhen defined, the check will ensure protected method names will add the\nprefix with the given value (regardless of casing).\nProtectedMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for protected method names\nmatching this regular expression.\nProtectedMethodSuffix\nWhen defined, the check will ensure protected method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nProtectedMethodCase of\nlower_case\nProtectedMethodPrefix of\npre_\nProtectedMethodSuffix of\n_post\nIdentifies and/or transforms protect method names as follows:\nBefore:\nclass\nFoo\n{\nprotected\n:\nint\nMember_Method\n();\n}\nAfter:\nclass\nFoo\n{\nprotected\n:\nint\npre_member_method_post\n();\n}\nPublicMemberCase\nWhen defined, the check will ensure public member names conform to the\nselected casing.\nPublicMemberPrefix\nWhen defined, the check will ensure public member names will add the\nprefix with the given value (regardless of casing).\nPublicMemberIgnoredRegexp\nIdentifier naming checks won’t be enforced for public member names\nmatching this regular expression.\nPublicMemberSuffix\nWhen defined, the check will ensure public member names will add the\nsuffix with the given value (regardless of casing).\nPublicMemberHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nPublicMemberCase of\nlower_case\nPublicMemberPrefix of\npre_\nPublicMemberSuffix of\n_post\nPublicMemberHungarianPrefix of\nOn\nIdentifies and/or transforms public member names as follows:\nBefore:\nclass\nFoo\n{\npublic\n:\nint\nMember_Variable\n;\n}\nAfter:\nclass\nFoo\n{\npublic\n:\nint\npre_member_variable_post\n;\n}\nPublicMethodCase\nWhen defined, the check will ensure public method names conform to the\nselected casing.\nPublicMethodPrefix\nWhen defined, the check will ensure public method names will add the\nprefix with the given value (regardless of casing).\nPublicMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for public method names\nmatching this regular expression.\nPublicMethodSuffix\nWhen defined, the check will ensure public method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nPublicMethodCase of\nlower_case\nPublicMethodPrefix of\npre_\nPublicMethodSuffix of\n_post\nIdentifies and/or transforms public method names as follows:\nBefore:\nclass\nFoo\n{\npublic\n:\nint\nMember_Method\n();\n}\nAfter:\nclass\nFoo\n{\npublic\n:\nint\npre_member_method_post\n();\n}\nScopedEnumConstantCase\nWhen defined, the check will ensure scoped enum constant names conform to\nthe selected casing.\nScopedEnumConstantPrefix\nWhen defined, the check will ensure scoped enum constant names will add the\nprefix with the given value (regardless of casing).\nScopedEnumConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for scoped enum constant names\nmatching this regular expression.\nScopedEnumConstantSuffix\nWhen defined, the check will ensure scoped enum constant names will add the\nsuffix with the given value (regardless of casing).\nScopedEnumConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nScopedEnumConstantCase of\nlower_case\nScopedEnumConstantPrefix of\npre_\nScopedEnumConstantSuffix of\n_post\nScopedEnumConstantHungarianPrefix of\nOn\nIdentifies and/or transforms enumeration constant names as follows:\nBefore:\nenum\nclass\nFOO\n{\nOne\n,\nTwo\n,\nThree\n};\nAfter:\nenum\nclass\nFOO\n{\npre_One_post\n,\npre_Two_post\n,\npre_Three_post\n};\nStaticConstexprVariableCase\nWhen defined, the check will ensure static\nconstexpr\nvariable names\nconform to the selected casing.\nStaticConstexprVariablePrefix\nWhen defined, the check will ensure static\nconstexpr\nvariable names\nwill add the prefixed with the given value (regardless of casing).\nStaticConstexprVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for static\nconstexpr\nvariable names matching this regular expression.\nStaticConstexprVariableSuffix\nWhen defined, the check will ensure static\nconstexpr\nvariable names\nwill add the suffix with the given value (regardless of casing).\nStaticConstexprVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will have a\nHungarian notation prefix based on the declared type.\nFor example using values of:\nStaticConstexprVariableCase of\nlower_case\nStaticConstexprVariablePrefix of\npre_\nStaticConstexprVariableSuffix of\n_post\nStaticConstexprVariableHungarianPrefix of\nOn\nIdentifies and/or transforms static\nconstexpr\nvariable names as follows:\nBefore:\nstatic\nunsigned\nconstexpr\nMyConstexprStatic_array\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nAfter:\nstatic\nunsigned\nconstexpr\npre_my_constexpr_static_array_post\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nStaticConstantCase\nWhen defined, the check will ensure static constant names conform to the\nselected casing.\nStaticConstantPrefix\nWhen defined, the check will ensure static constant names will add the\nprefix with the given value (regardless of casing).\nStaticConstantIgnoredRegexp\nIdentifier naming checks won’t be enforced for static constant names\nmatching this regular expression.\nStaticConstantSuffix\nWhen defined, the check will ensure static constant names will add the\nsuffix with the given value (regardless of casing).\nStaticConstantHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nStaticConstantCase of\nlower_case\nStaticConstantPrefix of\npre_\nStaticConstantSuffix of\n_post\nStaticConstantHungarianPrefix of\nOn\nIdentifies and/or transforms static constant names as follows:\nBefore:\nstatic\nunsigned\nconst\nMyConstStatic_array\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nAfter:\nstatic\nunsigned\nconst\npre_myconststatic_array_post\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nStaticVariableCase\nWhen defined, the check will ensure static variable names conform to the\nselected casing.\nStaticVariablePrefix\nWhen defined, the check will ensure static variable names will add the\nprefix with the given value (regardless of casing).\nStaticVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for static variable names\nmatching this regular expression.\nStaticVariableSuffix\nWhen defined, the check will ensure static variable names will add the\nsuffix with the given value (regardless of casing).\nStaticVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nStaticVariableCase of\nlower_case\nStaticVariablePrefix of\npre_\nStaticVariableSuffix of\n_post\nStaticVariableHungarianPrefix of\nOn\nIdentifies and/or transforms static variable names as follows:\nBefore:\nstatic\nunsigned\nMyStatic_array\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nAfter:\nstatic\nunsigned\npre_mystatic_array_post\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nStructCase\nWhen defined, the check will ensure struct names conform to the\nselected casing.\nStructPrefix\nWhen defined, the check will ensure struct names will add the\nprefix with the given value (regardless of casing).\nStructIgnoredRegexp\nIdentifier naming checks won’t be enforced for struct names\nmatching this regular expression.\nStructSuffix\nWhen defined, the check will ensure struct names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nStructCase of\nlower_case\nStructPrefix of\npre_\nStructSuffix of\n_post\nIdentifies and/or transforms struct names as follows:\nBefore:\nstruct\nFOO\n{\nFOO\n();\n~\nFOO\n();\n};\nAfter:\nstruct\npre_foo_post\n{\npre_foo_post\n();\n~\npre_foo_post\n();\n};\nTemplateParameterCase\nWhen defined, the check will ensure template parameter names conform to the\nselected casing.\nTemplateParameterPrefix\nWhen defined, the check will ensure template parameter names will add the\nprefix with the given value (regardless of casing).\nTemplateParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for template parameter names\nmatching this regular expression.\nTemplateParameterSuffix\nWhen defined, the check will ensure template parameter names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nTemplateParameterCase of\nlower_case\nTemplateParameterPrefix of\npre_\nTemplateParameterSuffix of\n_post\nIdentifies and/or transforms template parameter names as follows:\nBefore:\ntemplate\n<\ntypename\nT\n>\nclass\nFoo\n{};\nAfter:\ntemplate\n<\ntypename\npre_t_post\n>\nclass\nFoo\n{};\nTemplateTemplateParameterCase\nWhen defined, the check will ensure template template parameter names conform to the\nselected casing.\nTemplateTemplateParameterPrefix\nWhen defined, the check will ensure template template parameter names will add the\nprefix with the given value (regardless of casing).\nTemplateTemplateParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for template template parameter\nnames matching this regular expression.\nTemplateTemplateParameterSuffix\nWhen defined, the check will ensure template template parameter names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nTemplateTemplateParameterCase of\nlower_case\nTemplateTemplateParameterPrefix of\npre_\nTemplateTemplateParameterSuffix of\n_post\nIdentifies and/or transforms template template parameter names as follows:\nBefore:\ntemplate\n<\ntemplate\n<\ntypename\n>\nclass\nTPL_parameter\n,\nint\nCOUNT_params\n,\ntypename\n...\nTYPE_parameters\n>\nAfter:\ntemplate\n<\ntemplate\n<\ntypename\n>\nclass\npre_tpl_parameter_post\n,\nint\nCOUNT_params\n,\ntypename\n...\nTYPE_parameters\n>\nTypeAliasCase\nWhen defined, the check will ensure type alias names conform to the\nselected casing.\nTypeAliasPrefix\nWhen defined, the check will ensure type alias names will add the\nprefix with the given value (regardless of casing).\nTypeAliasIgnoredRegexp\nIdentifier naming checks won’t be enforced for type alias names\nmatching this regular expression.\nTypeAliasSuffix\nWhen defined, the check will ensure type alias names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nTypeAliasCase of\nlower_case\nTypeAliasPrefix of\npre_\nTypeAliasSuffix of\n_post\nIdentifies and/or transforms type alias names as follows:\nBefore:\nusing\nMY_STRUCT_TYPE\n=\nmy_structure\n;\nAfter:\nusing\npre_my_struct_type_post\n=\nmy_structure\n;\nTypedefCase\nWhen defined, the check will ensure typedef names conform to the\nselected casing.\nTypedefPrefix\nWhen defined, the check will ensure typedef names will add the\nprefix with the given value (regardless of casing).\nTypedefIgnoredRegexp\nIdentifier naming checks won’t be enforced for typedef names\nmatching this regular expression.\nTypedefSuffix\nWhen defined, the check will ensure typedef names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nTypedefCase of\nlower_case\nTypedefPrefix of\npre_\nTypedefSuffix of\n_post\nIdentifies and/or transforms typedef names as follows:\nBefore:\ntypedef\nint\nMYINT\n;\nAfter:\ntypedef\nint\npre_myint_post\n;\nTypeTemplateParameterCase\nWhen defined, the check will ensure type template parameter names conform to the\nselected casing.\nTypeTemplateParameterPrefix\nWhen defined, the check will ensure type template parameter names will add the\nprefix with the given value (regardless of casing).\nTypeTemplateParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for type template names\nmatching this regular expression.\nTypeTemplateParameterSuffix\nWhen defined, the check will ensure type template parameter names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nTypeTemplateParameterCase of\nlower_case\nTypeTemplateParameterPrefix of\npre_\nTypeTemplateParameterSuffix of\n_post\nIdentifies and/or transforms type template parameter names as follows:\nBefore:\ntemplate\n<\ntemplate\n<\ntypename\n>\nclass\nTPL_parameter\n,\nint\nCOUNT_params\n,\ntypename\n...\nTYPE_parameters\n>\nAfter:\ntemplate\n<\ntemplate\n<\ntypename\n>\nclass\nTPL_parameter\n,\nint\nCOUNT_params\n,\ntypename\n...\npre_type_parameters_post\n>\nUnionCase\nWhen defined, the check will ensure union names conform to the\nselected casing.\nUnionPrefix\nWhen defined, the check will ensure union names will add the\nprefix with the given value (regardless of casing).\nUnionIgnoredRegexp\nIdentifier naming checks won’t be enforced for union names\nmatching this regular expression.\nUnionSuffix\nWhen defined, the check will ensure union names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nUnionCase of\nlower_case\nUnionPrefix of\npre_\nUnionSuffix of\n_post\nIdentifies and/or transforms union names as follows:\nBefore:\nunion\nFOO\n{\nint\na\n;\nchar\nb\n;\n};\nAfter:\nunion\npre_foo_post\n{\nint\na\n;\nchar\nb\n;\n};\nValueTemplateParameterCase\nWhen defined, the check will ensure value template parameter names conform to the\nselected casing.\nValueTemplateParameterPrefix\nWhen defined, the check will ensure value template parameter names will add the\nprefix with the given value (regardless of casing).\nValueTemplateParameterIgnoredRegexp\nIdentifier naming checks won’t be enforced for value template parameter\nnames matching this regular expression.\nValueTemplateParameterSuffix\nWhen defined, the check will ensure value template parameter names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nValueTemplateParameterCase of\nlower_case\nValueTemplateParameterPrefix of\npre_\nValueTemplateParameterSuffix of\n_post\nIdentifies and/or transforms value template parameter names as follows:\nBefore:\ntemplate\n<\ntemplate\n<\ntypename\n>\nclass\nTPL_parameter\n,\nint\nCOUNT_params\n,\ntypename\n...\nTYPE_parameters\n>\nAfter:\ntemplate\n<\ntemplate\n<\ntypename\n>\nclass\nTPL_parameter\n,\nint\npre_count_params_post\n,\ntypename\n...\nTYPE_parameters\n>\nVariableCase\nWhen defined, the check will ensure variable names conform to the\nselected casing.\nVariablePrefix\nWhen defined, the check will ensure variable names will add the\nprefix with the given value (regardless of casing).\nVariableIgnoredRegexp\nIdentifier naming checks won’t be enforced for variable names\nmatching this regular expression.\nVariableSuffix\nWhen defined, the check will ensure variable names will add the\nsuffix with the given value (regardless of casing).\nVariableHungarianPrefix\nWhen enabled, the check ensures that the declared identifier will\nhave a Hungarian notation prefix based on the declared type.\nFor example using values of:\nVariableCase of\nlower_case\nVariablePrefix of\npre_\nVariableSuffix of\n_post\nVariableHungarianPrefix of\nOn\nIdentifies and/or transforms variable names as follows:\nBefore:\nunsigned\nMyVariable\n;\nAfter:\nunsigned\npre_myvariable_post\n;\nVirtualMethodCase\nWhen defined, the check will ensure virtual method names conform to the\nselected casing.\nVirtualMethodPrefix\nWhen defined, the check will ensure virtual method names will add the\nprefix with the given value (regardless of casing).\nVirtualMethodIgnoredRegexp\nIdentifier naming checks won’t be enforced for virtual method names\nmatching this regular expression.\nVirtualMethodSuffix\nWhen defined, the check will ensure virtual method names will add the\nsuffix with the given value (regardless of casing).\nFor example using values of:\nVirtualMethodCase of\nlower_case\nVirtualMethodPrefix of\npre_\nVirtualMethodSuffix of\n_post\nIdentifies and/or transforms virtual method names as follows:\nBefore:\nclass\nFoo\n{\npublic\n:\nvirtual\nint\nMemberFunction\n();\n}\nAfter:\nclass\nFoo\n{\npublic\n:\nvirtual\nint\npre_member_function_post\n();\n}\n\nThe default mapping table of Hungarian Notation\nIn Hungarian notation, a variable name starts with a group of lower-case\nletters which are mnemonics for the type or purpose of that variable, followed\nby whatever name the programmer has chosen; this last part is sometimes\ndistinguished as the given name. The first character of the given name can be\ncapitalized to separate it from the type indicators (see also CamelCase).\nOtherwise the case of this character denotes scope.\nThe following table is the default mapping table of Hungarian Notation\nwhich maps Decl to its prefix string. You can also have your own style\nin config file.\nPrimitive Type\nMicrosoft Type\nType\nPrefix\nType\nPrefix\nType\nPrefix\nint8_t\ni8\nsigned int\nsi\nBOOL\nb\nint16_t\ni16\nsigned short\nss\nBOOLEAN\nb\nint32_t\ni32\nsigned short int\nssi\nBYTE\nby\nint64_t\ni64\nsigned long long int\nslli\nCHAR\nc\nuint8_t\nu8\nsigned long long\nsll\nUCHAR\nuc\nuint16_t\nu16\nsigned long int\nsli\nSHORT\ns\nuint32_t\nu32\nsigned long\nsl\nUSHORT\nus\nuint64_t\nu64\nsigned\ns\nWORD\nw\nchar8_t\nc8\nunsigned long long int\nulli\nDWORD\ndw\nchar16_t\nc16\nunsigned long long\null\nDWORD32\ndw32\nchar32_t\nc32\nunsigned long int\nuli\nDWORD64\ndw64\nfloat\nf\nunsigned long\nul\nLONG\nl\ndouble\nd\nunsigned short int\nusi\nULONG\nul\nchar\nc\nunsigned short\nus\nULONG32\nul32\nbool\nb\nunsigned int\nui\nULONG64\nul64\n_Bool\nb\nunsigned char\nuc\nULONGLONG\null\nint\ni\nunsigned\nu\nHANDLE\nh\nsize_t\nn\nlong long int\nlli\nINT\ni\nshort\ns\nlong double\nld\nINT8\ni8\nsigned\ni\nlong long\nll\nINT16\ni16\nunsigned\nu\nlong int\nli\nINT32\ni32\nlong\nl\nlong\nl\nINT64\ni64\nlong long\nll\nptrdiff_t\np\nUINT\nui\nunsigned long\nul\nvoid\nnone\nUINT8\nu8\nlong double\nld\nUINT16\nu16\nptrdiff_t\np\nUINT32\nu32\nwchar_t\nwc\nUINT64\nu64\nshort int\nsi\nPVOID\np\nshort\ns\nThere are more trivial options for Hungarian Notation:\nHungarianNotation.General.*\nOptions are not belonging to any specific Decl.\nHungarianNotation.CString.*\nOptions for NULL-terminated string.\nHungarianNotation.DerivedType.*\nOptions for derived types.\nHungarianNotation.PrimitiveType.*\nOptions for primitive types.\nHungarianNotation.UserDefinedType.*\nOptions for user-defined types.\n\nOptions for Hungarian Notation\nHungarianNotation.General.TreatStructAsClass\nHungarianNotation.DerivedType.Array\nHungarianNotation.DerivedType.Pointer\nHungarianNotation.DerivedType.FunctionPointer\nHungarianNotation.CString.CharPointer\nHungarianNotation.CString.CharArray\nHungarianNotation.CString.WideCharPointer\nHungarianNotation.CString.WideCharArray\nHungarianNotation.PrimitiveType.*\nHungarianNotation.UserDefinedType.*\nHungarianNotation.General.TreatStructAsClass\nWhen defined, the check will treat naming of struct as a class.\nThe default value is\nfalse\n.\nHungarianNotation.DerivedType.Array\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\na\n.\nHungarianNotation.DerivedType.Pointer\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\np\n.\nHungarianNotation.DerivedType.FunctionPointer\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\nfn\n.\nBefore:\n// Array\nint\nDataArray\n[\n2\n]\n=\n{\n0\n};\n// Pointer\nvoid\n*\nDataBuffer\n=\nNULL\n;\n// FunctionPointer\ntypedef\nvoid\n(\n*\nFUNC_PTR\n)();\nFUNC_PTR\nFuncPtr\n=\nNULL\n;\nAfter:\n// Array\nint\naDataArray\n[\n2\n]\n=\n{\n0\n};\n// Pointer\nvoid\n*\npDataBuffer\n=\nNULL\n;\n// FunctionPointer\ntypedef\nvoid\n(\n*\nFUNC_PTR\n)();\nFUNC_PTR\nfnFuncPtr\n=\nNULL\n;\nHungarianNotation.CString.CharPointer\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\nsz\n.\nHungarianNotation.CString.CharArray\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\nsz\n.\nHungarianNotation.CString.WideCharPointer\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\nwsz\n.\nHungarianNotation.CString.WideCharArray\nWhen defined, the check will ensure variable name will add the prefix with\nthe given string. The default prefix is\nwsz\n.\nBefore:\n// CharPointer\nconst\nchar\n*\nNamePtr\n=\n\"Name\"\n;\n// CharArray\nconst\nchar\nNameArray\n[]\n=\n\"Name\"\n;\n// WideCharPointer\nconst\nwchar_t\n*\nWideNamePtr\n=\nL\n\"Name\"\n;\n// WideCharArray\nconst\nwchar_t\nWideNameArray\n[]\n=\nL\n\"Name\"\n;\nAfter:\n// CharPointer\nconst\nchar\n*\nszNamePtr\n=\n\"Name\"\n;\n// CharArray\nconst\nchar\nszNameArray\n[]\n=\n\"Name\"\n;\n// WideCharPointer\nconst\nwchar_t\n*\nwszWideNamePtr\n=\nL\n\"Name\"\n;\n// WideCharArray\nconst\nwchar_t\nwszWideNameArray\n[]\n=\nL\n\"Name\"\n;\nHungarianNotation.PrimitiveType.*\nWhen defined, the check will ensure variable name of involved primitive\ntypes will add the prefix with the given string. The default prefixes are\ndefined in the default mapping table.\nHungarianNotation.UserDefinedType.*\nWhen defined, the check will ensure variable name of involved primitive\ntypes will add the prefix with the given string. The default prefixes are\ndefined in the default mapping table.\nBefore:\nint8_t\nValueI8\n=\n0\n;\nint16_t\nValueI16\n=\n0\n;\nint32_t\nValueI32\n=\n0\n;\nint64_t\nValueI64\n=\n0\n;\nuint8_t\nValueU8\n=\n0\n;\nuint16_t\nValueU16\n=\n0\n;\nuint32_t\nValueU32\n=\n0\n;\nuint64_t\nValueU64\n=\n0\n;\nfloat\nValueFloat\n=\n0.0\n;\ndouble\nValueDouble\n=\n0.0\n;\nULONG\nValueUlong\n=\n0\n;\nDWORD\nValueDword\n=\n0\n;\nAfter:\nint8_t\ni8ValueI8\n=\n0\n;\nint16_t\ni16ValueI16\n=\n0\n;\nint32_t\ni32ValueI32\n=\n0\n;\nint64_t\ni64ValueI64\n=\n0\n;\nuint8_t\nu8ValueU8\n=\n0\n;\nuint16_t\nu16ValueU16\n=\n0\n;\nuint32_t\nu32ValueU32\n=\n0\n;\nuint64_t\nu64ValueU64\n=\n0\n;\nfloat\nfValueFloat\n=\n0.0\n;\ndouble\ndValueDouble\n=\n0.0\n;\nULONG\nulValueUlong\n=\n0\n;\nDWORD\ndwValueDword\n=\n0\n;"
    }
}