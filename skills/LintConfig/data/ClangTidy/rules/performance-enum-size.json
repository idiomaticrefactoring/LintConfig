{
    "performance-enum-size": {
        "description": "Description\n\nRecommends the smallest possible underlying type for an\nenum\nor\nenum\nclass based on the range of its enumerators. Analyzes the values of the\nenumerators in an\nenum\nor\nenum\nclass, including signed values, to\nrecommend the smallest possible underlying type that can represent all the\nvalues of the\nenum\n. The suggested underlying types are the integral types\nstd::uint8_t\n,\nstd::uint16_t\n, and\nstd::uint32_t\nfor unsigned types,\nand\nstd::int8_t\n,\nstd::int16_t\n, and\nstd::int32_t\nfor signed types.\nUsing the suggested underlying types can help reduce the memory footprint of\nthe program and improve performance in some cases.\n\nFor example:\n\n// BEFORE\nenum\nColor\n{\nRED\n=\n-1\n,\nGREEN\n=\n0\n,\nBLUE\n=\n1\n};\nstd\n::\noptional\n<\nColor\n>\ncolor_opt\n;\n\nThe\nColor\nenum\nuses the default underlying type, which is\nint\nin this\ncase, and its enumerators have values of -1, 0, and 1. Additionally, the\nstd::optional<Color>\nobject uses 8 bytes due to padding (platform\ndependent).\n\n// AFTER\nenum\nColor\n:\nstd\n::\nint8_t\n{\nRED\n=\n-1\n,\nGREEN\n=\n0\n,\nBLUE\n=\n1\n}\nstd\n::\noptional\n<\nColor\n>\ncolor_opt\n;\n\nIn the revised version of the\nColor\nenum\n, the underlying type has been\nchanged to\nstd::int8_t\n. The enumerator\nRED\nhas a value of -1, which can\nbe represented by a signed 8-bit integer.\n\nBy using a smaller underlying type, the memory footprint of the\nColor\nenum\nis reduced from 4 bytes to 1 byte. The revised version of the\nstd::optional<Color>\nobject would only require 2 bytes (due to lack of\npadding), since it contains a single byte for the\nColor\nenum\nand a single\nbyte for the\nbool\nflag that indicates whether the optional value is set.\n\nReducing the memory footprint of an\nenum\ncan have significant benefits in\nterms of memory usage and cache performance. However, itâ€™s important to\nconsider the trade-offs and potential impact on code readability and\nmaintainability.\n\nEnums without enumerators (empty) are excluded from analysis.\n\nRequires C++11 or above.\nDoes not provide auto-fixes.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nEnumIgnoreList\nOption is used to ignore certain enum types. It accepts a\nsemicolon-separated list of (fully qualified) enum type names or regular\nexpressions that match the enum type names. The default value is an empty\nstring, which means no enums will be ignored."
    }
}