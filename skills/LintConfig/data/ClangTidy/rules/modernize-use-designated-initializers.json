{
    "modernize-use-designated-initializers": {
        "description": "Description\n\nFinds initializer lists for aggregate types which could be written as\ndesignated initializers instead.\n\nWith plain initializer lists, it is very easy to introduce bugs when adding new\nfields in the middle of a struct or class type. The same confusion might arise\nwhen changing the order of fields.\n\nC++20 supports the designated initializer syntax for aggregate types. By\napplying it, we can always be sure that aggregates are constructed correctly,\nbecause every variable being initialized is referenced by its name.\n\nExample:\n\nstruct\nS\n{\nint\ni\n,\nj\n;\n};\n\nis an aggregate type that should be initialized as\n\nS\ns\n{\n.\ni\n=\n1\n,\n.\nj\n=\n2\n};\n\ninstead of\n\nS\ns\n{\n1\n,\n2\n};\n\nwhich could easily become an issue when\ni\nand\nj\nare swapped in the\ndeclaration of\nS\n.\n\nEven when compiling in a language version older than C++20, depending on your\ncompiler, designated initializers are potentially supported. Therefore, the\ncheck is by default restricted to C99/C++20 and above. Check out the options\n-Wc99-designator\nto get support for mixed designators in initializer list\nin C and\n-Wc++20-designator\nfor support of designated initializers in older\nC++ language modes.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nIgnoreMacros\nThe value\nfalse\nspecifies that components of initializer lists expanded from\nmacros are not checked. The default value is\ntrue\n.\nIgnoreSingleElementAggregates\nThe value\nfalse\nspecifies that even initializers for aggregate types with\nonly a single element should be checked. The default value is\ntrue\n.\nstd::array\ninitializations are always excluded, as the type is a\nstandard library abstraction and not intended to be initialized with\ndesignated initializers.\nRestrictToPODTypes\nThe value\ntrue\nspecifies that only Plain Old Data (POD) types shall be\nchecked. This makes the check applicable to even older C++ standards. The\ndefault value is\nfalse\n.\nStrictCStandardCompliance\nWhen set to\nfalse\n, the check will not restrict itself to C99 and above.\nThe default value is\ntrue\n.\nStrictCppStandardCompliance\nWhen set to\nfalse\n, the check will not restrict itself to C++20 and above.\nThe default value is\ntrue\n."
    }
}