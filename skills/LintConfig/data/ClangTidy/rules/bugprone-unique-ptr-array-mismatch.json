{
    "bugprone-unique-ptr-array-mismatch": {
        "description": "Description\n\nFinds initializations of C++ unique pointers to non-array type that are\ninitialized with an array.\n\nIf a pointer\nstd::unique_ptr<T>\nis initialized with a new-expression\nnew\nT[]\nthe memory is not deallocated correctly. A plain\ndelete\nis used\nin this case to deallocate the target memory. Instead a\ndelete[]\ncall is\nneeded. A\nstd::unique_ptr<T[]>\nuses the correct delete operator. The check\ndoes not emit warning if an\nunique_ptr\nwith user-specified deleter type is\nused.\n\nThe check offers replacement of\nunique_ptr<T>\nto\nunique_ptr<T[]>\nif it\nis used at a single variable declaration (one variable in one statement).\n\nExample:\n\nstd\n::\nunique_ptr\n<\nFoo\n>\nx\n(\nnew\nFoo\n[\n10\n]);\n// -> std::unique_ptr<Foo[]> x(new Foo[10]);\n//                     ^ warning: unique pointer to non-array is initialized with array\nstd\n::\nunique_ptr\n<\nFoo\n>\nx1\n(\nnew\nFoo\n),\nx2\n(\nnew\nFoo\n[\n10\n]);\n// no replacement\n//                                   ^ warning: unique pointer to non-array is initialized with array\nD\nd\n;\nstd\n::\nunique_ptr\n<\nFoo\n,\nD\n>\nx3\n(\nnew\nFoo\n[\n10\n],\nd\n);\n// no warning (custom deleter used)\nstruct\nS\n{\nstd\n::\nunique_ptr\n<\nFoo\n>\nx\n(\nnew\nFoo\n[\n10\n]);\n// no replacement in this case\n//                     ^ warning: unique pointer to non-array is initialized with array\n};\n\nThis check partially covers the CERT C++ Coding Standard rule\nMEM51-CPP. Properly deallocate dynamically allocated resources\nHowever, only the\nstd::unique_ptr\ncase is detected by this check.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}