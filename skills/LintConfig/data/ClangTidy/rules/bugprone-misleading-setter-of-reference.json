{
    "bugprone-misleading-setter-of-reference": {
        "description": "Description\n\nFinds setter-like member functions that take a pointer parameter and set a\nreference member of the same class with the pointed value.\n\nThe check detects member functions that take a single pointer parameter,\nand contain a single expression statement that dereferences the parameter and\nassigns the result to a data member with a reference type.\n\nThe fact that a setter function takes a pointer might cause the belief that an\ninternal reference (if it would be a pointer) is changed instead of the\npointed-to (or referenced) value.\n\nExample:\n\nclass\nMyClass\n{\nint\n&\nInternalRef\n;\n// non-const reference member\npublic\n:\nMyClass\n(\nint\n&\nValue\n)\n:\nInternalRef\n(\nValue\n)\n{}\n// Warning: This setter could lead to unintended behaviour.\nvoid\nsetRef\n(\nint\n*\nValue\n)\n{\nInternalRef\n=\n*\nValue\n;\n// This assigns to the referenced value, not changing what InternalRef references.\n}\n};\nint\nmain\n()\n{\nint\nValue1\n=\n42\n;\nint\nValue2\n=\n100\n;\nMyClass\nX\n(\nValue1\n);\n// This might look like it changes what InternalRef references to,\n// but it actually modifies Value1 to be 100.\nX\n.\nsetRef\n(\n&\nValue2\n);\n}\n\nPossible fixes:\nChange the parameter type of the “set” function to non-pointer type (for\nexample, a const reference).\nChange the type of the member variable to a pointer and in the “set”\nfunction assign a value to the pointer (without dereference).",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}