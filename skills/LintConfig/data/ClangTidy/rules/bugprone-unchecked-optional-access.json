{
    "bugprone-unchecked-optional-access": {
        "description": "Description\n\nNote\n: This check uses a flow-sensitive static analysis to produce its\nresults. Therefore, it may be more resource intensive (RAM, CPU) than the\naverage clang-tidy check.\n\nThis check identifies unsafe accesses to values contained in\nstd::optional<T>\n,\nabsl::optional<T>\n,\nbase::Optional<T>\n,\nfolly::Optional<T>\n,\nbsl::optional\n, or\nBloombergLP::bdlb::NullableValue\nobjects. Below we will refer to all these\ntypes collectively as\noptional<T>\n.\n\nAn access to the value of an\noptional<T>\noccurs when one of its\nvalue\n,\noperator*\n, or\noperator->\nmember functions is invoked.  To align with\ncommon misconceptions, the check considers these member functions as\nequivalent, even though there are subtle differences related to exceptions\nversus undefined behavior. See\nAdditional notes\n, below, for more information\non this topic.\n\nAn access to the value of an\noptional<T>\nis considered safe if and only if\ncode in the local scope (for example, a function body) ensures that the\noptional<T>\nhas a value in all possible execution paths that can reach the\naccess. That should happen either through an explicit check, using the\noptional<T>::has_value\nmember function, or by constructing the\noptional<T>\nin a way that shows that it unambiguously holds a value (e.g\nusing\nstd::make_optional\nwhich always returns a populated\nstd::optional<T>\n).\n\nBelow we list some examples, starting with unsafe optional access patterns,\nfollowed by safe access patterns.\n\nUnsafe access patterns\nAccess the value without checking if it exists\nThe check flags accesses to the value that are not locally guarded by\nexistence check:\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nuse\n(\n*\nopt\n);\n// unsafe: it is unclear whether `opt` has a value.\n}\nAccess the value in the wrong branch\nThe check is aware of the state of an optional object in different\nbranches of the code. For example:\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nif\n(\nopt\n.\nhas_value\n())\n{\n}\nelse\n{\nuse\n(\nopt\n.\nvalue\n());\n// unsafe: it is clear that `opt` does *not* have a value.\n}\n}\nAssume a function result to be stable\nThe check is aware that function results might not be stable. That is,\nconsecutive calls to the same function might return different values.\nFor example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nfoo\n.\ntake\n().\nhas_value\n())\n{\nuse\n(\n*\nfoo\n.\ntake\n());\n// unsafe: it is unclear whether `foo.take()` has a value.\n}\n}\nException: accessor methods\nThe check assumes\naccessor\nmethods of a class are stable, with a heuristic to\ndetermine which methods are accessors. Specifically, parameter-free\nconst\nmethods and smart pointer-like APIs (non\nconst\noverloads of\n*\nwhen\nthere is a parallel\nconst\noverload) are treated as accessors. Note that\nthis is not guaranteed to be safe – but, it is widely used (safely) in\npractice. Calls to non\nconst\nmethods are assumed to modify the state of\nthe object and affect the stability of earlier accessor calls.\nRely on invariants of uncommon APIs\nThe check is unaware of invariants of uncommon APIs. For example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nfoo\n.\nHasProperty\n(\n\"bar\"\n))\n{\nuse\n(\n*\nfoo\n.\nGetProperty\n(\n\"bar\"\n));\n// unsafe: it is unclear whether `foo.GetProperty(\"bar\")` has a value.\n}\n}\nCheck if a value exists, then pass the optional to another function\nThe check relies on local reasoning. The check and value access must\nboth happen in the same function. An access is considered unsafe even if\nthe caller of the function performing the access ensures that the\noptional has a value. For example:\nvoid\ng\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nuse\n(\n*\nopt\n);\n// unsafe: it is unclear whether `opt` has a value.\n}\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nif\n(\nopt\n.\nhas_value\n())\n{\ng\n(\nopt\n);\n}\n}\n\nSafe access patterns\nCheck if a value exists, then access the value\nThe check recognizes all straightforward ways for checking if a value\nexists and accessing the value contained in an optional object. For\nexample:\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nif\n(\nopt\n.\nhas_value\n())\n{\nuse\n(\n*\nopt\n);\n}\n}\nCheck if a value exists, then access the value from a copy\nThe criteria that the check uses is semantic, not syntactic. It\nrecognizes when a copy of the optional object being accessed is known to\nhave a value. For example:\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt1\n)\n{\nif\n(\nopt1\n.\nhas_value\n())\n{\nstd\n::\noptional\n<\nint\n>\nopt2\n=\nopt1\n;\nuse\n(\n*\nopt2\n);\n}\n}\nEnsure that a value exists using common macros\nThe check is aware of common macros like\nCHECK\nand\nDCHECK\n. Those can be\nused to ensure that an optional object has a value. For example:\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nDCHECK\n(\nopt\n.\nhas_value\n());\nuse\n(\n*\nopt\n);\n}\nEnsure that a value exists, then access the value in a correlated branch\nThe check is aware of correlated branches in the code and can figure out\nwhen an optional object is ensured to have a value on all execution\npaths that lead to an access. For example:\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nbool\nsafe\n=\nfalse\n;\nif\n(\nopt\n.\nhas_value\n()\n&&\nSomeOtherCondition\n())\n{\nsafe\n=\ntrue\n;\n}\n// ... more code...\nif\n(\nsafe\n)\n{\nuse\n(\n*\nopt\n);\n}\n}\n\nStabilize function results\nFunction results are not assumed to be stable across calls, except for\nconst accessor methods. For more complex accessors (non-const, or depend on\nmultiple params) it is best to store the result of the function call in a\nlocal variable and use that variable to access the value. For example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nconst\nauto\n&\nfoo_opt\n=\nfoo\n.\ntake\n();\nfoo_opt\n.\nhas_value\n())\n{\nuse\n(\n*\nfoo_opt\n);\n}\n}\n\nDo not rely on uncommon-API invariants\nWhen uncommon APIs guarantee that an optional has contents, do not rely on it\n– instead, check explicitly that the optional object has a value. For example:\nvoid\nf\n(\nFoo\nfoo\n)\n{\nif\n(\nconst\nauto\n&\nproperty\n=\nfoo\n.\nGetProperty\n(\n\"bar\"\n))\n{\nuse\n(\n*\nproperty\n);\n}\n}\ninstead of the\nHasProperty\n,\nGetProperty\npairing we saw above.\n\nDo not rely on caller-performed checks\nIf you know that all of a function’s callers have checked that an optional\nargument has a value, either change the function to take the value directly or\ncheck the optional again in the local scope of the callee. For example:\nvoid\ng\n(\nint\nval\n)\n{\nuse\n(\nval\n);\n}\nvoid\nf\n(\nstd\n::\noptional\n<\nint\n>\nopt\n)\n{\nif\n(\nopt\n.\nhas_value\n())\n{\ng\n(\n*\nopt\n);\n}\n}\nand\nstruct\nS\n{\nstd\n::\noptional\n<\nint\n>\nopt\n;\nint\nx\n;\n};\nvoid\ng\n(\nconst\nS\n&\ns\n)\n{\nif\n(\ns\n.\nopt\n.\nhas_value\n()\n&&\ns\n.\nx\n>\n10\n)\n{\nuse\n(\n*\ns\n.\nopt\n);\n}\nvoid\nf\n(\nS\ns\n)\n{\nif\n(\ns\n.\nopt\n.\nhas_value\n())\n{\ng\n(\ns\n);\n}\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nAdditional notes\nAliases created via\nusing\ndeclarations\nThe check is aware of aliases of optional types that are created via\nusing\ndeclarations. For example:\nusing\nOptionalInt\n=\nstd\n::\noptional\n<\nint\n>\n;\nvoid\nf\n(\nOptionalInt\nopt\n)\n{\nuse\n(\nopt\n.\nvalue\n());\n// unsafe: it is unclear whether `opt` has a value.\n}\nLambdas\nThe check does not currently report unsafe optional accesses in lambdas.\nA future version will expand the scope to lambdas, following the rules\noutlined above. It is best to follow the same principles when using\noptionals in lambdas.\nAccess with\noperator*()\nvs.\nvalue()\nGiven that\nvalue()\nhas well-defined behavior (either throwing an exception\nor terminating the program), why treat it the same as\noperator*()\nwhich\ncauses undefined behavior (UB)? That is, why is it considered unsafe to access\nan optional with\nvalue()\n, if it’s not provably populated with a value?  For\nthat matter, why is\nCHECK()\nfollowed by\noperator*()\nany better than\nvalue()\n, given that they are semantically equivalent (on configurations\nthat disable exceptions)?\nThe answer is that we assume most users do not realize the difference between\nvalue()\nand\noperator*()\n. Shifting to\noperator*()\nand some form of\nexplicit value-presence check or explicit program termination has two\nadvantages:\nReadability. The check, and any potential side effects like program\nshutdown, are very clear in the code. Separating access from checks can\nactually make the checks more obvious.\nPerformance. A single check can cover many or even all accesses within\nscope. This gives the user the best of both worlds – the safety of a\ndynamic check, but without incurring redundant costs.\nOptions\nIgnoreSmartPointerDereference\nIf set to\ntrue\n, the check ignores optionals that\nare reached through overloaded smart-pointer-like dereference (\noperator*\n,\noperator->\n) on classes other than the optional type itself. This helps\navoid false positives where the analysis cannot equate results across such\ncalls. This does not cover access through\noperator[]\n. Default is\nfalse\n.\nIgnoreValueCalls\nIf set to\ntrue\n, the check does not diagnose calls\nto\noptional::value()\n. Diagnostics for\noperator*()\nand\noperator->()\nremain enabled. This is useful for codebases that\nintentionally rely on\nvalue()\nfor defined, guarded access while still\nflagging UB-prone operator dereferences. Default is\nfalse\n."
    }
}