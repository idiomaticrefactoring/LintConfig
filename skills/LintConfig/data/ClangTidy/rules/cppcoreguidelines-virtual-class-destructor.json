{
    "cppcoreguidelines-virtual-class-destructor": {
        "description": "Description\n\nFinds virtual classes whose destructor is neither public and virtual\nnor protected and non-virtual. A virtual classâ€™s destructor should be specified\nin one of these ways to prevent undefined behavior.\n\nThis check implements\nC.35\nfrom the C++ Core Guidelines.\n\nNote that this check will diagnose a class with a virtual method regardless of\nwhether the class is used as a base class or not.\n\nFixes are available for user-declared and implicit destructors that are either\npublic and non-virtual or protected and virtual. No fixes are offered for\nprivate destructors. There, the decision whether to make them private and\nvirtual or protected and non-virtual depends on the use case and is thus left\nto the user.\n\nExample\nFor example, the following classes/structs get flagged by the check since they\nviolate guideline\nC.35\n:\nstruct\nFoo\n{\n// NOK, protected destructor should not be virtual\nvirtual\nvoid\nf\n();\nprotected\n:\nvirtual\n~\nFoo\n(){}\n};\nclass\nBar\n{\n// NOK, public destructor should be virtual\nvirtual\nvoid\nf\n();\npublic\n:\n~\nBar\n(){}\n};\nThis would be rewritten to look like this:\nstruct\nFoo\n{\n// OK, destructor is not virtual anymore\nvirtual\nvoid\nf\n();\nprotected\n:\n~\nFoo\n(){}\n};\nclass\nBar\n{\n// OK, destructor is now virtual\nvirtual\nvoid\nf\n();\npublic\n:\nvirtual\n~\nBar\n(){}\n};",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}