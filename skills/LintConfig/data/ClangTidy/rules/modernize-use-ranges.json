{
    "modernize-use-ranges": {
        "description": "Description\n\nDetects calls to standard library iterator algorithms that could be replaced\nwith a ranges version instead.\n\nExample\nauto\nIter1\n=\nstd\n::\nfind\n(\nItems\n.\nbegin\n(),\nItems\n.\nend\n(),\n0\n);\nauto\nAreSame\n=\nstd\n::\nequal\n(\nItems1\n.\ncbegin\n(),\nItems1\n.\ncend\n(),\nstd\n::\nbegin\n(\nItems2\n),\nstd\n::\nend\n(\nItems2\n));\nTransforms to:\nauto\nIter1\n=\nstd\n::\nranges\n::\nfind\n(\nItems\n,\n0\n);\nauto\nAreSame\n=\nstd\n::\nranges\n::\nequal\n(\nItems1\n,\nItems2\n);\n\nSupported algorithms\nCalls to the following std library algorithms are checked:\nstd::adjacent_find\n,\nstd::all_of\n,\nstd::any_of\n,\nstd::binary_search\n,\nstd::copy_backward\n,\nstd::copy_if\n,\nstd::copy\n,\nstd::destroy\n,\nstd::equal_range\n,\nstd::equal\n,\nstd::fill\n,\nstd::find_end\n,\nstd::find_if_not\n,\nstd::find_if\n,\nstd::find\n,\nstd::for_each\n,\nstd::generate\n,\nstd::includes\n,\nstd::inplace_merge\n,\nstd::iota\n,\nstd::is_heap_until\n,\nstd::is_heap\n,\nstd::is_partitioned\n,\nstd::is_permutation\n,\nstd::is_sorted_until\n,\nstd::is_sorted\n,\nstd::lexicographical_compare\n,\nstd::lower_bound\n,\nstd::make_heap\n,\nstd::max_element\n,\nstd::merge\n,\nstd::min_element\n,\nstd::minmax_element\n,\nstd::mismatch\n,\nstd::move_backward\n,\nstd::move\n,\nstd::next_permutation\n,\nstd::none_of\n,\nstd::partial_sort_copy\n,\nstd::partition_copy\n,\nstd::partition_point\n,\nstd::partition\n,\nstd::pop_heap\n,\nstd::prev_permutation\n,\nstd::push_heap\n,\nstd::remove_copy_if\n,\nstd::remove_copy\n,\nstd::remove\n,\nstd::remove_if\n,\nstd::replace_if\n,\nstd::replace\n,\nstd::reverse_copy\n,\nstd::reverse\n,\nstd::rotate\n,\nstd::rotate_copy\n,\nstd::sample\n,\nstd::search\n,\nstd::set_difference\n,\nstd::set_intersection\n,\nstd::set_symmetric_difference\n,\nstd::set_union\n,\nstd::shift_left\n,\nstd::shift_right\n,\nstd::sort_heap\n,\nstd::sort\n,\nstd::stable_partition\n,\nstd::stable_sort\n,\nstd::transform\n,\nstd::uninitialized_copy\n,\nstd::uninitialized_default_construct\n,\nstd::uninitialized_fill\n,\nstd::uninitialized_move\n,\nstd::uninitialized_value_construct\n,\nstd::unique_copy\n,\nstd::unique\n,\nstd::upper_bound\n.\nNote: some range algorithms for\nvector<bool>\nrequire C++23 because it uses\nproxy iterators.\n\nReverse Iteration\nIf calls are made using reverse iterators on containers, The code will be\nfixed using the\nstd::views::reverse\nadaptor.\nauto\nAreSame\n=\nstd\n::\nequal\n(\nItems1\n.\nrbegin\n(),\nItems1\n.\nrend\n(),\nstd\n::\ncrbegin\n(\nItems2\n),\nstd\n::\ncrend\n(\nItems2\n));\nTransforms to:\nauto\nAreSame\n=\nstd\n::\nranges\n::\nequal\n(\nstd\n::\nviews\n::\nreverse\n(\nItems1\n),\nstd\n::\nviews\n::\nreverse\n(\nItems2\n));",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nIncludeStyle\nA string specifying which include-style is used,\nllvm\nor\ngoogle\n. Default\nis\nllvm\n.\nUseReversePipe\nWhen\ntrue\n(default\nfalse\n), fixes which involve reverse ranges will use the\npipe adaptor syntax instead of the function syntax.\nstd\n::\nfind\n(\nItems\n.\nrbegin\n(),\nItems\n.\nrend\n(),\n0\n);\nTransforms to:\nstd\n::\nranges\n::\nfind\n(\nItems\n|\nstd\n::\nviews\n::\nreverse\n,\n0\n);"
    }
}