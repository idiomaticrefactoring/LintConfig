{
    "bugprone-nondeterministic-pointer-iteration-order": {
        "description": "Description\n\nFinds nondeterministic usages of pointers in unordered containers.\n\nOne canonical example is iteration across a container of pointers.\n\n{\nint\na\n=\n1\n,\nb\n=\n2\n;\nstd\n::\nunordered_set\n<\nint\n*>\nUnorderedPtrSet\n=\n{\n&\na\n,\n&\nb\n};\nfor\n(\nauto\ni\n:\nUnorderedPtrSet\n)\nf\n(\ni\n);\n}\n\nAnother such example is sorting a container of pointers.\n\n{\nint\na\n=\n1\n,\nb\n=\n2\n;\nstd\n::\nvector\n<\nint\n*>\nVectorOfPtr\n=\n{\n&\na\n,\n&\nb\n};\nstd\n::\nsort\n(\nVectorOfPtr\n.\nbegin\n(),\nVectorOfPtr\n.\nend\n());\n}\n\nIteration of a containers of pointers may present the order of different\npointers differently across different runs of a program. In some cases this\nmay be acceptable behavior, in others this may be unexpected behavior. This\ncheck is advisory for this reason.\n\nThis check only detects range-based for loops over unordered sets and maps. It\nalso detects calls sorting-like algorithms on containers holding pointers.\nOther similar usages will not be found and are false negatives.\n\nLimitations\nThis check currently does not check if a nondeterministic iteration order is\nlikely to be a mistake, and instead marks all such iterations as bugprone.\nstd::reference_wrapper is not considered yet.\nOnly for loops are considered, other iterators can be included in\nimprovements.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}