{
    "bugprone-unhandled-self-assignment": {
        "description": "Description\n\ncert-oop54-cpp\nredirects here as an alias for this check. For the CERT alias,\nthe\nWarnOnlyIfThisHasSuspiciousField\noption is set to\nfalse\n.\n\nFinds user-defined copy assignment operators which do not protect the code\nagainst self-assignment either by checking self-assignment explicitly or\nusing the copy-and-swap or the copy-and-move method.\n\nBy default, this check searches only those classes which have any pointer or C\narray field to avoid false positives. In case of a pointer or a C array, it’s\nlikely that self-copy assignment breaks the object if the copy assignment\noperator was not written with care.\n\nSee also:\nOOP54-CPP. Gracefully handle self-copy assignment\n\nA copy assignment operator must prevent that self-copy assignment ruins the\nobject state. A typical use case is when the class has a pointer field\nand the copy assignment operator first releases the pointed object and\nthen tries to assign it:\n\nclass\nT\n{\nint\n*\np\n;\npublic\n:\nT\n(\nconst\nT\n&\nrhs\n)\n:\np\n(\nrhs\n.\np\n?\nnew\nint\n(\n*\nrhs\n.\np\n)\n:\nnullptr\n)\n{}\n~\nT\n()\n{\ndelete\np\n;\n}\n// ...\nT\n&\noperator\n=\n(\nconst\nT\n&\nrhs\n)\n{\ndelete\np\n;\np\n=\nnew\nint\n(\n*\nrhs\n.\np\n);\nreturn\n*\nthis\n;\n}\n};\n\nThere are two common C++ patterns to avoid this problem. The first is\nthe self-assignment check:\n\nclass\nT\n{\nint\n*\np\n;\npublic\n:\nT\n(\nconst\nT\n&\nrhs\n)\n:\np\n(\nrhs\n.\np\n?\nnew\nint\n(\n*\nrhs\n.\np\n)\n:\nnullptr\n)\n{}\n~\nT\n()\n{\ndelete\np\n;\n}\n// ...\nT\n&\noperator\n=\n(\nconst\nT\n&\nrhs\n)\n{\nif\n(\nthis\n==\n&\nrhs\n)\nreturn\n*\nthis\n;\ndelete\np\n;\np\n=\nnew\nint\n(\n*\nrhs\n.\np\n);\nreturn\n*\nthis\n;\n}\n};\n\nThe second one is the copy-and-swap method when we create a temporary copy\n(using the copy constructor) and then swap this temporary object with\nthis\n:\n\nclass\nT\n{\nint\n*\np\n;\npublic\n:\nT\n(\nconst\nT\n&\nrhs\n)\n:\np\n(\nrhs\n.\np\n?\nnew\nint\n(\n*\nrhs\n.\np\n)\n:\nnullptr\n)\n{}\n~\nT\n()\n{\ndelete\np\n;\n}\n// ...\nvoid\nswap\n(\nT\n&\nrhs\n)\n{\nusing\nstd\n::\nswap\n;\nswap\n(\np\n,\nrhs\n.\np\n);\n}\nT\n&\noperator\n=\n(\nconst\nT\n&\nrhs\n)\n{\nT\n(\nrhs\n).\nswap\n(\n*\nthis\n);\nreturn\n*\nthis\n;\n}\n};\n\nThere is a third pattern which is less common. Let’s call it the copy-and-move\nmethod when we create a temporary copy (using the copy constructor) and then move\nthis temporary object into\nthis\n(needs a move assignment operator):\n\nclass\nT\n{\nint\n*\np\n;\npublic\n:\nT\n(\nconst\nT\n&\nrhs\n)\n:\np\n(\nrhs\n.\np\n?\nnew\nint\n(\n*\nrhs\n.\np\n)\n:\nnullptr\n)\n{}\n~\nT\n()\n{\ndelete\np\n;\n}\n// ...\nT\n&\noperator\n=\n(\nconst\nT\n&\nrhs\n)\n{\nT\nt\n=\nrhs\n;\n*\nthis\n=\nstd\n::\nmove\n(\nt\n);\nreturn\n*\nthis\n;\n}\nT\n&\noperator\n=\n(\nT\n&&\nrhs\n)\n{\np\n=\nrhs\n.\np\n;\nrhs\n.\np\n=\nnullptr\n;\nreturn\n*\nthis\n;\n}\n};",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nWarnOnlyIfThisHasSuspiciousField\nWhen\ntrue\n, the check will warn only if the container class of the copy\nassignment operator has any suspicious fields (pointer, C array and C++ smart\npointer).\nThis option is set to\ntrue\nby default."
    }
}