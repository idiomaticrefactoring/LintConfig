{
    "bugprone-branch-clone": {
        "description": "Description\n\nChecks for repeated branches in\nif/else\nif/else\nchains, consecutive\nrepeated branches in\nswitch\nstatements and identical true and false\nbranches in conditional operators.\n\nif\n(\ntest_value\n(\nx\n))\n{\ny\n++\n;\ndo_something\n(\nx\n,\ny\n);\n}\nelse\n{\ny\n++\n;\ndo_something\n(\nx\n,\ny\n);\n}\n\nIn this simple example (which could arise e.g. as a copy-paste error) the\nthen\nand\nelse\nbranches are identical and the code is equivalent the\nfollowing shorter and cleaner code:\n\ntest_value\n(\nx\n);\n// can be omitted unless it has side effects\ny\n++\n;\ndo_something\n(\nx\n,\ny\n);\n\nIf this is the intended behavior, then there is no reason to use a conditional\nstatement; otherwise the issue can be solved by fixing the branch that is\nhandled incorrectly.\n\nThe check detects repeated branches in longer\nif/else\nif/else\nchains\nwhere it would be even harder to notice the problem.\n\nThe check also detects repeated inner and outer\nif\nstatements that may\nbe a result of a copy-paste error. This check cannot currently detect\nidentical inner and outer\nif\nstatements if code is between the\nif\nconditions. An example is as follows.\n\nvoid\ntest_warn_inner_if_1\n(\nint\nx\n)\n{\nif\n(\nx\n==\n1\n)\n{\n// warns, if with identical inner if\nif\n(\nx\n==\n1\n)\n// inner if is here\n;\nif\n(\nx\n==\n1\n)\n{\n// does not warn, cannot detect\nint\ny\n=\nx\n;\nif\n(\nx\n==\n1\n)\n;\n}\n}\n\nIn\nswitch\nstatements the check only reports repeated branches when they are\nconsecutive, because it is relatively common that the\ncase:\nlabels have\nsome natural ordering and rearranging them would decrease the readability of\nthe code. For example:\n\nswitch\n(\nch\n)\n{\ncase\n'a'\n:\nreturn\n10\n;\ncase\n'A'\n:\nreturn\n10\n;\ncase\n'b'\n:\nreturn\n11\n;\ncase\n'B'\n:\nreturn\n11\n;\ndefault\n:\nreturn\n10\n;\n}\n\nHere the check reports that the\n'a'\nand\n'A'\nbranches are identical\n(and that the\n'b'\nand\n'B'\nbranches are also identical), but does not\nreport that the\ndefault:\nbranch is also identical to the first two branches.\nIf this is indeed the correct behavior, then it could be implemented as:\n\nswitch\n(\nch\n)\n{\ncase\n'a'\n:\ncase\n'A'\n:\nreturn\n10\n;\ncase\n'b'\n:\ncase\n'B'\n:\nreturn\n11\n;\ndefault\n:\nreturn\n10\n;\n}\n\nHere the check does not warn for the repeated\nreturn\n10;\n, which is good if\nwe want to preserve that\n'a'\nis before\n'b'\nand\ndefault:\nis the last\nbranch.\n\nSwitch cases marked with the\n[[fallthrough]]\nattribute are ignored.\n\nFinally, the check also examines conditional operators and reports code like:\n\nreturn\ntest_value\n(\nx\n)\n?\nx\n:\nx\n;\n\nUnlike if statements, the check does not detect chains of conditional\noperators.\n\nNote: This check also reports situations where branches become identical only\nafter preprocessing.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}