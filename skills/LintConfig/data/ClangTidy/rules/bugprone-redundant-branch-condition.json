{
    "bugprone-redundant-branch-condition": {
        "description": "Description\n\nFinds condition variables in nested\nif\nstatements that were also checked in\nthe outer\nif\nstatement and were not changed.\n\nSimple example:\n\nbool\nonFire\n=\nisBurning\n();\nif\n(\nonFire\n)\n{\nif\n(\nonFire\n)\nscream\n();\n}\n\nHere\nonFire\nis checked both in the outer\nif\nand the inner\nif\nstatement without a possible change between the two checks. The check warns for\nthis code and suggests removal of the second checking of variable\nonFire\n.\n\nThe checker also detects redundant condition checks if the condition variable\nis an operand of a logical “and” (\n&&\n) or a logical “or” (\n||\n) operator:\n\nbool\nonFire\n=\nisBurning\n();\nif\n(\nonFire\n)\n{\nif\n(\nonFire\n&&\npeopleInTheBuilding\n>\n0\n)\nscream\n();\n}\n\nbool\nonFire\n=\nisBurning\n();\nif\n(\nonFire\n)\n{\nif\n(\nonFire\n||\nisCollapsing\n())\nscream\n();\n}\n\nIn the first case (logical “and”) the suggested fix is to remove the redundant\ncondition variable and keep the other side of the\n&&\n. In the second case\n(logical “or”) the whole\nif\nis removed similarly to the simple case on the\ntop.\n\nThe condition of the outer\nif\nstatement may also be a logical “and”\n(\n&&\n) expression:\n\nbool\nonFire\n=\nisBurning\n();\nif\n(\nonFire\n&&\nfireFighters\n<\n10\n)\n{\nif\n(\nsomeOtherCondition\n())\n{\nif\n(\nonFire\n)\nscream\n();\n}\n}\n\nThe error is also detected if both the outer statement is a logical “and”\n(\n&&\n) and the inner statement is a logical “and” (\n&&\n) or “or” (\n||\n).\nThe inner\nif\nstatement does not have to be a direct descendant of the outer\none.\n\nNo error is detected if the condition variable may have been changed between\nthe two checks:\n\nbool\nonFire\n=\nisBurning\n();\nif\n(\nonFire\n)\n{\ntryToExtinguish\n(\nonFire\n);\nif\n(\nonFire\n&&\npeopleInTheBuilding\n>\n0\n)\nscream\n();\n}\n\nEvery possible change is considered, thus if the condition variable is not\na local variable of the function, it is a volatile or it has an alias (pointer\nor reference) then no warning is issued.\n\nLimitations\nThe\nelse\nbranch is not checked currently for negated condition variable:\nbool\nonFire\n=\nisBurning\n();\nif\n(\nonFire\n)\n{\nscream\n();\n}\nelse\n{\nif\n(\n!\nonFire\n)\n{\ncontinueWork\n();\n}\n}\nThe checker currently only detects redundant checking of single condition\nvariables. More complex expressions are not checked:\nif\n(\npeopleInTheBuilding\n==\n1\n)\n{\nif\n(\npeopleInTheBuilding\n==\n1\n)\n{\ndoSomething\n();\n}\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}