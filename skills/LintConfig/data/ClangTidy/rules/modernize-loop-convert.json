{
    "modernize-loop-convert": {
        "description": "Description\n\nThis check converts\nfor(...;\n...;\n...)\nloops to use the new range-based\nloops in C++11.\n\nThree kinds of loops can be converted:\n\nLoops over statically allocated arrays.\nLoops over containers, using iterators.\nLoops over array-like containers, using\noperator[]\nand\nat()\n.\n\nMinConfidence option\nrisky\nIn loops where the container expression is more complex than just a\nreference to a declared expression (a variable, function, enum, etc.),\nand some part of it appears elsewhere in the loop, we lower our confidence\nin the transformation due to the increased risk of changing semantics.\nTransformations for these loops are marked as\nrisky\n, and thus will only\nbe converted if the minimum required confidence level is set to\nrisky\n.\nint\narr\n[\n10\n][\n20\n];\nint\nl\n=\n5\n;\nfor\n(\nint\nj\n=\n0\n;\nj\n<\n20\n;\n++\nj\n)\nint\nk\n=\narr\n[\nl\n][\nj\n]\n+\nl\n;\n// using l outside arr[l] is considered risky\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nobj\n.\ngetVector\n().\nsize\n();\n++\ni\n)\nobj\n.\nfoo\n(\n10\n);\n// using 'obj' is considered risky\nSee\nRange-based loops evaluate end() only once\nfor an example of an incorrect transformation when the minimum required confidence\nlevel is set to\nrisky\n.\nreasonable (Default)\nIf a loop calls\n.end()\nor\n.size()\nafter each iteration, the\ntransformation for that loop is marked as\nreasonable\n, and thus will\nbe converted if the required confidence level is set to\nreasonable\n(default) or lower.\n// using size() is considered reasonable\nfor\n(\nint\ni\n=\n0\n;\ni\n<\ncontainer\n.\nsize\n();\n++\ni\n)\ncout\n<<\ncontainer\n[\ni\n];\nsafe\nAny other loops that do not match the above criteria to be marked as\nrisky\nor\nreasonable\nare marked\nsafe\n, and thus will be converted\nif the required confidence level is set to\nsafe\nor lower.\nint\narr\n[]\n=\n{\n1\n,\n2\n,\n3\n};\nfor\n(\nint\ni\n=\n0\n;\ni\n<\n3\n;\n++\ni\n)\ncout\n<<\narr\n[\ni\n];\n\nExample\nOriginal:\nconst\nint\nN\n=\n5\n;\nint\narr\n[]\n=\n{\n1\n,\n2\n,\n3\n,\n4\n,\n5\n};\nvector\n<\nint\n>\nv\n;\nv\n.\npush_back\n(\n1\n);\nv\n.\npush_back\n(\n2\n);\nv\n.\npush_back\n(\n3\n);\n// safe conversion\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nN\n;\n++\ni\n)\ncout\n<<\narr\n[\ni\n];\n// reasonable conversion\nfor\n(\nvector\n<\nint\n>::\niterator\nit\n=\nv\n.\nbegin\n();\nit\n!=\nv\n.\nend\n();\n++\nit\n)\ncout\n<<\n*\nit\n;\n// reasonable conversion\nfor\n(\nvector\n<\nint\n>::\niterator\nit\n=\nbegin\n(\nv\n);\nit\n!=\nend\n(\nv\n);\n++\nit\n)\ncout\n<<\n*\nit\n;\n// reasonable conversion\nfor\n(\nvector\n<\nint\n>::\niterator\nit\n=\nstd\n::\nbegin\n(\nv\n);\nit\n!=\nstd\n::\nend\n(\nv\n);\n++\nit\n)\ncout\n<<\n*\nit\n;\n// reasonable conversion\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nv\n.\nsize\n();\n++\ni\n)\ncout\n<<\nv\n[\ni\n];\n// reasonable conversion\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nsize\n(\nv\n);\n++\ni\n)\ncout\n<<\nv\n[\ni\n];\nAfter applying the check with minimum confidence level set to\nreasonable\n(default):\nconst\nint\nN\n=\n5\n;\nint\narr\n[]\n=\n{\n1\n,\n2\n,\n3\n,\n4\n,\n5\n};\nvector\n<\nint\n>\nv\n;\nv\n.\npush_back\n(\n1\n);\nv\n.\npush_back\n(\n2\n);\nv\n.\npush_back\n(\n3\n);\n// safe conversion\nfor\n(\nauto\n&\nelem\n:\narr\n)\ncout\n<<\nelem\n;\n// reasonable conversion\nfor\n(\nauto\n&\nelem\n:\nv\n)\ncout\n<<\nelem\n;\n// reasonable conversion\nfor\n(\nauto\n&\nelem\n:\nv\n)\ncout\n<<\nelem\n;\n\nReverse Iterator Support\nThe converter is also capable of transforming iterator loops which use\nrbegin\nand\nrend\nfor looping backwards over a container. Out of the box\nthis will automatically happen in C++20 mode using the\nranges\nlibrary,\nhowever the check can be configured to work without C++20 by specifying a\nfunction to reverse a range and optionally the header file where that function\nlives.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nUseCxx20ReverseRanges\nWhen set to true convert loops when in C++20 or later mode using\nstd::views::reverse\n.\nDefault value is\ntrue\n.\nMakeReverseRangeFunction\nSpecify the function used to reverse an iterator pair, the function should\naccept a class with\nrbegin\nand\nrend\nmethods and return a\nclass with\nbegin\nand\nend\nmethods that call the\nrbegin\nand\nrend\nmethods respectively. Common examples are\nstd::views::reverse\nand\nllvm::reverse\n.\nDefault value is an empty string.\nMakeReverseRangeHeader\nSpecifies the header file where\nMakeReverseRangeFunction\nis\ndeclared. For the previous examples this option would be set to\nrange/v3/view/reverse.hpp\nand\nllvm/ADT/STLExtras.h\nrespectively.\nIf this is an empty string and\nMakeReverseRangeFunction\nis set,\nthe check will proceed on the assumption that the function is already\navailable in the translation unit.\nThis can be wrapped in angle brackets to signify to add the include as a\nsystem include.\nDefault value is an empty string.\nIncludeStyle\nA string specifying which include-style is used,\nllvm\nor\ngoogle\n. Default\nis\nllvm\n.\n\nLimitations\nThere are certain situations where the tool may erroneously perform\ntransformations that remove information and change semantics. Users of the tool\nshould be aware of the behavior and limitations of the check outlined by\nthe cases below.\nComments inside loop headers\nComments inside the original loop header are ignored and deleted when\ntransformed.\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nN\n;\n/* This will be deleted */\n++\ni\n)\n{\n}\nRange-based loops evaluate end() only once\nThe C++11 range-based for loop calls\n.end()\nonly once during the\ninitialization of the loop. If in the original loop\n.end()\nis called after\neach iteration the semantics of the transformed loop may differ.\n// The following is semantically equivalent to the C++11 range-based for loop,\n// therefore the semantics of the header will not change.\nfor\n(\niterator\nit\n=\ncontainer\n.\nbegin\n(),\ne\n=\ncontainer\n.\nend\n();\nit\n!=\ne\n;\n++\nit\n)\n{\n}\n// Instead of calling .end() after each iteration, this loop will be\n// transformed to call .end() only once during the initialization of the loop,\n// which may affect semantics.\nfor\n(\niterator\nit\n=\ncontainer\n.\nbegin\n();\nit\n!=\ncontainer\n.\nend\n();\n++\nit\n)\n{\n}\nAs explained above, calling member functions of the container in the body\nof the loop is considered\nrisky\n. If the called member function modifies the\ncontainer the semantics of the converted loop will differ due to\n.end()\nbeing called only once.\nbool\nflag\n=\nfalse\n;\nfor\n(\nvector\n<\nT\n>::\niterator\nit\n=\nvec\n.\nbegin\n();\nit\n!=\nvec\n.\nend\n();\n++\nit\n)\n{\n// Add a copy of the first element to the end of the vector.\nif\n(\n!\nflag\n)\n{\n// This line makes this transformation 'risky'.\nvec\n.\npush_back\n(\n*\nit\n);\nflag\n=\ntrue\n;\n}\ncout\n<<\n*\nit\n;\n}\nThe original code above prints out the contents of the container including the\nnewly added element while the converted loop, shown below, will only print the\noriginal contents and not the newly added element.\nbool\nflag\n=\nfalse\n;\nfor\n(\nauto\n&\nelem\n:\nvec\n)\n{\n// Add a copy of the first element to the end of the vector.\nif\n(\n!\nflag\n)\n{\n// This line makes this transformation 'risky'\nvec\n.\npush_back\n(\nelem\n);\nflag\n=\ntrue\n;\n}\ncout\n<<\nelem\n;\n}\nSemantics will also be affected if\n.end()\nhas side effects. For example, in\nthe case where calls to\n.end()\nare logged the semantics will change in the\ntransformed loop if\n.end()\nwas originally called after each iteration.\niterator\nend\n()\n{\nnum_of_end_calls\n++\n;\nreturn\ncontainer\n.\nend\n();\n}\nOverloaded operator->() with side effects\nSimilarly, if\noperator->()\nwas overloaded to have side effects, such as\nlogging, the semantics will change. If the iterator’s\noperator->()\nwas used\nin the original loop it will be replaced with\n<container\nelement>.<member>\ninstead due to the implicit dereference as part of the range-based for loop.\nTherefore any side effect of the overloaded\noperator->()\nwill no longer be\nperformed.\nfor\n(\niterator\nit\n=\nc\n.\nbegin\n();\nit\n!=\nc\n.\nend\n();\n++\nit\n)\n{\nit\n->\nfunc\n();\n// Using operator->()\n}\n// Will be transformed to:\nfor\n(\nauto\n&\nelem\n:\nc\n)\n{\nelem\n.\nfunc\n();\n// No longer using operator->()\n}\nPointers and references to containers\nWhile most of the check’s risk analysis is dedicated to determining whether\nthe iterator or container was modified within the loop, it is possible to\ncircumvent the analysis by accessing and modifying the container through a\npointer or reference.\nIf the container were directly used instead of using the pointer or reference\nthe following transformation would have only been applied at the\nrisky\nlevel since calling a member function of the container is considered\nrisky\n.\nThe check cannot identify expressions associated with the container that are\ndifferent than the one used in the loop header, therefore the transformation\nbelow ends up being performed at the\nsafe\nlevel.\nvector\n<\nint\n>\nvec\n;\nvector\n<\nint\n>\n*\nptr\n=\n&\nvec\n;\nvector\n<\nint\n>\n&\nref\n=\nvec\n;\nfor\n(\nvector\n<\nint\n>::\niterator\nit\n=\nvec\n.\nbegin\n(),\ne\n=\nvec\n.\nend\n();\nit\n!=\ne\n;\n++\nit\n)\n{\nif\n(\n!\nflag\n)\n{\n// Accessing and modifying the container is considered risky, but the risk\n// level is not raised here.\nptr\n->\npush_back\n(\n*\nit\n);\nref\n.\npush_back\n(\n*\nit\n);\nflag\n=\ntrue\n;\n}\n}\nOpenMP\nAs range-based for loops are only available since OpenMP 5, this check should\nnot be used on code with a compatibility requirement of OpenMP prior to\nversion 5. It is\nintentional\nthat this check does not make any attempts to\nexclude incorrect diagnostics on OpenMP for loops prior to OpenMP 5.\nTo prevent this check to be applied (and to break) OpenMP for loops\nbut still be applied to non-OpenMP for loops the usage of\nNOLINT\n(see\nSuppressing Undesired Diagnostics\n) on the specific for loops is recommended."
    }
}