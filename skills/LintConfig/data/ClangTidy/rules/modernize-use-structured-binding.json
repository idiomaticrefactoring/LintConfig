{
    "modernize-use-structured-binding": {
        "description": "Description\n\nFinds places where structured bindings could be used to decompose pairs and\nsuggests replacing them.\n\nThis check finds three code patterns and recommends using structured bindings\nfor clearer, more idiomatic C++17 code.\n\n1. Decompose a pair variable by assigning its members to separate variables\nright after its definition:\n\nauto\np\n=\ngetPair\n<\nint\n,\nint\n>\n();\nint\nx\n=\np\n.\nfirst\n;\nint\ny\n=\np\n.\nsecond\n;\ninto\n:\nauto\n[\nx\n,\ny\n]\n=\ngetPair\n<\nint\n,\nint\n>\n();\n\nUse\nstd::tie\nto decompose a pair into two predefined variables:\n\nint\na\n;\nint\nb\n;\nstd\n::\ntie\n(\na\n,\nb\n)\n=\ngetPair\n<\nint\n,\nint\n>\n();\ninto\n:\nauto\n[\na\n,\nb\n]\n=\ngetPair\n<\nint\n,\nint\n>\n();\n\n3. Manually decompose a pair by assigning to its members to local variables\nin a range-based for loop:\n\nfor\n(\nauto\np\n:\nvecOfPairs\n)\n{\nint\nx\n=\np\n.\nfirst\n;\nint\ny\n=\np\n.\nsecond\n;\n// ...\n}\ninto\n:\nfor\n(\nauto\n[\nx\n,\ny\n]\n:\nvecOfPairs\n)\n{\n// use x and y\n}\n\nLimitations\nThe check currently ignores variables defined with attributes or qualifiers\nexcept\nconst\nand\n&\nsince it’s not very common:\nstatic\nauto\npair\n=\ngetPair\n();\nstatic\nint\nb\n=\npair\n.\nfirst\n;\nstatic\nint\nc\n=\npair\n.\nsecond\n;\nThe check doesn’t handle some situations which could possibly be transferred\nto structured bindings, for example:\nconst\nauto\n&\nresults\n=\nmapping\n.\ntry_emplace\n(\n\"hello!\"\n);\nconst\niterator\n&\nit\n=\nresults\n.\nfirst\n;\nbool\nsucceed\n=\nresults\n.\nsecond\n;\n// succeed is not changed in the following code\nand:\nconst\nauto\nresults\n=\nmapping\n.\ntry_emplace\n(\n\"hello!\"\n);\nif\n(\nresults\n.\nsecond\n)\n{\nhandle_inserted\n(\nresults\n.\nfirst\n);\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}