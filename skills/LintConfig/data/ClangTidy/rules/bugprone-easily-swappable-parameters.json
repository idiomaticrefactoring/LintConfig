{
    "bugprone-easily-swappable-parameters": {
        "description": "Description\n\nFinds function definitions where parameters of convertible types follow each\nother directly, making call sites prone to calling the function with\nswapped (or badly ordered) arguments.\n\nvoid\ndrawPoint\n(\nint\nX\n,\nint\nY\n)\n{\n/* ... */\n}\nFILE\n*\nopen\n(\nconst\nchar\n*\nDir\n,\nconst\nchar\n*\nName\n,\nFlags\nMode\n)\n{\n/* ... */\n}\n\nA potential call like\ndrawPoint(-2,\n5)\nor\nopenPath(\"a.txt\",\n\"tmp\",\nRead)\nis perfectly legal from the language’s\nperspective, but might not be what the developer of the function intended.\n\nMore elaborate and type-safe constructs, such as opaque typedefs or strong\ntypes should be used instead, to prevent a mistaken order of arguments.\n\nstruct\nCoord2D\n{\nint\nX\n;\nint\nY\n;\n};\nvoid\ndrawPoint\n(\nconst\nCoord2D\nPos\n)\n{\n/* ... */\n}\nFILE\n*\nopen\n(\nconst\nPath\n&\nDir\n,\nconst\nFilename\n&\nName\n,\nFlags\nMode\n)\n{\n/* ... */\n}\n\nDue to the potentially elaborate refactoring and API-breaking that is necessary\nto strengthen the type safety of a project, no automatic fix-its are offered.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nExtension/relaxation options\nRelaxation (or extension) options can be used to broaden the scope of the\nanalysis and fine-tune the enabling of more mixes between types.\nSome mixes may depend on coding style or preference specific to a project,\nhowever, it should be noted that enabling\nall\nof these relaxations model the\nway of mixing at call sites the most.\nThese options are expected to make the check report for more functions, and\nreport longer mixable ranges.\nQualifiersMix\nWhether to consider parameters of some\ncvr-qualified\nT\nand a\ndifferently\ncvr-qualified\nT\n(i.e.\nT\nand\nconst\nT\n,\nconst\nT\nand\nvolatile\nT\n, etc.) mixable between one another.\nIf\nfalse\n, the check will consider differently qualified types unmixable.\nTrue\nturns the warnings on.\nDefaults to\nfalse\n.\nThe following example produces a diagnostic only if\nQualifiersMix\nis\nenabled:\nvoid\n*\nmemcpy\n(\nconst\nvoid\n*\nDestination\n,\nvoid\n*\nSource\n,\nstd\n::\nsize_t\nN\n)\n{\n/* ... */\n}\nModelImplicitConversions\nWhether to consider parameters of type\nT\nand\nU\nmixable if there\nexists an implicit conversion from\nT\nto\nU\nand\nU\nto\nT\n.\nIf\nfalse\n, the check will not consider implicitly convertible types for\nmixability.\nTrue\nturns warnings for implicit conversions on.\nDefaults to\ntrue\n.\nThe following examples produce a diagnostic only if\nModelImplicitConversions\nis enabled:\nvoid\nfun\n(\nint\nInt\n,\ndouble\nDouble\n)\n{\n/* ... */\n}\nvoid\ncompare\n(\nconst\nchar\n*\nCharBuf\n,\nstd\n::\nstring\nString\n)\n{\n/* ... */\n}\nNote\nChanging the qualifiers of an expression’s type (e.g. from\nint\nto\nconst\nint\n) is defined as an\nimplicit conversion\nin the C++\nStandard.\nHowever, the check separates this decision-making on the mixability of\ndifferently qualified types based on whether\nQualifiersMix\nwas\nenabled.\nFor example, the following code snippet will only produce a diagnostic\nif\nboth\nQualifiersMix\nand\nModelImplicitConversions\nare enabled:\nvoid\nfun2\n(\nint\nInt\n,\nconst\ndouble\nDouble\n)\n{\n/* ... */\n}\nFiltering options\nFiltering options can be used to lessen the size of the diagnostics emitted by\nthe checker, whether the aim is to ignore certain constructs or dampen the\nnoisiness.\nMinimumLength\nThe minimum length required from an adjacent parameter sequence to be\ndiagnosed.\nDefaults to\n2\n.\nMight be any positive integer greater or equal to\n2\n.\nIf\n0\nor\n1\nis given, the default value\n2\nwill be used instead.\nFor example, if\n3\nis specified, the examples above will not be matched.\nIgnoredParameterNames\nThe list of parameter\nnames\nthat should never be considered part of a\nswappable adjacent parameter sequence.\nThe value is a\n;\n-separated list of names.\nTo ignore unnamed parameters, add\n“”\nto the list verbatim (not the\nempty string, but the two quotes, potentially escaped!).\nThis option is case-sensitive!\nBy default, the following parameter names, and their Uppercase-initial\nvariants are ignored:\n“”\n(unnamed parameters),\niterator\n,\nbegin\n,\nend\n,\nfirst\n,\nlast\n,\nlhs\n,\nrhs\n.\nIgnoredParameterTypeSuffixes\nThe list of parameter\ntype name suffixes\nthat should never be\nconsidered part of a swappable adjacent parameter sequence.\nParameters which type, as written in the source code, end with an element\nof this option will be ignored.\nThe value is a\n;\n-separated list of names.\nThis option is case-sensitive!\nBy default, the following, and their lowercase-initial variants are ignored:\nbool\n,\nIt\n,\nIterator\n,\nInputIt\n,\nForwardIt\n,\nBidirIt\n,\nRandomIt\n,\nrandom_iterator\n,\nReverseIt\n,\nreverse_iterator\n,\nreverse_const_iterator\n,\nRandomIt\n,\nrandom_iterator\n,\nReverseIt\n,\nreverse_iterator\n,\nreverse_const_iterator\n,\nConst_Iterator\n,\nConstIterator\n,\nconst_reverse_iterator\n,\nConstReverseIterator\n.\nIn addition,\n_Bool\n(but not\n_bool\n) is also part of the default value.\nSuppressParametersUsedTogether\nSuppresses diagnostics about parameters that are used together or in a\nsimilar fashion inside the function’s body.\nDefaults to\ntrue\n.\nSpecifying\nfalse\nwill turn off the heuristics.\nCurrently, the following heuristics are implemented which will suppress the\nwarning about the parameter pair involved:\nThe parameters are used in the same expression, e.g.\nf(a,\nb)\nor\na\n<\nb\n.\nThe parameters are further passed to the same function to the same\nparameter of that function, of the same overload.\nE.g.\nf(a,\n1)\nand\nf(b,\n2)\nto some\nf(T,\nint)\n.\nNote\nThe check does not perform path-sensitive analysis, and as such,\n“same function” in this context means the same function declaration.\nIf the same member function of a type on two distinct instances are\ncalled with the parameters, it will still be regarded as\n“same function”.\nThe same member field is accessed, or member method is called of the\ntwo parameters, e.g.\na.foo()\nand\nb.foo()\n.\nSeparate\nreturn\nstatements return either of the parameters on\ndifferent code paths.\nNamePrefixSuffixSilenceDissimilarityThreshold\nThe number of characters two parameter names might be different on\neither\nthe head or the tail end with the rest of the name the same so that the\nwarning about the two parameters are silenced.\nDefaults to\n1\n.\nMight be any positive integer.\nIf\n0\n, the filtering heuristic based on the parameters’ names is turned\noff.\nThis option can be used to silence warnings about parameters where the\nnaming scheme indicates that the order of those parameters do not matter.\nFor example, the parameters\nLHS\nand\nRHS\nare 1-dissimilar suffixes\nof each other:\nL\nand\nR\nis the different character, while\nHS\nis the common suffix.\nSimilarly, parameters\ntext1,\ntext2,\ntext3\nare 1-dissimilar prefixes\nof each other, with the numbers at the end being the dissimilar part.\nIf the value is at least\n1\n, such cases will not be reported.\n\nLimitations\nThis check is designed to check function signatures!\nThe check does not investigate functions that are generated by the compiler\nin a context that is only determined from a call site.\nThese cases include variadic functions, functions in C code that do not have\nan argument list, and C++ template instantiations.\nMost of these cases, which are otherwise swappable from a caller’s standpoint,\nhave no way of getting “fixed” at the definition point.\nIn the case of C++ templates, only primary template definitions and explicit\nspecializations are matched and analyzed.\nNone of the following cases produce a diagnostic:\nint\nprintf\n(\nconst\nchar\n*\nFormat\n,\n...)\n{\n/* ... */\n}\nint\nsomeOldCFunction\n()\n{\n/* ... */\n}\ntemplate\n<\ntypename\nT\n,\ntypename\nU\n>\nint\nadd\n(\nT\nX\n,\nU\nY\n)\n{\nreturn\nX\n+\nY\n};\nvoid\ntheseAreNotWarnedAbout\n()\n{\nprintf\n(\n\"%d %d\n\\n\n\"\n,\n1\n,\n2\n);\n// Two ints passed, they could be swapped.\nsomeOldCFunction\n(\n1\n,\n2\n,\n3\n);\n// Similarly, multiple ints passed.\nadd\n(\n1\n,\n2\n);\n// Instantiates 'add<int, int>', but that's not a user-defined function.\n}\nDue to the limitation above, parameters which type are further dependent upon\ntemplate instantiations to\nprove\nthat they mix with another parameter’s is\nnot diagnosed.\ntemplate\n<\ntypename\nT\n>\nstruct\nVector\n{\ntypedef\nT\nelement_type\n;\n};\n// Diagnosed: Explicit instantiation was done by the user, we can prove it\n// is the same type.\nvoid\ninstantiated\n(\nint\nA\n,\nVector\n<\nint\n>::\nelement_type\nB\n)\n{\n/* ... */\n}\n// Diagnosed: The two parameter types are exactly the same.\ntemplate\n<\ntypename\nT\n>\nvoid\nexact\n(\ntypename\nVector\n<\nT\n>::\nelement_type\nA\n,\ntypename\nVector\n<\nT\n>::\nelement_type\nB\n)\n{\n/* ... */\n}\n// Skipped: The two parameters are both 'T' but we cannot prove this\n// without actually instantiating.\ntemplate\n<\ntypename\nT\n>\nvoid\nfalseNegative\n(\nT\nA\n,\ntypename\nVector\n<\nT\n>::\nelement_type\nB\n)\n{\n/* ... */\n}\nIn the context of\nimplicit conversions\n(when\nModelImplicitConversions\nis\nenabled), the modelling performed by the check\nwarns if the parameters are swappable and the swapped order matches implicit\nconversions.\nIt does not model whether there exists an unrelated third type from which\nboth\nparameters can be given in a function call.\nThis means that in the following example, even while\nstrs()\nclearly carries\nthe possibility to be called with swapped arguments (as long as the arguments\nare string literals), will not be warned about.\nstruct\nString\n{\nString\n(\nconst\nchar\n*\nBuf\n);\n};\nstruct\nStringView\n{\nStringView\n(\nconst\nchar\n*\nBuf\n);\noperator\nconst\nchar\n*\n()\nconst\n;\n};\n// Skipped: Directly swapping expressions of the two type cannot mix.\n// (Note: StringView -> const char * -> String would be **two**\n// user-defined conversions, which is disallowed by the language.)\nvoid\nstrs\n(\nString\nStr\n,\nStringView\nSV\n)\n{\n/* ... */\n}\n// Diagnosed: StringView implicitly converts to and from a buffer.\nvoid\ncStr\n(\nStringView\nSV\n,\nconst\nchar\n*\nBuf\n()\n{\n/* ... */\n}"
    }
}