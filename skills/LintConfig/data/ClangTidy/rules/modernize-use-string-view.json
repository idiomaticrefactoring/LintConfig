{
    "modernize-use-string-view": {
        "description": "Description\n\nLooks for functions returning\nstd::[w|u8|u16|u32]string\nand suggests to\nchange it to\nstd::[...]string_view\nfor performance reasons if possible.\n\nEach time a new\nstd::string\nis created from a literal, a copy of that\nliteral is allocated either in\nstd::string\n’s internal buffer\n(for short literals) or on the heap.\n\nFor the cases where\nstd::string\nis returned from a function,\nsuch allocations can sometimes be eliminated by using\nstd::string_view\nas a return type.\n\nThis check looks for such functions returning\nstd::string\nconstructed from\nthe literals and suggests replacing their return type to\nstd::string_view\n.\n\nIt handles\nstd::string\n,\nstd::wstring\n,\nstd::u8string\n,\nstd::u16string\nand\nstd::u32string\nalong with their aliases and selects\nthe proper kind of\nstd::string_view\nto return.\n\nConsider the following example:\n\nstd\n::\nstring\nfoo\n(\nint\ni\n)\n{\nswitch\n(\ni\n)\n{\ncase\n1\n:\nreturn\n\"case 1\"\n;\n...\ndefault\n:\nreturn\n\"default\"\n;\n}\n}\n\nIn the code above a new\nstd::string\nobject is created on each function\ninvocation, making a copy of a string literal and possibly allocating a memory\non the heap.\n\nThe check gets this code transformed into:\n\nstd\n::\nstring_view\nfoo\n(\nint\ni\n)\n{\nswitch\n(\ni\n)\n{\ncase\n1\n:\nreturn\n\"case 1\"\n;\n...\ndefault\n:\nreturn\n\"default\"\n;\n}\n}\n\nNew version re-uses statically allocated literals without additional overhead.\n\nSuppressing diagnostic\nTo prevent an undesired diagnostic wrap the string literal with an explicit\nstd::string(...)\nconstructor:\nstd\n::\nstring\nfoo\n()\n{\nreturn\n\"default\"\n;\n//warning and fix are generated\n}\nstd\n::\nstring\nbar\n()\n{\nreturn\nstd\n::\nstring\n(\n\"default\"\n);\n//warning and fix are NOT generated\n}\n\nLimitations\nNo warning and/or fix are generated as for now for these code patterns:\nreturn\nstd::string(\"literal\");\nreturn\nstd::string{\"literal\"};\nreturn\n\"simpleLiteral\"s;\nauto\nfoo()\n{\nreturn\n\"autoReturn\";\n}\nauto\nTrailing()\n->\nstd::string\n{\nreturn\n\"Trailing\";\n}\nwarns, doesn’t fix\nreturnings from lambda\ncomplicated macro and templated code\nIn some cases the fixed code will not compile due to lack of conversion from\nstd::string_view\nto\nstd::string\n. It can be fixed (preferably) by\nconverting receiver\nstd::string\nto\nstd::string_view\nif possible or\nsimply make an explicit conversion.\nstring\nfoo\n()\n{\n// <--- will be replaced with string_view\nreturn\n\"foo\"\n;\n}\nvoid\nbar\n()\n{\nstring\nerr\n=\nfoo\n();\n// <----- error: no viable conversion from\n// 'std::string_view' (aka 'basic_string_view<char>')\n// to 'std::string' (aka 'basic_string<char>')\nstring\nfix\n(\nfoo\n());\n// <----- no errors\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nIgnoredFunctions\nA semicolon-separated list of the names of functions or methods to be\nignored. Regular expressions are accepted, e.g.\n[Rr]ef(erence)?$\nmatches\nevery type with suffix\nRef\n,\nref\n,\nReference\nand\nreference\n.\nIf a name in the list contains the sequence\n::\nit is matched against the\nqualified type name (i.e.\nnamespace::Type\n), otherwise it is matched\nagainst only the type name (i.e.\nType\n).\nThe default is\ntoString$;ToString$;to_string$\n.\nReplacementStringViewClass\nA semicolon-separated list of\nstring=string_view\npairs for replacing\nstring\nto\nstring_view\ncounterparts.\nKey\nValue (example)\nDefault value\nstring\nllvm::StringRef\nstd::string_view\nwstring\nboost::wstring_view\nstd::wstring_view\nu8string\nabsl::u8string_view\nstd::u8string_view\nu16string\nQStringView\nstd::u16string_view\nu32string\nstd::u32zstring_view\nstd::u32string_view"
    }
}