{
    "readability-non-const-parameter": {
        "description": "Description\n\nThe check finds function parameters of a pointer type that could be changed to\npoint to a constant type instead.\n\nWhen\nconst\nis used properly, many mistakes can be avoided. Advantages when\nusing\nconst\nproperly:\n\nprevent unintentional modification of data;\nget additional warnings such as using uninitialized data;\nmake it easier for developers to see possible side effects.\n\nThis check is not strict about constness, it only warns when the constness will\nmake the function interface safer.\n\n// warning here; the declaration \"const char *p\" would make the function\n// interface safer.\nchar\nf1\n(\nchar\n*\np\n)\n{\nreturn\n*\np\n;\n}\n// no warning; the declaration could be more const \"const int * const p\" but\n// that does not make the function interface safer.\nint\nf2\n(\nconst\nint\n*\np\n)\n{\nreturn\n*\np\n;\n}\n// no warning; making x const does not make the function interface safer\nint\nf3\n(\nint\nx\n)\n{\nreturn\nx\n;\n}\n// no warning; Technically, *p can be const (\"const struct S *p\"). But making\n// *p const could be misleading. People might think that it's safe to pass\n// const data to this function.\nstruct\nS\n{\nint\n*\na\n;\nint\n*\nb\n;\n};\nint\nf3\n(\nstruct\nS\n*\np\n)\n{\n*\n(\np\n->\na\n)\n=\n0\n;\n}\n// no warning; p is referenced by an lvalue.\nvoid\nf4\n(\nint\n*\np\n)\n{\nint\n&\nx\n=\n*\np\n;\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}