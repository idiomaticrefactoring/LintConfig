{
    "readability-qualified-auto": {
        "description": "Description\n\nAdds pointer qualifications to\nauto\n-typed variables that are deduced to\npointers.\n\nLLVM Coding Standards\nadvises to make it obvious if a\nauto\ntyped variable is a pointer. This\ncheck will transform\nauto\nto\nauto\n*\nwhen the type is deduced to be a\npointer.\n\nfor\n(\nauto\nData\n:\nMutatablePtrContainer\n)\n{\nchange\n(\n*\nData\n);\n}\nfor\n(\nauto\nData\n:\nConstantPtrContainer\n)\n{\nobserve\n(\n*\nData\n);\n}\n\nWould be transformed into:\n\nfor\n(\nauto\n*\nData\n:\nMutatablePtrContainer\n)\n{\nchange\n(\n*\nData\n);\n}\nfor\n(\nconst\nauto\n*\nData\n:\nConstantPtrContainer\n)\n{\nobserve\n(\n*\nData\n);\n}\n\nNote\nconst\nvolatile\nqualified types will retain their\nconst\nand\nvolatile\nqualifiers. Pointers to pointers will not be fully qualified.\n\nconst\nauto\nFoo\n=\ncast\n<\nint\n*>\n(\nBaz1\n);\nconst\nauto\nBar\n=\ncast\n<\nconst\nint\n*>\n(\nBaz2\n);\nvolatile\nauto\nFooBar\n=\ncast\n<\nint\n*>\n(\nBaz3\n);\nauto\nBarFoo\n=\ncast\n<\nint\n**>\n(\nBaz4\n);\n\nWould be transformed into:\n\nauto\n*\nconst\nFoo\n=\ncast\n<\nint\n*>\n(\nBaz1\n);\nconst\nauto\n*\nconst\nBar\n=\ncast\n<\nconst\nint\n*>\n(\nBaz2\n);\nauto\n*\nvolatile\nFooBar\n=\ncast\n<\nint\n*>\n(\nBaz3\n);\nauto\n*\nBarFoo\n=\ncast\n<\nint\n**>\n(\nBaz4\n);",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nAddConstToQualified\nWhen set to\ntrue\nthe check will add const qualifiers variables defined as\nauto\n*\nor\nauto\n&\nwhen applicable.\nDefault value is\ntrue\n.\nauto\nFoo1\n=\ncast\n<\nconst\nint\n*>\n(\nBar1\n);\nauto\n*\nFoo2\n=\ncast\n<\nconst\nint\n*>\n(\nBar2\n);\nauto\n&\nFoo3\n=\ncast\n<\nconst\nint\n&>\n(\nBar3\n);\nIf AddConstToQualified is set to\nfalse\n, it will be transformed into:\nconst\nauto\n*\nFoo1\n=\ncast\n<\nconst\nint\n*>\n(\nBar1\n);\nauto\n*\nFoo2\n=\ncast\n<\nconst\nint\n*>\n(\nBar2\n);\nauto\n&\nFoo3\n=\ncast\n<\nconst\nint\n&>\n(\nBar3\n);\nOtherwise it will be transformed into:\nconst\nauto\n*\nFoo1\n=\ncast\n<\nconst\nint\n*>\n(\nBar1\n);\nconst\nauto\n*\nFoo2\n=\ncast\n<\nconst\nint\n*>\n(\nBar2\n);\nconst\nauto\n&\nFoo3\n=\ncast\n<\nconst\nint\n&>\n(\nBar3\n);\nNote in the LLVM alias, the default value is\nfalse\n.\nAllowedTypes\nA semicolon-separated list of names of types to ignore when\nauto\nis\ndeduced to that type or a pointer to that type. Note that this distinguishes\ntype aliases from the original type, so specifying e.g.\nmy_int\nwill not\nsuppress reports about\nint\neven if it is defined as a\ntypedef\nalias\nfor\nint\n. Regular expressions are accepted, e.g.\n[Rr]ef(erence)?$\nmatches every type with suffix\nRef\n,\nref\n,\nReference\nand\nreference\n. If a name in the list contains the sequence\n::\nit is matched\nagainst the qualified type name (i.e.\nnamespace::Type\n), otherwise it is\nmatched against only the type name (i.e.\nType\n). E.g. to suppress reports\nfor\nstd::array\niterators use\nstd::array<.*>::(const_)?iterator\nstring.\nThe default is an empty string.\nIgnoreAliasing\nIf set to\ntrue\nthe check will use the underlying type to determine the type\nthat\nauto\nis deduced to. If set to\nfalse\nthe check will not look beyond\nthe first type alias.\nDefault value is\ntrue\n.\nusing\nIntPtr\n=\nint\n*\n;\nIntPtr\nfoo\n();\nauto\nbar\n=\nfoo\n();\nIf\nIgnoreAliasing\nis set to\ntrue\n, it will be transformed into:\nauto\n*\nbar\n=\nfoo\n();\nOtherwise no changes will occur.\n\nLimitations\nWhen\nIgnoreAliasing\nis set to\nfalse\n, there are cases where\nClang has not preserved the type alias and the underlying type will be used so\nfalse positives may occur.\nFor example:\nusing\nIntPtr\n=\nint\n*\n;\nvoid\nloopPtr\n(\nconst\nstd\n::\nvector\n<\nIntPtr\n>\n&\nVectorIntPtr\n)\n{\n// May fail for IgnoreAliasing==false as AST does not have the 'IntPtr'\nfor\n(\nauto\nData\n:\nVectorIntPtr\n)\n{\n}\n}"
    }
}