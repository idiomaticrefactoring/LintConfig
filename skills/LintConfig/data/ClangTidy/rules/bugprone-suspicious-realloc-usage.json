{
    "bugprone-suspicious-realloc-usage": {
        "description": "Description\n\nThis check finds usages of\nrealloc\nwhere the return value is assigned to\nthe same expression as passed to the first argument:\np\n=\nrealloc(p,\nsize);\nThe problem with this construct is that if\nrealloc\nfails it returns a\nnull pointer but does not deallocate the original memory. If no other variable\nis pointing to it, the original memory block is not available any more for the\nprogram to use or free. In either case\np\n=\nrealloc(p,\nsize);\nindicates bad\ncoding style and can be replaced by\nq\n=\nrealloc(p,\nsize);\n.\n\nThe pointer expression (used at\nrealloc\n) can be a variable or a field\nmember of a data structure, but can not contain function calls or unresolved\ntypes.\n\nIn obvious cases when the pointer used at realloc is assigned to another\nvariable before the\nrealloc\ncall, no warning is emitted. This happens only\nif a simple expression in form of\nq\n=\np\nor\nvoid\n*q\n=\np\nis found in the\nsame function where\np\n=\nrealloc(p,\n...)\nis found. The assignment has to be\nbefore the call to realloc (but otherwise at any place) in the same function.\nThis suppression works only if\np\nis a single variable.\n\nExamples:\n\nstruct\nA\n{\nvoid\n*\np\n;\n};\nA\n&\ngetA\n();\nvoid\nfoo\n(\nvoid\n*\np\n,\nA\n*\na\n,\nint\nnew_size\n)\n{\np\n=\nrealloc\n(\np\n,\nnew_size\n);\n// warning: 'p' may be set to null if 'realloc' fails, which may result in a leak of the original buffer\na\n->\np\n=\nrealloc\n(\na\n->\np\n,\nnew_size\n);\n// warning: 'a->p' may be set to null if 'realloc' fails, which may result in a leak of the original buffer\ngetA\n().\np\n=\nrealloc\n(\ngetA\n().\np\n,\nnew_size\n);\n// no warning\n}\nvoid\nfoo1\n(\nvoid\n*\np\n,\nint\nnew_size\n)\n{\nvoid\n*\np1\n=\np\n;\np\n=\nrealloc\n(\np\n,\nnew_size\n);\n// no warning\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}