{
    "modernize-use-auto": {
        "description": "Description\n\nThis check is responsible for using the\nauto\ntype specifier for variable\ndeclarations to\nimprove code readability and maintainability\n. For example:\n\nstd\n::\nvector\n<\nint\n>::\niterator\nI\n=\nmy_container\n.\nbegin\n();\n// transforms to:\nauto\nI\n=\nmy_container\n.\nbegin\n();\n\nThe\nauto\ntype specifier will only be introduced in situations where the\nvariable type matches the type of the initializer expression. In other words\nauto\nshould deduce the same type that was originally spelled in the source.\nHowever, not every situation should be transformed:\n\nint\nval\n=\n42\n;\nInfoStruct\n&\nI\n=\nSomeObject\n.\ngetInfo\n();\n// Should not become:\nauto\nval\n=\n42\n;\nauto\n&\nI\n=\nSomeObject\n.\ngetInfo\n();\n\nIn this example using\nauto\nfor builtins doesnâ€™t improve readability. In\nother situations it makes the code less self-documenting impairing readability\nand maintainability. As a result,\nauto\nis used only introduced in specific\nsituations described below.\n\nIterators\nIterator type specifiers tend to be long and used frequently, especially in\nloop constructs. Since the functions generating iterators have a common format,\nthe type specifier can be replaced without obscuring the meaning of code while\nimproving readability and maintainability.\nfor\n(\nstd\n::\nvector\n<\nint\n>::\niterator\nI\n=\nmy_container\n.\nbegin\n(),\nE\n=\nmy_container\n.\nend\n();\nI\n!=\nE\n;\n++\nI\n)\n{\n}\n// becomes\nfor\n(\nauto\nI\n=\nmy_container\n.\nbegin\n(),\nE\n=\nmy_container\n.\nend\n();\nI\n!=\nE\n;\n++\nI\n)\n{\n}\nThe check will only replace iterator type-specifiers when all of the following\nconditions are satisfied:\nThe iterator is for one of the standard containers in\nstd\nnamespace:\narray\ndeque\nforward_list\nlist\nvector\nmap\nmultimap\nset\nmultiset\nunordered_map\nunordered_multimap\nunordered_set\nunordered_multiset\nqueue\npriority_queue\nstack\nThe iterator is one of the possible iterator types for standard containers:\niterator\nreverse_iterator\nconst_iterator\nconst_reverse_iterator\nIn addition to using iterator types directly, typedefs or other ways of\nreferring to those types are also allowed. However, implementation-specific\ntypes for which a type like\nstd::vector<int>::iterator\nis itself a\ntypedef will not be transformed. Consider the following examples:\n// The following direct uses of iterator types will be transformed.\nstd\n::\nvector\n<\nint\n>::\niterator\nI\n=\nMyVec\n.\nbegin\n();\n{\nusing\nnamespace\nstd\n;\nlist\n<\nint\n>::\niterator\nI\n=\nMyList\n.\nbegin\n();\n}\n// The type specifier for J would transform to auto since it's a typedef\n// to a standard iterator type.\ntypedef\nstd\n::\nmap\n<\nint\n,\nstd\n::\nstring\n>::\nconst_iterator\nmap_iterator\n;\nmap_iterator\nJ\n=\nMyMap\n.\nbegin\n();\n// The following implementation-specific iterator type for which\n// std::vector<int>::iterator could be a typedef would not be transformed.\n__gnu_cxx\n::\n__normal_iterator\n<\nint\n*\n,\nstd\n::\nvector\n>\nK\n=\nMyVec\n.\nbegin\n();\nThe initializer for the variable being declared is not a braced initializer\nlist. Otherwise, use of\nauto\nwould cause the type of the variable to be\ndeduced as\nstd::initializer_list\n.\n\nNew expressions\nFrequently, when a pointer is declared and initialized with\nnew\n, the\npointee type is written twice: in the declaration type and in the\nnew\nexpression. In this case, the declaration type can be replaced with\nauto\nimproving readability and maintainability.\nTypeName\n*\nmy_pointer\n=\nnew\nTypeName\n(\nmy_param\n);\n// becomes\nauto\n*\nmy_pointer\n=\nnew\nTypeName\n(\nmy_param\n);\nThe check will also replace the declaration type in multiple declarations, if\nthe following conditions are satisfied:\nAll declared variables have the same type (i.e. all of them are pointers to\nthe same type).\nAll declared variables are initialized with a\nnew\nexpression.\nThe types of all the new expressions are the same than the pointee of the\ndeclaration type.\nTypeName\n*\nmy_first_pointer\n=\nnew\nTypeName\n,\n*\nmy_second_pointer\n=\nnew\nTypeName\n;\n// becomes\nauto\n*\nmy_first_pointer\n=\nnew\nTypeName\n,\n*\nmy_second_pointer\n=\nnew\nTypeName\n;\n\nCast expressions\nFrequently, when a variable is declared and initialized with a cast, the\nvariable type is written twice: in the declaration type and in the\ncast expression. In this case, the declaration type can be replaced with\nauto\nimproving readability and maintainability.\nTypeName\n*\nmy_pointer\n=\nstatic_cast\n<\nTypeName\n>\n(\nmy_param\n);\n// becomes\nauto\n*\nmy_pointer\n=\nstatic_cast\n<\nTypeName\n>\n(\nmy_param\n);\nThe check handles\nstatic_cast\n,\ndynamic_cast\n,\nconst_cast\n,\nreinterpret_cast\n, functional casts, C-style casts and function templates\nthat behave as casts, such as\nllvm::dyn_cast\n,\nboost::lexical_cast\nand\ngsl::narrow_cast\n. Calls to function templates are considered to behave as\ncasts if the first template argument is explicit and is a type, and the\nfunction returns that type, or a pointer or reference to it.\n\nLimitations\nIf the initializer is an explicit conversion constructor, the check will not\nreplace the type specifier even though it would be safe to do so.\nUser-defined iterators are not handled at this time.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nMinTypeNameLength\nIf the option is set to non-zero (default\n5\n), the check will ignore type\nnames having a length less than the option value. The option affects\nexpressions only, not iterators.\nSpaces between multi-lexeme type names (\nlong\nint\n) are considered as one.\nIf the\nRemoveStars\noption (see below) is set to\ntrue\n, then\n*s\nin the type are also counted as a part of the type name.\n// MinTypeNameLength = 0, RemoveStars=0\nint\na\n=\nstatic_cast\n<\nint\n>\n(\nfoo\n());\n// ---> auto a = ...\n// length(bool *) = 4\nbool\n*\nb\n=\nnew\nbool\n;\n// ---> auto *b = ...\nunsigned\nc\n=\nstatic_cast\n<\nunsigned\n>\n(\nfoo\n());\n// ---> auto c = ...\n// MinTypeNameLength = 5, RemoveStars=0\nint\na\n=\nstatic_cast\n<\nint\n>\n(\nfoo\n());\n// ---> int  a = ...\nbool\nb\n=\nstatic_cast\n<\nbool\n>\n(\nfoo\n());\n// ---> bool b = ...\nbool\n*\npb\n=\nstatic_cast\n<\nbool\n*>\n(\nfoo\n());\n// ---> bool *pb = ...\nunsigned\nc\n=\nstatic_cast\n<\nunsigned\n>\n(\nfoo\n());\n// ---> auto c = ...\n// length(long <on-or-more-spaces> int) = 8\nlong\nint\nd\n=\nstatic_cast\n<\nlong\nint\n>\n(\nfoo\n());\n// ---> auto d = ...\n// MinTypeNameLength = 5, RemoveStars=1\nint\na\n=\nstatic_cast\n<\nint\n>\n(\nfoo\n());\n// ---> int  a = ...\n// length(int * * ) = 5\nint\n**\npa\n=\nstatic_cast\n<\nint\n**>\n(\nfoo\n());\n// ---> auto pa = ...\nbool\nb\n=\nstatic_cast\n<\nbool\n>\n(\nfoo\n());\n// ---> bool b = ...\nbool\n*\npb\n=\nstatic_cast\n<\nbool\n*>\n(\nfoo\n());\n// ---> auto pb = ...\nunsigned\nc\n=\nstatic_cast\n<\nunsigned\n>\n(\nfoo\n());\n// ---> auto c = ...\nlong\nint\nd\n=\nstatic_cast\n<\nlong\nint\n>\n(\nfoo\n());\n// ---> auto d = ...\nRemoveStars\nIf the option is set to\ntrue\n(default is\nfalse\n), the check will remove\nstars from the non-typedef pointer types when replacing type names with\nauto\n. Otherwise, the check will leave stars. For example:\nTypeName\n*\nmy_first_pointer\n=\nnew\nTypeName\n,\n*\nmy_second_pointer\n=\nnew\nTypeName\n;\n// RemoveStars = 0\nauto\n*\nmy_first_pointer\n=\nnew\nTypeName\n,\n*\nmy_second_pointer\n=\nnew\nTypeName\n;\n// RemoveStars = 1\nauto\nmy_first_pointer\n=\nnew\nTypeName\n,\nmy_second_pointer\n=\nnew\nTypeName\n;"
    }
}