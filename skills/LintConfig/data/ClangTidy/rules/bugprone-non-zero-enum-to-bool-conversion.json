{
    "bugprone-non-zero-enum-to-bool-conversion": {
        "description": "Description\n\nDetect implicit and explicit casts of\nenum\ntype into\nbool\nwhere\nenum\ntype doesnâ€™t have a zero-value enumerator. If the\nenum\nis used\nonly to hold values equal to its enumerators, then conversion to\nbool\nwill\nalways result in\ntrue\nvalue. This can lead to unnecessary code that reduces\nreadability and maintainability and can result in bugs.\n\nMay produce false positives if the\nenum\nis used to store other values\n(used as a bit-mask or zero-initialized on purpose). To deal with them,\n//\nNOLINT\nor casting first to the underlying type before casting to\nbool\ncan be used.\n\nIt is important to note that this check will not generate warnings if the\ndefinition of the enumeration type is not available.\nAdditionally, C++11 enumeration classes are supported by this check.\n\nOverall, this check serves to improve code quality and readability by\nidentifying and flagging instances where implicit or explicit casts from\nenumeration types to boolean could cause potential issues.\n\nExample\nenum\nEStatus\n{\nOK\n=\n1\n,\nNOT_OK\n,\nUNKNOWN\n};\nvoid\nprocess\n(\nEStatus\nstatus\n)\n{\nif\n(\n!\nstatus\n)\n{\n// this true-branch won't be executed\nreturn\n;\n}\n// proceed with \"valid data\"\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nEnumIgnoreList\nOption is used to ignore certain enum types when checking for\nimplicit/explicit casts to bool. It accepts a semicolon-separated list of\n(fully qualified) enum type names or regular expressions that match the enum\ntype names.\nThe default value is an empty string, which means no enums will be ignored."
    }
}