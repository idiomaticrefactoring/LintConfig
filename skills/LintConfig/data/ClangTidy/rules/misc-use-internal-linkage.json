{
    "misc-use-internal-linkage": {
        "description": "Description\n\nDetects variables, functions, and classes that can be marked as static or\n(in C++) moved into an anonymous namespace to enforce internal linkage.\n\nAny entity that’s only used within a single file should be given internal\nlinkage. Doing so gives the compiler more information, allowing it to better\nremove dead code and perform more aggressive optimizations.\n\nExample:\n\nint\nv1\n;\n// can be marked as static\nvoid\nfn1\n()\n{}\n// can be marked as static\n// already declared as extern\nextern\nint\nv2\n;\nvoid\nfn3\n();\n// without function body in all declaration, maybe external linkage\nvoid\nfn3\n();\n// === C++-specific ===\nstruct\nS1\n{};\n// can be moved into anonymous namespace\nnamespace\n{\n// already in anonymous namespace\nint\nv2\n;\nvoid\nfn2\n();\nstruct\nS2\n{};\n}\n// export declarations\nexport\nvoid\nfn4\n()\n{}\nexport\nnamespace\nt\n{\nvoid\nfn5\n()\n{}\n}\nexport\nint\nv2\n;\nexport\nclass\nC\n{};",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nFixMode\nSelects what kind of a fix the check should provide. The default is\nUseStatic\n.\nNone\nDon’t fix automatically.\nUseStatic\nAdd\nstatic\nfor internal linkage variable and function.\nAnalyzeFunctions\nWhether to suggest giving functions internal linkage. Default is\ntrue\n.\nAnalyzeVariables\nWhether to suggest giving variables internal linkage. Default is\ntrue\n.\nAnalyzeTypes\n(C++ only) Whether to suggest giving user-defined types (structs,\nclasses, unions, and enums) internal linkage. Default is\ntrue\n."
    }
}