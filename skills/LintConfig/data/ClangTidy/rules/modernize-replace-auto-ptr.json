{
    "modernize-replace-auto-ptr": {
        "description": "Description\n\nThis check replaces the uses of the deprecated class\nstd::auto_ptr\nby\nstd::unique_ptr\n(introduced in C++11). The transfer of ownership, done\nby the copy-constructor and the assignment operator, is changed to match\nstd::unique_ptr\nusage by using explicit calls to\nstd::move()\n.\n\nMigration example:\n\n-\nvoid\ntake_ownership_fn\n(\nstd\n::\nauto_ptr\n<\nint\n>\nint_ptr\n);\n+\nvoid\ntake_ownership_fn\n(\nstd\n::\nunique_ptr\n<\nint\n>\nint_ptr\n);\nvoid\nf\n(\nint\nx\n)\n{\n-\nstd\n::\nauto_ptr\n<\nint\n>\na\n(\nnew\nint\n(\nx\n));\n-\nstd\n::\nauto_ptr\n<\nint\n>\nb\n;\n+\nstd\n::\nunique_ptr\n<\nint\n>\na\n(\nnew\nint\n(\nx\n));\n+\nstd\n::\nunique_ptr\n<\nint\n>\nb\n;\n-\nb\n=\na\n;\n-\ntake_ownership_fn\n(\nb\n);\n+\nb\n=\nstd\n::\nmove\n(\na\n);\n+\ntake_ownership_fn\n(\nstd\n::\nmove\n(\nb\n));\n}\n\nSince\nstd::move()\nis a library function declared in\n<utility>\nit may be\nnecessary to add this include. The check will add the include directive when\nnecessary.\n\nLimitations\nIf headers modification is not activated or if a header is not allowed to be\nchanged this check will produce broken code (compilation error), where the\nheaders’ code will stay unchanged while the code using them will be changed.\nClient code that declares a reference to an\nstd::auto_ptr\ncoming from\ncode that can’t be migrated (such as a header coming from a 3\nrd\nparty library) will produce a compilation error after migration. This is\nbecause the type of the reference will be changed to\nstd::unique_ptr\nbut\nthe type returned by the library won’t change, binding a reference to\nstd::unique_ptr\nfrom an\nstd::auto_ptr\n. This pattern doesn’t make much\nsense and usually\nstd::auto_ptr\nare stored by value (otherwise what is\nthe point in using them instead of a reference or a pointer?).\n// <3rd-party header...>\nstd\n::\nauto_ptr\n<\nint\n>\nget_value\n();\nconst\nstd\n::\nauto_ptr\n<\nint\n>\n&\nget_ref\n();\n// <calling code (with migration)...>\n-\nstd\n::\nauto_ptr\n<\nint\n>\na\n(\nget_value\n());\n+\nstd\n::\nunique_ptr\n<\nint\n>\na\n(\nget_value\n());\n// ok, unique_ptr constructed from auto_ptr\n-\nconst\nstd\n::\nauto_ptr\n<\nint\n>\n&\np\n=\nget_ptr\n();\n+\nconst\nstd\n::\nunique_ptr\n<\nint\n>\n&\np\n=\nget_ptr\n();\n// won't compile\nNon-instantiated templates aren’t modified.\ntemplate\n<\ntypename\nX\n>\nvoid\nf\n()\n{\nstd\n::\nauto_ptr\n<\nX\n>\np\n;\n}\n// only 'f<int>()' (or similar) will trigger the replacement.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nIncludeStyle\nA string specifying which include-style is used,\nllvm\nor\ngoogle\n. Default\nis\nllvm\n."
    }
}