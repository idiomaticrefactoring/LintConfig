{
    "modernize-use-std-print": {
        "description": "Description\n\nConverts calls to\nprintf\n,\nfprintf\n,\nabsl::PrintF\nand\nabsl::FPrintf\nto equivalent calls to C++23’s\nstd::print\nor\nstd::println\nas appropriate, modifying the format string appropriately.\nThe replaced and replacement functions can be customised by configuration\noptions. Each argument that is the result of a call to\nstd::string::c_str()\nand\nstd::string::data()\nwill have that\nnow-unnecessary call removed in a similar manner to the\nreadability-redundant-string-cstr\ncheck.\n\nIn other words, it turns lines like:\n\nfprintf\n(\nstderr\n,\n\"The %s is %3d\n\\n\n\"\n,\ndescription\n.\nc_str\n(),\nvalue\n);\n\ninto:\n\nstd\n::\nprintln\n(\nstderr\n,\n\"The {} is {:3}\"\n,\ndescription\n,\nvalue\n);\n\nIf the\nReplacementPrintFunction\nor\nReplacementPrintlnFunction\noptions\nare left at or set to their default values then this check is only enabled\nwith\n-std=c++23\nor later.\n\nMacros starting with\nPRI\nand\n__PRI\nfrom\n<inttypes.h>\nare\nexpanded, escaping is handled and adjacent strings are concatenated to form\na single\nStringLiteral\nbefore the format string is converted. Use of\nany other macros in the format string will cause a warning message to be\nemitted and no conversion will be performed. The converted format string\nwill always be a single string literal.\n\nThe check doesn’t do a bad job, but it’s not perfect. In particular:\n\nIt assumes that the format string is correct for the arguments. If you\nget any warnings when compiling with\n-Wformat\nthen misbehaviour is\npossible.\nAt the point that the check runs, the AST contains a single\nStringLiteral\nfor the format string where escapes have been expanded.\nThe check tries to reconstruct escape sequences, they may not be the same\nas they were written (e.g.\n\"\\x41\\x0a\"\nwill become\n\"A\\n\"\nand\n\"ab\"\n\"cd\"\nwill become\n\"abcd\"\n.)\nIt supports field widths, precision, positional arguments, leading zeros,\nleading\n+\n, alignment and alternative forms.\nUse of any unsupported flags or specifiers will cause the entire\nstatement to be left alone and a warning to be emitted. Particular\nunsupported features are:\nThe\n%'\nflag for thousands separators.\nThe glibc extension\n%m\n.\nprintf\nand similar functions return the number of characters printed.\nstd::print\ndoes not. This means that any invocations that use the\nreturn value will not be converted. Unfortunately this currently includes\nexplicitly-casting to\nvoid\n. Deficiencies in this check mean that any\ninvocations inside\nGCC\ncompound statements cannot be converted even\nif the resulting value is not used.\n\nIf conversion would be incomplete or unsafe then the entire invocation will\nbe left unchanged.\n\nIf the call is deemed suitable for conversion then:\n\nprintf\n,\nfprintf\n,\nabsl::PrintF\n,\nabsl::FPrintF\nand any\nfunctions specified by the\nPrintfLikeFunctions\noption or\nFprintfLikeFunctions\nare replaced with the function specified by the\nReplacementPrintlnFunction\noption if the format string ends with\n\\n\nor\nReplacementPrintFunction\notherwise.\nthe format string is rewritten to use the\nstd::formatter\nlanguage. If\na\n\\n\nis found at the end of the format string not preceded by\nr\nthen it is removed and\nReplacementPrintlnFunction\nis used rather than\nReplacementPrintFunction\n.\nany arguments that corresponded to\n%p\nspecifiers that\nstd::formatter\nwouldn’t accept are wrapped in a\nstatic_cast\nto\nconst\nvoid\n*\n.\nany arguments that corresponded to\n%s\nspecifiers where the argument\nis of\nsigned\nchar\nor\nunsigned\nchar\ntype are wrapped in a\nreinterpret_cast<const\nchar\n*>\n.\nany arguments where the format string and the parameter differ in\nsignedness will be wrapped in an appropriate\nstatic_cast\nif\nStrictMode\nis enabled.\nany arguments that end in a call to\nstd::string::c_str()\nor\nstd::string::data()\nwill have that call removed.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nStrictMode\nWhen\ntrue\n, the check will add casts when converting from variadic\nfunctions like\nprintf\nand printing signed or unsigned integer types\n(including fixed-width integer types from\n<cstdint>\n,\nptrdiff_t\n,\nsize_t\nand\nssize_t\n) as the opposite signedness to ensure that\nthe output matches that of\nprintf\n. This does not apply when\nconverting from non-variadic functions such as\nabsl::PrintF\nand\nfmt::printf\n. For example, with\nStrictMode\nenabled:\nint\ni\n=\n-42\n;\nunsigned\nint\nu\n=\n0xffffffff\n;\nprintf\n(\n\"%u %d\n\\n\n\"\n,\ni\n,\nu\n);\nwould be converted to:\nstd\n::\nprint\n(\n\"{} {}\n\\n\n\"\n,\nstatic_cast\n<\nunsigned\nint\n>\n(\ni\n),\nstatic_cast\n<\nint\n>\n(\nu\n));\nto ensure that the output will continue to be the unsigned representation\nof\n-42\nand the signed representation of\n0xffffffff\n(often\n4294967254\nand\n-1\nrespectively.) When\nfalse\n(which is the default),\nthese casts will not be added which may cause a change in the output.\nPrintfLikeFunctions\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement\nthat the first parameter contains the printf-style format string and the\narguments to be formatted follow immediately afterwards. Qualified member\nfunction names are supported, but the replacement function name must be\nunqualified. If neither this option nor\nFprintfLikeFunctions\nare set then\nthe default value is\nprintf; absl::PrintF\n, otherwise it is the empty\nstring.\nFprintfLikeFunctions\nA semicolon-separated list of regular expressions matching the\n(fully qualified) names of functions to replace, with the requirement\nthat the first parameter is retained, the second parameter contains the\nprintf-style format string and the arguments to be formatted follow\nimmediately afterwards. Qualified member function names are supported,\nbut the replacement function name must be unqualified. If neither this\noption nor\nPrintfLikeFunctions\nare set then the default value is\nfprintf;absl::FPrintF\n, otherwise it is the empty string.\nReplacementPrintFunction\nThe function that will be used to replace\nprintf\n,\nfprintf\netc.\nduring conversion rather than the default\nstd::print\nwhen the\noriginalformat string does not end with\n\\n\n. It is expected that the\nfunction provides an interface that is compatible with\nstd::print\n. A\nsuitable candidate would be\nfmt::print\n.\nReplacementPrintlnFunction\nThe function that will be used to replace\nprintf\n,\nfprintf\netc.\nduring conversion rather than the default\nstd::println\nwhen the\noriginal format string ends with\n\\n\n. It is expected that the\nfunction provides an interface that is compatible with\nstd::println\n.\nA suitable candidate would be\nfmt::println\n.\nPrintHeader\nThe header that must be included for the declaration of\nReplacementPrintFunction\nso that a\n#include\ndirective can be\nadded if required. If\nReplacementPrintFunction\nis\nstd::print\nthen this option will default to\n<print>\n, otherwise this option will\ndefault to nothing and no\n#include\ndirective will be added."
    }
}