{
    "bugprone-narrowing-conversions": {
        "description": "Description\n\ncppcoreguidelines-narrowing-conversions\nredirects here as an alias for\nthis check.\n\nChecks for silent narrowing conversions, e.g:\nint\ni\n=\n0;\ni\n+=\n0.1;\n. While\nthe issue is obvious in this former example, it might not be so in the\nfollowing:\nvoid\nMyClass::f(double\nd)\n{\nint_member_\n+=\nd;\n}\n.\n\nWe flag narrowing conversions from:\nan integer to a narrower integer (e.g.\nchar\nto\nunsigned\nchar\n)\nif WarnOnIntegerNarrowingConversion Option is set,\nan integer to a narrower floating-point (e.g.\nuint64_t\nto\nfloat\n)\nif WarnOnIntegerToFloatingPointNarrowingConversion Option is set,\na floating-point to an integer (e.g.\ndouble\nto\nint\n),\na floating-point to a narrower floating-point (e.g.\ndouble\nto\nfloat\n)\nif WarnOnFloatingPointNarrowingConversion Option is set.\nThis check will flag:\nAll narrowing conversions that are not marked by an explicit cast (c-style\nor\nstatic_cast\n). For example:\nint\ni\n=\n0;\ni\n+=\n0.1;\n,\nvoid\nf(int);\nf(0.1);\n,\nAll applications of binary operators with a narrowing conversions.\nFor example:\nint\ni;\ni+=\n0.1;\n.\n\nArithmetic with smaller integer types than\nint\ntrigger implicit conversions,\nas explained under\n“Integral Promotion” on cppreference.com\n.\nThis check diagnoses more instances of narrowing than the compiler warning\n-Wconversion\ndoes. The example below demonstrates this behavior.\n\n// The following function definition demonstrates usage of arithmetic with\n// integer types smaller than `int` and how the narrowing conversion happens\n// implicitly.\nvoid\ncomputation\n(\nshort\nargument1\n,\nshort\nargument2\n)\n{\n// Arithmetic written by humans:\nshort\nresult\n=\nargument1\n+\nargument2\n;\n// Arithmetic actually performed by C++:\nshort\nresult\n=\nstatic_cast\n<\nshort\n>\n(\nstatic_cast\n<\nint\n>\n(\nargument1\n)\n+\nstatic_cast\n<\nint\n>\n(\nargument2\n));\n}\nvoid\nrecommended_resolution\n(\nshort\nargument1\n,\nshort\nargument2\n)\n{\nshort\nresult\n=\nargument1\n+\nargument2\n;\n//           ^ warning: narrowing conversion from 'int' to signed type 'short' is implementation-defined\n// The cppcoreguidelines recommend to resolve this issue by using the GSL\n// in one of two ways. Either by a cast that throws if a loss of precision\n// would occur.\nshort\nresult\n=\ngsl\n::\nnarrow\n<\nshort\n>\n(\nargument1\n+\nargument2\n);\n// Or it can be resolved without checking the result risking invalid results.\nshort\nresult\n=\ngsl\n::\nnarrow_cast\n<\nshort\n>\n(\nargument1\n+\nargument2\n);\n// A classical `static_cast` will silence the warning as well if the GSL\n// is not available.\nshort\nresult\n=\nstatic_cast\n<\nshort\n>\n(\nargument1\n+\nargument2\n);\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nWarnOnIntegerNarrowingConversion\nWhen\ntrue\n, the check will warn on narrowing integer conversion\n(e.g.\nint\nto\nsize_t\n).\ntrue\nby default.\nWarnOnIntegerToFloatingPointNarrowingConversion\nWhen\ntrue\n, the check will warn on narrowing integer to floating-point\nconversion (e.g.\nsize_t\nto\ndouble\n).\ntrue\nby default.\nWarnOnFloatingPointNarrowingConversion\nWhen\ntrue\n, the check will warn on narrowing floating point conversion\n(e.g.\ndouble\nto\nfloat\n).\ntrue\nby default.\nWarnWithinTemplateInstantiation\nWhen\ntrue\n, the check will warn on narrowing conversions within template\ninstantiations.\nfalse\nby default.\nWarnOnEquivalentBitWidth\nWhen\ntrue\n, the check will warn on narrowing conversions that arise from\ncasting between types of equivalent bit width. (e.g.\nint n = uint(0);\nor\nlong long n = double(0);\n)\ntrue\nby default.\nIgnoreConversionFromTypes\nNarrowing conversions from any type in this semicolon-separated list will be\nignored. This may be useful to weed out commonly occurring, but less commonly\nproblematic assignments such as\nint n = std::vector<char>().size();\nor\nint n = std::difference(it1, it2);\n. The default list is empty, but one\nsuggested list for a legacy codebase would be\nsize_t;ptrdiff_t;size_type;difference_type\n.\nPedanticMode\nWhen\ntrue\n, the check will warn on assigning a floating point constant\nto an integer value even if the floating point value is exactly\nrepresentable in the destination type (e.g.\nint\ni\n=\n1.0;\n).\nfalse\nby default.\n\nFAQ\nWhat does “narrowing conversion from ‘int’ to ‘float’” mean?\nAn IEEE754 Floating Point number can represent all integer values in the range\n[-2^PrecisionBits, 2^PrecisionBits] where PrecisionBits is the number of bits\nin the mantissa.\nFor\nfloat\nthis would be [-2^23, 2^23], where\nint\ncan represent values\nin the range [-2^31, 2^31-1].\nWhat does “implementation-defined” mean?\nYou may have encountered messages like “narrowing conversion from ‘unsigned\nint’ to signed type ‘int’ is implementation-defined”.\nThe C/C++ standard does not mandate two’s complement for signed integers, and\nso the compiler is free to define what the semantics are for converting an\nunsigned integer to signed integer. Clang’s implementation uses the two’s\ncomplement format."
    }
}