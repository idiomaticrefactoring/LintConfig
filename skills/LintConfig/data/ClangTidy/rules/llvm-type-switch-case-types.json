{
    "llvm-type-switch-case-types": {
        "description": "Description\n\nFinds\nllvm::TypeSwitch::Case\ncalls with redundant explicit template\narguments that can be inferred from the lambda parameter type.\n\nThis check identifies two patterns:\n\nRedundant explicit type\n: When the lambda parameter type matches the\nCase\ntemplate argument, the explicit type can be removed.\nAuto parameter with explicit type\n: When a lambda uses\nauto\nbut\nCase\nhas an explicit template argument, suggests using an explicit\ntype in the lambda instead.\n\nExample\nllvm\n::\nTypeSwitch\n<\nBase\n*\n,\nint\n>\n(\nbase\n)\n.\nCase\n<\nDerivedA\n>\n([](\nDerivedA\n*\na\n)\n{\nreturn\n1\n;\n})\n// Redundant.\n.\nCase\n<\nDerivedB\n>\n([](\nauto\nb\n)\n{\nreturn\n2\n;\n});\n// `auto` with explicit type.\nTransforms to:\nllvm\n::\nTypeSwitch\n<\nBase\n*\n,\nint\n>\n(\nbase\n)\n.\nCase\n([](\nDerivedA\n*\na\n)\n{\nreturn\n1\n;\n})\n// Type inferred from lambda.\n.\nCase\n<\nDerivedB\n>\n([](\nauto\nb\n)\n{\nreturn\n2\n;\n});\n// Warning only.\nNote: The second case (\nauto\nparameter) only emits a warning without a\nfix-it, because the deduced type of\nauto\ndepends on\ndyn_cast\nbehavior\nwhich varies between pointer types and MLIR handle types.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}