{
    "bugprone-inc-dec-in-conditions": {
        "description": "Description\n\nDetects when a variable is both incremented/decremented and referenced inside a\ncomplex condition and suggests moving them outside to avoid ambiguity in the\nvariable’s value.\n\nWhen a variable is modified and also used in a complex condition, it can lead\nto unexpected behavior. The side-effect of changing the variable’s value within\nthe condition can make the code difficult to reason about. Additionally, the\ndeveloper’s intended timing for the modification of the variable may not be\nclear, leading to misunderstandings and errors. This can be particularly\nproblematic when the condition involves logical operators like\n&&\nand\n||\n, where the order of evaluation can further complicate the situation.\n\nConsider the following example:\n\nint\ni\n=\n0\n;\n// ...\nif\n(\ni\n++\n<\n5\n&&\ni\n>\n0\n)\n{\n// do something\n}\n\nIn this example, the result of the expression may not be what the developer\nintended. The original intention of the developer could be to increment\ni\nafter the entire condition is evaluated, but in reality, i will be incremented\nbefore\ni\n>\n0\nis executed. This can lead to unexpected behavior and bugs in\nthe code. To fix this issue, the developer should separate the increment\noperation from the condition and perform it separately. For example, they can\nincrement\ni\nin a separate statement before or after the condition is\nevaluated. This ensures that the value of\ni\nis predictable and consistent\nthroughout the code.\n\nint\ni\n=\n0\n;\n// ...\ni\n++\n;\nif\n(\ni\n<=\n5\n&&\ni\n>\n0\n)\n{\n// do something\n}\n\nAnother common issue occurs when multiple increments or decrements are\nperformed on the same variable inside a complex condition. For example:\n\nint\ni\n=\n4\n;\n// ...\nif\n(\ni\n++\n<\n5\n||\n--\ni\n>\n2\n)\n{\n// do something\n}\n\nThere is a potential issue with this code due to the order of evaluation in\nC++. The\n||\noperator used in the condition statement guarantees that if\nthe first operand evaluates to\ntrue\n, the second operand will not be\nevaluated. This means that if\ni\nwere initially\n4\n, the first operand\ni\n<\n5\nwould evaluate to\ntrue\nand the second operand\ni\n>\n2\nwould\nnot be evaluated. As a result, the decrement operation\n--i\nwould not be\nexecuted and\ni\nwould hold value\n5\n, which may not be the intended\nbehavior for the developer.\n\nTo avoid this potential issue, the both increment and decrement operation on\ni\nshould be moved outside the condition statement.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}