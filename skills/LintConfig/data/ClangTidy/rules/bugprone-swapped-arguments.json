{
    "bugprone-swapped-arguments": {
        "description": "Description\n\nFinds potentially swapped arguments by examining implicit conversions.\nIt analyzes the types of the arguments being passed to a function and compares\nthem to the expected types of the corresponding parameters. If there is a\nmismatch or an implicit conversion that indicates a potential swap, a warning\nis raised.\n\nvoid\nprintNumbers\n(\nint\na\n,\nfloat\nb\n);\nint\nmain\n()\n{\n// Swapped arguments: float passed as int, int as float)\nprintNumbers\n(\n10.0f\n,\n5\n);\nreturn\n0\n;\n}\n\nCovers a wide range of implicit conversions, including:\n- User-defined conversions\n- Conversions from floating-point types to boolean or integral types\n- Conversions from integral types to boolean or floating-point types\n- Conversions from boolean to integer types or floating-point types\n- Conversions from (member) pointers to boolean\n\nIt is important to note that for most argument swaps, the types need to match\nexactly. However, there are exceptions to this rule. Specifically, when the\nswapped argument is of integral type, an exact match is not always necessary.\nImplicit casts from other integral types are also accepted. Similarly, when\ndealing with floating-point arguments, implicit casts between different\nfloating-point types are considered acceptable.\n\nTo avoid confusion, swaps where both swapped arguments are of integral types or\nboth are of floating-point types do not trigger the warning. In such cases,\nitâ€™s assumed that the developer intentionally used different integral or\nfloating-point types and does not raise a warning. This approach prevents false\npositives and provides flexibility in handling situations where varying\nintegral or floating-point types are intentionally utilized.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}