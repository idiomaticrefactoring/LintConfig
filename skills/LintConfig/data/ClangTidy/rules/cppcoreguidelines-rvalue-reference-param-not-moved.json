{
    "cppcoreguidelines-rvalue-reference-param-not-moved": {
        "description": "Description\n\nWarns when an rvalue reference function parameter is never moved within\nthe function body.\n\nRvalue reference parameters indicate a parameter that should be moved with\nstd::move\nfrom within the function body. Any such parameter that is\nnever moved is confusing and potentially indicative of a buggy program.\n\nExample:\n\nvoid\nlogic\n(\nstd\n::\nstring\n&&\nInput\n)\n{\nstd\n::\nstring\nCopy\n(\nInput\n);\n// Oops - forgot to std::move\n}\n\nNote that parameters that are unused and marked as such will not be diagnosed.\n\nExample:\n\nvoid\nconditional_use\n([[\nmaybe_unused\n]]\nstd\n::\nstring\n&&\nInput\n)\n{\n// No diagnostic here since Input is unused and marked as such\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nAllowPartialMove\nIf set to\ntrue\n, the check accepts\nstd::move\ncalls containing any\nsubexpression containing the parameter. CppCoreGuideline F.18 officially\nmandates that the parameter itself must be moved. Default is\nfalse\n.\n// 'p' is flagged by this check if and only if AllowPartialMove is false\nvoid\nmove_members_of\n(\npair\n<\nObj\n,\nObj\n>&&\np\n)\n{\npair\n<\nObj\n,\nObj\n>\nother\n;\nother\n.\nfirst\n=\nstd\n::\nmove\n(\np\n.\nfirst\n);\nother\n.\nsecond\n=\nstd\n::\nmove\n(\np\n.\nsecond\n);\n}\n// 'p' is never flagged by this check\nvoid\nmove_whole_pair\n(\npair\n<\nObj\n,\nObj\n>&&\np\n)\n{\npair\n<\nObj\n,\nObj\n>\nother\n=\nstd\n::\nmove\n(\np\n);\n}\nIgnoreUnnamedParams\nIf set to\ntrue\n, the check ignores unnamed rvalue reference parameters.\nDefault is\nfalse\n.\nIgnoreNonDeducedTemplateTypes\nIf set to\ntrue\n, the check ignores non-deduced template type rvalue\nreference parameters. Default is\nfalse\n.\ntemplate\n<\nclass\nT\n>\nstruct\nSomeClass\n{\n// Below, 'T' is not deduced and 'T&&' is an rvalue reference type.\n// This will be flagged if and only if IgnoreNonDeducedTemplateTypes is\n// false. One suggested fix would be to specialize the class for 'T' and\n// 'T&' separately (e.g., see std::future), or allow only one of 'T' or\n// 'T&' instantiations of SomeClass (e.g., see std::optional).\nSomeClass\n(\nT\n&&\nt\n)\n{\n}\n};\n// Never flagged, since 'T' is a forwarding reference in a deduced context\ntemplate\n<\nclass\nT\n>\nvoid\nforwarding_ref\n(\nT\n&&\nt\n)\n{\nT\nother\n=\nstd\n::\nforward\n<\nT\n>\n(\nt\n);\n}\nMoveFunction\nSpecify the function used for moving. Default is\n::std::move\n.\nThis check implements\nF.18\nfrom the C++ Core Guidelines."
    }
}