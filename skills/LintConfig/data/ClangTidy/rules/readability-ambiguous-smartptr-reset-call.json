{
    "readability-ambiguous-smartptr-reset-call": {
        "description": "Description\n\nFinds potentially erroneous calls to\nreset\nmethod on smart pointers when\nthe pointee type also has a\nreset\nmethod. Having a\nreset\nmethod in\nboth classes makes it easy to accidentally make the pointer null when\nintending to reset the underlying object.\n\nstruct\nResettable\n{\nvoid\nreset\n()\n{\n/* Own reset logic */\n}\n};\nauto\nptr\n=\nstd\n::\nmake_unique\n<\nResettable\n>\n();\nptr\n->\nreset\n();\n// Calls underlying reset method\nptr\n.\nreset\n();\n// Makes the pointer null\n\nBoth calls are valid C++ code, but the second one might not be what the\ndeveloper intended, as it destroys the pointed-to object rather than resetting\nits state. It’s easy to make such a typo because the difference between\n.\nand\n->\nis really small.\n\nThe recommended approach is to make the intent explicit by using either member\naccess or direct assignment:\n\nstd\n::\nunique_ptr\n<\nResettable\n>\nptr\n=\nstd\n::\nmake_unique\n<\nResettable\n>\n();\n(\n*\nptr\n).\nreset\n();\n// Clearly calls underlying reset method\nptr\n=\nnullptr\n;\n// Clearly makes the pointer null\n\nThe default smart pointers and classes that are considered are\nstd::unique_ptr\n,\nstd::shared_ptr\n,\nboost::shared_ptr\n. To specify\nother smart pointers or other classes use the\nSmartPointers\noption.\n\nNote\nThe check may emit invalid fix-its and misleading warning messages when\nspecifying custom smart pointers or other classes in the\nSmartPointers\noption. For example,\nboost::scoped_ptr\ndoes not\nhave an\noperator=\nwhich makes fix-its invalid.\n\nNote\nAutomatic fix-its are enabled only if\nclang-tidy\nis invoked with\nthe\n–fix-notes\noption.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nSmartPointers\nSemicolon-separated list of fully qualified class names of custom smart\npointers. Default value is\n::std::unique_ptr;::std::shared_ptr;\n::boost::shared_ptr\n."
    }
}