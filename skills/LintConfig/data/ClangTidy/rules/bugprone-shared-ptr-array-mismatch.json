{
    "bugprone-shared-ptr-array-mismatch": {
        "description": "Description\n\nFinds initializations of C++ shared pointers to non-array type that are\ninitialized with an array.\n\nIf a shared pointer\nstd::shared_ptr<T>\nis initialized with a new-expression\nnew\nT[]\nthe memory is not deallocated correctly. The pointer uses plain\ndelete\nin this case to deallocate the target memory. Instead a\ndelete[]\ncall is needed. A\nstd::shared_ptr<T[]>\ncalls the correct delete operator.\n\nThe check offers replacement of\nshared_ptr<T>\nto\nshared_ptr<T[]>\nif it\nis used at a single variable declaration (one variable in one statement).\n\nExample:\n\nstd\n::\nshared_ptr\n<\nFoo\n>\nx\n(\nnew\nFoo\n[\n10\n]);\n// -> std::shared_ptr<Foo[]> x(new Foo[10]);\n//                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\nstd\n::\nshared_ptr\n<\nFoo\n>\nx1\n(\nnew\nFoo\n),\nx2\n(\nnew\nFoo\n[\n10\n]);\n// no replacement\n//                                   ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\nstd\n::\nshared_ptr\n<\nFoo\n>\nx3\n(\nnew\nFoo\n[\n10\n],\n[](\nconst\nFoo\n*\nptr\n)\n{\ndelete\n[]\nptr\n;\n});\n// no warning\nstruct\nS\n{\nstd\n::\nshared_ptr\n<\nFoo\n>\nx\n(\nnew\nFoo\n[\n10\n]);\n// no replacement in this case\n//                     ^ warning: shared pointer to non-array is initialized with array [bugprone-shared-ptr-array-mismatch]\n};\n\nThis check partially covers the CERT C++ Coding Standard rule\nMEM51-CPP. Properly deallocate dynamically allocated resources\nHowever, only the\nstd::shared_ptr\ncase is detected by this check.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}