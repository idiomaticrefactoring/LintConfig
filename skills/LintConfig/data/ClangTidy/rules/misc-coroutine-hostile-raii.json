{
    "misc-coroutine-hostile-raii": {
        "description": "Description\n\nDetects when objects of certain hostile RAII types persists across suspension\npoints in a coroutine. Such hostile types include scoped-lockable types and\ntypes belonging to a configurable denylist.\n\nSome objects require that they be destroyed on the same thread that created\nthem. Traditionally this requirement was often phrased as “must be a local\nvariable”, under the assumption that local variables always work this way.\nHowever this is incorrect with C++20 coroutines, since an intervening\nco_await\nmay cause the coroutine to suspend and later be resumed on\nanother thread.\n\nThe lifetime of an object that requires being destroyed on the same thread\nmust not encompass a\nco_await\nor\nco_yield\npoint. If you create/destroy\nan object, you must do so without allowing the coroutine to suspend in the\nmeantime.\n\nFollowing types are considered as hostile:\n\nScoped-lockable types: A scoped-lockable object persisting across a\nsuspension point is problematic as the lock held by this object could\nbe unlocked by a different thread. This would be undefined behaviour.\nThis includes all types annotated with the\nscoped_lockable\nattribute.\nTypes belonging to a configurable denylist.\n\n// Call some async API while holding a lock.\ntask\ncoro\n()\n{\nconst\nstd\n::\nlock_guard\nl\n(\n&\nmu_\n);\n// Oops! The async Bar function may finish on a different\n// thread from the one that created the lock_guard (and called\n// Mutex::Lock). After suspension, Mutex::Unlock will be called on the wrong thread.\nco_await\nBar\n();\n}",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nRAIITypesList\nA semicolon-separated list of qualified types which should not be allowed to\npersist across suspension points.\nEg:\nmy::lockable;a::b;::my::other::lockable\nThe default value of this option is\nstd::lock_guard;std::scoped_lock\n.\nAllowedAwaitablesList\nA semicolon-separated list of qualified types of awaitables types which can\nbe safely awaited while having hostile RAII objects in scope.\nco_await\n-ing an expression of\nawaitable\ntype is considered\nsafe if the\nawaitable\ntype is part of this list.\nRAII objects persisting across such a\nco_await\nexpression are\nconsidered safe and hence are not flagged.\nExample usage:\n// Consider option AllowedAwaitablesList = \"safe_awaitable\"\nstruct\nsafe_awaitable\n{\nbool\nawait_ready\n()\nnoexcept\n{\nreturn\nfalse\n;\n}\nvoid\nawait_suspend\n(\nstd\n::\ncoroutine_handle\n<>\n)\nnoexcept\n{}\nvoid\nawait_resume\n()\nnoexcept\n{}\n};\nauto\nwait\n()\n{\nreturn\nsafe_awaitable\n{};\n}\ntask\ncoro\n()\n{\n// This persists across both the co_await's but is not flagged\n// because the awaitable is considered safe to await on.\nconst\nstd\n::\nlock_guard\nl\n(\n&\nmu_\n);\nco_await\nsafe_awaitable\n{};\nco_await\nwait\n();\n}\nEg:\nmy::safe::awaitable;other::awaitable\nDefault is an empty string.\nAllowedCallees\nA semicolon-separated list of callee function names which can\nbe safely awaited while having hostile RAII objects in scope.\nExample usage:\n// Consider option AllowedCallees = \"noop\"\ntask\nnoop\n()\n{\nco_return\n;\n}\ntask\ncoro\n()\n{\n// This persists across the co_await but is not flagged\n// because the awaitable is considered safe to await on.\nconst\nstd\n::\nlock_guard\nl\n(\n&\nmu_\n);\nco_await\nnoop\n();\n}\nEg:\nmy::safe::await;other::await\nDefault is an empty string."
    }
}