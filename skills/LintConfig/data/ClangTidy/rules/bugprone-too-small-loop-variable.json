{
    "bugprone-too-small-loop-variable": {
        "description": "Description\n\nDetects those\nfor\nloops that have a loop variable with a “too small” type\nwhich means this type can’t represent all values which are part of the\niteration range.\n\nint\nmain\n()\n{\nlong\nsize\n=\n294967296l\n;\nfor\n(\nshort\ni\n=\n0\n;\ni\n<\nsize\n;\n++\ni\n)\n{}\n}\n\nThis\nfor\nloop is an infinite loop because the\nshort\ntype can’t\nrepresent all values in the\n[0..size]\ninterval.\n\nIn a real use case size means a container’s size which depends on the\nuser input.\n\nint\ndoSomething\n(\nconst\nstd\n::\nvector\n&\nitems\n)\n{\nfor\n(\nshort\ni\n=\n0\n;\ni\n<\nitems\n.\nsize\n();\n++\ni\n)\n{}\n}\n\nThis algorithm works for a small amount of objects, but will lead to freeze for\na larger user input.\n\nIt’s recommended to enable the compiler warning\n-Wtautological-constant-out-of-range-compare\nas well, since check does\nnot inspect compile-time constant loop boundaries to avoid overlaps with\nthe warning.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nMagnitudeBitsUpperLimit\nUpper limit for the magnitude bits of the loop variable. If it’s set the check\nfilters out those catches in which the loop variable’s type has more magnitude\nbits as the specified upper limit. The default value is 16.\nFor example, if the user sets this option to 31 (bits), then a 32-bit\nunsigned\nint\nis ignored by the check, however a 32-bit\nint\nis not (A 32-bit\nsigned\nint\nhas 31 magnitude bits).\nint\nmain\n()\n{\nlong\nsize\n=\n294967296l\n;\nfor\n(\nunsigned\ni\n=\n0\n;\ni\n<\nsize\n;\n++\ni\n)\n{}\n// no warning with MagnitudeBitsUpperLimit = 31 on a system where unsigned is 32-bit\nfor\n(\nint\ni\n=\n0\n;\ni\n<\nsize\n;\n++\ni\n)\n{}\n// warning with MagnitudeBitsUpperLimit = 31 on a system where int is 32-bit\n}"
    }
}