{
    "bugprone-incorrect-enable-if": {
        "description": "Description\n\nDetects incorrect usages of\nstd::enable_if\nthat donâ€™t name the nested\ntype\ntype.\n\nIn C++11 introduced\nstd::enable_if\nas a convenient way to leverage SFINAE.\nOne form of using\nstd::enable_if\nis to declare an unnamed template type\nparameter with a default type equal to\ntypename\nstd::enable_if<condition>::type\n. If the author forgets to name\nthe nested type\ntype\n, then the code will always consider the candidate\ntemplate even if the condition is not met.\n\nBelow are some examples of code using\nstd::enable_if\ncorrectly and\nincorrect examples that this check flags.\n\ntemplate\n<\ntypename\nT\n,\ntypename\n=\ntypename\nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>::\ntype\n>\nvoid\nvalid_usage\n()\n{\n...\n}\ntemplate\n<\ntypename\nT\n,\ntypename\n=\nstd\n::\nenable_if_t\n<\nT\n::\nsome_trait\n>>\nvoid\nvalid_usage_with_trait_helpers\n()\n{\n...\n}\n// The below code is not a correct application of SFINAE. Even if\n// T::some_trait is not true, the function will still be considered in the\n// set of function candidates. It can either incorrectly select the function\n// when it should not be a candidates, and/or lead to hard compile errors\n// if the body of the template does not compile if the condition is not\n// satisfied.\ntemplate\n<\ntypename\nT\n,\ntypename\n=\nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>>\nvoid\ninvalid_usage\n()\n{\n...\n}\n// The tool suggests the following replacement for 'invalid_usage':\ntemplate\n<\ntypename\nT\n,\ntypename\n=\ntypename\nstd\n::\nenable_if\n<\nT\n::\nsome_trait\n>::\ntype\n>\nvoid\nfixed_invalid_usage\n()\n{\n...\n}\n\nC++14 introduced the trait helper\nstd::enable_if_t\nwhich reduces the\nlikelihood of this error. C++20 introduces constraints, which generally\nsupersede the use of\nstd::enable_if\n. See\nmodernize-type-traits\nfor another tool\nthat will replace\nstd::enable_if\nwith\nstd::enable_if_t\n, and see\nmodernize-use-constraints\nfor another\ntool that replaces\nstd::enable_if\nwith C++20 constraints. Consider these\nnewer mechanisms where possible.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nThis rule has no specific options."
    }
}