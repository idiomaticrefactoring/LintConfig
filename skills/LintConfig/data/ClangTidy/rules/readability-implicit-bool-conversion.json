{
    "readability-implicit-bool-conversion": {
        "description": "Description\n\nThis check can be used to find implicit conversions between built-in types and\nbooleans. Depending on use case, it may simply help with readability of the\ncode, or in some cases, point to potential bugs which remain unnoticed due to\nimplicit conversions.\n\nThe following is a real-world example of bug which was hiding behind implicit\nbool\nconversion:\n\nclass\nFoo\n{\nint\nm_foo\n;\npublic\n:\nvoid\nsetFoo\n(\nbool\nfoo\n)\n{\nm_foo\n=\nfoo\n;\n}\n// warning: implicit conversion bool -> int\nint\ngetFoo\n()\n{\nreturn\nm_foo\n;\n}\n};\nvoid\nuse\n(\nFoo\n&\nfoo\n)\n{\nbool\nvalue\n=\nfoo\n.\ngetFoo\n();\n// warning: implicit conversion int -> bool\n}\n\nThis code is the result of unsuccessful refactoring, where type of\nm_foo\nchanged from\nbool\nto\nint\n. The programmer forgot to change all\noccurrences of\nbool\n, and the remaining code is no longer correct, yet it\nstill compiles without any visible warnings.\n\nIn addition to issuing warnings, fix-it hints are provided to help solve the\nreported issues. This can be used for improving readability of code, for\nexample:\n\nvoid\nconversionsToBool\n()\n{\nfloat\nfloating\n;\nbool\nboolean\n=\nfloating\n;\n// ^ propose replacement: bool boolean = floating != 0.0f;\nint\ninteger\n;\nif\n(\ninteger\n)\n{}\n// ^ propose replacement: if (integer != 0) {}\nint\n*\npointer\n;\nif\n(\n!\npointer\n)\n{}\n// ^ propose replacement: if (pointer == nullptr) {}\nwhile\n(\n1\n)\n{}\n// ^ propose replacement: while (true) {}\n}\nvoid\nfunctionTakingInt\n(\nint\nparam\n);\nvoid\nconversionsFromBool\n()\n{\nbool\nboolean\n;\nfunctionTakingInt\n(\nboolean\n);\n// ^ propose replacement: functionTakingInt(static_cast<int>(boolean));\nfunctionTakingInt\n(\ntrue\n);\n// ^ propose replacement: functionTakingInt(1);\n}\n\nIn general, the following conversion types are checked:\n\ninteger expression/literal to boolean (conversion from a single bit bitfield\nto boolean is explicitly allowed, since thereâ€™s no ambiguity / information\nloss in this case),\nfloating expression/literal to boolean,\npointer/pointer to member/\nnullptr\n/\nNULL\nto boolean,\nboolean expression/literal to integer (conversion from boolean to a single\nbit bitfield is explicitly allowed),\nboolean expression/literal to floating.\n\nThe rules for generating fix-it hints are:\n\nin case of conversions from other built-in type to bool, an explicit\ncomparison is proposed to make it clear what exactly is being compared:\nbool\nboolean\n=\nfloating;\nis changed to\nbool\nboolean\n=\nfloating\n==\n0.0f;\n,\nfor other types, appropriate literals are used (\n0\n,\n0u\n,\n0.0f\n,\n0.0\n,\nnullptr\n),\nin case of negated expressions conversion to bool, the proposed replacement\nwith comparison is simplified:\nif\n(!pointer)\nis changed to\nif\n(pointer\n==\nnullptr)\n,\nin case of conversions from bool to other built-in types, an explicit\nstatic_cast\n(or a C-style cast since C23) is proposed to make it clear\nthat a conversion is taking place:\nint\ninteger\n=\nboolean;\nis changed to\nint\ninteger\n=\nstatic_cast<int>(boolean);\n,\nif the conversion is performed on type literals, an equivalent literal is\nproposed, according to what type is actually expected, for example:\nfunctionTakingBool(0);\nis changed to\nfunctionTakingBool(false);\n,\nfunctionTakingInt(true);\nis changed to\nfunctionTakingInt(1);\n,\nfor other types, appropriate literals are used (\nfalse\n,\ntrue\n,\n0\n,\n1\n,\n0u\n,\n1u\n,\n0.0f\n,\n1.0f\n,\n0.0\n,\n1.0f\n).\n\nSome additional accommodations are made for pre-C++11 dialects:\n\nfalse\nliteral conversion to pointer is detected,\ninstead of\nnullptr\nliteral,\n0\nis proposed as replacement.\n\nSome additional accommodations are made for C:\n\nbool\n(or\n_Bool\n) operands in logical operators (\n&&\n,\n||\n) are\nignored.\n\nOccurrences of implicit conversions inside macros and template instantiations\nare deliberately ignored, as it is not clear how to deal with such cases.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nAllowIntegerConditions\nWhen\ntrue\n, the check will allow conditional integer conversions. Default\nis\nfalse\n.\nAllowPointerConditions\nWhen\ntrue\n, the check will allow conditional pointer conversions. Default\nis\nfalse\n.\nUseUpperCaseLiteralSuffix\nWhen\ntrue\n, the replacements will use an uppercase literal suffix in the\nprovided fixes. Default is\nfalse\n.\nExample\nuint32_t\nfoo\n;\nif\n(\nfoo\n)\n{}\n// ^ propose replacement default: if (foo != 0u) {}\n// ^ propose replacement with option `UseUpperCaseLiteralSuffix`: if (foo != 0U) {}"
    }
}