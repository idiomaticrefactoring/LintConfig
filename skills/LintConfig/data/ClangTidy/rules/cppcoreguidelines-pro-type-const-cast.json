{
    "cppcoreguidelines-pro-type-const-cast": {
        "description": "Description\n\nImposes limitations on the use of\nconst_cast\nwithin C++ code. It depends on\nthe\nStrictMode\noption setting to determine whether it should flag all\ninstances of\nconst_cast\nor only those that remove either\nconst\nor\nvolatile\nqualifier.\n\nModifying a variable that has been declared as\nconst\nin C++ is generally\nconsidered undefined behavior, and this remains true even when using\nconst_cast\n. In C++, the\nconst\nqualifier indicates that a variable is\nintended to be read-only, and the compiler enforces this by disallowing any\nattempts to change the value of that variable.\n\nRemoving the\nvolatile\nqualifier in C++ can have serious consequences. This\nqualifier indicates that a variable’s value can change unpredictably, and\nremoving it may lead to undefined behavior, optimization problems, and\ndebugging challenges. It’s essential to retain the\nvolatile\nqualifier in\nsituations where the variable’s volatility is a crucial aspect of program\ncorrectness and reliability.\n\nThis rule is part of the\nType safety (Type 3)\nprofile and\nES.50: Don’t cast away const\nrule from the C++ Core Guidelines.",
        "option": "Static analysis (Clang-Tidy) options are configured via .clang-tidy file.\n\nOptions\nStrictMode\nWhen this setting is set to\ntrue\n, it means that any usage of\nconst_cast\nis not allowed. On the other hand, when it’s set to\nfalse\n, it permits\ncasting to\nconst\nor\nvolatile\ntypes. Default value is\nfalse\n."
    }
}