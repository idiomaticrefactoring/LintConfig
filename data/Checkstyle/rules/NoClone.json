{"rule_name": {"description": "Description\n\nChecks that the clone method is not overridden from the\nObject class.\n\n\nThis check is almost exactly the same as the NoFinalizerCheck.\n\n\nSee\nObject.clone()\n\n\nRationale: The clone method relies on strange, hard to follow rules that\nare difficult to get right and do not work in all situations.\nIn some cases, either a copy constructor\nor a static factory method can be used instead of the clone method\nto return copies of an object.\nFor more information on rules for the clone method and its issues, see Effective Java:\nProgramming Language Guide First Edition by Joshua Bloch\npages 45-52.\n\n\nBelow are some rules/reasons why the clone method should be avoided.\n\n\n\nClasses supporting the clone method should implement the Cloneable interface\nbut the Cloneable interface does not include the clone method.\nAs a result, it doesn't enforce the method override.\n\n\nThe Cloneable interface forces the Object's clone method to work correctly.\nWithout implementing it, the Object's clone method will throw a\nCloneNotSupportedException.\n\n\nNon-final classes must return the object returned from a call to super.clone().\n\n\nFinal classes can use a constructor to create a clone which is different\nfrom non-final classes.\n\n\nIf a super class implements the clone method incorrectly all subclasses calling\nsuper.clone() are doomed to failure.\n\n\nIf a class has references to mutable objects then those object references must be\nreplaced with copies in the clone method after calling super.clone().\n\n\nThe clone method does not work correctly with final mutable object references because\nfinal references cannot be reassigned.\n\n\nIf a super class overrides the clone method then all subclasses must provide a correct\nclone implementation.\n\n\n\nTwo alternatives to the clone method, in some cases, is a copy constructor or a static\nfactory method to return copies of an object. Both of these approaches are simpler and\ndo not conflict with final fields. They do not force the calling client to handle a\nCloneNotSupportedException.  They also are typed therefore no casting is necessary.\nFinally, they are more flexible since they can take interface types rather than concrete\nclasses.\n\n\nSometimes a copy constructor or static factory is not an acceptable alternative to the\nclone method.  The example below highlights the limitation of a copy constructor\n(or static factory). Assume Square is a subclass for Shape.\n\n\n\nShape s1 = new Square();\nSystem.out.println(s1 instanceof Square); //true\n\n\n...assume at this point the code knows nothing of s1 being a Square that's the beauty\nof polymorphism but the code wants to copy the Square which is declared as a Shape,\nits super type...\n\n\n\nShape s2 = new Shape(s1); //using the copy constructor\nSystem.out.println(s2 instanceof Square); //false\n\n\nThe working solution (without knowing about all subclasses and doing many casts) is to do\nthe following (assuming correct clone implementation).\n\n\n\nShape s2 = s1.clone();\nSystem.out.println(s2 instanceof Square); //true\n\n\nJust keep in mind if this type of polymorphic cloning is required then a properly\nimplemented clone method may be the best choice.\n\n\nMuch of this information was taken from Effective Java: Programming Language Guide First\nEdition by Joshua Bloch pages 45-52.  Give Bloch credit for writing an excellent book.", "option": ""}}