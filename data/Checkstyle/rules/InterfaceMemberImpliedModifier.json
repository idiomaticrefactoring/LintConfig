{"rule_name": {"description": "Description\n\nChecks for implicit modifiers on interface members and nested types.\n\n\nThis check is effectively the opposite of\nRedundantModifier.\nIt checks the modifiers on interface members, ensuring that certain\nmodifiers are explicitly specified even though they are actually redundant.\n\n\nMethods in interfaces are public by default, however from Java 9\nthey can also be private. This check provides the ability to enforce\nthat public is explicitly coded and not implicitly added by the compiler.\n\n\nFrom Java 8, there are three types of methods in interfaces - static methods\nmarked with static, default methods marked with default and\nabstract methods which do not have to be marked with anything.\nFrom Java 9, there are also private methods marked with private.\nThis check provides the ability to enforce that abstract is explicitly\ncoded and not implicitly added by the compiler.\n\n\nFields in interfaces are always public static final and as such the\ncompiler does not require these modifiers. This check provides the ability to\nenforce that these modifiers are explicitly coded and not implicitly added by\nthe compiler.\n\n\nNested types within an interface are always public static and as such the\ncompiler does not require the public static modifiers. This check provides\nthe ability to enforce that the public and static modifiers\nare explicitly coded and not implicitly added by the compiler.\n\n\n\npublic interface AddressFactory {\n// check enforces code contains \"public static final\"\npublic static final String UNKNOWN = \"Unknown\";\n\nString OTHER = \"Other\";  // violation\n\n// check enforces code contains \"public\" or \"private\"\npublic static AddressFactory instance();\n\n// check enforces code contains \"public abstract\"\npublic abstract Address createAddress(String addressLine, String city);\n\nList<Address> findAddresses(String city);  // violation\n\n// check enforces default methods are explicitly declared \"public\"\npublic default Address createAddress(String city) {\nreturn createAddress(UNKNOWN, city);\n}\n\ndefault Address createOtherAddress() {  // violation\nreturn createAddress(OTHER, OTHER);\n}\n}\n\n\nRationale for this check:\nMethods, fields and nested types are treated differently depending on whether\nthey are part of an interface or part of a class. For example, by default methods\nare package-scoped on classes, but public in interfaces. However, from Java 8 onwards,\ninterfaces have changed to be much more like abstract classes.\nInterfaces now have static and instance methods with code. Developers should not have\nto remember which modifiers are required and which are implied.\nThis check allows the simpler alternative approach to be adopted where the\nimplied modifiers must always be coded explicitly.", "option": "\nviolateImpliedAbstractMethod, Control whether to enforce that abstract is explicitly coded on interface methods., boolean, true\nviolateImpliedFinalField, Control whether to enforce that final is explicitly coded on interface fields., boolean, true\nviolateImpliedPublicField, Control whether to enforce that public is explicitly coded on interface fields., boolean, true\nviolateImpliedPublicMethod, Control whether to enforce that public is explicitly coded on interface methods., boolean, true\nviolateImpliedPublicNested, Control whether to enforce that public is explicitly coded on interface nested types., boolean, true\nviolateImpliedStaticField, Control whether to enforce that static is explicitly coded on interface fields., boolean, true\nviolateImpliedStaticNested, Control whether to enforce that static is explicitly coded on interface nested types., boolean, true"}}