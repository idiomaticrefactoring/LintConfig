{"PackageDeclaration": {"description": "Description\n\nEnsures that a class has a package declaration, and (optionally) whether\nthe package name matches the directory name for the source file.\n\n\nRationale: Classes that live in the null package cannot be\nimported. Many novice developers are not aware of this.\n\n\nPackages provide logical namespace to classes and should be stored in\nthe form of directory levels to provide physical grouping to your classes.\nThese directories are added to the classpath so that your classes\nare visible to JVM when it runs the code.", "option": "\nmatchDirectoryStructure, Control whether to check for directory and package name match., boolean, true"}, "VisibilityModifier": {"description": "Description\n\nChecks visibility of class members. Only static final, immutable or annotated\nby specified annotation members may be public; other class members must be private\nunless the property protectedAllowed or packageAllowed is set.\n\n\nPublic members are not flagged if the name matches the public\nmember regular expression (contains \"^serialVersionUID$\" by default).\n\nNote that\nCheckstyle 2 used to include \"^f[A-Z][a-zA-Z0-9]*$\" in the default\npattern to allow names used in container-managed persistence for Enterprise JavaBeans\n(EJB) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have\npublic access for persistent fields, so the default has been changed.\n\n\nRationale: Enforce encapsulation.\n\n\nCheck also has options making it less strict:\n\n\nignoreAnnotationCanonicalNames - the list of annotations which ignore variables\nin consideration. If user want to provide short annotation name that type\nwill match to any named the same type without consideration of package.\n\n\nallowPublicFinalFields - which allows public final fields.\n\n\nallowPublicImmutableFields - which allows immutable fields to be declared as\npublic if defined in final class.\n\n\nField is known to be immutable if:\n\n\nIt's declared as final\n\nHas either a primitive type or instance of class user defined to be immutable\n(such as String, ImmutableCollection from Guava, etc.)\n\n\n\nClasses known to be immutable are listed in immutableClassCanonicalNames by their\ncanonical names.\n\n\nProperty Rationale: Forcing all fields of class to have private modifier by default is\ngood in most cases, but in some cases it drawbacks in too much boilerplate get/set code.\nOne of such cases are immutable classes.\n\n\nRestriction: Check doesn't check if class is immutable, there's no\nchecking if accessory methods are missing and all fields are immutable, we only check\nif current field is immutable or final. Under the flag\nallowPublicImmutableFields, the enclosing class must also be final, to encourage\nimmutability. Under the flag allowPublicFinalFields, the final modifier on\nthe enclosing class is optional.\n\n\nStar imports are out of scope of this Check. So if one of type imported via\nstar import collides with user specified one by its short name -\nthere won't be Check's violation.", "option": "\nallowPublicFinalFields, Allow final fields to be declared as public., boolean, false\nallowPublicImmutableFields, Allow immutable fields to be declared as public if defined in final class., boolean, false\nignoreAnnotationCanonicalNames, Specify annotations canonical names which ignore variables in consideration., String[], com.google.common.annotations.VisibleForTesting, org.junit.ClassRule, org.junit.Rule\nimmutableClassCanonicalNames, Specify immutable classes canonical names., String[], java.io.File, java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.StackTraceElement, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.net.Inet4Address, java.net.Inet6Address, java.net.InetSocketAddress, java.net.URI, java.net.URL, java.util.Locale, java.util.UUID\npackageAllowed, Control whether package visible members are allowed., boolean, false\nprotectedAllowed, Control whether protected members are allowed., boolean, false\npublicMemberPattern, Specify pattern for public members that should be ignored., Pattern, \"^serialVersionUID$\""}, "Indentation": {"description": "Description\n\nChecks correct indentation of Java code.\n\n\nThe idea behind this is that while pretty printers are\nsometimes convenient for bulk reformats of legacy code, they often\neither aren't configurable enough or just can't anticipate how\nformat should be done. Sometimes this is personal preference, other\ntimes it is practical experience. In any case, this check should\njust ensure that a minimal set of indentation rules is followed.\n\n\nBasic offset indentation is used for indentation inside code blocks.\nFor any lines that span more than 1, line wrapping indentation is used for those\nlines after the first.\nBrace adjustment, case, and throws indentations are all used only if those specific\nidentifiers start the line. If, for example, a brace is used in the middle of the line,\nits indentation will not take effect.\nAll indentations have an accumulative/recursive effect when they are triggered. If\nduring a line wrapping, another code block is found and it doesn't end on that same\nline, then the subsequent lines afterwards, in that new code block, are increased on\ntop of the line wrap and any indentations above it.\n\nExample:\n\n\nif ((condition1 && condition2)\n|| (condition3 && condition4)    // line wrap with bigger indentation\n||!(condition5 && condition6)) { // line wrap with bigger indentation\nfield.doSomething()                    // basic offset\n.doSomething()                     // line wrap\n.doSomething( c -> {               // line wrap\nreturn c.doSome();               // basic offset\n});\n}", "option": "\narrayInitIndent, Specify how far an array initialization should be indented when on next line., int, 4\nbasicOffset, Specify how far new indentation level should be indented when on the next line., int, 4\nbraceAdjustment, Specify how far a braces should be indented when on the next line., int, 0\ncaseIndent, Specify how far a case label should be indented when on next line., int, 4\nforceStrictCondition, Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like., boolean, false\nlineWrappingIndentation, Specify how far continuation line should be indented when line-wrapping is present., int, 4\nthrowsIndent, Specify how far a throws clause should be indented when on next line., int, 4"}, "OneTopLevelClass": {"description": "Description\n\nChecks that each top-level class, interface, enum\nor annotation resides in a source file of its own.\nOfficial description of a 'top-level' term:\n7.6. Top Level Type Declarations.\nIf file doesn't contain public class, interface, enum or annotation,\ntop-level type is the first type in file.", "option": ""}, "MissingDeprecated": {"description": "Description\n\nVerifies that the annotation @Deprecated and the Javadoc tag\n@deprecated are both present when either of them is present.\n\n\nBoth ways of flagging deprecation serve their own purpose.\nThe @Deprecated annotation is used for compilers and development tools.\nThe @deprecated javadoc tag is used to document why something is deprecated\nand what, if any, alternatives exist.\n\n\nIn order to properly mark something as deprecated both forms of\ndeprecation should be present.\n\n\nPackage deprecation is an exception to the rule of always using the\njavadoc tag and annotation to deprecate.  It is not clear if the\njavadoc tool will support it or not as newer versions keep flip-flopping\non if it is supported or will cause an error.\nSee\nJDK-8160601.\nThe deprecated javadoc tag is currently the only way to say why the package\nis deprecated and what to use instead.  Until this is resolved, if you\ndon't want to print violations on package-info, you can use a\nfilter to ignore these files until\nthe javadoc tool faithfully supports it. An example config using\nSuppressionSingleFilter is:\n\n\n\n<!-- required till https://bugs.openjdk.org/browse/JDK-8160601 -->\n<module name=\"SuppressionSingleFilter\">\n<property name=\"checks\" value=\"MissingDeprecatedCheck\"/>\n<property name=\"files\" value=\"package-info\\.java\"/>\n</module>", "option": "\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "JavadocVariable": {"description": "Description\n\nChecks that a variable has a Javadoc comment. Ignores serialVersionUID\nfields.", "option": "\nexcludeScope, Specify the visibility scope where Javadoc comments are not checked., Scope, null\nignoreNamePattern, Specify the regexp to define variable names to ignore., Pattern, null\nscope, Specify the visibility scope where Javadoc comments are checked., Scope, private\ntokens, tokens to check, subset of tokens\n\nENUM_CONSTANT_DEF\n.\n,\n\nENUM_CONSTANT_DEF\n.\n"}, "NoEnumTrailingComma": {"description": "Description\n\nChecks that enum definition does not contain a trailing comma.\nRationale: JLS allows trailing commas in arrays and enumerations, but does not allow\nthem in other locations. To unify the coding style, the use of trailing commas should\nbe prohibited.\n\n\n\nenum Foo1 {\nFOO,\nBAR;\n}\n\n\nThe check demands that there should not be any comma after last constant in\nenum definition.\n\n\n\nenum Foo1 {\nFOO,\nBAR, //violation\n}", "option": ""}, "UniqueProperties": {"description": "Description\n\nDetects duplicated keys in properties files.\n\n\nRationale: Multiple property keys usually appear after merge\nor rebase of several branches. While there are no problems in\nruntime, there can be a confusion due to having different values\nfor the duplicated properties.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], .properties"}, "JavadocTagContinuationIndentation": {"description": "Description\n\nChecks the indentation of the continuation lines in block tags.\nThat is whether the\ncontinued description of at clauses should be indented or not. If the text is not properly\nindented it throws a violation. A continuation line is when the description starts/spans\npast the line with the tag. Default indentation required is at least 4, but this can be\nchanged with the help of properties below.", "option": "\noffset, Specify how many spaces to use for new indentation level., int, 4\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "LambdaParameterName": {"description": "Description\n\nChecks lambda parameter names.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "SuperFinalize": {"description": "Description\n\nChecks that an overriding finalize() method invokes\nsuper.finalize(). Does not check native methods, as\nthey have no possible java defined implementation.\n\n\nReferences:\n\nHow to Handle Java Finalization's Memory-Retention Issues;\n\n10 points on finalize method in Java.", "option": ""}, "EmptyForIteratorPad": {"description": "Description\n\nChecks the padding of an empty for iterator; that is whether a white\nspace is required at an empty for iterator, or such white space is\nforbidden. No check occurs if there is a line wrap at the iterator,\nas in\n\n\n\nfor (Iterator foo = very.long.line.iterator();\nfoo.hasNext();\n)", "option": "\noption, Specify policy on how to pad an empty for iterator., PadOption, nospace"}, "OneStatementPerLine": {"description": "Description\n\nChecks that there is only one statement per line.\n\n\nRationale: It's very difficult to read multiple statements on one line.\n\n\nIn the Java programming language, statements are the fundamental unit of\nexecution. All statements except blocks are terminated by a semicolon.\nBlocks are denoted by open and close curly braces.\n\n\nOneStatementPerLineCheck checks the following types of statements:\nvariable declaration statements, empty statements, import statements,\nassignment statements, expression statements, increment statements,\nobject creation statements, 'for loop' statements, 'break' statements,\n'continue' statements, 'return' statements, resources statements (optional).", "option": "\ntreatTryResourcesAsStatement, Enable resources processing., boolean, false"}, "InterfaceTypeParameterName": {"description": "Description\n\nChecks that interface type parameter names conform to a specified pattern.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[A-Z]$\""}, "MissingJavadocMethod": {"description": "Description\n\nChecks for missing Javadoc comments for a method or constructor.\nThe scope to verify is specified using the Scope class and\ndefaults to Scope.PUBLIC. To verify another\nscope, set property scope to a different\nscope.\n\n\nJavadoc is not required on a method that is tagged with the\n@Override annotation. However, under\nJava 5 it is not possible to mark a method required for an\ninterface (this was corrected under Java 6). Hence,\nCheckstyle supports using the convention of using a single\n{@inheritDoc} tag instead of all the\nother tags.\n\n\nFor getters and setters for the property allowMissingPropertyJavadoc,\nthe methods must match exactly the structures below.\n\n\n\npublic void setNumber(final int number)\n{\nmNumber = number;\n}\n\npublic int getNumber()\n{\nreturn mNumber;\n}\n\npublic boolean isSomething()\n{\nreturn false;\n}", "option": "\nallowMissingPropertyJavadoc, Control whether to allow missing Javadoc on accessor methods for properties (setters and getters)., boolean, false\nallowedAnnotations, Configure annotations that allow missed documentation., String[], Override\nexcludeScope, Specify the visibility scope where Javadoc comments are not checked., Scope, null\nignoreMethodNamesRegex, Ignore method whose names are matching specified regex., Pattern, null\nminLineCount, Control the minimal amount of lines in method to allow no documentation., int, -1\nscope, Specify the visibility scope where Javadoc comments are checked., Scope, public\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nANNOTATION_FIELD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nANNOTATION_FIELD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "JavaNCSS": {"description": "Description\n\nDetermines complexity of methods, classes and files by\ncounting the Non Commenting Source Statements (NCSS). This\ncheck adheres to the\nspecification for the\nJavaNCSS-Tool\nwritten by Chr. Clemens Lee.\n\n\nRoughly said the NCSS metric is calculated by\ncounting the source lines which are not comments, (nearly)\nequivalent to counting the semicolons and opening curly braces.\n\n\nThe NCSS for a class is summarized from the NCSS\nof all its methods, the NCSS of its nested classes and the\nnumber of member variable declarations.\n\n\nThe NCSS for a file is summarized from the ncss of all its top level classes,\nthe number of imports and the package declaration.\n\n\nRationale: Too large methods and classes are hard to read and\ncostly to maintain. A large NCSS number often means that a\nmethod or class has too many responsibilities and/or\nfunctionalities which should be decomposed into smaller units.", "option": "\nclassMaximum, Specify the maximum allowed number of non commenting lines in a class., int, 1500\nfileMaximum, Specify the maximum allowed number of non commenting lines in a file including all top level and nested classes., int, 2000\nmethodMaximum, Specify the maximum allowed number of non commenting lines in a method., int, 50\nrecordMaximum, Specify the maximum allowed number of non commenting lines in a record., int, 150"}, "UnnecessaryParentheses": {"description": "Description\n\nChecks if unnecessary parentheses are used in a statement or expression.\nThe check will flag the following with warnings:\n\n\n\nreturn (x);          // parens around identifier\nreturn (x + 1);      // parens around return value\nint x = (y / 2 + 1); // parens around assignment rhs\nfor (int i = (0); i < 10; i++) {  // parens around literal\nt -= (z + 1);                     // parens around assignment rhs\nboolean a = (x > 7 && y > 5)      // parens around expression\n|| z < 9;\nboolean b = (~a) > -27            // parens around ~a\n&& (a-- < 30);        // parens around expression", "option": "\ntokens, tokens to check, subset of tokens\n\nEXPR\n,\nIDENT\n,\nNUM_DOUBLE\n,\nNUM_FLOAT\n,\nNUM_INT\n,\nNUM_LONG\n,\nSTRING_LITERAL\n,\nLITERAL_NULL\n,\nLITERAL_FALSE\n,\nLITERAL_TRUE\n,\nASSIGN\n,\nBAND_ASSIGN\n,\nBOR_ASSIGN\n,\nBSR_ASSIGN\n,\nBXOR_ASSIGN\n,\nDIV_ASSIGN\n,\nMINUS_ASSIGN\n,\nMOD_ASSIGN\n,\nPLUS_ASSIGN\n,\nSL_ASSIGN\n,\nSR_ASSIGN\n,\nSTAR_ASSIGN\n,\nLAMBDA\n,\nTEXT_BLOCK_LITERAL_BEGIN\n,\nLAND\n,\nLOR\n,\nLITERAL_INSTANCEOF\n,\nGT\n,\nLT\n,\nGE\n,\nLE\n,\nEQUAL\n,\nNOT_EQUAL\n,\nUNARY_MINUS\n,\nUNARY_PLUS\n,\nINC\n,\nDEC\n,\nLNOT\n,\nBNOT\n,\nPOST_INC\n,\nPOST_DEC\n,\nBXOR\n,\nBOR\n,\nBAND\n.\n,\n\nEXPR\n,\nIDENT\n,\nNUM_DOUBLE\n,\nNUM_FLOAT\n,\nNUM_INT\n,\nNUM_LONG\n,\nSTRING_LITERAL\n,\nLITERAL_NULL\n,\nLITERAL_FALSE\n,\nLITERAL_TRUE\n,\nASSIGN\n,\nBAND_ASSIGN\n,\nBOR_ASSIGN\n,\nBSR_ASSIGN\n,\nBXOR_ASSIGN\n,\nDIV_ASSIGN\n,\nMINUS_ASSIGN\n,\nMOD_ASSIGN\n,\nPLUS_ASSIGN\n,\nSL_ASSIGN\n,\nSR_ASSIGN\n,\nSTAR_ASSIGN\n,\nLAMBDA\n,\nTEXT_BLOCK_LITERAL_BEGIN\n,\nLAND\n,\nLOR\n,\nLITERAL_INSTANCEOF\n,\nGT\n,\nLT\n,\nGE\n,\nLE\n,\nEQUAL\n,\nNOT_EQUAL\n,\nUNARY_MINUS\n,\nUNARY_PLUS\n,\nINC\n,\nDEC\n,\nLNOT\n,\nBNOT\n,\nPOST_INC\n,\nPOST_DEC\n.\n"}, "FallThrough": {"description": "Description\n\nChecks for fall-through in switch\nstatements. Finds locations where a case\ncontains Java code but lacks a break, return,\nyield, throw or continue\nstatement.\n\n\nThe check honors special comments to suppress the warning.\nBy default, the texts\n\"fallthru\", \"fall thru\", \"fall-thru\",\n\"fallthrough\", \"fall through\", \"fall-through\"\n\"fallsthrough\", \"falls through\", \"falls-through\" (case-sensitive).\nThe comment containing these words must be all on one line,\nand must be on the last non-empty line before the\ncase triggering the warning or on\nthe same line before the case\n(ugly, but possible).\n\n\nNote: The check assumes that there is no unreachable\ncode in the case.", "option": "\ncheckLastCaseGroup, Control whether the last case group must be checked., boolean, false\nreliefPattern, Define the RegExp to match the relief comment that suppresses the warning about a fall through., Pattern, \"falls?[ -]?thr(u|ough)\""}, "JavadocType": {"description": "Description\n\nChecks the Javadoc comments for type definitions.\nBy default, does not check for author or version tags. The\nscope to verify is specified using the Scope\nclass and defaults to Scope.PRIVATE. To verify\nanother scope, set property scope to one of the\nScope constants. To define the format for an\nauthor tag or a version tag, set property authorFormat or\nversionFormat respectively to a\n\npattern.\n\n\nDoes not perform checks for author and version tags for inner\nclasses, as they should be redundant because of outer class.\n\n\nDoes not perform checks for type definitions that do not have\nany Javadoc comments.\n\n\nError messages about type parameters and record components for which no\nparam tags are present can be suppressed by defining property\nallowMissingParamTags.", "option": "\nallowMissingParamTags, Control whether to ignore violations when a class has type parameters but does not have matching param tags in the Javadoc., boolean, false\nallowUnknownTags, Control whether to ignore violations when a Javadoc tag is not recognised., boolean, false\nallowedAnnotations, Specify annotations that allow skipping validation at all. Only short names are allowed, e.g. Generated., String[], Generated\nauthorFormat, Specify the pattern for @author tag., Pattern, null\nexcludeScope, Specify the visibility scope where Javadoc comments are not checked., Scope, null\nscope, Specify the visibility scope where Javadoc comments are checked., Scope, private\nversionFormat, Specify the pattern for @version tag., Pattern, null\ntokens, tokens to check, subset of tokens\n\nINTERFACE_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nINTERFACE_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "NPathComplexity": {"description": "Description\n\nChecks the NPATH complexity against a specified limit.\n\n\nThe NPATH metric computes the number of possible execution\npaths through a function(method). It takes into account the nesting of\nconditional statements and multipart boolean expressions\n(A && B, C || D, E ? F :G and their combinations).\n\n\nThe NPATH metric was designed base on Cyclomatic complexity to\navoid problem of Cyclomatic complexity metric like nesting level within a\nfunction(method).\n\n\nMetric was described at\n\"NPATH: a measure of execution pathcomplexity and its applications\".\nIf you need detailed description of algorithm, please read that article,\nit is well written and have number of examples and details.\n\nHere is some quotes:\nAn NPATH threshold value of 200 has been established\nfor a function. The value 200 is based on studies done\nat AT&T Bell Laboratories [1988 year].\n\n\nSome of the most effective methods of reducing the NPATH value include:\n\n\ndistributing functionality;\nimplementing multiple if statements as a switch statement;\n\ncreating a separate function for logical expressions with a high\ncount of variables and (&&) and or (||) operators.\n\n\n\n\nAlthough strategies to reduce the NPATH complexity\nof functions are important, care must be taken not to\ndistort the logical clarity of the software by applying a\nstrategy to reduce the complexity of functions. That is,\nthere is a point of diminishing return beyond which a\nfurther attempt at reduction of complexity distorts the\nlogical clarity of the system structure.\n\n\nExamples\n\n\nStructure\nComplexity expression\n\nif ([expr]) { [if-range] }\nNP(if-range) + 1 + NP(expr)\n\nif ([expr]) { [if-range] } else { [else-range] }\nNP(if-range)\n+ NP(else-range) + NP(expr)\n\nwhile ([expr]) { [while-range] }\nNP(while-range) + NP(expr) + 1\n\n\ndo { [do-range] } while ([expr])\nNP(do-range) + NP(expr) + 1\n\nfor([expr1]; [expr2]; [expr3]) { [for-range] }\nNP(for-range) + NP(expr1)\n+ NP(expr2) + NP(expr3) + 1\n\nswitch ([expr]) { case : [case-range] default: [default-range] }\nS(i=1:i=n)NP(case-range[i]) + NP(default-range) + NP(expr)\n\n\n[expr1] ? [expr2] : [expr3]\nNP(expr1) + NP(expr2) + NP(expr3) + 2\n\n\ngoto label\n1\n\nbreak\n1\n\nExpressions\nNumber of && and || operators in expression. No\noperators - 0\n\ncontinue\n1\n\nreturn\n1\n\nStatement (even sequential statements)\n1\n\nEmpty block {}\n1\n\nFunction call\n1\n\nFunction(Method) declaration or Block\nP(i=1:i=N)NP(Statement[i])\n\n\n\n\nRationale: Nejmeh says that his group had an informal NPATH\nlimit of 200 on individual routines; functions(methods) that exceeded\nthis value were candidates for further decomposition - or at\nleast a closer look.\nPlease do not be fanatic with limit 200\n- choose number that suites your project style. Limit 200 is\nempirical number base on some sources of at AT&T Bell Laboratories\nof 1988 year.", "option": "\nmax, Specify the maximum threshold allowed., int, 200"}, "TrailingComment": {"description": "Description\n\nThe check to ensure that lines with code do not end with comment.\nFor the case of // comments that means that the only thing\nthat should precede it is whitespace. It doesn't check comments if\nthey do not end a line; for example, it accepts the following:\nThread.sleep( 10 /*some comment here*/ ); Format\nproperty is intended to deal with the } // while example.\n\n\nRationale: Steve McConnell in Code Complete suggests that\nendline comments are a bad practice. An end line comment would be\none that is on the same line as actual code. For example:\n\n\n\na = b + c;      // Some insightful comment\nd = e / f;        // Another comment for this line\n\n\nQuoting Code Complete for the justification:\n\n\n\"The comments have to be aligned so that they do not\ninterfere with the visual structure of the code. If you don't align\nthem neatly, they'll make your listing look like it's been through a\nwashing machine.\"\n\n\"Endline comments tend to be hard to format...It takes\ntime to align them. Such time is not spent learning more about the\ncode; it's dedicated solely to the tedious task of pressing the\nspacebar or tab key.\"\n\n\"Endline comments are also hard to maintain. If the code\non any line containing an endline comment grows, it bumps the\ncomment farther out, and all the other endline comments will have to\nbumped out to match. Styles that are hard to maintain aren't\nmaintained....\"\n\n\"Endline comments also tend to be cryptic. The right side\nof the line doesn't offer much room and the desire to keep the\ncomment on one line means the comment must be short. Work then goes\ninto making the line as short as possible instead of as clear as\npossible. The comment usually ends up as cryptic as\npossible....\"\n\n\"A systemic problem with endline comments is that it's\nhard to write a meaningful comment for one line of code. Most\nendline comments just repeat the line of code, which hurts more than\nit helps.\"\n\n\n\nMcConnell's comments on being hard to maintain when the size of the line\nchanges are even more important in the age of automated\nrefactorings.", "option": "\nformat, Specify pattern for strings allowed before the comment., Pattern, \"^[\\s});]*$\"\nlegalComment, Define pattern for text allowed in trailing comments. This pattern will not be applied to multiline comments., Pattern, null"}, "PackageAnnotation": {"description": "Description\n\nChecks that all package annotations are in the package-info.java file.\n\n\nFor Java SE8 and above, placement of package annotations in the package-info.java\nfile is enforced by the compiler and this check is not necessary.\n\n\nFor Java SE7 and below, the Java Language Specification highly recommends\nbut doesn't require that annotations are placed in the package-info.java file,\nand this check can help to enforce that placement.\n\n\nSee\nJava Language Specification, \u00a77.4.1 for more info.", "option": ""}, "BooleanExpressionComplexity": {"description": "Description\n\nRestricts the number of boolean operators (&&, ||,\n&, | and ^) in an expression.\n\n\nRationale: Too many conditions leads to code that is difficult\nto read and hence debug and maintain.\n\n\nNote that the operators & and\n| are not only integer bitwise operators, they are also the\n\nnon-shortcut versions of the boolean operators\n&& and ||.\n\n\nNote that &, | and ^ are not checked\nif they are part of constructor or method call\nbecause they can be applied to non-boolean variables and\nCheckstyle does not know types of methods from different classes.", "option": "\nmax, Specify the maximum number of boolean operations allowed in one expression., int, 3\ntokens, tokens to check, subset of tokens\n\nLAND\n,\nBAND\n,\nLOR\n,\nBOR\n,\nBXOR\n.\n,\n\nLAND\n,\nBAND\n,\nLOR\n,\nBOR\n,\nBXOR\n.\n"}, "UnusedImports": {"description": "Description\n\nChecks for unused import statements. An\nimport statement is considered unused if:\n\n\n\nIt is not referenced in the file. The algorithm does not support\nwild-card imports like import\njava.io.*;. Most IDE's provide very sophisticated checks\nfor imports that handle wild-card imports.\n\n\nThe class imported is from the java.lang\npackage. For example importing java.lang.String.\n\n\nThe class imported is from the same package.\n\n\nA static method is imported when used as method reference. In that case,\nonly the type needs to be imported and that's enough to resolve the method.\n\n\nOptionally: it is referenced in Javadoc comments. This check\nis on by default, but it is considered bad practice to introduce\na compile-time dependency for documentation purposes only.\nAs an example, the import java.util.List would be\nconsidered referenced with the Javadoc comment\n{@link List}. The alternative to avoid introducing a\ncompile-time dependency would be to write the Javadoc comment as\n{@link java.util.List}.\n\n\n\nThe main limitation of this check is handling the cases where:\n\n\n\nAn imported type has the same name as a declaration, such as a member variable.\n\n\nThere are two or more static imports with the same method name\n(javac can distinguish imports with same name but different parameters, but checkstyle\ncan not due to\nlimitation.)", "option": "\nprocessJavadoc, Control whether to process Javadoc comments., boolean, true"}, "HideUtilityClassConstructor": {"description": "Description\n\nMakes sure that utility classes (classes that contain only static\nmethods or fields in their API) do not have a public constructor.\n\n\nRationale: Instantiating utility classes does not make sense. Hence,\nthe constructors should either be private or (if you want to allow\nsubclassing) protected. A common mistake is forgetting to hide the\ndefault constructor.\n\n\nIf you make the constructor protected you may want to consider the\nfollowing constructor implementation technique to disallow\ninstantiating subclasses:\n\n\n\npublic class StringUtils // not final to allow subclassing\n{\nprotected StringUtils() {\n// prevents calls from subclass\nthrow new UnsupportedOperationException();\n}\n\npublic static int count(char c, String s) {\n// ...\n}\n}", "option": ""}, "NestedIfDepth": {"description": "Description\nRestricts nested if-else blocks to a specified depth.", "option": "\nmax, Specify maximum allowed nesting depth., int, 1"}, "NoWhitespaceBeforeCaseDefaultColon": {"description": "Description\n\nChecks that there is no whitespace before the colon in a switch block.", "option": ""}, "ThrowsCount": {"description": "Description\n\nRestricts throws statements to a specified count.\nMethods with \"Override\" or \"java.lang.Override\" annotation are skipped\nfrom validation as current class cannot change signature of these methods.\n\n\nRationale: Exceptions form part of a method's interface. Declaring a\nmethod to throw too many differently rooted exceptions makes\nexception handling onerous and leads to poor programming practices\nsuch as writing code like catch(Exception ex).\n4 is the empirical value which is based on reports that we had for\nthe ThrowsCountCheck over big projects such as OpenJDK.\nThis check also forces developers to put exceptions into a hierarchy\nsuch that in the simplest case, only one type of exception need be\nchecked for by a caller but any subclasses can be caught specifically\nif necessary. For more information on rules for the exceptions and\ntheir issues, see Effective Java: Programming Language Guide\nSecond Edition by Joshua Bloch pages 264-273.\n\n\nignorePrivateMethods - allows to skip private methods as they do\nnot cause problems for other classes.", "option": "\nignorePrivateMethods, Allow private methods to be ignored., boolean, true\nmax, Specify maximum allowed number of throws statements., int, 4"}, "CommentsIndentation": {"description": "Description\n\nControls the indentation between comments and surrounding code.\nComments are indented at the same level as the surrounding code.\nDetailed info about such convention can be found\n\nhere", "option": "\ntokens, tokens to check, subset of tokens\n\nSINGLE_LINE_COMMENT\n,\nBLOCK_COMMENT_BEGIN\n.\n,\n\nSINGLE_LINE_COMMENT\n,\nBLOCK_COMMENT_BEGIN\n.\n"}, "UnnecessarySemicolonInEnumeration": {"description": "Description\n\nChecks if unnecessary semicolon is in enum definitions.\nSemicolon is not needed if enum body contains only enum constants.", "option": ""}, "MethodLength": {"description": "Description\n\nChecks for long methods and constructors.\n\n\nRationale: If a method becomes very long it is hard to\nunderstand. Therefore, long methods should usually be refactored into\nseveral individual methods that focus on a specific task.", "option": "\ncountEmpty, Control whether to count empty lines and comments., boolean, true\nmax, Specify the maximum number of lines allowed., int, 150\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "OrderedProperties": {"description": "Description\n\nDetects if keys in properties files are in correct order.\n\n\nRationale: Sorted properties make it easy for people to find required properties by name\nin file. This makes it easier to merge. While there are no problems at runtime.\nThis check is valuable only on files with string resources where order of lines\ndoes not matter at all, but this can be improved.\nE.g.: checkstyle/src/main/resources/com/puppycrawl/tools/checkstyle/messages.properties\nYou may suppress warnings of this check for files that have a logical structure like\nbuild files or log4j configuration files. See SuppressionFilter.\n\n<suppress checks=\"OrderedProperties\"\nfiles=\"log4j.properties|ResourceBundle/Bug.*.properties|logging.properties\"/>\n\n\n\nKnown limitation: The key should not contain a newline.\nThe string compare will work, but not the line number reporting.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], .properties"}, "TypecastParenPad": {"description": "Description\n\nChecks the policy on the padding of parentheses for typecasts. That\nis, whether a space is required after a left parenthesis and before\na right parenthesis, or such spaces are forbidden.", "option": "\noption, Specify policy on how to pad parentheses., PadOption, nospace"}, "TypeName": {"description": "Description\n\nChecks that type names conform to a specified pattern.", "option": "\napplyToPackage, Control if check should apply to package-private members., boolean, true\napplyToPrivate, Control if check should apply to private members., boolean, true\napplyToProtected, Control if check should apply to protected members., boolean, true\napplyToPublic, Control if check should apply to public members., boolean, true\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[A-Z][a-zA-Z0-9]*$\"\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "UnnecessarySemicolonAfterOuterTypeDeclaration": {"description": "Description\n\nChecks if unnecessary semicolon is used after type declaration.", "option": "\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "VariableDeclarationUsageDistance": {"description": "Description\n\nChecks the distance between declaration of variable and its first usage.\nNote : Variable declaration/initialization statements are not counted\nwhile calculating length.", "option": "\nallowedDistance, Specify distance between declaration of variable and its first usage. Values should be greater than 0., int, 3\nignoreFinal, Allow to ignore variables with a 'final' modifier., boolean, true\nignoreVariablePattern, Define RegExp to ignore distance calculation for variables listed in this pattern., Pattern, \"\"\nvalidateBetweenScopes, Allow to calculate the distance between declaration of variable and its first usage in the different scopes., boolean, false"}, "InvalidJavadocPosition": {"description": "Description\n\nChecks that Javadocs are located at the correct position.\nAs specified at\n\nDocumentation Comment Specification for the Standard Doclet,\nJavadocs are recognized only when placed immediately before module, package, class,\ninterface, constructor, method, or field declarations. Any other position, like\nin the body of a method, will be ignored by the javadoc tool and is considered\ninvalid by this check.", "option": ""}, "MissingJavadocType": {"description": "Description\n\nChecks for missing Javadoc comments for class, enum, interface, and annotation\ninterface definitions. The scope to verify is specified using the Scope\nclass and defaults to Scope.PUBLIC. To verify\nanother scope, set property scope to one of the\nScope constants.", "option": "\nexcludeScope, Specify the visibility scope where Javadoc comments are not checked., Scope, null\nscope, Specify the visibility scope where Javadoc comments are checked., Scope, public\nskipAnnotations, Specify annotations that allow missed documentation. If annotation is present in target sources in multiple forms of qualified name, all forms should be listed in this property., String[], Generated\ntokens, tokens to check, subset of tokens\n\nINTERFACE_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nINTERFACE_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "RegexpHeader": {"description": "Description\n\nChecks the header of a source file against a header that contains a\n\npattern for each line of the source header.\n\n\nRationale: In some projects checking against a\nfixed header is not sufficient, e.g. the header might require a\ncopyright line where the year information is not static.\n\n\nFor example, consider the following header:\n\n\n\nline  1: ^/{71}$\nline  2: ^// checkstyle:$\nline  3: ^// Checks Java source code for adherence to a set of rules\\.$\nline  4: ^// Copyright \\(C\\) \\d\\d\\d\\d  Oliver Burn$\nline  5: ^// Last modification by \\$Author.*\\$$\nline  6: ^/{71}$\nline  7:\nline  8: ^package\nline  9:\nline 10: ^import\nline 11:\nline 12: ^/\\*\\*\nline 13: ^ \\*([^/]|$)\nline 14: ^ \\*/\n\n\nLines 1 and 6 demonstrate a more compact notation for 71 '/'\ncharacters. Line 4 enforces that the copyright notice includes a\nfour digit year. Line 5 is an example how to enforce revision\ncontrol keywords in a file header. Lines 12-14 is a template for\njavadoc (line 13 is so complicated to remove conflict with and of\njavadoc comment). Lines 7, 9 and 11 will be treated as '^$' and\nwill forcefully expect the line to be empty.\n\n\nDifferent programming languages have different comment syntax\nrules, but all of them start a comment with a non-word\ncharacter. Hence, you can often use the non-word character\nclass to abstract away the concrete comment syntax and allow\nchecking the header for different languages with a single\nheader definition. For example, consider the following header\nspecification (note that this is not the full Apache license\nheader):\n\n\n\nline 1: ^#!\nline 2: ^<\\?xml.*>$\nline 3: ^\\W*$\nline 4: ^\\W*Copyright 2006 The Apache Software Foundation or its licensors, as applicable\\.$\nline 5: ^\\W*Licensed under the Apache License, Version 2\\.0 \\(the \"License\"\\);$\nline 6: ^\\W*$\n\n\nLines 1 and 2 leave room for technical header lines, e.g. the\n\"#!/bin/sh\" line in Unix shell scripts, or the XML file header\nof XML files. Set the multiline property to \"1, 2\" so these\nlines can be ignored for file types where they do no apply.\nLines 3 through 6 define the actual header content. Note how\nlines 2, 4 and 5 use escapes for characters that have special\nregexp semantics.\n\n\nIn default configuration, if header is not specified, the default value\nof header is set to null and the check does not rise any violations.", "option": "\ncharset, Specify the character encoding to use when reading the headerFile., String, the charset property of the parent <a href=\"https://checkstyle.org/config.html#Checker\">Checker</a> module\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nheader, Define the required header specified inline. Individual header lines must be separated by the string \"\\n\" (even on platforms with a different line separator). For header lines containing \"\\n\\n\" checkstyle will forcefully expect an empty line to exist. See examples below. Regular expressions must not span multiple lines., String, null\nheaderFile, Specify the name of the file containing the required header., URI, null\nmultiLines, Specify the line numbers to repeat (zero or more times)., int[], {}"}, "EmptyCatchBlock": {"description": "Description\n\nChecks for empty catch blocks.\nBy default, check allows empty catch block with any comment inside.", "option": "\ncommentFormat, Specify the RegExp for the first comment inside empty catch block. If check meets comment inside empty catch block matching specified format - empty block is suppressed. If it is multi-line comment - only its first line is analyzed., Pattern, \".*\"\nexceptionVariableName, Specify the RegExp for the name of the variable associated with exception. If check meets variable name matching specified value - empty block is suppressed., Pattern, \"^$\""}, "RecordComponentName": {"description": "Description\nChecks that record component names conform to a specified pattern.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "CovariantEquals": {"description": "Description\n\nChecks that classes and records which define a covariant equals() method\nalso override method equals(Object).\n\n\nCovariant equals() - method that is similar to equals(Object),\nbut with a covariant parameter type (any subtype of Object).\n\n\nNotice: the enums are also checked, even\nthough they cannot override equals(Object). The reason is\nto point out that implementing equals() in enums is considered an\nawful practice: it may cause having two different enum values that are equal using\ncovariant enum method, and not equal when compared normally.\n\n\nInspired by\nFinding Bugs is Easy, chapter '4.5 Bad Covariant Definition of Equals (Eq)':\n\n\nJava classes and records may override the equals(Object) method to define\na predicate for object equality. This method is used by many of the Java runtime\nlibrary classes; for example, to implement generic containers.\n\n\nProgrammers sometimes mistakenly use the type of their class Foo\nas the type of the parameter to equals():\n\n\n\npublic boolean equals(Foo obj) {...}\n\n\nThis covariant version of equals() does not override the version in the\nObject class, and it may lead to unexpected behavior at runtime,\nespecially if the class is used with one of the standard collection classes\nwhich expect that the standard equals(Object) method is overridden.\n\n\nThis kind of bug is not obvious because it looks correct, and in circumstances where\nthe class is accessed through the references of the class type (rather than a supertype),\nit will work correctly. However, the first time it is used in a container,\nthe behavior might be mysterious. For these reasons, this type of bug can elude\ntesting and code inspections.", "option": ""}, "OperatorWrap": {"description": "Description\n\nChecks the policy on how to wrap lines on operators.", "option": "\noption, Specify policy on how to wrap lines., WrapOption, nl\ntokens, tokens to check, subset of tokens\n\nQUESTION\n,\nCOLON\n,\nEQUAL\n,\nNOT_EQUAL\n,\nDIV\n,\nPLUS\n,\nMINUS\n,\nSTAR\n,\nMOD\n,\nSR\n,\nBSR\n,\nGE\n,\nGT\n,\nSL\n,\nLE\n,\nLT\n,\nBXOR\n,\nBOR\n,\nLOR\n,\nBAND\n,\nLAND\n,\nLITERAL_INSTANCEOF\n,\nTYPE_EXTENSION_AND\n,\nASSIGN\n,\nDIV_ASSIGN\n,\nPLUS_ASSIGN\n,\nMINUS_ASSIGN\n,\nSTAR_ASSIGN\n,\nMOD_ASSIGN\n,\nSR_ASSIGN\n,\nBSR_ASSIGN\n,\nSL_ASSIGN\n,\nBXOR_ASSIGN\n,\nBOR_ASSIGN\n,\nBAND_ASSIGN\n,\nMETHOD_REF\n.\n,\n\nQUESTION\n,\nCOLON\n,\nEQUAL\n,\nNOT_EQUAL\n,\nDIV\n,\nPLUS\n,\nMINUS\n,\nSTAR\n,\nMOD\n,\nSR\n,\nBSR\n,\nGE\n,\nGT\n,\nSL\n,\nLE\n,\nLT\n,\nBXOR\n,\nBOR\n,\nLOR\n,\nBAND\n,\nLAND\n,\nTYPE_EXTENSION_AND\n,\nLITERAL_INSTANCEOF\n.\n"}, "AvoidInlineConditionals": {"description": "Description\n\nDetects inline conditionals. Here is one example of an inline conditional:\n\n\n\nString a = getParameter(\"a\");\nString b = (a==null || a.length()<1) ? null : a.substring(1);\n\n\nRationale: Some developers find inline conditionals hard to read, so\ntheir employer's coding standards forbid them.", "option": ""}, "MemberName": {"description": "Description\n\nChecks that instance variable names conform to a specified pattern.", "option": "\napplyToPackage, Control if check should apply to package-private members., boolean, true\napplyToPrivate, Control if check should apply to private members., boolean, true\napplyToProtected, Control if check should apply to protected members., boolean, true\napplyToPublic, Control if check should apply to public members., boolean, true\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "OverloadMethodsDeclarationOrder": {"description": "Description\n\nChecks that overloaded methods are grouped together. Overloaded methods have the same\nname but different signatures where the signature can differ by the number of input\nparameters or type of input parameters or both.", "option": ""}, "AvoidDoubleBraceInitialization": {"description": "Description\n\nDetects double brace initialization.\n\n\nRationale: Double brace initialization (set of\n\nInstance Initializers in class body) may look cool,\nbut it is considered as anti-pattern and should be avoided.\nThis is also can lead to a hard-to-detect memory leak, if the anonymous class instance is\nreturned outside and other object(s) hold reference to it.\nCreated anonymous class is not static, it holds an implicit reference to the outer class\ninstance.\nSee this\n\nblog post and\n\narticle for more details.\nCheck ignores any comments and semicolons in class body.", "option": ""}, "AvoidNoArgumentSuperConstructorCall": {"description": "Description\n\nChecks if call to superclass constructor without arguments is present.\nSuch invocation is redundant because constructor body implicitly\nbegins with a superclass constructor invocation super();\nSee\nspecification for detailed information.", "option": ""}, "MethodTypeParameterName": {"description": "Description\n\nChecks that method type parameter names conform to a specified pattern.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[A-Z]$\""}, "MissingOverride": {"description": "Description\n\nVerifies that the @Override annotation is present\nwhen the @inheritDoc javadoc tag is present.\n\n\nRationale: The @Override annotation helps\ncompiler tools ensure that an override is actually occurring.  It is\nquite easy to accidentally overload a method or hide a static method\nand using the @Override annotation points out these problems.\n\n\nThis check will log a violation if using the @inheritDoc tag on a method that\nis not valid (ex: private, or static method).\n\n\nThere is a slight difference between the @Override annotation in Java 5 versus\nJava 6 and above. In Java 5, any method overridden from an interface cannot\nbe annotated with @Override. In Java 6 this behavior is allowed.\n\n\nAs a result of the aforementioned difference between Java 5 and Java 6, a\nproperty called javaFiveCompatibility is available. This\nproperty will only check classes, interfaces, etc. that do not contain the\nextends or implements keyword or are not anonymous classes. This means it\nonly checks methods overridden from java.lang.Object.\nJava 5 Compatibility mode severely limits this check. It is recommended to\nonly use it on Java 5 source.", "option": "\njavaFiveCompatibility, Enable java 5 compatibility mode., boolean, false"}, "ClassMemberImpliedModifier": {"description": "Description\n\nChecks for implicit modifiers on nested types in classes and records.\n\n\nThis check is effectively the opposite of\nRedundantModifier.\nIt checks the modifiers on nested types in classes and records, ensuring that certain\nmodifiers are explicitly specified even though they are actually redundant.\n\n\nNested enums, interfaces, and records within a class are always static and as\nsuch the compiler does not require the static modifier. This check provides\nthe ability to enforce that the static modifier is explicitly coded and not\nimplicitly added by the compiler.\n\n\n\npublic final class Person {\nenum Age {  // violation\nCHILD, ADULT\n}\n}\n\n\nRationale for this check:\nNested enums, interfaces, and records are treated differently from nested classes as they\nare only allowed to be static. Developers should not need to remember this\nrule, and this check provides the means to enforce that the modifier is coded explicitly.", "option": "\nviolateImpliedStaticOnNestedEnum, Control whether to enforce that static is explicitly coded on nested enums in classes and records., boolean, true\nviolateImpliedStaticOnNestedInterface, Control whether to enforce that static is explicitly coded on nested interfaces in classes and records., boolean, true\nviolateImpliedStaticOnNestedRecord, Control whether to enforce that static is explicitly coded on nested records in classes and records., boolean, true"}, "ClassDataAbstractionCoupling": {"description": "Description\n\nMeasures the number of instantiations of other\nclasses within the given class or record. This type of coupling is not\ncaused by inheritance or the object-oriented\nparadigm. Generally speaking, any data type with other data\ntypes as members or local variable that is an instantiation\n(object) of another class has data abstraction coupling (DAC).\nThe higher the DAC, the more complex the structure of the class.\n\n\nThis check processes files in the following way:\n\n\n\nIterates over the list of tokens (defined below) and counts all mentioned classes.\n\n\n\n\nPACKAGE_DEF\n\n\n\nIMPORT\n\n\n\nCLASS_DEF\n\n\n\nINTERFACE_DEF\n\n\n\nENUM_DEF\n\n\n\nLITERAL_NEW\n\n\n\nRECORD_DEF\n\n\n\n\nIf a class was imported with direct import (i.e.\nimport java.math.BigDecimal), or the class was referenced with the\npackage name (i.e. java.math.BigDecimal value) and the package was\nadded to the excludedPackages parameter, the class does not\nincrease complexity.\n\n\nIf a class name was added to the excludedClasses parameter,\nthe class does not increase complexity.", "option": "\nexcludeClassesRegexps, Specify user-configured regular expressions to ignore classes., Pattern[], ^$\nexcludedClasses, Specify user-configured class names to ignore., String[], ArrayIndexOutOfBoundsException, ArrayList, Boolean, Byte, Character, Class, Collection, Deprecated, Deque, Double, DoubleStream, EnumSet, Exception, Float, FunctionalInterface, HashMap, HashSet, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, IntStream, Integer, LinkedHashMap, LinkedHashSet, LinkedList, List, Long, LongStream, Map, NullPointerException, Object, Optional, OptionalDouble, OptionalInt, OptionalLong, Override, Queue, RuntimeException, SafeVarargs, SecurityException, Set, Short, SortedMap, SortedSet, Stream, String, StringBuffer, StringBuilder, SuppressWarnings, Throwable, TreeMap, TreeSet, UnsupportedOperationException, Void, boolean, byte, char, double, float, int, long, short, var, void\nexcludedPackages, Specify user-configured packages to ignore., String[], {}\nmax, Specify the maximum threshold allowed., int, 7"}, "AnnotationUseStyle": {"description": "Description\n\nChecks the style of elements in annotations.\n\n\nAnnotations have three element styles starting with the least verbose.\n\n\nElementStyleOption.COMPACT_NO_ARRAY\nElementStyleOption.COMPACT\nElementStyleOption.EXPANDED\n\n\nTo not enforce an element style a ElementStyleOption.IGNORE type is provided.\nThe desired style can be set through the elementStyle property.\n\n\nUsing the ElementStyleOption.EXPANDED style is more verbose.\nThe expanded version is sometimes referred to as \"named parameters\" in other languages.\n\n\nUsing the ElementStyleOption.COMPACT style is less verbose.\nThis style can only be used when there is an element called 'value' which is either\nthe sole element or all other elements have default values.\n\n\nUsing the ElementStyleOption.COMPACT_NO_ARRAY style is less verbose.\nIt is similar to the ElementStyleOption.COMPACT style but single value arrays\nare flagged.\nWith annotations a single value array does not need to be placed in an array initializer.\n\n\nThe ending parenthesis are optional when using annotations with no elements.\nTo always require ending parenthesis use the ClosingParensOption.ALWAYS type.\nTo never have ending parenthesis use the ClosingParensOption.NEVER type.\nTo not enforce a closing parenthesis preference a ClosingParensOption.IGNORE\ntype is provided. Set this through the closingParens property.\n\n\nAnnotations also allow you to specify arrays of elements in a standard format.\nAs with normal arrays, a trailing comma is optional.\nTo always require a trailing comma use the TrailingArrayCommaOption.ALWAYS\ntype.\nTo never have a trailing comma use the TrailingArrayCommaOption.NEVER type.\nTo not enforce a trailing array comma preference a\nTrailingArrayCommaOption.IGNORE type is provided.\nSet this through the trailingArrayComma property.\n\n\nBy default, the ElementStyleOption is set to COMPACT_NO_ARRAY,\nthe TrailingArrayCommaOption is set to NEVER,\nand the ClosingParensOption is set to NEVER.\n\n\nAccording to the JLS, it is legal to include a trailing comma\nin arrays used in annotations but Sun's Java 5 & 6 compilers will not\ncompile with this syntax. This may in be a bug in Sun's compilers\nsince eclipse 3.4's built-in compiler does allow this syntax as\ndefined in the JLS. Note: this was tested with compilers included with\nJDK versions 1.5.0.17 and 1.6.0.11 and the compiler included with eclipse 3.4.1.\n\n\nSee\nJava Language specification, \u00a79.7.", "option": "\nclosingParens, Define the policy for ending parenthesis., ClosingParensOption, never\nelementStyle, Define the annotation element styles., ElementStyleOption, compact_no_array\ntrailingArrayComma, Define the policy for trailing comma in arrays., TrailingArrayCommaOption, never"}, "ClassTypeParameterName": {"description": "Description\nChecks that class type parameter names conform to a specified pattern.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[A-Z]$\""}, "ParameterNumber": {"description": "Description\n\nChecks the number of parameters of a method or constructor.", "option": "\nignoreAnnotatedBy, Ignore methods and constructors annotated with the specified annotation(s)., String[], {}\nignoreOverriddenMethods, Ignore number of parameters for methods with @Override annotation., boolean, false\nmax, Specify the maximum number of parameters allowed., int, 7\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nCTOR_DEF\n.\n,\n\nMETHOD_DEF\n,\nCTOR_DEF\n.\n"}, "IllegalInstantiation": {"description": "Description\n\nChecks for illegal instantiations where a factory method is\npreferred.\n\n\nRationale: Depending on the project, for some classes it might be\npreferable to create instances through factory methods rather than\ncalling the constructor.\n\n\nA simple example is the java.lang.Boolean\nclass. For performance reasons, it is preferable to\nuse the predefined constants  TRUE and\nFALSE. Constructor invocations should be\nreplaced by calls to Boolean.valueOf().\n\n\nSome extremely performance sensitive projects may require the use of\nfactory methods for other classes as well, to enforce the usage of\nnumber caches or object pools.", "option": "\nclasses, Specify fully qualified class names that should not be instantiated., String[], {}"}, "AvoidStaticImport": {"description": "Description\n\nChecks that there are no static import statements.\n\n\nRationale: Importing static members can lead to naming\nconflicts between class' members. It may lead to poor code\nreadability since it may no longer be clear what class a\nmember resides in (without looking at the import statement).", "option": "\nexcludes, Control whether to allow for certain classes via a star notation to be excluded such as java.lang.Math.* or specific static members to be excluded like java.lang.System.out for a variable or java.lang.Math.random for a method. See notes section for details., String[], {}"}, "MatchXpath": {"description": "Description\n\nEvaluates Xpath query and report violation on all matching AST nodes. This check allows\nuser to implement custom checks using Xpath. If Xpath query is not specified explicitly,\nthen the check does nothing.\n\n\nIt is recommended to define custom message for violation to explain what is not allowed\nand what to use instead, default message might be too abstract. To customize a message\nyou need to add message element with matchxpath.match as\nkey attribute and desired message as value attribute.\n\n\nPlease read more about Xpath syntax at\n\nXpath Syntax.\nInformation regarding Xpath functions can be found at\n\nXSLT/XPath Reference.\nNote, that @text attribute can be used only with token types that\nare listed in\n\nXpathUtil.", "option": "\nquery, Specify Xpath query., String, \"\""}, "IllegalTokenText": {"description": "Description\n\nChecks specified tokens text for matching an illegal pattern.\nBy default, no tokens are specified.", "option": "\nformat, Define the RegExp for illegal pattern., Pattern, \"^$\"\nignoreCase, Control whether to ignore case when matching., boolean, false\nmessage, Define the message which is used to notify about violations; if empty then the default message is used., String, \"\"\ntokens, tokens to check, subset of tokens\n\nNUM_DOUBLE\n,\nNUM_FLOAT\n,\nNUM_INT\n,\nNUM_LONG\n,\nIDENT\n,\nCOMMENT_CONTENT\n,\nSTRING_LITERAL\n,\nCHAR_LITERAL\n,\nTEXT_BLOCK_CONTENT\n,\nSTRING_TEMPLATE_CONTENT\n.\n, empty"}, "Translation": {"description": "Description\n\nEnsures the correct translation of code by checking property files for\nconsistency regarding their keys. Two property files\ndescribing one and the same context are consistent if they\ncontain the same keys. TranslationCheck also can check an existence of required\ntranslations which must exist in project, if requiredTranslations\noption is used.\n\n\nConsider the following properties file in the same directory:\n\n\n\n#messages.properties\nhello=Hello\ncancel=Cancel\n\n#messages_de.properties\nhell=Hallo\nok=OK\n\n\nThe Translation check will find the typo in the German hello\nkey, the missing ok key in the default resource file and the\nmissing cancel key in the German resource file:\n\n\n\nmessages_de.properties: Key 'hello' missing.\nmessages_de.properties: Key 'cancel' missing.\nmessages.properties: Key 'hell' missing.\nmessages.properties: Key 'ok' missing.", "option": "\nbaseName, Specify\nBase name of resource bundles which contain message resources. It helps the check to distinguish config and localization resources., Pattern, \"^messages.*$\"\nfileExtensions, Specify the file extensions of the files to process., String[], .properties\nrequiredTranslations, Specify language codes of required translations which must exist in project., String[], {}"}, "MissingCtor": {"description": "Description\n\nChecks that classes (except abstract ones) define a constructor and don't\nrely on the default one.", "option": ""}, "ExecutableStatementCount": {"description": "Description\nRestricts the number of executable statements to a specified limit.", "option": "\nmax, Specify the maximum threshold allowed., int, 30\ntokens, tokens to check, subset of tokens\n\nCTOR_DEF\n,\nMETHOD_DEF\n,\nINSTANCE_INIT\n,\nSTATIC_INIT\n,\nCOMPACT_CTOR_DEF\n,\nLAMBDA\n.\n,\n\nCTOR_DEF\n,\nMETHOD_DEF\n,\nINSTANCE_INIT\n,\nSTATIC_INIT\n,\nCOMPACT_CTOR_DEF\n,\nLAMBDA\n.\n"}, "JavadocContentLocation": {"description": "Description\n\nChecks that the Javadoc content begins from the same position\nfor all Javadoc comments in the project. Any leading asterisks and spaces\nare not counted as the beginning of the content and are therefore ignored.\n\n\nIt is possible to enforce two different styles:\n\n\n\n{@code first_line} - Javadoc content starts from the first line:\n\n\n\n/** Summary text.\n* More details.\n*/\npublic void method();\n\n\n\n{@code second_line} - Javadoc content starts from the second line:\n\n\n\n/**\n* Summary text.\n* More details.\n*/\npublic void method();", "option": "\nlocation, Specify the policy on placement of the Javadoc content., JavadocContentLocationOption, second_line"}, "RegexpMultiline": {"description": "Description\n\nChecks that a specified pattern matches across multiple lines in\nany file type.\n\n\nRationale: This check can be used to when the regular\nexpression can be span multiple lines.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nformat, Specify the format of the regular expression to match., Pattern, \"$.\"\nignoreCase, Control whether to ignore case when searching., boolean, false\nmatchAcrossLines, Control whether to match expressions across multiple lines., boolean, false\nmaximum, Specify the maximum number of matches required in each file., int, 0\nmessage, Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used., String, null\nminimum, Specify the minimum number of matches required in each file., int, 0"}, "AtclauseOrder": {"description": "Description\n\nChecks the order of\n\njavadoc block-tags or javadoc tags.\n\n\nNote: Google used the term \"at-clauses\" for block tags in their guide till 2017-02-28.", "option": "\ntagOrder, Specify the order by tags., String[], @author, @deprecated, @exception, @param, @return, @see, @serial, @serialData, @serialField, @since, @throws, @version\ntarget, Specify block tags targeted., subset of tokens TokenTypes,\n\nCLASS_DEF\n,\nCOMPACT_CTOR_DEF\n,\nCTOR_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nMETHOD_DEF\n,\nRECORD_DEF\n,\nVARIABLE_DEF\n\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "InnerTypeLast": {"description": "Description\n\nChecks nested (internal) classes/interfaces are declared at the bottom of the\nprimary (top-level) class after all init and static init blocks,\nmethod, constructor and field declarations.", "option": ""}, "FinalLocalVariable": {"description": "Description\n\nChecks that local variables that never have their values changed are\ndeclared final. The check can be configured to also check that\nunchanged parameters are declared final.", "option": "\nvalidateEnhancedForLoopVariable, Control whether to check\nenhanced for-loop variable., boolean, false\ntokens, tokens to check, subset of tokens\n\nVARIABLE_DEF\n,\nPARAMETER_DEF\n.\n,\n\nVARIABLE_DEF\n.\n"}, "WhitespaceAfter": {"description": "Description\n\nChecks that a token is followed by whitespace, with the exception that it\ndoes not check for whitespace after the semicolon of an empty for iterator. Use Check\n\nEmptyForIteratorPad to validate empty for iterators.", "option": "\ntokens, tokens to check, subset of tokens\n\nCOMMA\n,\nSEMI\n,\nTYPECAST\n,\nLITERAL_IF\n,\nLITERAL_ELSE\n,\nLITERAL_WHILE\n,\nLITERAL_DO\n,\nLITERAL_FOR\n,\nLITERAL_FINALLY\n,\nLITERAL_RETURN\n,\nLITERAL_YIELD\n,\nLITERAL_CATCH\n,\nDO_WHILE\n,\nELLIPSIS\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_TRY\n,\nLITERAL_CASE\n,\nLAMBDA\n.\n,\n\nCOMMA\n,\nSEMI\n,\nTYPECAST\n,\nLITERAL_IF\n,\nLITERAL_ELSE\n,\nLITERAL_WHILE\n,\nLITERAL_DO\n,\nLITERAL_FOR\n,\nLITERAL_FINALLY\n,\nLITERAL_RETURN\n,\nLITERAL_YIELD\n,\nLITERAL_CATCH\n,\nDO_WHILE\n,\nELLIPSIS\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_TRY\n,\nLITERAL_CASE\n,\nLAMBDA\n.\n"}, "ClassFanOutComplexity": {"description": "Description\n\nChecks the number of other types a given class/record/interface/enum/annotation\nrelies on. Also, the square of this has been shown to indicate the amount of\nmaintenance required in functional programs (on a file basis) at least.\n\n\nThis check processes files in the following way:\n\n\n\nIterates over all tokens that might contain type reference.\n\n\nIf a class was imported with direct import (i.e.\nimport java.math.BigDecimal), or the class was referenced with the\npackage name (i.e. java.math.BigDecimal value) and the package was\nadded to the excludedPackages parameter, the class does not increase\ncomplexity.\n\n\nIf a class name was added to the excludedClasses parameter,\nthe class does not increase complexity.", "option": "\nexcludeClassesRegexps, Specify user-configured regular expressions to ignore classes., Pattern[], ^$\nexcludedClasses, Specify user-configured class names to ignore., String[], ArrayIndexOutOfBoundsException, ArrayList, Boolean, Byte, Character, Class, Collection, Deprecated, Deque, Double, DoubleStream, EnumSet, Exception, Float, FunctionalInterface, HashMap, HashSet, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, IntStream, Integer, LinkedHashMap, LinkedHashSet, LinkedList, List, Long, LongStream, Map, NullPointerException, Object, Optional, OptionalDouble, OptionalInt, OptionalLong, Override, Queue, RuntimeException, SafeVarargs, SecurityException, Set, Short, SortedMap, SortedSet, Stream, String, StringBuffer, StringBuilder, SuppressWarnings, Throwable, TreeMap, TreeSet, UnsupportedOperationException, Void, boolean, byte, char, double, float, int, long, short, var, void\nexcludedPackages, Specify user-configured packages to ignore., String[], {}\nmax, Specify the maximum threshold allowed., int, 20"}, "RegexpSinglelineJava": {"description": "Description\n\nChecks that a specified pattern matches a single-line in Java files.\n\n\nThis class is variation on\nRegexpSingleline for detecting\nsingle-lines that match a supplied regular expression in Java files. It supports\nsuppressing matches in Java comments.", "option": "\nformat, Specify the format of the regular expression to match., Pattern, \"$.\"\nignoreCase, Control whether to ignore case when searching., boolean, false\nignoreComments, Control whether to ignore text in comments when searching., boolean, false\nmaximum, Specify the maximum number of matches required in each file., int, 0\nmessage, Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used., String, null\nminimum, Specify the minimum number of matches required in each file., int, 0"}, "SingleLineJavadoc": {"description": "Description\n\nChecks that a Javadoc block can fit in a single-line and doesn't\ncontain block tags. Javadoc comment that contains at least one block tag\nshould be formatted in a few lines.", "option": "\nignoreInlineTags, Control whether\ninline tags must be ignored., boolean, true\nignoredTags, Specify\nblock tags which are ignored by the check., String[], {}\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "NoLineWrap": {"description": "Description\n\nChecks that chosen statements are not line-wrapped. By default, this\nCheck restricts wrapping import and package statements, but it's possible to check\nany statement.", "option": "\ntokens, tokens to check, subset of tokens\n\nIMPORT\n,\nSTATIC_IMPORT\n,\nPACKAGE_DEF\n,\nCLASS_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nPACKAGE_DEF\n,\nIMPORT\n,\nSTATIC_IMPORT\n.\n"}, "MethodCount": {"description": "Description\n\nChecks the number of methods declared in each type declaration by access modifier or\ntotal count.\n\n\nThis check can be configured to flag classes that define too many methods to prevent the\nclass from getting too complex.\nCounting can be customized to prevent too many total methods in a type definition\n(maxTotal), or to prevent too many methods of a specific access modifier\n(private, package, protected or\npublic).\nEach count is completely separated to customize how many methods of each you want to\nallow. For example, specifying a maxTotal of 10, still means you can\nprevent more than 0 maxPackage methods. A violation won't appear for 8\npublic methods, but one will appear if there is also 3 private methods or any\npackage-private methods.\n\n\nMethods defined in anonymous classes are not counted towards any totals.\nCounts only go towards the main type declaration parent, and are kept separate from it's\nchildren's inner types.\n\n\n\npublic class ExampleClass {\npublic enum Colors {\nRED, GREEN, YELLOW;\n\npublic String getRGB() { ... } // NOT counted towards ExampleClass\n}\n\npublic void example() { // counted towards ExampleClass\nRunnable r = (new Runnable() {\npublic void run() { ... } // NOT counted towards ExampleClass, won't produce any violations\n});\n}\n\npublic static class InnerExampleClass {\nprotected void example2() { ... } // NOT counted towards ExampleClass,\n// but counted towards InnerExampleClass\n}\n}", "option": "\nmaxPackage, Specify the maximum number of package methods allowed., int, 100\nmaxPrivate, Specify the maximum number of private methods allowed., int, 100\nmaxProtected, Specify the maximum number of protected methods allowed., int, 100\nmaxPublic, Specify the maximum number of public methods allowed., int, 100\nmaxTotal, Specify the maximum number of methods allowed at all scope levels., int, 100\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nCLASS_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "AnnotationLocation": {"description": "Description\n\nChecks location of annotation on language elements.\nBy default, Check enforce to locate annotations immediately after documentation block\nand before target element, annotation should be located on separate line from target\nelement. This check also verifies that the annotations are on the same indenting level as\nthe annotated element if they are not on the same line.\n\n\nAttention: Elements that cannot have JavaDoc comments like local variables are not in the\nscope of this check even though a token type like VARIABLE_DEF would match\nthem.\n\n\nAttention: Annotations among modifiers are ignored (looks like false-negative)\nas there might be a problem with annotations for return types:\n\n\npublic @Nullable Long getStartTimeOrNull() { ... }\n\nSuch annotations are better to keep close to type.\nDue to limitations, Checkstyle can not examine the target of an annotation.\n\n\nExample:\n\n\n\n@Override\n@Nullable\npublic String getNameIfPresent() { ... }", "option": "\nallowSamelineMultipleAnnotations, Allow annotation(s) to be located on the same line as target element., boolean, false\nallowSamelineParameterizedAnnotation, Allow one and only parameterized annotation to be located on the same line as target element., boolean, false\nallowSamelineSingleParameterlessAnnotation, Allow single parameterless annotation to be located on the same line as target element., boolean, true\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nPACKAGE_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nPACKAGE_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nVARIABLE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "RedundantModifier": {"description": "Description\n\nChecks for redundant modifiers.\n\n\nRationale: The Java Language Specification strongly\ndiscourages the usage of public and abstract for method\ndeclarations in interface definitions as a matter of style.\n\nThe check validates:\n\nInterface and annotation definitions.\nFinal modifier on methods of final and anonymous classes.\n\nType declarations nested under interfaces that are declared as public\nor static.\n\nClass constructors.\n\nNested enum definitions that are declared\nas static.\n\n\nrecord definitions that are declared as final and nested\nrecord definitions that are declared as static.\n\n\n\ninterfaces by definition are abstract so the abstract modifier is\nredundant on them.\n\n\nType declarations nested under interfaces by definition are public and static,\nso the public and static modifiers on nested type\ndeclarations are redundant. On the other hand, classes inside of interfaces can\nbe abstract or non abstract. So, abstract modifier is allowed.\n\n\nFields in interfaces and annotations are automatically\npublic, static and final, so these modifiers are redundant as\nwell.\n\n\nAs annotations are a form of interface, their fields are also\nautomatically public, static and final just as their\nannotation fields are automatically public and abstract.\n\n\nA record class is implicitly final and cannot be abstract, these restrictions emphasize\nthat the API of a record class is defined solely by its state description, and cannot be\nenhanced later by another class. Nested records are implicitly static. This avoids an\nimmediately enclosing instance which would silently add state to the record class.\nSee JEP 395 for more info.\n\n\nEnums by definition are static implicit subclasses of java.lang.Enum<E>.\nSo, the static modifier on the enums is redundant. In addition,\nif enum is inside of interface, public modifier is also redundant.\n\n\nEnums can also contain abstract methods and methods which can be overridden by the\ndeclared enumeration fields.\nSee the following example:\n\n\n\npublic enum EnumClass {\nFIELD_1,\nFIELD_2 {\n@Override\npublic final void method1() {} // violation expected\n};\n\npublic void method1() {}\npublic final void method2() {} // no violation expected\n}\n\n\nSince these methods can be overridden in these situations, the final methods are not\nmarked as redundant even though they can't be extended by other classes/enums.\n\n\nNested enum types are always static by default.\n\n\nFinal classes by definition cannot be extended so the final\nmodifier on the method of a final class is redundant.\n\n\nPublic modifier for constructors in non-public non-protected classes\nis always obsolete:\n\n\n\npublic class PublicClass {\npublic PublicClass() {} // OK\n}\n\nclass PackagePrivateClass {\npublic PackagePrivateClass() {} // violation expected\n}\n\nThere is no violation in the following example,\nbecause removing public modifier from ProtectedInnerClass\nconstructor will make this code not compiling:\n\n\n\npackage a;\npublic class ClassExample {\nprotected class ProtectedInnerClass {\npublic ProtectedInnerClass () {}\n}\n}\n\npackage b;\nimport a.ClassExample;\npublic class ClassExtending extends ClassExample {\nProtectedInnerClass pc = new ProtectedInnerClass();\n}", "option": "\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_FIELD_DEF\n,\nINTERFACE_DEF\n,\nCTOR_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nRESOURCE\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n,\n\nMETHOD_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_FIELD_DEF\n,\nINTERFACE_DEF\n,\nCTOR_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nRESOURCE\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "JavadocPackage": {"description": "Description\n\nChecks that each Java package has a Javadoc file used for\ncommenting. By default, it only allows a package-info.java file, but can be\nconfigured to allow a package.html\nfile.\n\n\nA violation will be reported if both files exist as this is not\nallowed by the Javadoc tool.", "option": "\nallowLegacy, Allow legacy package.html file to be used., boolean, false\nfileExtensions, Specify the file extensions of the files to process., String[], .java"}, "DesignForExtension": {"description": "Description\n\nChecks that classes are designed for extension (subclass creation).\n\n\nNothing wrong could be with founded classes.\nThis check makes sense only for library projects (not application projects)\nwhich care of ideal OOP-design to make sure that class works in all cases even misusage.\nEven in library projects this check most likely will find classes that are designed\nfor extension by somebody. User needs to use suppressions extensively to got a benefit\nfrom this check, and keep in suppressions all confirmed/known classes that are deigned\nfor inheritance intentionally to let the check catch only new classes, and bring this to\nteam/user attention.\n\n\nATTENTION: Only user can decide whether a class is designed for extension or not.\nThe check just shows all classes which are possibly designed for extension.\nIf smth inappropriate is found please use suppression.\n\n\nATTENTION: If the method which can be overridden in a subclass has a javadoc comment\n(a good practice is to explain its self-use of overridable methods) the check will not\nrise a violation. The violation can also be skipped if the method which can be overridden\nin a subclass has one or more annotations that are specified in ignoredAnnotations\noption. Note, that by default @Override annotation is not included in the\nignoredAnnotations set as in a subclass the method which has the annotation can also be\noverridden in its subclass.\n\n\nProblem is described at \"Effective Java, 2nd Edition by Joshua Bloch\" book, chapter\n\"Item 17: Design and document for inheritance or else prohibit it\".\n\n\nSome quotes from book:\n\nThe class must document its self-use of overridable methods.\nBy convention, a method that invokes overridable methods contains a description\nof these invocations at the end of its documentation comment. The description\nbegins with the phrase \u201cThis implementation.\u201d\n\nThe best solution to this problem is to prohibit subclassing in classes that\nare not designed and documented to be safely subclassed.\n\nIf a concrete class does not implement a standard interface, then you may\ninconvenience some programmers by prohibiting inheritance. If you feel that you\nmust allow inheritance from such a class, one reasonable approach is to ensure\nthat the class never invokes any of its overridable methods and to document this\nfact. In other words, eliminate the class\u2019s self-use of overridable methods entirely.\nIn doing so, you\u2019ll create a class that is reasonably safe to subclass. Overriding a\nmethod will never affect the behavior of any other method.\n\n\nThe check finds classes that have overridable methods (public or protected methods\nthat are non-static, not-final, non-abstract) and have non-empty implementation.\n\n\nRationale: This library design style protects superclasses against\nbeing broken by subclasses. The downside is that subclasses are\nlimited in their flexibility, in particular they cannot prevent\nexecution of code in the superclass, but that also means that\nsubclasses cannot corrupt the state of the superclass by forgetting\nto call the superclass's method.\n\n\nMore specifically,\nit enforces a programming style where superclasses provide empty\n\"hooks\" that can be implemented by subclasses.\n\n\nExample of code that cause violation as it is designed for extension:\n\n\n\npublic abstract class Plant {\nprivate String roots;\nprivate String trunk;\n\nprotected void validate() {\nif (roots == null) throw new IllegalArgumentException(\"No roots!\");\nif (trunk == null) throw new IllegalArgumentException(\"No trunk!\");\n}\n\npublic abstract void grow();\n}\n\npublic class Tree extends Plant {\nprivate List leaves;\n\n@Overrides\nprotected void validate() {\nsuper.validate();\nif (leaves == null) throw new IllegalArgumentException(\"No leaves!\");\n}\n\npublic void grow() {\nvalidate();\n}\n}\n\n\nExample of code without violation:\n\n\n\npublic abstract class Plant {\nprivate String roots;\nprivate String trunk;\n\nprivate void validate() {\nif (roots == null) throw new IllegalArgumentException(\"No roots!\");\nif (trunk == null) throw new IllegalArgumentException(\"No trunk!\");\nvalidateEx();\n}\n\nprotected void validateEx() { }\n\npublic abstract void grow();\n}", "option": "\nignoredAnnotations, Specify annotations which allow the check to skip the method from validation., String[], After, AfterClass, Before, BeforeClass, Test\nrequiredJavadocPhrase, Specify the comment text pattern which qualifies a method as designed for extension. Supports multi-line regex., Pattern, \".*\""}, "CatchParameterName": {"description": "Description\n\nChecks that catch parameter names conform to a specified pattern.\n\n\nDefault pattern has the following characteristic:\n\n\nallows names beginning with two lowercase letters followed by at least one uppercase\nor lowercase letter\nallows e abbreviation (suitable for exceptions end errors)\nallows ex abbreviation (suitable for exceptions)\nallows t abbreviation (suitable for throwables)\nprohibits numbered abbreviations like e1 or t2\nprohibits one letter prefixes like pException\nprohibits two letter abbreviations like ie or ee\nprohibits any other characters than letters", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^(e|t|ex|[a-z][a-z][a-zA-Z]+)$\""}, "MissingSwitchDefault": {"description": "Description\n\nChecks that switch statement has a default clause.\n\n\nRationale: It's usually a good idea to introduce a default case in\nevery switch statement. Even if the developer is sure that all\ncurrently possible cases are covered, this should be expressed in\nthe default branch, e.g. by using an assertion. This way the code is\nprotected against later changes, e.g. introduction of new types in an\nenumeration type.\n\n\nThis check does not validate any switch expressions. Rationale:\nThe compiler requires switch expressions to be exhaustive. This means\nthat all possible inputs must be covered.\n\n\nThis check does not validate switch statements that use pattern or null\nlabels. Rationale: Switch statements that use pattern or null labels are\nchecked by the compiler for exhaustiveness. This means that all possible\ninputs must be covered.\n\n\nSee the\n\nJava Language Specification for more information about switch statements\nand expressions.", "option": ""}, "StringLiteralEquality": {"description": "Description\n\nChecks that string literals are not used with == or\n!=.\nSince == will compare the object references,\nnot the actual value of the strings,\nString.equals() should be used.\nMore information can be found\n\nin this article.\n\n\nRationale: Novice Java programmers often use code like:\n\n\n\nif (x == \"something\")\n\nwhen they mean\n\n\nif (\"something\".equals(x))", "option": ""}, "ArrayTypeStyle": {"description": "Description\n\nChecks the style of array type definitions. Some like Java style:\npublic static void main(String[] args) and some like\nC style: public static void main(String args[]).\n\n\nBy default, the Check enforces Java style.\n\n\nThis check strictly enforces only Java style for method return types\nregardless of the value for 'javaStyle'. For example, byte[] getData().\nThis is because C doesn't compile methods with array declarations on the name.", "option": "\njavaStyle, Control whether to enforce Java style (true) or C style (false)., boolean, true"}, "NoArrayTrailingComma": {"description": "Description\n\nChecks that array initialization do not contain a trailing comma.\nRationale: JLS allows trailing commas in arrays and enumerations, but does not allow\nthem in other locations. To unify the coding style, the use of trailing commas should\nbe prohibited.\n\n\n\nint[] foo = new int[] {\n1,\n2\n};\n\n\nThe check demands that there should not be any comma after the last element of an array.\n\n\n\nString[] foo = new String[] {\n\"FOO\",\n\"BAR\", //violation\n}", "option": ""}, "FileLength": {"description": "Description\n\nChecks for long source files.\n\n\nRationale: If a source file becomes very long it is hard to\nunderstand. Therefore, long classes should usually be refactored\ninto several individual classes that focus on a specific task.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nmax, Specify the maximum number of lines allowed., int, 2000"}, "SimplifyBooleanExpression": {"description": "Description\n\nChecks for over-complicated boolean expressions. Currently, it finds\ncode like  if (b == true), b || true, !false,\nboolean a = q > 12 ? true : false,\netc.\n\n\nRationale: Complex boolean logic makes code hard to understand and\nmaintain.", "option": ""}, "IllegalToken": {"description": "Description\n\nChecks for illegal tokens. By default, labels are prohibited.\n\n\nRationale: Certain language features can harm readability, lead to\nconfusion or are not obvious to novice developers. Other features\nmay be discouraged in certain frameworks, such as not having\nnative methods in Enterprise JavaBeans components.", "option": "\ntokens, tokens to check, set of any supported\n\ntokens\n,\n\nLABELED_STAT\n.\n"}, "InnerAssignment": {"description": "Description\n\nChecks for assignments in subexpressions, such as in\nString s = Integer.toString(i = 2);.\n\n\nRationale: Except for the loop idioms,\nall assignments should occur in their own top-level statement\nto increase readability. With inner assignments like the one given above, it is difficult\nto see all places where a variable is set.\n\n\nNote: Check allows usage of the popular assignments in loops:\n\n\n\nString line;\nwhile ((line = bufferedReader.readLine()) != null) { // OK\n// process the line\n}\n\nfor (;(line = bufferedReader.readLine()) != null;) { // OK\n// process the line\n}\n\ndo {\n// process the line\n}\nwhile ((line = bufferedReader.readLine()) != null); // OK\n\n\nAssignment inside a condition is not a problem here, as the assignment is surrounded by\nan extra pair of parentheses. The comparison is != null and there is no\nchance that intention was to write line == reader.readLine().", "option": ""}, "MissingJavadocPackage": {"description": "Description\n\nChecks for missing package definition Javadoc comments in package-info.java files.\n\n\nRationale: description and other related documentation for a package can be written up\nin the package-info.java file and it gets used in the production of the Javadocs.\nSee\nlink for more info.\n\n\nThis check specifically only validates package definitions. It will not validate any\nmethods or interfaces declared in the package-info.java file.", "option": ""}, "AvoidNestedBlocks": {"description": "Description\n\nFinds nested blocks (blocks that are used freely in the code).\n\n\nRationale: Nested blocks are often leftovers from the\ndebugging process, they confuse the reader.\n\n\nFor example, this check finds the obsolete braces in\n\n\n\npublic void guessTheOutput()\n{\nint whichIsWhich = 0;\n{\nwhichIsWhich = 2;\n}\nSystem.out.println(\"value = \" + whichIsWhich);\n}\n\nand debugging / refactoring leftovers such as\n\n\n// if (conditionThatIsNotUsedAnyLonger)\n{\nSystem.out.println(\"unconditional\");\n}\n\n\nA case in a switch statement does not implicitly form a block.\nThus, to be able to introduce local variables that have case\nscope it is necessary to open a nested block. This is\nsupported, set the allowInSwitchCase property to true and\ninclude all statements of the case in the block.", "option": "\nallowInSwitchCase, Allow nested blocks if they are the only child of a switch case., boolean, false"}, "MethodParamPad": {"description": "Description\n\nChecks the padding between the identifier of a method definition,\nconstructor definition, method call, or constructor invocation; and\nthe left parenthesis of the parameter list. That is, if the\nidentifier and left parenthesis are on the same line, checks whether\na space is required immediately after the identifier or such a space\nis forbidden. If they are not on the same line, reports a violation,\nunless configured to allow line breaks. To allow linebreaks after\nthe identifier, set property allowLineBreaks to\ntrue.", "option": "\nallowLineBreaks, Allow a line break between the identifier and left parenthesis., boolean, false\noption, Specify policy on how to pad method parameter., PadOption, nospace\ntokens, tokens to check, subset of tokens\n\nCTOR_DEF\n,\nLITERAL_NEW\n,\nMETHOD_CALL\n,\nMETHOD_DEF\n,\nSUPER_CTOR_CALL\n,\nENUM_CONSTANT_DEF\n,\nRECORD_DEF\n.\n,\n\nCTOR_DEF\n,\nLITERAL_NEW\n,\nMETHOD_CALL\n,\nMETHOD_DEF\n,\nSUPER_CTOR_CALL\n,\nENUM_CONSTANT_DEF\n,\nRECORD_DEF\n.\n"}, "LeftCurly": {"description": "Description\n\nChecks for the placement of left curly braces\n('{') for code blocks.", "option": "\nignoreEnums, Allow to ignore enums when left curly brace policy is EOL., boolean, true\noption, Specify the policy on placement of a left curly brace ('{')., LeftCurlyOption, eol\ntokens, tokens to check, subset of tokens\n\nANNOTATION_DEF\n,\nCLASS_DEF\n,\nCTOR_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nLAMBDA\n,\nLITERAL_CASE\n,\nLITERAL_CATCH\n,\nLITERAL_DEFAULT\n,\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FINALLY\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_TRY\n,\nLITERAL_WHILE\n,\nMETHOD_DEF\n,\nOBJBLOCK\n,\nSTATIC_INIT\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nANNOTATION_DEF\n,\nCLASS_DEF\n,\nCTOR_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nLAMBDA\n,\nLITERAL_CASE\n,\nLITERAL_CATCH\n,\nLITERAL_DEFAULT\n,\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FINALLY\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_TRY\n,\nLITERAL_WHILE\n,\nMETHOD_DEF\n,\nOBJBLOCK\n,\nSTATIC_INIT\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "ImportControl": {"description": "Description\n\nControls what can be imported in each package and file. Useful for\nensuring that application layering rules are not violated,\nespecially on large projects.\n\n\nYou can control imports based on the package name or based on the file\nname. When controlling packages, all files and sub-packages in the declared\npackage will be controlled by this check. To specify differences between a main package\nand a sub-package, you must define the sub-package inside the main package. When\ncontrolling file, only the file name is considered and only files processed by\nTreeWalker. The file's extension is ignored.\n\n\nShort description of the behaviour:\n\n\nCheck starts checking from the longest matching subpackage (later 'current\nsubpackage') or the first file name match described inside import\ncontrol file to package defined in class file.\n\n\n\nThe longest matching subpackage is found by starting with the root package\nand examining if any of the sub-packages or file definitions match the\ncurrent class' package or file name.\n\n\nIf a file name is matched first, that is considered the longest\nmatch and becomes the current file/subpackage.\n\n\nIf another subpackage is matched, then it's subpackages and file\nnames are examined for the next longest match and the process repeats\nrecursively.\n\n\nIf no subpackages or file names are matched, the current subpackage\nis then used.\n\n\n\n\nOrder of rules in the same subpackage/root are defined by the order of\ndeclaration in the XML file, which is from top (first) to bottom (last).\n\n\nIf there is matching allow/disallow rule inside the current file/subpackage\nthen the Check returns the first \"allowed\" or \"disallowed\" message.\n\n\nIf there is no matching allow/disallow rule inside the current file/subpackage\nthen it continues checking in the parent subpackage.\n\n\nIf there is no matching allow/disallow rule in any of the files/subpackages,\nincluding the root level (import-control), then the import is disallowed by default.\n\n\n\nThe DTD for an import control XML document is at\nhttps://checkstyle.org/dtds/import_control_1_4.dtd. It\ncontains documentation on each of the elements and attributes.\n\n\nThe check validates a XML document when it loads the document.\nTo validate against the above DTD, include the following\ndocument type declaration in your XML document:\n\n\n\n\n<!DOCTYPE import-control PUBLIC\n\"-//Checkstyle//DTD ImportControl Configuration 1.4//EN\"\n\"https://checkstyle.org/dtds/import_control_1_4.dtd\">", "option": "\nfile, Specify the location of the file containing the import control configuration. It can be a regular file, URL or resource path. It will try loading the path as a URL first, then as a file, and finally as a resource., URI, null\npath, Specify the regular expression of file paths to which this check should apply. Files that don't match the pattern will not be checked. The pattern will be matched against the full absolute file path., Pattern, \".*\""}, "RecordTypeParameterName": {"description": "Description\nChecks that record type parameter names conform to a specified pattern.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[A-Z]$\""}, "UpperEll": {"description": "Description\n\nChecks that long constants are defined with an upper ell. That\nis 'L' and not 'l'. This is in accordance with the Java\nLanguage Specification,\n\nSection 3.10.1.\n\n\nRationale: The lower-case ell 'l' looks a lot like 1.", "option": ""}, "ParameterAssignment": {"description": "Description\nDisallows assignment of parameters.\n\nRationale: Parameter assignment is often considered poor programming\npractice. Forcing developers to declare parameters as final is often\nonerous. Having a check ensure that parameters are never assigned\nwould give the best of both worlds.", "option": ""}, "NoClone": {"description": "Description\n\nChecks that the clone method is not overridden from the\nObject class.\n\n\nThis check is almost exactly the same as the NoFinalizerCheck.\n\n\nSee\nObject.clone()\n\n\nRationale: The clone method relies on strange, hard to follow rules that\nare difficult to get right and do not work in all situations.\nIn some cases, either a copy constructor\nor a static factory method can be used instead of the clone method\nto return copies of an object.\nFor more information on rules for the clone method and its issues, see Effective Java:\nProgramming Language Guide First Edition by Joshua Bloch\npages 45-52.\n\n\nBelow are some rules/reasons why the clone method should be avoided.\n\n\n\nClasses supporting the clone method should implement the Cloneable interface\nbut the Cloneable interface does not include the clone method.\nAs a result, it doesn't enforce the method override.\n\n\nThe Cloneable interface forces the Object's clone method to work correctly.\nWithout implementing it, the Object's clone method will throw a\nCloneNotSupportedException.\n\n\nNon-final classes must return the object returned from a call to super.clone().\n\n\nFinal classes can use a constructor to create a clone which is different\nfrom non-final classes.\n\n\nIf a super class implements the clone method incorrectly all subclasses calling\nsuper.clone() are doomed to failure.\n\n\nIf a class has references to mutable objects then those object references must be\nreplaced with copies in the clone method after calling super.clone().\n\n\nThe clone method does not work correctly with final mutable object references because\nfinal references cannot be reassigned.\n\n\nIf a super class overrides the clone method then all subclasses must provide a correct\nclone implementation.\n\n\n\nTwo alternatives to the clone method, in some cases, is a copy constructor or a static\nfactory method to return copies of an object. Both of these approaches are simpler and\ndo not conflict with final fields. They do not force the calling client to handle a\nCloneNotSupportedException.  They also are typed therefore no casting is necessary.\nFinally, they are more flexible since they can take interface types rather than concrete\nclasses.\n\n\nSometimes a copy constructor or static factory is not an acceptable alternative to the\nclone method.  The example below highlights the limitation of a copy constructor\n(or static factory). Assume Square is a subclass for Shape.\n\n\n\nShape s1 = new Square();\nSystem.out.println(s1 instanceof Square); //true\n\n\n...assume at this point the code knows nothing of s1 being a Square that's the beauty\nof polymorphism but the code wants to copy the Square which is declared as a Shape,\nits super type...\n\n\n\nShape s2 = new Shape(s1); //using the copy constructor\nSystem.out.println(s2 instanceof Square); //false\n\n\nThe working solution (without knowing about all subclasses and doing many casts) is to do\nthe following (assuming correct clone implementation).\n\n\n\nShape s2 = s1.clone();\nSystem.out.println(s2 instanceof Square); //true\n\n\nJust keep in mind if this type of polymorphic cloning is required then a properly\nimplemented clone method may be the best choice.\n\n\nMuch of this information was taken from Effective Java: Programming Language Guide First\nEdition by Joshua Bloch pages 45-52.  Give Bloch credit for writing an excellent book.", "option": ""}, "CustomImportOrder": {"description": "Description\n\nChecks that the groups of import declarations appear in the order specified\nby the user. If there is an import but its group is not specified in the\nconfiguration such an import should be placed at the end of the import list.", "option": "\ncustomImportOrderRules, Specify ordered list of import groups., String[], {}\nseparateLineBetweenGroups, Force empty line separator between import groups., boolean, true\nsortImportsInGroupAlphabetically, Force grouping alphabetically, in ASCII sort order., boolean, false\nspecialImportsRegExp, Specify RegExp for SPECIAL_IMPORTS group imports., Pattern, \"^$\"\nstandardPackageRegExp, Specify RegExp for STANDARD_JAVA_PACKAGE group imports., Pattern, \"^(java|javax)\\.\"\nthirdPartyPackageRegExp, Specify RegExp for THIRD_PARTY_PACKAGE group imports., Pattern, \".*\""}, "InterfaceIsType": {"description": "Description\n\nImplements Joshua Bloch, Effective Java, Item 17 - Use Interfaces only to\ndefine types.\n\n\nAccording to Bloch, an interface should describe a type.\nIt is therefore inappropriate to define an interface that does not\ncontain any methods but only constants. The Standard interface\njavax.swing.SwingConstants\nis an example of an interface that would be flagged by this check.\n\n\nThe check can be configured to also disallow marker interfaces like\njava.io.Serializable, that do not contain methods or\nconstants at all.", "option": "\nallowMarkerInterfaces, Control whether marker interfaces like Serializable are allowed., boolean, true"}, "UnnecessarySemicolonAfterTypeMemberDeclaration": {"description": "Description\n\nChecks if unnecessary semicolon is used after type member declaration.", "option": "\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_FIELD_DEF\n,\nSTATIC_INIT\n,\nINSTANCE_INIT\n,\nCTOR_DEF\n,\nMETHOD_DEF\n,\nENUM_CONSTANT_DEF\n,\nCOMPACT_CTOR_DEF\n,\nRECORD_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nVARIABLE_DEF\n,\nANNOTATION_FIELD_DEF\n,\nSTATIC_INIT\n,\nINSTANCE_INIT\n,\nCTOR_DEF\n,\nMETHOD_DEF\n,\nENUM_CONSTANT_DEF\n,\nCOMPACT_CTOR_DEF\n,\nRECORD_DEF\n.\n"}, "ReturnCount": {"description": "Description\n\nRestricts the number of return statements in methods, constructors and lambda expressions.\nIgnores specified methods (equals by default).\n\n\nmax property will only check returns in methods and lambdas that return a specific\nvalue (Ex: 'return 1;').\n\n\nmaxForVoid property will only check returns in methods, constructors, and lambdas\nthat have no return type (IE 'return;').\nIt will only count visible return statements. Return statements not normally written, but\nimplied, at the end of the method/constructor definition will not be taken into account.\nTo disallow \"return;\" in void return type methods, use a value of 0.\n\n\nRationale: Too many return points can mean that code is\nattempting to do too much or may be difficult to understand.", "option": "\nformat, Specify method names to ignore., Pattern, \"^equals$\"\nmax, Specify maximum allowed number of return statements in non-void methods/lambdas., int, 2\nmaxForVoid, Specify maximum allowed number of return statements in void methods/constructors/lambdas., int, 1\ntokens, tokens to check, subset of tokens\n\nCTOR_DEF\n,\nMETHOD_DEF\n,\nLAMBDA\n.\n,\n\nCTOR_DEF\n,\nMETHOD_DEF\n,\nLAMBDA\n.\n"}, "LocalFinalVariableName": {"description": "Description\n\nChecks that local final variable names conform to a specified pattern.\nA catch parameter and resources in try statements\nare considered to be a local, final variables.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\"\ntokens, tokens to check, subset of tokens\n\nVARIABLE_DEF\n,\nPARAMETER_DEF\n,\nRESOURCE\n.\n,\n\nVARIABLE_DEF\n,\nPARAMETER_DEF\n,\nRESOURCE\n.\n"}, "PatternVariableName": {"description": "Description\n\nChecks that pattern variable names conform to a specified pattern.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "OuterTypeNumber": {"description": "Description\n\nChecks for the number of types declared at the outer\n(or root) level in a file.\n\n\nRationale: It is considered good practice to only define one outer\ntype per file.", "option": "\nmax, Specify the maximum number of outer types allowed., int, 1"}, "UnnecessarySemicolonInTryWithResources": {"description": "Description\n\nChecks if unnecessary semicolon is used in last resource declaration.", "option": "\nallowWhenNoBraceAfterSemicolon, Allow unnecessary semicolon if closing paren is not on the same line., boolean, true"}, "EmptyForInitializerPad": {"description": "Description\n\nChecks the padding of an empty for initializer; that is whether\na white space is required at an empty for initializer, or such white\nspace is forbidden.  No check occurs if there is a line wrap at the\ninitializer, as in\n\n\n\nfor (\n; i < j; i++, j--)", "option": "\noption, Specify policy on how to pad an empty for iterator., PadOption, nospace"}, "ExplicitInitialization": {"description": "Description\n\nChecks if any class or object member is explicitly initialized to\ndefault for its type value (null for\nobject references, zero for numeric types and char and false for\nboolean.\n\n\nRationale: Each instance variable gets initialized twice, to the\nsame value. Java initializes each instance variable to its default value\n(0 or null) before performing any initialization specified in\nthe code. So there is a minor inefficiency.", "option": "\nonlyObjectReferences, Control whether only explicit initializations made to null for objects should be checked., boolean, false"}, "IllegalType": {"description": "Description\n\nChecks that particular classes or interfaces are never used.\n\n\nRationale: Helps reduce coupling on concrete classes.\n\n\nFor additional restriction of type usage see also:\nIllegalInstantiation,\nIllegalImport", "option": "\nignoredMethodNames, Specify methods that should not be checked., String[], getEnvironment, getInitialContext\nillegalAbstractClassNameFormat, Specify RegExp for illegal abstract class names., Pattern, \"^(.*[.])?Abstract.*$\"\nillegalClassNames, Specify classes that should not be used as types in variable declarations, return values or parameters., String[], HashMap, HashSet, LinkedHashMap, LinkedHashSet, TreeMap, TreeSet, java.util.HashMap, java.util.HashSet, java.util.LinkedHashMap, java.util.LinkedHashSet, java.util.TreeMap, java.util.TreeSet\nlegalAbstractClassNames, Define abstract classes that may be used as types., String[], {}\nmemberModifiers, Control whether to check only methods and fields with any of the specified modifiers. This property does not affect method calls nor method references nor record components., subset of tokens TokenTypes, {}\nvalidateAbstractClassNames, Control whether to validate abstract class names., boolean, false\ntokens, tokens to check, subset of tokens\n\nANNOTATION_FIELD_DEF\n,\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nMETHOD_CALL\n,\nMETHOD_DEF\n,\nMETHOD_REF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nRECORD_DEF\n,\nRECORD_COMPONENT_DEF\n.\n,\n\nANNOTATION_FIELD_DEF\n,\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nMETHOD_CALL\n,\nMETHOD_DEF\n,\nMETHOD_REF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nRECORD_DEF\n,\nRECORD_COMPONENT_DEF\n.\n"}, "FinalParameters": {"description": "Description\n\nChecks that parameters for methods, constructors, catch and for-each blocks are\nfinal. Interface, abstract, and native methods are not checked: the final\nkeyword does not make sense for interface, abstract, and native method\nparameters as there is no code that could modify the parameter.\n\n\nRationale: Changing the value of parameters during the execution of\nthe method's algorithm can be confusing and should be avoided. A\ngreat way to let the Java compiler prevent this coding style is to\ndeclare parameters final.", "option": "\nignorePrimitiveTypes, Ignore primitive types as parameters., boolean, false\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nLITERAL_CATCH\n,\nFOR_EACH_CLAUSE\n.\n,\n\nMETHOD_DEF\n,\nCTOR_DEF\n.\n"}, "IllegalImport": {"description": "Description\n\nChecks for imports from a set of illegal packages.", "option": "\nillegalClasses, Specify class names to reject, if regexp property is not set, checks if import equals class name. If regexp property is set, then list of class names will be interpreted as regular expressions. Note, all properties for match will be used., String[], {}\nillegalPkgs, Specify packages to reject, if regexp property is not set, checks if import is the part of package. If regexp property is set, then list of packages will be interpreted as regular expressions. Note, all properties for match will be used., String[], sun\nregexp, Control whether the illegalPkgs and illegalClasses should be interpreted as regular expressions., boolean, false"}, "RequireEmptyLineBeforeBlockTagGroup": {"description": "Description\n\nChecks that one blank line before the block tag if it is present in Javadoc.", "option": "\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "NeedBraces": {"description": "Description\nChecks for braces around code blocks.", "option": "\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n"}, "TodoComment": {"description": "Description\n\nChecks for TODO: comments. Actually\nit is a generic\n\npattern matcher on Java comments. To check for other\npatterns in Java comments, set the format property.", "option": "\nformat, Specify pattern to match comments against., Pattern, \"TODO:\""}, "DescendantToken": {"description": "Description\n\nChecks for restricted tokens beneath other tokens.\n\n\nWARNING: This is a very powerful and flexible check, but, at the\nsame time, it is low-level and very implementation-dependent because\nits results depend on the grammar we use to build abstract syntax\ntrees. Thus, we recommend using other checks when they provide the\ndesired functionality. Essentially, this check just works on the level\nof an abstract syntax tree and knows nothing about language structures.", "option": "\nlimitedTokens, Specify set of tokens with limited occurrences as descendants., subset of tokens TokenTypes, {}\nmaximumDepth, Specify the maximum depth for descendant counts., int, 2147483647\nmaximumMessage, Define the violation message when the maximum count is exceeded., String, null\nmaximumNumber, Specify a maximum count for descendants., int, 2147483647\nminimumDepth, Specify the minimum depth for descendant counts., int, 0\nminimumMessage, Define the violation message when the minimum count is not reached., String, null\nminimumNumber, Specify a minimum count for descendants., int, 0\nsumTokenCounts, Control whether the number of tokens found should be calculated from the sum of the individual token counts., boolean, false\ntokens, tokens to check, set of any supported\n\ntokens\n, empty"}, "EmptyStatement": {"description": "Description\n\nDetects empty statements (standalone \";\" semicolon).\nEmpty statements often introduce bugs that are hard to spot", "option": ""}, "SingleSpaceSeparator": {"description": "Description\n\nChecks that non-whitespace characters are separated by no more than one\nwhitespace. Separating characters by tabs or multiple spaces will be\nreported. Currently, the check doesn't permit horizontal alignment. To inspect\nwhitespaces before and after comments, set the property\nvalidateComments to true.\n\n\nSetting validateComments to false will ignore cases like:\n\n\n\nint i;  // Multiple whitespaces before comment tokens will be ignored.\nprivate void foo(int  /* whitespaces before and after block-comments will be\nignored */  i) {\n\n\nSometimes, users like to space similar items on different lines to the same\ncolumn position for easier reading. This feature isn't supported by this\ncheck, so both braces in the following case will be reported as violations.\n\n\n\npublic long toNanos(long d)  { return d;             } // 2 violations\npublic long toMicros(long d) { return d / (C1 / C0); }", "option": "\nvalidateComments, Control whether to validate whitespaces surrounding comments., boolean, false"}, "RegexpSingleline": {"description": "Description\n\nChecks that a specified pattern matches a single-line in any file type.\n\n\nRationale: This check can be used to prototype checks and to\nfind common bad practice such as calling ex.printStacktrace(),\nSystem.out.println(), System.exit(), etc.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nformat, Specify the format of the regular expression to match., Pattern, \"$.\"\nignoreCase, Control whether to ignore case when searching., boolean, false\nmaximum, Specify the maximum number of matches required in each file., int, 0\nmessage, Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used., String, null\nminimum, Specify the minimum number of matches required in each file., int, 0"}, "RecordComponentNumber": {"description": "Description\n\nChecks the number of record components in the\n\nheader\n\nof a record definition.", "option": "\naccessModifiers, Access modifiers of record definitions where the number of record components should be checked., AccessModifierOption[], public, protected, package, private\nmax, Specify the maximum number of components allowed in the header of a record definition., int, 8"}, "Regexp": {"description": "Description\n\nChecks that a specified pattern exists, exists less\nthan a set number of times, or does not exist in the file.\n\n\nThis check combines all the functionality provided by\nRegexpHeader\nexcept supplying the regular expression from a file.\n\n\nIt differs from them in that it works in multiline mode.\nIts regular expression can span multiple lines and it checks this\nagainst the whole file at once.\nThe others work in single-line mode.\nTheir single or multiple regular expressions can only span one line.\nThey check each of these against each line in the file in turn.\n\n\nNote: Because of the different mode of operation there may be\nsome changes in the regular expressions used to achieve a particular end.\n\nIn multiline mode...\n\n^ means the beginning of a line, as opposed to beginning of the\ninput.\nFor beginning of the input use \\A.\n$ means the end of a line, as opposed to the end of the input.\nFor end of input use \\Z.\nEach line in the file is terminated with a line feed character.\n\n\nNote: Not all regular expression engines are created equal. Some provide extra\nfunctions that others do not and some elements of the syntax may vary.\nThis check makes use of the\n\njava.util.regex package; please check its documentation for\ndetails of how to construct a regular expression to achieve a particular\ngoal.\n\n\nNote: When entering a regular expression as a parameter in the\nXML config file you must also take into account the XML rules. e.g. if\nyou want to match a < symbol you need to enter &lt;. The regular\nexpression should be entered on one line.", "option": "\nduplicateLimit, Control whether to check for duplicates of a required pattern, any negative value means no checking for duplicates, any positive value is used as the maximum number of allowed duplicates, if the limit is exceeded violations will be logged., int, 0\nerrorLimit, Specify the maximum number of violations before the check will abort., int, 100\nformat, Specify the pattern to match against., Pattern, \"^$\"\nignoreComments, Control whether to ignore matches found within comments., boolean, false\nillegalPattern, Control whether the pattern is required or illegal., boolean, false\nmessage, Specify message which is used to notify about violations, if empty then the default (hard-coded) message is used., String, null"}, "UncommentedMain": {"description": "Description\n\nDetects uncommented main methods.\n\n\nRationale: A main method is often used for debugging\npurposes. When debugging is finished, developers often forget\nto remove the method, which changes the API and increases the\nsize of the resulting class or JAR file. Except for\nthe real program entry points, all main methods should be\nremoved or commented out of the sources.", "option": "\nexcludedClasses, Specify pattern for qualified names of classes which are allowed to have a main method., Pattern, \"^$\""}, "EmptyLineSeparator": {"description": "Description\n\nChecks for empty line separators before package, all import declarations,\nfields, constructors, methods, nested classes,\nstatic initializers and instance initializers.\n\n\nChecks for empty line separators before not only statements but\nimplementation and documentation comments and blocks as well.\n\n\nATTENTION: empty line separator is required between token siblings,\nnot after line where token is found.\nIf token does not have a sibling of the same type, then empty line\nis required at its end (for example for CLASS_DEF it is after '}').\nAlso, trailing comments are skipped.", "option": "\nallowMultipleEmptyLines, Allow multiple empty lines between class members., boolean, true\nallowMultipleEmptyLinesInsideClassMembers, Allow multiple empty lines inside class members., boolean, true\nallowNoEmptyLineBetweenFields, Allow no empty line between fields., boolean, false\ntokens, tokens to check, subset of tokens\n\nPACKAGE_DEF\n,\nIMPORT\n,\nSTATIC_IMPORT\n,\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nSTATIC_INIT\n,\nINSTANCE_INIT\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nVARIABLE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nPACKAGE_DEF\n,\nIMPORT\n,\nSTATIC_IMPORT\n,\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nSTATIC_INIT\n,\nINSTANCE_INIT\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nVARIABLE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "HiddenField": {"description": "Description\n\nChecks that a local variable or a parameter does not shadow a field\nthat is defined in the same class.", "option": "\nignoreAbstractMethods, Control whether to ignore parameters of abstract methods., boolean, false\nignoreConstructorParameter, Control whether to ignore constructor parameters., boolean, false\nignoreFormat, Define the RegExp for names of variables and parameters to ignore., Pattern, null\nignoreSetter, Allow to ignore the parameter of a property setter method., boolean, false\nsetterCanReturnItsClass, Allow to expand the definition of a setter method to include methods that return the class' instance., boolean, false\ntokens, tokens to check, subset of tokens\n\nVARIABLE_DEF\n,\nPARAMETER_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nLAMBDA\n,\nRECORD_COMPONENT_DEF\n.\n,\n\nVARIABLE_DEF\n,\nPARAMETER_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nLAMBDA\n,\nRECORD_COMPONENT_DEF\n.\n"}, "SuppressWarnings": {"description": "Description\nAllows to specify what warnings that @SuppressWarnings\nis not allowed to suppress.\nYou can also specify a list of TokenTypes that\nthe configured warning(s) cannot be suppressed on.\n\n\nLimitations:  This check does not consider conditionals\ninside the @SuppressWarnings annotation.\n\n\nFor example:\n@SuppressWarnings((false) ? (true) ? \"unchecked\" : \"foo\" : \"unused\").\nAccording to the above example, the \"unused\" warning is being suppressed\nnot the \"unchecked\" or \"foo\" warnings.  All of these warnings will be\nconsidered and matched against regardless of what the conditional\nevaluates to.\nThe check also does not support code like @SuppressWarnings(\"un\" + \"used\"),\n@SuppressWarnings((String) \"unused\") or\n@SuppressWarnings({('u' + (char)'n') + (\"\"+(\"used\" + (String)\"\")),}).\n\n\nBy default, any warning specified will be disallowed on\nall legal TokenTypes unless otherwise specified via\nthe tokens property.\n\n\nAlso, by default warnings that are empty strings or all\nwhitespace (regex: ^$|^\\s+$) are flagged.  By specifying,\nthe format property these defaults no longer apply.\n\n\nThis check can be configured so that the \"unchecked\"\nand \"unused\" warnings cannot be suppressed on\nanything but variable and parameter declarations.\nSee below of an example.", "option": "\nformat, Specify the RegExp to match against warnings. Any warning being suppressed matching this pattern will be flagged., Pattern, \"^\\s*+$\"\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nENUM_CONSTANT_DEF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nCOMPACT_CTOR_DEF\n,\nRECORD_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nENUM_CONSTANT_DEF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nCOMPACT_CTOR_DEF\n,\nRECORD_DEF\n.\n"}, "JavadocMissingLeadingAsterisk": {"description": "Description\n\nChecks if the javadoc has\n\nleading asterisks\n\non each line.\n\n\nThe check does not require asterisks on the first line, nor on the last line\nif it is blank. All other lines in a Javadoc should start with *,\nincluding blank lines and code blocks.", "option": "\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "JavadocMethod": {"description": "Description\n\nChecks the Javadoc of a method or constructor.\n\n\nViolates parameters and type parameters\nfor which no param tags are\npresent can be suppressed by defining property\nallowMissingParamTags.\n\n\nViolates methods which return non-void but for which no return tag is\npresent can be suppressed by defining property\nallowMissingReturnTag.\n\n\nViolates exceptions which are declared to be thrown (by throws in the method\nsignature or by throw new in the method body), but for which no throws tag is\npresent by activation of property validateThrows.\nNote that throw new is not checked in the following places:\n\n\n\nInside a try block (with catch). It is not possible to determine if the thrown\nexception can be caught by the catch block as there is no knowledge of the\ninheritance hierarchy, so the try block is ignored entirely. However, catch\nand finally blocks, as well as try blocks without catch, are still checked.\n\n\nLocal classes, anonymous classes and lambda expressions. It is not known when the\nthrow statements inside such classes are going to be evaluated, so they are ignored.\n\n\n\nATTENTION: Checkstyle does not have information about hierarchy of exception types\nso usage of base class is considered as separate exception type.\nAs workaround, you need to specify both types in javadoc (parent and exact type).\n\n\nJavadoc is not required on a method that is tagged with the\n@Override annotation. However, under\nJava 5 it is not possible to mark a method required for an\ninterface (this was corrected under Java 6). Hence,\nCheckstyle supports using the convention of using a single\n{@inheritDoc} tag instead of all the\nother tags.\n\n\nNote that only inheritable items will allow the\n{@inheritDoc} tag to be used in place\nof comments. Static methods at all visibilities, private non-static\nmethods and constructors are not inheritable.\n\n\nFor example, if the following method is\nimplementing a method required by an interface, then the\nJavadoc could be done as:\n\n\n\n/** {@inheritDoc} */\npublic int checkReturnTag(final int aTagIndex,\nJavadocTag[] aTags,\nint aLineNo)", "option": "\naccessModifiers, Specify the access modifiers where Javadoc comments are checked., AccessModifierOption[], public, protected, package, private\nallowMissingParamTags, Control whether to ignore violations when a method has parameters but does not have matching param tags in the javadoc., boolean, false\nallowMissingReturnTag, Control whether to ignore violations when a method returns non-void type and does not have a return tag in the javadoc., boolean, false\nallowedAnnotations, Specify annotations that allow missed documentation., String[], Override\nvalidateThrows, Control whether to validate throws tags., boolean, false\ntokens, tokens to check, subset of tokens\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nANNOTATION_FIELD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nMETHOD_DEF\n,\nCTOR_DEF\n,\nANNOTATION_FIELD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "SimplifyBooleanReturn": {"description": "Description\n\nChecks for over-complicated boolean return statements. For example\nthe following code\n\n\n\nif (valid())\nreturn false;\nelse\nreturn true;\n\n\ncould be written as\n\n\n\nreturn !valid();\n\n\nThe idea for this Check has been shamelessly stolen from the\nequivalent\nPMD rule.", "option": ""}, "SummaryJavadoc": {"description": "Description\n\nChecks that\n\nJavadoc summary sentence does not contain phrases that are not recommended to use.\nSummaries that contain only the {@inheritDoc} tag are skipped. Summaries\nthat contain a non-empty {@code {@return}} are allowed. Check also violate Javadoc that\ndoes not contain first sentence, though with {@code {@return}} a period is not required\nas the Javadoc tool adds it.", "option": "\nforbiddenSummaryFragments, Specify the regexp for forbidden summary fragments., Pattern, \"^$\"\nperiod, Specify the period symbol at the end of first javadoc sentence., String, \".\"\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "EqualsHashCode": {"description": "Description\n\nChecks that classes that either override equals()\nor hashCode() also overrides the other.\nThis check only verifies that the method declarations match\nObject.equals(Object) and Object.hashCode() exactly to be\nconsidered an override. This check does not verify invalid method names, parameters\nother than Object, or anything else.\n\n\nRationale: The contract of equals() and\nhashCode() requires that equal objects\nhave the same hashCode. Therefore, whenever you override\nequals() you must override hashCode()\nto ensure that your class can be used in hash-based collections.", "option": ""}, "UnusedLocalVariable": {"description": "Description\n\nChecks that a local variable is declared and/or assigned, but not used.\nDoesn't support pattern variables yet.\nDoesn't check array components as array\ncomponents are classified as different kind of variables by JLS.", "option": ""}, "JavadocParagraph": {"description": "Description\n\nChecks the Javadoc paragraph.\n\n\nChecks that:\n\n\n\nThere is one blank line between each of two paragraphs.\n\n\nEach paragraph but the first has <p> immediately before the first word, with\nno space after.", "option": "\nallowNewlineParagraph, Control whether the <p> tag should be placed immediately before the first word., boolean, true\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "NoWhitespaceBefore": {"description": "Description\n\nChecks that there is no whitespace before a token. More\nspecifically, it checks that it is not preceded with whitespace, or\n(if linebreaks are allowed) all characters on the line before are\nwhitespace. To allow linebreaks before a token, set property\nallowLineBreaks to true. No check occurs\nbefore semicolons in empty for loop initializers or conditions.", "option": "\nallowLineBreaks, Control whether whitespace is allowed if the token is at a linebreak., boolean, false\ntokens, tokens to check, subset of tokens\n\nCOMMA\n,\nSEMI\n,\nPOST_INC\n,\nPOST_DEC\n,\nDOT\n,\nGENERIC_START\n,\nGENERIC_END\n,\nELLIPSIS\n,\nLABELED_STAT\n,\nMETHOD_REF\n.\n,\n\nCOMMA\n,\nSEMI\n,\nPOST_INC\n,\nPOST_DEC\n,\nELLIPSIS\n,\nLABELED_STAT\n.\n"}, "LambdaBodyLength": {"description": "Description\n\nChecks lambda body length.\n\n\nRationale: Similar to anonymous inner classes, if lambda body becomes very long\nit is hard to understand and to see the flow of the method\nwhere the lambda is defined. Therefore, long lambda body\nshould usually be extracted to method.", "option": "\nmax, Specify the maximum number of lines allowed., int, 10"}, "JavadocStyle": {"description": "Description\n\nValidates Javadoc comments to help ensure they are well formed.\n\n\nThe following checks are performed:\n\n\n\nEnsures the first sentence ends with proper punctuation\n(That is a period, question mark, or exclamation mark, by default).\nNote that this check is not applied to inline @return tags,\nbecause the Javadoc tools automatically appends a period to the end of the tag\ncontent.\nJavadoc automatically places the first sentence in the\nmethod summary table and index. Without proper punctuation\nthe Javadoc may be malformed. All items eligible for the\n{@inheritDoc} tag are exempt from this\nrequirement.\n\n\nCheck text for Javadoc statements that do not have any\ndescription. This includes both completely empty Javadoc,\nand Javadoc with only tags such as @param and @return.\n\n\nCheck text for incomplete HTML tags. Verifies that HTML\ntags have corresponding end tags and issues an \"Unclosed\nHTML tag found:\" error if not. An \"Extra HTML tag found:\"\nerror is issued if an end tag is found without a previous\nopen tag.\n\n\nCheck that a package Javadoc comment is well-formed (as\ndescribed above).\n\n\nCheck for allowed HTML tags. The list of allowed HTML tags\nis \"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"b\", \"bdo\", \"big\",\n\"blockquote\", \"br\", \"caption\", \"cite\", \"code\", \"colgroup\", \"dd\",\n\"del\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\", \"fieldset\", \"font\", \"h1\",\n\"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"i\", \"img\", \"ins\", \"kbd\", \"li\",\n\"ol\", \"p\", \"pre\", \"q\", \"samp\", \"small\", \"span\", \"strong\", \"sub\",\n\"sup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"tt\",\n\"u\", \"ul\", \"var\".\n\n\n\nThese checks were patterned after the checks made by the\nDocCheck\ndoclet available from Sun. Note: Original Sun's DocCheck tool does not exist anymore.", "option": "\ncheckEmptyJavadoc, Control whether to check if the Javadoc is missing a describing text., boolean, false\ncheckFirstSentence, Control whether to check the first sentence for proper end of sentence., boolean, true\ncheckHtml, Control whether to check for incomplete HTML tags., boolean, true\nendOfSentenceFormat, Specify the format for matching the end of a sentence., Pattern, \"([.?!][ \\t\\n\\r\\f<])|([.?!]$)\"\nexcludeScope, Specify the visibility scope where Javadoc comments are not checked., Scope, null\nscope, Specify the visibility scope where Javadoc comments are checked., Scope, private\ntokens, tokens to check, subset of tokens\n\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nCLASS_DEF\n,\nCTOR_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nMETHOD_DEF\n,\nPACKAGE_DEF\n,\nVARIABLE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nCLASS_DEF\n,\nCTOR_DEF\n,\nENUM_CONSTANT_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nMETHOD_DEF\n,\nPACKAGE_DEF\n,\nVARIABLE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "NestedForDepth": {"description": "Description\nRestricts nested for blocks to a specified depth.", "option": "\nmax, Specify maximum allowed nesting depth., int, 1"}, "RedundantImport": {"description": "Description\n\nChecks for redundant import statements. An import statement is\nconsidered redundant if:\n\n\n\nIt is a duplicate of another import. This is, when a class is\nimported more than once.\n\n\nThe class non-statically imported is from the java.lang\npackage, e.g. importing java.lang.String.\n\n\nThe class non-statically imported is from the same package as the current package.", "option": ""}, "ParenPad": {"description": "Description\n\nChecks the policy on the padding of parentheses; that is whether a\nspace is required after a left parenthesis and before a right\nparenthesis, or such spaces are forbidden. No check occurs at\nthe right parenthesis after an empty for iterator, at the left\nparenthesis before an empty for initialization, or at the right\nparenthesis of a try-with-resources resource specification where\nthe last resource variable has a trailing semicolon.\nUse Check\nEmptyForIteratorPad to validate empty for iterators and\n\nEmptyForInitializerPad to validate empty for initializers.\nTypecasts are also not checked, as there is\n\nTypecastParenPad to validate them.", "option": "\noption, Specify policy on how to pad parentheses., PadOption, nospace\ntokens, tokens to check, subset of tokens\n\nANNOTATION\n,\nANNOTATION_FIELD_DEF\n,\nCTOR_CALL\n,\nCTOR_DEF\n,\nDOT\n,\nENUM_CONSTANT_DEF\n,\nEXPR\n,\nLITERAL_CATCH\n,\nLITERAL_DO\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_NEW\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_WHILE\n,\nMETHOD_CALL\n,\nMETHOD_DEF\n,\nQUESTION\n,\nRESOURCE_SPECIFICATION\n,\nSUPER_CTOR_CALL\n,\nLAMBDA\n,\nRECORD_DEF\n.\n,\n\nANNOTATION\n,\nANNOTATION_FIELD_DEF\n,\nCTOR_CALL\n,\nCTOR_DEF\n,\nDOT\n,\nENUM_CONSTANT_DEF\n,\nEXPR\n,\nLITERAL_CATCH\n,\nLITERAL_DO\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_NEW\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_WHILE\n,\nMETHOD_CALL\n,\nMETHOD_DEF\n,\nQUESTION\n,\nRESOURCE_SPECIFICATION\n,\nSUPER_CTOR_CALL\n,\nLAMBDA\n,\nRECORD_DEF\n.\n"}, "LineLength": {"description": "Description\n\nChecks for long lines.\n\n\nRationale: Long lines are hard to read in printouts or if developers\nhave limited screen space for the source code, e.g. if the IDE\ndisplays additional information like project tree, class hierarchy,\netc.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nignorePattern, Specify pattern for lines to ignore., Pattern, \"^(package|import) .*\"\nmax, Specify the maximum line length allowed., int, 80"}, "JavadocBlockTagLocation": {"description": "Description\n\nChecks that a\n\njavadoc block tag appears only at the beginning of a line, ignoring\nleading asterisks and white space. A block tag is a token that starts\nwith @ symbol and is preceded by a whitespace. This check\nignores block tags in comments and inside inline tags {@code } and\n{@literal }.\n\n\nRationale: according to\n\nthe specification all javadoc block tags should be placed at the\nbeginning of a line. Tags that are not placed at the beginning are treated\nas plain text. To recognize intentional tag placement to text area\nit is better to escape the @ symbol, and all non-escaped\ntags should be located at the beginning of the line. See NOTE section\nfor details on how to escape.", "option": "\ntags, Specify the javadoc tags to process., String[], author, deprecated, exception, hidden, param, provides, return, see, serial, serialData, serialField, since, throws, uses, version\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "ModifierOrder": {"description": "Description\n\nChecks that the order of modifiers conforms to the suggestions in\nthe Java\nLanguage specification, \u00a7 8.1.1, 8.3.1, 8.4.3 and\n\n9.4. The correct order is:\n\n\n\npublic\n\n\nprotected\n\n\nprivate\n\n\nabstract\n\n\ndefault\n\n\nstatic\n\n\nsealed\n\n\nnon-sealed\n\n\nfinal\n\n\ntransient\n\n\nvolatile\n\n\nsynchronized\n\n\nnative\n\n\nstrictfp\n\n\n\nIn additional, modifiers are checked to ensure all annotations are\ndeclared before all other modifiers.\n\n\nRationale: Code is easier to read if everybody follows a standard.\n\n\nATTENTION: We skip\n\ntype annotations from validation.", "option": ""}, "DefaultComesLast": {"description": "Description\n\nCheck that the default is after all the\ncases in a switch statement.\n\n\nRationale: Java allows default anywhere\nwithin the switch statement. But it is\nmore readable if it comes after the last case.", "option": "\nskipIfLastAndSharedWithCase, Control whether to allow default along with case if they are not last., boolean, false"}, "NoCodeInFile": {"description": "Description\n\nChecks whether file contains code.\nJava compiler is not raising errors on files with no code or all commented out.\nFiles which are considered to have no code:\n\n\n\nFile with no text\n\n\nFile with single-line comment(s)\n\n\nFile with a multi line comment(s).", "option": ""}, "MultipleStringLiterals": {"description": "Description\n\nChecks for multiple occurrences of the same string literal within a\nsingle file.\n\n\nRationale: Code duplication makes maintenance more difficult, so it\ncan be better to replace the multiple occurrences with a constant.", "option": "\nallowedDuplicates, Specify the maximum number of occurrences to allow without generating a warning., int, 1\nignoreOccurrenceContext, Specify token type names where duplicate strings are ignored even if they don't match ignoredStringsRegexp. This allows you to exclude syntactical contexts like annotations or static initializers from the check., subset of tokens TokenTypes,\n\nANNOTATION\n\nignoreStringsRegexp, Specify RegExp for ignored strings (with quotation marks)., Pattern, \"^\"\"$\""}, "AbstractClassName": {"description": "Description\n\nEnsures that the names of abstract classes conforming to some pattern and\ncheck that abstract modifier exists.\n\n\nRationale: Abstract classes are convenience base class implementations of\ninterfaces. For this reason, it should be made obvious that a given class\nis abstract by prefacing the class name with 'Abstract'.", "option": "\nformat, Specify valid identifiers., Pattern, \"^Abstract.+$\"\nignoreModifier, Control whether to ignore checking for the abstract modifier on classes that match the name., boolean, false\nignoreName, Control whether to ignore checking the name. Realistically only useful if using the check to identify that match name and do not have the abstract modifier., boolean, false"}, "WhitespaceAround": {"description": "Description\n\nChecks that a token is surrounded by whitespace. Empty constructor,\nmethod, class, enum, interface, loop bodies (blocks), lambdas of the form\n\n\npublic MyClass() {}      // empty constructor\npublic void func() {}    // empty method\npublic interface Foo {} // empty interface\npublic class Foo {} // empty class\npublic enum Foo {} // empty enum\nMyClass c = new MyClass() {}; // empty anonymous class\nwhile (i = 1) {} // empty while loop\nfor (int i = 1; i > 1; i++) {} // empty for loop\ndo {} while (i = 1); // empty do-while loop\nRunnable noop = () -> {}; // empty lambda\npublic @interface Beta {} // empty annotation type\n\n\nmay optionally be exempted from the policy using the\nallowEmptyMethods, allowEmptyConstructors,\nallowEmptyTypes, allowEmptyLoops,\nallowEmptyLambdas and allowEmptyCatches\nproperties.\n\nThis check does not flag as violation double brace initialization like:\n\n\n\nnew Properties() {{\nsetProperty(\"key\", \"value\");\n}};\n\n\nParameter allowEmptyCatches allows to suppress violations when token\nlist contains SLIST to check if beginning of block is surrounded by\nwhitespace and catch block is empty, for example:\n\n\n\ntry {\nk = 5 / i;\n} catch (ArithmeticException ex) {}\n\n\n\nWith this property turned off, this raises violation because the beginning of the\ncatch block (left curly bracket) is not separated from the end of the catch\nblock (right curly bracket).", "option": "\nallowEmptyCatches, Allow empty catch bodies., boolean, false\nallowEmptyConstructors, Allow empty constructor bodies., boolean, false\nallowEmptyLambdas, Allow empty lambda bodies., boolean, false\nallowEmptyLoops, Allow empty loop bodies., boolean, false\nallowEmptyMethods, Allow empty method bodies., boolean, false\nallowEmptyTypes, Allow empty class, interface and enum bodies., boolean, false\nignoreEnhancedForColon, Ignore whitespace around colon in\nenhanced for loop., boolean, true\ntokens, tokens to check, subset of tokens\n\nASSIGN\n,\nARRAY_INIT\n,\nBAND\n,\nBAND_ASSIGN\n,\nBOR\n,\nBOR_ASSIGN\n,\nBSR\n,\nBSR_ASSIGN\n,\nBXOR\n,\nBXOR_ASSIGN\n,\nCOLON\n,\nDIV\n,\nDIV_ASSIGN\n,\nDO_WHILE\n,\nEQUAL\n,\nGE\n,\nGT\n,\nLAMBDA\n,\nLAND\n,\nLCURLY\n,\nLE\n,\nLITERAL_CATCH\n,\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FINALLY\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_RETURN\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_TRY\n,\nLITERAL_WHILE\n,\nLOR\n,\nLT\n,\nMINUS\n,\nMINUS_ASSIGN\n,\nMOD\n,\nMOD_ASSIGN\n,\nNOT_EQUAL\n,\nPLUS\n,\nPLUS_ASSIGN\n,\nQUESTION\n,\nRCURLY\n,\nSL\n,\nSLIST\n,\nSL_ASSIGN\n,\nSR\n,\nSR_ASSIGN\n,\nSTAR\n,\nSTAR_ASSIGN\n,\nLITERAL_ASSERT\n,\nTYPE_EXTENSION_AND\n,\nWILDCARD_TYPE\n,\nGENERIC_START\n,\nGENERIC_END\n,\nELLIPSIS\n.\n,\n\nASSIGN\n,\nBAND\n,\nBAND_ASSIGN\n,\nBOR\n,\nBOR_ASSIGN\n,\nBSR\n,\nBSR_ASSIGN\n,\nBXOR\n,\nBXOR_ASSIGN\n,\nCOLON\n,\nDIV\n,\nDIV_ASSIGN\n,\nDO_WHILE\n,\nEQUAL\n,\nGE\n,\nGT\n,\nLAMBDA\n,\nLAND\n,\nLCURLY\n,\nLE\n,\nLITERAL_CATCH\n,\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FINALLY\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_RETURN\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_TRY\n,\nLITERAL_WHILE\n,\nLOR\n,\nLT\n,\nMINUS\n,\nMINUS_ASSIGN\n,\nMOD\n,\nMOD_ASSIGN\n,\nNOT_EQUAL\n,\nPLUS\n,\nPLUS_ASSIGN\n,\nQUESTION\n,\nRCURLY\n,\nSL\n,\nSLIST\n,\nSL_ASSIGN\n,\nSR\n,\nSR_ASSIGN\n,\nSTAR\n,\nSTAR_ASSIGN\n,\nLITERAL_ASSERT\n,\nTYPE_EXTENSION_AND\n.\n"}, "NonEmptyAtclauseDescription": {"description": "Description\n\nChecks that the block tag is followed by description.", "option": "\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false\njavadocTokens, javadoc tokens to check, subset of javadoc tokens\n\nPARAM_LITERAL\n,\nRETURN_LITERAL\n,\nTHROWS_LITERAL\n,\nEXCEPTION_LITERAL\n,\nDEPRECATED_LITERAL\n.\n,\n\nPARAM_LITERAL\n,\nRETURN_LITERAL\n,\nTHROWS_LITERAL\n,\nEXCEPTION_LITERAL\n,\nDEPRECATED_LITERAL\n.\n"}, "ImportOrder": {"description": "Description\nChecks the ordering/grouping of imports. Features are:\n\ngroups type/static imports: ensures that groups of imports come in a\nspecific order (e.g., java. comes first, javax. comes second,\nthen everything else)\nadds a separation between type import groups : ensures that a blank\nline sit between each group\ntype/static import groups aren't separated internally: ensures that\neach group aren't separated internally by blank line or comment\nsorts type/static imports inside each group: ensures that imports\nwithin each group are in lexicographic order\n\nsorts according to case: ensures that the comparison\nbetween imports is case-sensitive, in\nASCII sort order\n\n\narrange static imports: ensures the relative order between\ntype imports and static imports (see\nImportOrderOption)", "option": "\ncaseSensitive, Control whether string comparison should be case-sensitive or not. Case-sensitive sorting is in ASCII sort order. It affects both type imports and static imports., boolean, true\ngroups, Specify list of type import groups. Every group identified either by a common prefix string, or by a regular expression enclosed in forward slashes (e.g. /regexp/). All type imports, which does not match any group, falls into an additional group, located at the end. Thus, the empty list of type groups (the default value) means one group for all type imports., Pattern[], {}\noption, Specify policy on the relative order between type imports and static imports., ImportOrderOption, under\nordered, Control whether type imports within each group should be sorted. It doesn't affect sorting for static imports., boolean, true\nseparated, Control whether type import groups should be separated by, at least, one blank line or comment and aren't separated internally. It doesn't affect separations for static imports., boolean, false\nseparatedStaticGroups, Control whether static import groups should be separated by, at least, one blank line or comment and aren't separated internally. This property has effect only when the property option is set to top or bottom and when property staticGroups is enabled., boolean, false\nsortStaticImportsAlphabetically, Control whether static imports located at top or bottom are sorted within the group., boolean, false\nstaticGroups, Specify list of static import groups. Every group identified either by a common prefix string, or by a regular expression enclosed in forward slashes (e.g. /regexp/). All static imports, which does not match any group, fall into an additional group, located at the end. Thus, the empty list of static groups (the default value) means one group for all static imports. This property has effect only when the property option is set to top or bottom., Pattern[], {}\nuseContainerOrderingForStatic, Control whether to use container ordering (Eclipse IDE term) for static imports or not., boolean, false"}, "NoFinalizer": {"description": "Description\nChecks that there is no method finalize with zero parameters.\n\nSee\nObject.finalize()\n\n\nRationale: Finalizers are unpredictable, often dangerous, and generally unnecessary.\nTheir use can cause erratic behavior, poor performance, and portability problems.\nFor more information for the finalize method and its issues, see Effective Java:\nProgramming Language Guide Third Edition by Joshua Bloch, \u00a78.", "option": ""}, "MagicNumber": {"description": "Description\n\nChecks that there are no\n\n\"magic numbers\" where a magic\nnumber is a numeric literal that is not defined as a constant.\nBy default, -1, 0, 1, and 2 are not considered to be magic numbers.\n\n\nConstant definition is any variable/field that has 'final' modifier.\nIt is fine to have one constant defining multiple numeric literals within one expression:\n\n\n\nstatic final int SECONDS_PER_DAY = 24 * 60 * 60;\nstatic final double SPECIAL_RATIO = 4.0 / 3.0;\nstatic final double SPECIAL_SUM = 1 + Math.E;\nstatic final double SPECIAL_DIFFERENCE = 4 - Math.PI;\nstatic final Border STANDARD_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3);\nstatic final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer(42);", "option": "\nconstantWaiverParentToken, Specify tokens that are allowed in the AST path from the number literal to the enclosing constant definition., subset of tokens TokenTypes,\n\nARRAY_INIT\n,\nASSIGN\n,\nDIV\n,\nELIST\n,\nEXPR\n,\nLITERAL_NEW\n,\nMETHOD_CALL\n,\nMINUS\n,\nPLUS\n,\nSTAR\n,\nTYPECAST\n,\nUNARY_MINUS\n,\nUNARY_PLUS\n\nignoreAnnotation, Ignore magic numbers in annotation declarations., boolean, false\nignoreAnnotationElementDefaults, Ignore magic numbers in annotation elements defaults., boolean, true\nignoreFieldDeclaration, Ignore magic numbers in field declarations., boolean, false\nignoreHashCodeMethod, Ignore magic numbers in hashCode methods., boolean, false\nignoreNumbers, Specify non-magic numbers., double[], -1, 0, 1, 2\ntokens, tokens to check, subset of tokens\n\nNUM_DOUBLE\n,\nNUM_FLOAT\n,\nNUM_INT\n,\nNUM_LONG\n.\n,\n\nNUM_DOUBLE\n,\nNUM_FLOAT\n,\nNUM_INT\n,\nNUM_LONG\n.\n"}, "AvoidEscapedUnicodeCharacters": {"description": "Description\n\nRestricts using\n\nUnicode escapes (such as \\u221e).\nIt is possible to allow using escapes for\n\nnon-printable, control characters.\nAlso, this check can be configured to allow using escapes\nif trail comment is present. By the option it is possible to\nallow using escapes if literal contains only them.", "option": "\nallowByTailComment, Allow use escapes if trail comment is present., boolean, false\nallowEscapesForControlCharacters, Allow use escapes for non-printable, control characters., boolean, false\nallowIfAllCharactersEscaped, Allow if all characters in literal are escaped., boolean, false\nallowNonPrintableEscapes, Allow use escapes for non-printable, whitespace characters., boolean, false"}, "AbbreviationAsWordInName": {"description": "Description\n\nValidates abbreviations (consecutive capital letters) length in identifier name,\nit also allows to enforce camel case naming. Please read more at\n\nGoogle Style Guide\nto get to know how to avoid long abbreviations in names.\n\n'_' is considered as word separator in identifier name.\n\nallowedAbbreviationLength specifies how many consecutive capital letters are\nallowed in the identifier.\nA value of 3 indicates that up to 4 consecutive capital letters are allowed,\none after the other, before a violation is printed. The identifier 'MyTEST' would be\nallowed, but 'MyTESTS' would not be.\nA value of 0 indicates that only 1 consecutive capital letter is allowed. This\nis what should be used to enforce strict camel casing. The identifier 'MyTest' would\nbe allowed, but 'MyTEst' would not be.\n\n\nignoreFinal, ignoreStatic, and ignoreStaticFinal\ncontrol whether variables with the respective modifiers are to be ignored.\nNote that a variable that is both static and final will always be considered under\nignoreStaticFinal only, regardless of the values of ignoreFinal\nand ignoreStatic. So for example if ignoreStatic is true but\nignoreStaticFinal is false, then static final variables will not be ignored.", "option": "\nallowedAbbreviationLength, Indicate the number of consecutive capital letters allowed in targeted identifiers (abbreviations in the classes, interfaces, variables and methods names, ... )., int, 3\nallowedAbbreviations, Specify abbreviations that must be skipped for checking., String[], {}\nignoreFinal, Allow to skip variables with final modifier., boolean, true\nignoreOverriddenMethods, Allow to ignore methods tagged with @Override annotation (that usually mean inherited name)., boolean, true\nignoreStatic, Allow to skip variables with static modifier., boolean, true\nignoreStaticFinal, Allow to skip variables with both static and final modifiers., boolean, true\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nMETHOD_DEF\n,\nENUM_CONSTANT_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nRECORD_DEF\n,\nRECORD_COMPONENT_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nMETHOD_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nRECORD_DEF\n,\nRECORD_COMPONENT_DEF\n.\n"}, "EmptyBlock": {"description": "Description\nChecks for empty blocks. This check does not validate sequential blocks.\nSequential blocks won't be checked. Also, no violations for fallthrough:\n\n\nswitch (a) {\ncase 1:                          // no violation\ncase 2:                          // no violation\ncase 3: someMethod(); { }        // no violation\ndefault: break;\n}\n\n\nNOTE: This check processes LITERAL_CASE and LITERAL_DEFAULT separately.\nVerification empty block is done for single nearest {@code case} or {@code default}.", "option": "\noption, Specify the policy on block contents., BlockOption, statement\ntokens, tokens to check, subset of tokens\n\nLITERAL_WHILE\n,\nLITERAL_TRY\n,\nLITERAL_CATCH\n,\nLITERAL_FINALLY\n,\nLITERAL_DO\n,\nLITERAL_IF\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nINSTANCE_INIT\n,\nSTATIC_INIT\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nARRAY_INIT\n.\n,\n\nLITERAL_WHILE\n,\nLITERAL_TRY\n,\nLITERAL_FINALLY\n,\nLITERAL_DO\n,\nLITERAL_IF\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nINSTANCE_INIT\n,\nSTATIC_INIT\n,\nLITERAL_SWITCH\n,\nLITERAL_SYNCHRONIZED\n.\n"}, "NoWhitespaceAfter": {"description": "Description\n\nChecks that there is no whitespace after a token. More specifically,\nit checks that it is not followed by whitespace, or (if linebreaks\nare allowed) all characters on the line after are whitespace. To\nforbid linebreaks after a token, set property allowLineBreaks to\nfalse.\n\n\nThe check processes\n\nARRAY_DECLARATOR\nand\nINDEX_OP\ntokens specially from other tokens. Actually it is checked that there is\nno whitespace before these tokens, not after them.\nSpace after the\n\nANNOTATIONS before\n\nARRAY_DECLARATOR\nand\n\nINDEX_OP\nwill be ignored.\n\n\nIf the annotation is between the type and the array,\nlike char @NotNull [] param, the check will skip\nvalidation for spaces.\n\n\nNote: This check processes the\n\nLITERAL_SYNCHRONIZED token only when it appears as a part of a\n\nsynchronized statement, i.e. synchronized(this) {}.", "option": "\nallowLineBreaks, Control whether whitespace is allowed if the token is at a linebreak., boolean, true\ntokens, tokens to check, subset of tokens\n\nARRAY_INIT\n,\nAT\n,\nINC\n,\nDEC\n,\nUNARY_MINUS\n,\nUNARY_PLUS\n,\nBNOT\n,\nLNOT\n,\nDOT\n,\nTYPECAST\n,\nARRAY_DECLARATOR\n,\nINDEX_OP\n,\nLITERAL_SYNCHRONIZED\n,\nMETHOD_REF\n.\n,\n\nARRAY_INIT\n,\nAT\n,\nINC\n,\nDEC\n,\nUNARY_MINUS\n,\nUNARY_PLUS\n,\nBNOT\n,\nLNOT\n,\nDOT\n,\nARRAY_DECLARATOR\n,\nINDEX_OP\n.\n"}, "ConstantName": {"description": "Description\n\nChecks that constant names conform to a specified pattern.\nA constant is a static and final field or an\ninterface/annotation field, except serialVersionUID and\nserialPersistentFields.", "option": "\napplyToPackage, Control if check should apply to package-private members., boolean, true\napplyToPrivate, Control if check should apply to private members., boolean, true\napplyToProtected, Control if check should apply to protected members., boolean, true\napplyToPublic, Control if check should apply to public members., boolean, true\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\""}, "AnnotationOnSameLine": {"description": "Description\n\nChecks that annotations are located on the same line with their targets.\nVerifying with this check is not good practice, but it is using by some style guides.", "option": "\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nVARIABLE_DEF\n,\nPARAMETER_DEF\n,\nANNOTATION_DEF\n,\nTYPECAST\n,\nLITERAL_THROWS\n,\nIMPLEMENTS_CLAUSE\n,\nTYPE_ARGUMENT\n,\nLITERAL_NEW\n,\nDOT\n,\nANNOTATION_FIELD_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nVARIABLE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n"}, "InterfaceMemberImpliedModifier": {"description": "Description\n\nChecks for implicit modifiers on interface members and nested types.\n\n\nThis check is effectively the opposite of\nRedundantModifier.\nIt checks the modifiers on interface members, ensuring that certain\nmodifiers are explicitly specified even though they are actually redundant.\n\n\nMethods in interfaces are public by default, however from Java 9\nthey can also be private. This check provides the ability to enforce\nthat public is explicitly coded and not implicitly added by the compiler.\n\n\nFrom Java 8, there are three types of methods in interfaces - static methods\nmarked with static, default methods marked with default and\nabstract methods which do not have to be marked with anything.\nFrom Java 9, there are also private methods marked with private.\nThis check provides the ability to enforce that abstract is explicitly\ncoded and not implicitly added by the compiler.\n\n\nFields in interfaces are always public static final and as such the\ncompiler does not require these modifiers. This check provides the ability to\nenforce that these modifiers are explicitly coded and not implicitly added by\nthe compiler.\n\n\nNested types within an interface are always public static and as such the\ncompiler does not require the public static modifiers. This check provides\nthe ability to enforce that the public and static modifiers\nare explicitly coded and not implicitly added by the compiler.\n\n\n\npublic interface AddressFactory {\n// check enforces code contains \"public static final\"\npublic static final String UNKNOWN = \"Unknown\";\n\nString OTHER = \"Other\";  // violation\n\n// check enforces code contains \"public\" or \"private\"\npublic static AddressFactory instance();\n\n// check enforces code contains \"public abstract\"\npublic abstract Address createAddress(String addressLine, String city);\n\nList<Address> findAddresses(String city);  // violation\n\n// check enforces default methods are explicitly declared \"public\"\npublic default Address createAddress(String city) {\nreturn createAddress(UNKNOWN, city);\n}\n\ndefault Address createOtherAddress() {  // violation\nreturn createAddress(OTHER, OTHER);\n}\n}\n\n\nRationale for this check:\nMethods, fields and nested types are treated differently depending on whether\nthey are part of an interface or part of a class. For example, by default methods\nare package-scoped on classes, but public in interfaces. However, from Java 8 onwards,\ninterfaces have changed to be much more like abstract classes.\nInterfaces now have static and instance methods with code. Developers should not have\nto remember which modifiers are required and which are implied.\nThis check allows the simpler alternative approach to be adopted where the\nimplied modifiers must always be coded explicitly.", "option": "\nviolateImpliedAbstractMethod, Control whether to enforce that abstract is explicitly coded on interface methods., boolean, true\nviolateImpliedFinalField, Control whether to enforce that final is explicitly coded on interface fields., boolean, true\nviolateImpliedPublicField, Control whether to enforce that public is explicitly coded on interface fields., boolean, true\nviolateImpliedPublicMethod, Control whether to enforce that public is explicitly coded on interface methods., boolean, true\nviolateImpliedPublicNested, Control whether to enforce that public is explicitly coded on interface nested types., boolean, true\nviolateImpliedStaticField, Control whether to enforce that static is explicitly coded on interface fields., boolean, true\nviolateImpliedStaticNested, Control whether to enforce that static is explicitly coded on interface nested types., boolean, true"}, "IllegalCatch": {"description": "Description\n\nChecks that certain exception types do not appear in a catch statement.\n\n\nRationale:\ncatching java.lang.Exception, java.lang.Error or\njava.lang.RuntimeException is almost never acceptable.\nNovice developers often simply catch Exception in an\nattempt to handle multiple exception classes. This unfortunately\nleads to code that inadvertently catches NullPointerException,\nOutOfMemoryError, etc.", "option": "\nillegalClassNames, Specify exception class names to reject., String[], Error, Exception, RuntimeException, Throwable, java.lang.Error, java.lang.Exception, java.lang.RuntimeException, java.lang.Throwable"}, "ModifiedControlVariable": {"description": "Description\n\nChecks that for loop control variables are not modified inside\nthe for block. An example is:\n\n\n\nfor (int i = 0; i < 1; i++) {\ni++; // violation\n}\n\n\nRationale: If the control variable is modified inside the loop\nbody, the program flow becomes more difficult to follow. See\n\nFOR statement specification for more details.\n\n\nSuch loop would be suppressed:\n\n\n\nfor (int i = 0; i < 10;) {\ni++;\n}\n\n\nNOTE:The check works with only primitive type variables.\nThe check will not work for arrays used as control variable.An example is\n\n\n\nfor (int a[]={0};a[0] < 10;a[0]++) {\na[0]++;   // it will skip this violation\n}", "option": "\nskipEnhancedForLoopVariable, Control whether to check\nenhanced for-loop variable., boolean, false"}, "FinalClass": {"description": "Description\n\nEnsures that identifies classes that can be effectively declared as final are explicitly\nmarked as final. The following are different types of classes that can be identified:\n\n\n\nPrivate classes with no declared constructors.\n\n\nClasses with any modifier, and contains only private constructors.\n\n\n\nClasses are skipped if:\n\n\n\nClass is Super class of some Anonymous inner class.\n\n\nClass is extended by another class in the same file.", "option": ""}, "IllegalThrows": {"description": "Description\n\nChecks that specified types are not declared to be thrown.\nDeclaring that a method throws java.lang.Error or\njava.lang.RuntimeException is almost never acceptable.", "option": "\nignoreOverriddenMethods, Allow to ignore checking overridden methods (marked with Override or java.lang.Override annotation)., boolean, true\nignoredMethodNames, Specify names of methods to ignore., String[], finalize\nillegalClassNames, Specify throw class names to reject., String[], Error, RuntimeException, Throwable, java.lang.Error, java.lang.RuntimeException, java.lang.Throwable"}, "IllegalIdentifierName": {"description": "Description\n\nChecks identifiers with a pattern for a set of illegal names, such as those\nthat are restricted or contextual keywords. Examples include \"yield\", \"record\",\n\"_\", and \"var\". Please read more at\n\nJava Language Specification\nto get to know more about restricted keywords. Since this check uses a\npattern to specify valid identifiers, users can also prohibit the usage\nof certain symbols, such as \"$\", or any non-ascii character.", "option": "\nformat, Sets the pattern to match valid identifiers., Pattern, \"(?i)^(?!(record|yield|var|permits|sealed|_)$).+$\"\ntokens, tokens to check, subset of tokens\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nMETHOD_DEF\n,\nENUM_CONSTANT_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nRECORD_DEF\n,\nRECORD_COMPONENT_DEF\n,\nLAMBDA\n.\n,\n\nCLASS_DEF\n,\nINTERFACE_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nANNOTATION_FIELD_DEF\n,\nPARAMETER_DEF\n,\nVARIABLE_DEF\n,\nMETHOD_DEF\n,\nENUM_CONSTANT_DEF\n,\nPATTERN_VARIABLE_DEF\n,\nRECORD_DEF\n,\nRECORD_COMPONENT_DEF\n,\nLAMBDA\n.\n"}, "ParameterName": {"description": "Description\n\nChecks that method parameter names conform to a specified pattern.\nBy using accessModifiers property it is possible\nto specify different formats for methods at different visibility levels.\n\n\nTo validate catch parameters please use\n\nCatchParameterName\n.\n\n\nTo validate lambda parameters please use\n\nLambdaParameterName\n.", "option": "\naccessModifiers, Access modifiers of methods where parameters are checked., AccessModifierOption[], public, protected, package, private\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\"\nignoreOverridden, Allows to skip methods with Override annotation from validation., boolean, false"}, "SeparatorWrap": {"description": "Description\n\nChecks line wrapping with separators.", "option": "\noption, Specify policy on how to wrap lines., WrapOption, eol\ntokens, tokens to check, subset of tokens\n\nDOT\n,\nCOMMA\n,\nSEMI\n,\nELLIPSIS\n,\nAT\n,\nLPAREN\n,\nRPAREN\n,\nARRAY_DECLARATOR\n,\nRBRACK\n,\nMETHOD_REF\n.\n,\n\nDOT\n,\nCOMMA\n.\n"}, "NewlineAtEndOfFile": {"description": "Description\n\nChecks whether files end with a line separator.\n\n\nRationale: Any source files and text files in general should\nend with a line separator to let other easily add new content\nat the end of file and \"diff\" command does not show previous lines as changed.\n\n\nExample (the line with 'No newline at end of file' should not be in the diff):\n\n\n\n@@ -32,4 +32,5 @@ ForbidWildcardAsReturnTypeCheck.returnTypeClassNamesIgnoreRegex\nPublicReferenceToPrivateTypeCheck.name = Public Reference To Private Type\n\nStaticMethodCandidateCheck.name = Static Method Candidate\n-StaticMethodCandidateCheck.desc = Checks whether private methods should be declared as static.\n\\ No newline at end of file\n+StaticMethodCandidateCheck.desc = Checks whether private methods should be declared as static.\n+StaticMethodCandidateCheck.skippedMethods = Method names to skip during the check.\n\n\nIt can also trick the VCS to report the wrong owner for such lines.\nAn engineer who has added nothing but a newline character becomes\nthe last known author for the entire line. As a result, a mate can ask\nhim a question to which he will not give the correct answer.\n\n\nOld Rationale: CVS source control management\nsystems will even print a warning when it\nencounters a file that doesn't end with a line separator.\n\n\nAttention: property fileExtensions works with files that are passed by similar property\nfor at Checker.\nPlease make sure required file extensions are mentioned at Checker's fileExtensions\nproperty.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nlineSeparator, Specify the type of line separator., LineSeparatorOption, lf_cr_crlf"}, "MutableException": {"description": "Description\n\nEnsures that exception classes (classes with names conforming to some pattern\nand explicitly extending classes with names conforming to other\npattern) are immutable, that is, that they have only final fields.\n\n\nThe current algorithm is very simple: it checks that all members of\nexception are final. The user can still mutate an exception's instance\n(e.g. Throwable has a method called setStackTrace\nwhich changes the exception's stack trace). But, at least, all information\nprovided by this exception type is unchangeable.\n\n\nRationale: Exception instances should represent an error\ncondition. Having non-final fields not only allows the state to be\nmodified by accident and therefore mask the original condition but\nalso allows developers to accidentally forget to set the initial state.\nIn both cases, code catching the exception could draw incorrect\nconclusions based on the state.", "option": "\nextendedClassNameFormat, Specify pattern for extended class names., Pattern, \"^.*Exception$|^.*Error$|^.*Throwable$\"\nformat, Specify pattern for exception class names., Pattern, \"^.*Exception$|^.*Error$|^.*Throwable$\""}, "ArrayTrailingComma": {"description": "Description\n\nChecks that array initialization contains a trailing comma.\n\n\n\nint[] a = new int[]\n{\n1,\n2,\n3,\n};\n\n\nBy default, the check demands a comma at the end if neither left nor right curly braces\nare on the same line as the last element of the array.\n\n\n\nreturn new int[] { 0 };\nreturn new int[] { 0\n};\nreturn new int[] {\n0 };\n\n\nRationale: Putting this comma in makes it easier to change the order\nof the elements or add new elements on the end. Main benefit of a trailing\ncomma is that when you add new entry to an array, no surrounding lines are changed.\n\n\n\n{\n100000000000000000000,\n200000000000000000000, // OK\n}\n\n{\n100000000000000000000,\n200000000000000000000,\n300000000000000000000,  // Just this line added, no other changes\n}\n\n\nIf closing brace is on the same line as trailing comma, this benefit is gone\n(as the check does not demand a certain location of curly braces the following\ntwo cases will not produce a violation):\n\n\n\n{100000000000000000000,\n200000000000000000000,} // Trailing comma not needed, line needs to be modified anyway\n\n{100000000000000000000,\n200000000000000000000, // Modified line\n300000000000000000000,} // Added line\n\n\nIf opening brace is on the same line as trailing comma there's also (more arguable)\nproblem:\n\n\n\n{100000000000000000000, // Line cannot be just duplicated to slightly modify entry\n}\n\n{100000000000000000000,\n100000000000000000001, // More work needed to duplicate\n}", "option": "\nalwaysDemandTrailingComma, Control whether to always check for a trailing comma, even when an array is inline., boolean, false"}, "DeclarationOrder": {"description": "Description\n\nChecks that the parts of a class, record, or interface declaration appear in the order\nsuggested by the\n\nCode Conventions for the Java Programming Language.\n\n\nAccording to\n\nCode Conventions for the Java Programming Language , the parts\nof a class or interface declaration should appear in the following\norder:\n\n\n\nClass (static) variables. First the public class variables, then\nprotected, then package level (no access modifier), and then\nprivate.\n\n\nInstance variables. First the public class variables, then\nprotected, then package level (no access modifier), and then\nprivate.\n\nConstructors\nMethods\n\n\nPurpose of ignore* option is to ignore related violations,\nhowever it still impacts on other class members.\n\n\nATTENTION: the check skips class fields which have\n\nforward references\nfrom validation due to the fact that we have Checkstyle's limitations to clearly\ndetect user intention of fields location and grouping. For example:\n\n\n\npublic class A {\nprivate double x = 1.0;\nprivate double y = 2.0;\npublic double slope = x / y; // will be skipped from validation due to forward reference\n}", "option": "\nignoreConstructors, Control whether to ignore constructors., boolean, false\nignoreModifiers, Control whether to ignore modifiers (fields, ...)., boolean, false"}, "AvoidStarImport": {"description": "Description\n\nChecks that there are no import statements that use the * notation.\n\n\nRationale: Importing all classes from a package or static\nmembers from a class leads to tight coupling between packages\nor classes and might lead to problems when a new version of a\nlibrary introduces name clashes.", "option": "\nallowClassImports, Control whether to allow starred class imports like import java.util.*;., boolean, false\nallowStaticMemberImports, Control whether to allow starred static member imports like import static org.junit.Assert.*;., boolean, false\nexcludes, Specify packages where starred class imports are allowed and classes where starred static member imports are allowed., String[], {}"}, "JavadocMissingWhitespaceAfterAsterisk": {"description": "Description\n\nChecks that there is at least one whitespace after the leading asterisk.\nAlthough spaces after asterisks are optional in the Javadoc comments, their absence\nmakes the documentation difficult to read. It is the de facto standard to put at least\none whitespace after the leading asterisk.", "option": "\nviolateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules., boolean, false"}, "StaticVariableName": {"description": "Description\n\nChecks that static, non-final variable names\nconform to a specified pattern.", "option": "\napplyToPackage, Control if check should apply to package-private members., boolean, true\napplyToPrivate, Control if check should apply to private members., boolean, true\napplyToProtected, Control if check should apply to protected members., boolean, true\napplyToPublic, Control if check should apply to public members., boolean, true\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "Header": {"description": "Description\n\nChecks that a source file begins with a specified header. Property\nheaderFile specifies a file that contains\nthe required header. Alternatively, the header specification can be\nset directly in the header property\nwithout the need for an external file.\n\n\nProperty ignoreLines specifies the line\nnumbers to ignore when matching lines in a header file. This\nproperty is very useful for supporting headers that contain\ncopyright dates. For example, consider the following header:\n\n\n\nline 1: ////////////////////////////////////////////////////////////////////\nline 2: // checkstyle:\nline 3: // Checks Java source code for adherence to a set of rules.\nline 4: // Copyright (C) 2002  Oliver Burn\nline 5: ////////////////////////////////////////////////////////////////////\n\n\nSince the year information will change over time, you can tell\nCheckstyle to ignore line 4 by setting property ignoreLines to\n4.", "option": "\ncharset, Specify the character encoding to use when reading the headerFile., String, the charset property of the parent <a href=\"https://checkstyle.org/config.html#Checker\">Checker</a> module\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nheader, Specify the required header specified inline. Individual header lines must be separated by the string \"\\n\"(even on platforms with a different line separator)., String, null\nheaderFile, Specify the name of the file containing the required header., URI, null\nignoreLines, Specify the line numbers to ignore., int[], {}"}, "RegexpOnFilename": {"description": "Description\n\nChecks that a specified pattern matches based on file and/or folder path.\nIt can also be used to verify files match specific naming\npatterns not covered by other checks (Ex: properties, xml, etc.).\n\n\nWhen customizing the check, the properties are applied in a specific order.\nThe fileExtensions property first picks only files that match any of the\nspecific extensions supplied.\nOnce files are matched against the fileExtensions, the match property is then\nused in conjunction with the patterns to determine if the check is looking\nfor a match or mismatch on those files. If the fileNamePattern is\nsupplied, the matching is only applied to the fileNamePattern and not the\nfolderPattern. If no fileNamePattern is supplied, then matching is applied\nto the folderPattern only and will result in all files in a folder to be\nreported on violations. If no folderPattern is supplied, then all folders\nthat checkstyle finds are examined for violations.\nThe ignoreFileNameExtensions property drops the file extension and applies\nthe fileNamePattern only to the rest of file name. For example, if the file is\nnamed 'test.java' and this property is turned on, the pattern is only applied\nto 'test'.\n\n\nIf this check is configured with no properties, then the default behavior\nof this check is to report file names with spaces in them.\nWhen at least one pattern property is supplied, the entire check is under\nthe user's control to allow them to fully customize the behavior.\n\n\nIt is recommended that if you create your own pattern, to also\nspecify a custom violation message. This allows the violation message printed\nto be clear what the violation is, especially if multiple RegexpOnFilename\nchecks are used.\nArgument 0 for the message populates the check's folderPattern.\nArgument 1 for the message populates the check's fileNamePattern.\nThe file name is not passed as an argument since it is part of CheckStyle's\ndefault violation messages.", "option": "\nfileExtensions, Specify the file extensions of the files to process., String[], all files\nfileNamePattern, Specify the regular expression to match the file name against., Pattern, null\nfolderPattern, Specify the regular expression to match the folder path against., Pattern, null\nignoreFileNameExtensions, Control whether to ignore the file extension for the file name match., boolean, false\nmatch, Control whether to look for a match or mismatch on the file name, if the fileNamePattern is supplied, otherwise it is applied on the folderPattern., boolean, true"}, "FileTabCharacter": {"description": "Description\n\nChecks that there are no tab characters ('\\t') in the source code.\n\n\nRationale:\n\n\n\nDevelopers should not need to configure the tab width of their\ntext editors in order to be able to read source code.\n\n\nFrom the Apache jakarta coding standards: In a distributed\ndevelopment environment, when the commit messages get sent\nto a mailing list, they are almost impossible to read if you\nuse tabs.", "option": "\neachLine, Control whether to report on each line containing a tab, or just the first instance., boolean, false\nfileExtensions, Specify the file extensions of the files to process., String[], all files"}, "EqualsAvoidNull": {"description": "Description\n\nChecks that any combination of String literals\nis on the left side of an equals() comparison.\nAlso checks for String literals assigned to some field\n(such as someString.equals(anotherString = \"text\")).\n\n\nRationale: Calling the equals()\nmethod on String literals will avoid a potential\nNullPointerException. Also, it is pretty common to see null\nchecks right before equals comparisons but following this rule such checks\nare not required.", "option": "\nignoreEqualsIgnoreCase, Control whether to ignore String.equalsIgnoreCase(String) invocations., boolean, false"}, "SuperClone": {"description": "Description\n\nChecks that an overriding clone() method invokes\nsuper.clone(). Does not check native methods, as\nthey have no possible java defined implementation.\n\n\nReference:\nObject.clone().", "option": ""}, "WriteTag": {"description": "Description\n\nRequires user defined Javadoc tag to be present in Javadoc comment with\ndefined format. To define the format for a tag, set property tagFormat to a regular\nexpression. Property tagSeverity is used for severity of events when the tag exists.", "option": "\ntag, Specify the name of tag., String, null\ntagFormat, Specify the regexp to match tag content., Pattern, null\ntagSeverity, Specify the severity level when tag is found and printed., SeverityLevel, info\ntokens, tokens to check, subset of tokens\n\nINTERFACE_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nENUM_CONSTANT_DEF\n,\nANNOTATION_FIELD_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n.\n,\n\nINTERFACE_DEF\n,\nCLASS_DEF\n,\nENUM_DEF\n,\nANNOTATION_DEF\n,\nRECORD_DEF\n.\n"}, "CyclomaticComplexity": {"description": "Description\n\nChecks cyclomatic complexity against a specified limit.\nIt is a measure of the minimum number of\npossible paths through the source and therefore the number of\nrequired tests, it is not about quality of code!\nIt is only applied to methods, c-tors,\n\nstatic initializers and instance initializers.\n\n\nThe complexity is equal to the number of decision points  + 1.\nDecision points: if, while\n, do, for, ?:, catch\n, switch, case\nstatements and operators && and ||\nin the body of target.\n\n\nBy pure theory level 1-4 is considered easy to test, 5-7 OK, 8-10\nconsider re-factoring to ease testing, and 11+ re-factor now as testing will be painful.\n\n\nWhen it comes to code quality measurement by this metric\nlevel 10 is very good level as a ultimate target (that is hard to archive).\nDo not be ashamed to have complexity level 15 or even higher,\nbut keep it below 20 to catch really bad-designed code automatically.\n\n\nPlease use Suppression to avoid violations on cases that could not be split in few\nmethods without damaging readability of code or encapsulation.", "option": "\nmax, Specify the maximum threshold allowed., int, 10\nswitchBlockAsSingleDecisionPoint, Control whether to treat the whole switch block as a single decision point., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_WHILE\n,\nLITERAL_DO\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_SWITCH\n,\nLITERAL_CASE\n,\nLITERAL_CATCH\n,\nQUESTION\n,\nLAND\n,\nLOR\n.\n,\n\nLITERAL_WHILE\n,\nLITERAL_DO\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_SWITCH\n,\nLITERAL_CASE\n,\nLITERAL_CATCH\n,\nQUESTION\n,\nLAND\n,\nLOR\n.\n"}, "AnonInnerLength": {"description": "Description\n\nChecks for long anonymous inner classes.\n\n\nRationale: If an anonymous inner class becomes very long it is hard\nto understand and to see the flow of the method where the class is\ndefined. Therefore, long anonymous inner classes should usually be\nrefactored into a named inner class. See also Bloch, Effective\nJava, p. 93.", "option": "\nmax, Specify the maximum number of lines allowed., int, 20"}, "OuterTypeFilename": {"description": "Description\n\nChecks that the outer type name and the file name match. For example,\nthe class Foo must be in a file named\nFoo.java.", "option": ""}, "LocalVariableName": {"description": "Description\n\nChecks that local, non-final variable names conform to a specified pattern.\nA catch parameter is considered to be a local variable.", "option": "\nallowOneCharVarInForLoop, Allow one character variable name in\ninitialization expressions in FOR loop if one char variable name is prohibited by format regexp., boolean, false\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "NestedTryDepth": {"description": "Description\nRestricts nested try-catch-finally blocks to a specified depth.", "option": "\nmax, Specify maximum allowed nesting depth., int, 1"}, "MethodName": {"description": "Description\n\nChecks that method names conform to a specified pattern.\n\n\nAlso, checks if a method name has the same name as the residing class.\nThe default is false (it is not allowed). It is legal in Java to have\nmethod with the same name as a class. As long as a return type is specified\nit is a method and not a constructor which it could be easily confused as.\nDoes not check-style the name of an overridden methods because the developer\ndoes not have a choice in renaming such methods.", "option": "\nallowClassName, Control whether to allow a method name to have the same name as the enclosing class name. Setting this property false helps to avoid confusion between constructors and methods., boolean, false\napplyToPackage, Control if check should apply to package-private members., boolean, true\napplyToPrivate, Control if check should apply to private members., boolean, true\napplyToProtected, Control if check should apply to protected members., boolean, true\napplyToPublic, Control if check should apply to public members., boolean, true\nformat, Sets the pattern to match valid identifiers., Pattern, \"^[a-z][a-zA-Z0-9]*$\""}, "GenericWhitespace": {"description": "Description\n\nChecks that the whitespace around the Generic tokens (angle brackets)\n\"<\" and \">\" are correct to the typical convention.\nThe convention is not configurable.\n\n\nLeft angle bracket (\"<\"):\n\n\nshould be preceded with whitespace only in generic methods definitions.\nshould not be preceded with whitespace when it is preceded method name\nor constructor.\nshould not be preceded with whitespace when following type name.\nshould not be followed with whitespace in all cases.\n\n\nRight angle bracket (\">\"):\n\n\nshould not be preceded with whitespace in all cases.\nshould be followed with whitespace in almost all cases, except diamond operators\nand when preceding a method name, constructor, or record header.", "option": ""}, "RightCurly": {"description": "Description\n\nChecks the placement of right curly braces ('}') for code blocks.\nThis check supports if-else, try-catch-finally blocks, switch statements, switch cases,\nwhile-loops, for-loops, method definitions, class definitions, constructor definitions,\ninstance, static initialization blocks, annotation definitions and enum definitions.\nFor right curly brace of expression blocks of arrays, lambdas and class instances\nplease follow issue\n#5945.\nFor right curly brace of enum constant please follow issue\n#7519.", "option": "\noption, Specify the policy on placement of a right curly brace ('}')., RightCurlyOption, same\ntokens, tokens to check, subset of tokens\n\nLITERAL_TRY\n,\nLITERAL_CATCH\n,\nLITERAL_FINALLY\n,\nLITERAL_IF\n,\nLITERAL_ELSE\n,\nCLASS_DEF\n,\nMETHOD_DEF\n,\nCTOR_DEF\n,\nLITERAL_FOR\n,\nLITERAL_WHILE\n,\nLITERAL_DO\n,\nSTATIC_INIT\n,\nINSTANCE_INIT\n,\nANNOTATION_DEF\n,\nENUM_DEF\n,\nINTERFACE_DEF\n,\nRECORD_DEF\n,\nCOMPACT_CTOR_DEF\n,\nLITERAL_SWITCH\n,\nLITERAL_CASE\n.\n,\n\nLITERAL_TRY\n,\nLITERAL_CATCH\n,\nLITERAL_FINALLY\n,\nLITERAL_IF\n,\nLITERAL_ELSE\n.\n"}, "PackageName": {"description": "Description\n\nChecks that package names conform to a specified pattern.\n\n\nThe default value of format for module PackageName has been\nchosen to match the requirements in the\nJava\nLanguage specification and the Sun coding conventions. However,\nboth underscores and uppercase letters are rather uncommon, so most\nconfigurations should probably assign value ^[a-z]+(\\.[a-z][a-z0-9]*)*$ to\nformat for module PackageName.", "option": "\nformat, Control the pattern to match valid identifiers., Pattern, \"^[a-z]+(\\.[a-zA-Z_]\\w*)*$\""}, "RequireThis": {"description": "Description\n\nChecks that references to instance variables and methods of the present\nobject are explicitly of the form \"this.varName\" or\n\"this.methodName(args)\" and that those references don't\nrely on the default behavior when \"this.\" is absent.\n\n\nWarning: the Check is very controversial if 'validateOnlyOverlapping' option is set to\n'false' and not that actual nowadays.\n\n\nRationale:\n\n\n\nThe same notation/habit for C++ and Java (C++ have global methods, so having\n\"this.\" do make sense in it to distinguish call of method of class\ninstead of global).\n\n\nNon-IDE development (ease of refactoring, some clearness to distinguish\nstatic and non-static methods).", "option": "\ncheckFields, Control whether to check references to fields., boolean, true\ncheckMethods, Control whether to check references to methods., boolean, true\nvalidateOnlyOverlapping, Control whether to check only overlapping by variables or arguments., boolean, true"}, "MultipleVariableDeclarations": {"description": "Description\n\nChecks that each variable declaration is in its own statement and on\nits own line.\n\n\nRationale:\n\nthe Java code conventions chapter 6.1 recommends that\ndeclarations should be one per line/statement.", "option": ""}}